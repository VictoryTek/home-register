{"files":[{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","errors.rs"],"content":"use serde::Serialize;\nuse std::fmt;\nuse warp::{Reply, http::StatusCode, reject::Reject};\n\n/// Custom error types for the application\n#[derive(Debug)]\n#[allow(dead_code)]\npub enum AppError {\n    DatabaseError(String),\n    ValidationError(String),\n    Unauthorized,\n    Forbidden(String),\n    NotFound(String),\n    Conflict(String),\n    BadRequest(String),\n    InternalServerError(String),\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            AppError::DatabaseError(msg) => write!(f, \"Database error: {}\", msg),\n            AppError::ValidationError(msg) => write!(f, \"Validation error: {}\", msg),\n            AppError::Unauthorized => write!(f, \"Unauthorized\"),\n            AppError::Forbidden(msg) => write!(f, \"Forbidden: {}\", msg),\n            AppError::NotFound(msg) => write!(f, \"Not found: {}\", msg),\n            AppError::Conflict(msg) => write!(f, \"Conflict: {}\", msg),\n            AppError::BadRequest(msg) => write!(f, \"Bad request: {}\", msg),\n            AppError::InternalServerError(msg) => write!(f, \"Internal server error: {}\", msg),\n        }\n    }\n}\n\nimpl std::error::Error for AppError {}\n\nimpl Reject for AppError {}\n\n#[derive(Serialize)]\npub struct ErrorResponse {\n    pub error: String,\n    pub message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub details: Option<Vec<String>>,\n}\n\nimpl ErrorResponse {\n    pub fn new(error: &str, message: &str) -> Self {\n        Self {\n            error: error.to_string(),\n            message: message.to_string(),\n            details: None,\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn with_details(error: &str, message: &str, details: Vec<String>) -> Self {\n        Self {\n            error: error.to_string(),\n            message: message.to_string(),\n            details: Some(details),\n        }\n    }\n}\n\nimpl AppError {\n    /// Convert AppError to HTTP response with proper error hiding\n    /// Internal errors are logged but never exposed to clients\n    pub fn to_http_response(&self) -> (StatusCode, ErrorResponse) {\n        match self {\n            AppError::ValidationError(msg) => (\n                StatusCode::BAD_REQUEST,\n                ErrorResponse::new(\"VALIDATION_FAILED\", msg),\n            ),\n            AppError::Unauthorized => (\n                StatusCode::UNAUTHORIZED,\n                ErrorResponse::new(\"UNAUTHORIZED\", \"Authentication required\"),\n            ),\n            AppError::NotFound(resource) => (\n                StatusCode::NOT_FOUND,\n                ErrorResponse::new(\"NOT_FOUND\", &format!(\"{} not found\", resource)),\n            ),\n            AppError::Conflict(msg) => (StatusCode::CONFLICT, ErrorResponse::new(\"CONFLICT\", msg)),\n            // Never expose database errors externally\n            AppError::DatabaseError(internal_msg) => {\n                tracing::error!(\n                    error_type = \"database_error\",\n                    error = %internal_msg,\n                    \"Database error occurred\"\n                );\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    ErrorResponse::new(\n                        \"INTERNAL_ERROR\",\n                        \"An error occurred processing your request\",\n                    ),\n                )\n            }\n            // Never expose internal server errors externally\n            AppError::InternalServerError(internal_msg) => {\n                tracing::error!(\n                    error_type = \"internal_server_error\",\n                    error = %internal_msg,\n                    \"Internal server error occurred\"\n                );\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    ErrorResponse::new(\"INTERNAL_ERROR\", \"An error occurred\"),\n                )\n            }\n            AppError::BadRequest(msg) => (\n                StatusCode::BAD_REQUEST,\n                ErrorResponse::new(\"BAD_REQUEST\", msg),\n            ),\n            AppError::Forbidden(msg) => {\n                (StatusCode::FORBIDDEN, ErrorResponse::new(\"FORBIDDEN\", msg))\n            }\n        }\n    }\n}\n\n/// Convert rejection to HTTP response using standardized error handling\n/// This ensures internal errors are never exposed to clients\npub async fn handle_rejection(\n    err: warp::Rejection,\n) -> Result<impl Reply, std::convert::Infallible> {\n    let (status, body) = if let Some(app_err) = err.find::<AppError>() {\n        // Use the standardized error converter\n        app_err.to_http_response()\n    } else if err.is_not_found() {\n        (\n            StatusCode::NOT_FOUND,\n            ErrorResponse::new(\"NOT_FOUND\", \"Resource not found\"),\n        )\n    } else if err.find::<warp::reject::MethodNotAllowed>().is_some() {\n        (\n            StatusCode::METHOD_NOT_ALLOWED,\n            ErrorResponse::new(\"METHOD_NOT_ALLOWED\", \"Method not allowed\"),\n        )\n    } else if let Some(e) = err.find::<warp::body::BodyDeserializeError>() {\n        tracing::warn!(\n            error_type = \"body_deserialize_error\",\n            error = %e,\n            \"Failed to deserialize request body\"\n        );\n        (\n            StatusCode::BAD_REQUEST,\n            ErrorResponse::new(\"INVALID_BODY\", \"Invalid request body\"),\n        )\n    } else if err.find::<warp::reject::InvalidQuery>().is_some() {\n        tracing::warn!(error_type = \"invalid_query\", \"Invalid query parameters\");\n        (\n            StatusCode::BAD_REQUEST,\n            ErrorResponse::new(\"INVALID_QUERY\", \"Invalid query parameters\"),\n        )\n    } else if err.find::<warp::reject::MissingHeader>().is_some() {\n        (\n            StatusCode::BAD_REQUEST,\n            ErrorResponse::new(\"MISSING_HEADER\", \"Missing required header\"),\n        )\n    } else if err.find::<warp::reject::InvalidHeader>().is_some() {\n        (\n            StatusCode::BAD_REQUEST,\n            ErrorResponse::new(\"INVALID_HEADER\", \"Invalid header value\"),\n        )\n    } else if err.find::<warp::reject::PayloadTooLarge>().is_some() {\n        (\n            StatusCode::PAYLOAD_TOO_LARGE,\n            ErrorResponse::new(\"PAYLOAD_TOO_LARGE\", \"Request payload too large\"),\n        )\n    } else if err.find::<warp::reject::UnsupportedMediaType>().is_some() {\n        (\n            StatusCode::UNSUPPORTED_MEDIA_TYPE,\n            ErrorResponse::new(\"UNSUPPORTED_MEDIA_TYPE\", \"Unsupported media type\"),\n        )\n    } else {\n        // Log unhandled rejections but don't expose details\n        tracing::error!(\n            error_type = \"unhandled_rejection\",\n            error = ?err,\n            \"Unhandled rejection occurred\"\n        );\n        (\n            StatusCode::INTERNAL_SERVER_ERROR,\n            ErrorResponse::new(\"INTERNAL_ERROR\", \"An error occurred\"),\n        )\n    };\n\n    Ok(warp::reply::with_status(warp::reply::json(&body), status))\n}\n\n/// Helper macro to convert database errors\n#[macro_export]\nmacro_rules! db_error {\n    ($err:expr) => {\n        $crate::errors::AppError::DatabaseError($err.to_string())\n    };\n}\n\n/// Helper macro for validation errors\n#[macro_export]\nmacro_rules! validation_error {\n    ($msg:expr) => {\n        $crate::errors::AppError::ValidationError($msg.to_string())\n    };\n}\n\n/// Helper macro for not found errors\n#[macro_export]\nmacro_rules! not_found {\n    ($msg:expr) => {\n        $crate::errors::AppError::NotFound($msg.to_string())\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","admin","mod.rs"],"content":"pub mod users;\n\npub use users::*;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","admin","users.rs"],"content":"use crate::DbPool;\nuse crate::errors::AppError;\nuse crate::handlers::auth::seed_default_organizers;\nuse crate::middleware::AuthContext;\nuse crate::models::{\n    AdminChangePasswordRequest, AdminCreateUserRequest, AdminToggleActiveRequest,\n    AdminUpdateUserRequest, TransferOwnershipRequest, TransferOwnershipResponse, UserListResponse,\n    UserResponse,\n};\nuse chrono::Utc;\nuse serde_json::json;\nuse uuid::Uuid;\nuse warp::Reply;\n\n// Authentication and JWT utilities\nuse bcrypt::{DEFAULT_COST, hash};\n\n// Async-safe bcrypt operation using tokio::task::spawn_blocking\nasync fn hash_password(password: String) -> Result<String, bcrypt::BcryptError> {\n    tokio::task::spawn_blocking(move || hash(&password, DEFAULT_COST))\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Task join error during password hashing\");\n            bcrypt::BcryptError::InvalidCost(DEFAULT_COST.to_string())\n        })?\n}\n\n/// List all users with pagination\npub async fn list_users(\n    auth: AuthContext,\n    page: Option<i32>,\n    per_page: Option<i32>,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let page = page.unwrap_or(1).max(1);\n    let per_page = per_page.unwrap_or(20).clamp(1, 100);\n    let offset = (page - 1) * per_page;\n\n    // Get total count\n    let count_query = \"SELECT COUNT(*) FROM users\";\n    let total: i64 = match db.query_one(count_query, &[]).await {\n        Ok(row) => row.get(0),\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to count users\");\n            return Err(warp::reject::custom(AppError::DatabaseError(\n                \"Failed to count users\".to_string(),\n            )));\n        }\n    };\n\n    // Get paginated users\n    let query = \"\n        SELECT id, username, email, full_name, is_admin, is_active, created_at, updated_at\n        FROM users\n        ORDER BY created_at DESC\n        LIMIT $1 OFFSET $2\n    \";\n\n    match db\n        .query(query, &[&(per_page as i64), &(offset as i64)])\n        .await\n    {\n        Ok(rows) => {\n            let users: Vec<UserResponse> = rows\n                .iter()\n                .map(|row| UserResponse {\n                    id: row.get(\"id\"),\n                    username: row.get(\"username\"),\n                    email: row.get(\"email\"),\n                    full_name: row.get(\"full_name\"),\n                    is_admin: row.get(\"is_admin\"),\n                    is_active: row.get(\"is_active\"),\n                    created_at: row.get(\"created_at\"),\n                    updated_at: row.get(\"updated_at\"),\n                })\n                .collect();\n\n            let response = UserListResponse {\n                users,\n                total,\n                page,\n                per_page,\n            };\n\n            tracing::info!(\n                admin_id = %auth.user_id,\n                page = page,\n                per_page = per_page,\n                total = total,\n                \"Admin listed users\"\n            );\n\n            Ok(warp::reply::json(&response))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error listing users\");\n            Err(warp::reject::custom(AppError::DatabaseError(\n                \"Failed to list users\".to_string(),\n            )))\n        }\n    }\n}\n\n/// Get a specific user by ID\npub async fn get_user(\n    user_id: Uuid,\n    _auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let query = \"\n        SELECT id, username, email, full_name, is_admin, is_active, created_at, updated_at\n        FROM users\n        WHERE id = $1\n    \";\n\n    match db.query_opt(query, &[&user_id]).await {\n        Ok(Some(row)) => {\n            let user = UserResponse {\n                id: row.get(\"id\"),\n                username: row.get(\"username\"),\n                email: row.get(\"email\"),\n                full_name: row.get(\"full_name\"),\n                is_admin: row.get(\"is_admin\"),\n                is_active: row.get(\"is_active\"),\n                created_at: row.get(\"created_at\"),\n                updated_at: row.get(\"updated_at\"),\n            };\n\n            Ok(warp::reply::json(&user))\n        }\n        Ok(None) => Err(warp::reject::custom(AppError::NotFound(\"User\".to_string()))),\n        Err(e) => {\n            tracing::error!(error = %e, user_id = %user_id, \"Database error fetching user\");\n            Err(warp::reject::custom(AppError::DatabaseError(\n                \"Failed to fetch user\".to_string(),\n            )))\n        }\n    }\n}\n\n/// Create a new user (admin only)\npub async fn create_user(\n    request: AdminCreateUserRequest,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Hash password\n    let password_hash = match hash_password(request.password.clone()).await {\n        Ok(hash) => hash,\n        Err(e) => {\n            tracing::error!(error = %e, \"Password hashing error\");\n            return Err(warp::reject::custom(AppError::InternalServerError(\n                \"Failed to process password\".to_string(),\n            )));\n        }\n    };\n\n    let user_id = Uuid::new_v4();\n    let now = Utc::now();\n\n    let query = \"\n        INSERT INTO users (id, username, email, full_name, password_hash, is_admin, is_active, created_at, updated_at)\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n        RETURNING id, username, email, full_name, is_admin, is_active, created_at, updated_at\n    \";\n\n    match db\n        .query_one(\n            query,\n            &[\n                &user_id,\n                &request.username,\n                &request.email,\n                &request.full_name,\n                &password_hash,\n                &request.is_admin,\n                &request.is_active,\n                &now,\n                &now,\n            ],\n        )\n        .await\n    {\n        Ok(row) => {\n            let user = UserResponse {\n                id: row.get(\"id\"),\n                username: row.get(\"username\"),\n                email: row.get(\"email\"),\n                full_name: row.get(\"full_name\"),\n                is_admin: row.get(\"is_admin\"),\n                is_active: row.get(\"is_active\"),\n                created_at: row.get(\"created_at\"),\n                updated_at: row.get(\"updated_at\"),\n            };\n\n            // Seed default organizers for the new user\n            if let Err(e) = seed_default_organizers(&db, &user_id).await {\n                tracing::error!(error = %e, user_id = %user_id, \"Failed to seed default organizers for new user\");\n                // Don't fail user creation if organizer seeding fails\n            }\n\n            tracing::info!(\n                admin_id = %auth.user_id,\n                new_user_id = %user.id,\n                username = %user.username,\n                is_admin = user.is_admin,\n                \"Admin created new user\"\n            );\n\n            Ok(warp::reply::with_status(\n                warp::reply::json(&user),\n                warp::http::StatusCode::CREATED,\n            ))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error creating user\");\n            if e.to_string().contains(\"duplicate key\") {\n                Err(warp::reject::custom(AppError::Conflict(\n                    \"Username or email already exists\".to_string(),\n                )))\n            } else {\n                Err(warp::reject::custom(AppError::DatabaseError(\n                    \"Failed to create user\".to_string(),\n                )))\n            }\n        }\n    }\n}\n\n/// Update a user (admin only)\npub async fn update_user(\n    user_id: Uuid,\n    request: AdminUpdateUserRequest,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Check if trying to demote self\n    if let Some(is_admin) = request.is_admin\n        && !is_admin\n        && user_id == auth.user_id\n    {\n        return Err(warp::reject::custom(AppError::BadRequest(\n            \"Cannot demote yourself from admin\".to_string(),\n        )));\n    }\n\n    // Check if trying to deactivate self\n    if let Some(is_active) = request.is_active\n        && !is_active\n        && user_id == auth.user_id\n    {\n        return Err(warp::reject::custom(AppError::BadRequest(\n            \"Cannot deactivate your own account\".to_string(),\n        )));\n    }\n\n    let mut updates = Vec::new();\n    let mut param_index = 1;\n\n    if let Some(ref username) = request.username {\n        updates.push((format!(\"username = ${}\", param_index), username.clone()));\n        param_index += 1;\n    }\n\n    if let Some(ref email) = request.email {\n        updates.push((format!(\"email = ${}\", param_index), email.clone()));\n        param_index += 1;\n    }\n\n    if let Some(ref full_name) = request.full_name {\n        updates.push((format!(\"full_name = ${}\", param_index), full_name.clone()));\n        param_index += 1;\n    }\n\n    if let Some(is_admin) = request.is_admin {\n        // Check if this would remove the last admin\n        if !is_admin {\n            let admin_check = db\n                .query_one(\n                    \"SELECT COUNT(*) FROM users WHERE is_admin = true AND id != $1\",\n                    &[&user_id],\n                )\n                .await\n                .map_err(|e| {\n                    tracing::error!(error = %e, \"Failed to check admin count\");\n                    warp::reject::custom(AppError::DatabaseError(\n                        \"Failed to verify admin count\".to_string(),\n                    ))\n                })?;\n\n            let admin_count: i64 = admin_check.get(0);\n            if admin_count == 0 {\n                return Err(warp::reject::custom(AppError::BadRequest(\n                    \"Cannot remove last admin user\".to_string(),\n                )));\n            }\n        }\n\n        updates.push((format!(\"is_admin = ${}\", param_index), is_admin.to_string()));\n        param_index += 1;\n    }\n\n    if let Some(is_active) = request.is_active {\n        updates.push((\n            format!(\"is_active = ${}\", param_index),\n            is_active.to_string(),\n        ));\n        param_index += 1;\n    }\n\n    if updates.is_empty() {\n        return Err(warp::reject::custom(AppError::BadRequest(\n            \"No fields to update\".to_string(),\n        )));\n    }\n\n    // Build the update query dynamically\n    let update_fields: Vec<String> = updates.iter().map(|(field, _)| field.clone()).collect();\n    let query = format!(\n        \"UPDATE users SET {}, updated_at = NOW() WHERE id = ${}\n         RETURNING id, username, email, full_name, is_admin, is_active, created_at, updated_at\",\n        update_fields.join(\", \"),\n        param_index\n    );\n\n    // Execute with proper parameters\n    let stmt = db.prepare(&query).await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to prepare statement\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Failed to prepare query\".to_string(),\n        ))\n    })?;\n\n    // Build params dynamically based on what we're updating\n    let mut query_params: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> = Vec::new();\n\n    if let Some(ref username) = request.username {\n        query_params.push(username);\n    }\n    if let Some(ref email) = request.email {\n        query_params.push(email);\n    }\n    if let Some(ref full_name) = request.full_name {\n        query_params.push(full_name);\n    }\n    if let Some(ref is_admin) = request.is_admin {\n        query_params.push(is_admin);\n    }\n    if let Some(ref is_active) = request.is_active {\n        query_params.push(is_active);\n    }\n    query_params.push(&user_id);\n\n    match db.query_one(&stmt, &query_params).await {\n        Ok(row) => {\n            let user = UserResponse {\n                id: row.get(\"id\"),\n                username: row.get(\"username\"),\n                email: row.get(\"email\"),\n                full_name: row.get(\"full_name\"),\n                is_admin: row.get(\"is_admin\"),\n                is_active: row.get(\"is_active\"),\n                created_at: row.get(\"created_at\"),\n                updated_at: row.get(\"updated_at\"),\n            };\n\n            tracing::info!(\n                admin_id = %auth.user_id,\n                updated_user_id = %user.id,\n                \"Admin updated user\"\n            );\n\n            Ok(warp::reply::json(&user))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, user_id = %user_id, \"Database error updating user\");\n            if e.to_string().contains(\"duplicate key\") {\n                Err(warp::reject::custom(AppError::Conflict(\n                    \"Email already exists\".to_string(),\n                )))\n            } else {\n                Err(warp::reject::custom(AppError::DatabaseError(\n                    \"Failed to update user\".to_string(),\n                )))\n            }\n        }\n    }\n}\n\n/// Delete a user (admin only)\npub async fn delete_user(\n    user_id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Prevent deleting self\n    if user_id == auth.user_id {\n        return Err(warp::reject::custom(AppError::BadRequest(\n            \"Cannot delete your own account\".to_string(),\n        )));\n    }\n\n    // Check if user is an admin\n    let user_check = db\n        .query_one(\"SELECT is_admin FROM users WHERE id = $1\", &[&user_id])\n        .await\n        .map_err(|e| {\n            if e.to_string().contains(\"no rows\") {\n                warp::reject::custom(AppError::NotFound(\"User\".to_string()))\n            } else {\n                tracing::error!(error = %e, \"Failed to fetch user\");\n                warp::reject::custom(AppError::DatabaseError(\"Failed to fetch user\".to_string()))\n            }\n        })?;\n\n    let is_admin: bool = user_check.get(0);\n\n    // If deleting an admin, check if it's the last one\n    if is_admin {\n        let admin_count_check = db\n            .query_one(\"SELECT COUNT(*) FROM users WHERE is_admin = true\", &[])\n            .await\n            .map_err(|e| {\n                tracing::error!(error = %e, \"Failed to check admin count\");\n                warp::reject::custom(AppError::DatabaseError(\n                    \"Failed to verify admin count\".to_string(),\n                ))\n            })?;\n\n        let admin_count: i64 = admin_count_check.get(0);\n        if admin_count <= 1 {\n            return Err(warp::reject::custom(AppError::BadRequest(\n                \"Cannot delete the last admin user\".to_string(),\n            )));\n        }\n    }\n\n    // Delete user (cascade will handle related data)\n    match db\n        .execute(\"DELETE FROM users WHERE id = $1\", &[&user_id])\n        .await\n    {\n        Ok(deleted) => {\n            if deleted == 0 {\n                return Err(warp::reject::custom(AppError::NotFound(\"User\".to_string())));\n            }\n\n            tracing::info!(\n                admin_id = %auth.user_id,\n                deleted_user_id = %user_id,\n                \"Admin deleted user\"\n            );\n\n            Ok(warp::reply::json(&json!({\n                \"message\": \"User deleted successfully\"\n            })))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, user_id = %user_id, \"Database error deleting user\");\n            Err(warp::reject::custom(AppError::DatabaseError(\n                \"Failed to delete user\".to_string(),\n            )))\n        }\n    }\n}\n\n/// Toggle user active status (admin only)\npub async fn toggle_active(\n    user_id: Uuid,\n    request: AdminToggleActiveRequest,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Prevent deactivating self\n    if user_id == auth.user_id && !request.is_active {\n        return Err(warp::reject::custom(AppError::BadRequest(\n            \"Cannot deactivate your own account\".to_string(),\n        )));\n    }\n\n    let now = Utc::now();\n\n    match db\n        .execute(\n            \"UPDATE users SET is_active = $1, updated_at = $2 WHERE id = $3\",\n            &[&request.is_active, &now, &user_id],\n        )\n        .await\n    {\n        Ok(updated) => {\n            if updated == 0 {\n                return Err(warp::reject::custom(AppError::NotFound(\"User\".to_string())));\n            }\n\n            tracing::info!(\n                admin_id = %auth.user_id,\n                target_user_id = %user_id,\n                is_active = request.is_active,\n                \"Admin toggled user active status\"\n            );\n\n            Ok(warp::reply::json(&serde_json::json!({\n                \"message\": if request.is_active { \"User activated successfully\" } else { \"User deactivated successfully\" }\n            })))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, user_id = %user_id, \"Database error toggling user active status\");\n            Err(warp::reject::custom(AppError::DatabaseError(\n                \"Failed to toggle user active status\".to_string(),\n            )))\n        }\n    }\n}\n\n/// Change a user's password (admin only)\npub async fn change_user_password(\n    user_id: Uuid,\n    request: AdminChangePasswordRequest,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Hash new password\n    let password_hash = match hash_password(request.new_password.clone()).await {\n        Ok(hash) => hash,\n        Err(e) => {\n            tracing::error!(error = %e, \"Password hashing error\");\n            return Err(warp::reject::custom(AppError::InternalServerError(\n                \"Failed to process password\".to_string(),\n            )));\n        }\n    };\n\n    let now = Utc::now();\n\n    match db\n        .execute(\n            \"UPDATE users SET password_hash = $1, updated_at = $2 WHERE id = $3\",\n            &[&password_hash, &now, &user_id],\n        )\n        .await\n    {\n        Ok(updated) => {\n            if updated == 0 {\n                return Err(warp::reject::custom(AppError::NotFound(\"User\".to_string())));\n            }\n\n            tracing::info!(\n                admin_id = %auth.user_id,\n                target_user_id = %user_id,\n                \"Admin changed user password\"\n            );\n\n            Ok(warp::reply::json(&json!({\n                \"message\": \"Password changed successfully\"\n            })))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, user_id = %user_id, \"Database error changing password\");\n            Err(warp::reject::custom(AppError::DatabaseError(\n                \"Failed to change password\".to_string(),\n            )))\n        }\n    }\n}\n\n/// Transfer ownership of all humidors and cigars from one user to another\npub async fn transfer_ownership(\n    request: TransferOwnershipRequest,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    // Validate that source and target users are different\n    if request.from_user_id == request.to_user_id {\n        return Err(warp::reject::custom(AppError::ValidationError(\n            \"Source and target users must be different\".to_string(),\n        )));\n    }\n\n    let mut db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Start transaction for atomic operation\n    let transaction = db.transaction().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to start transaction\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Failed to start transaction\".to_string(),\n        ))\n    })?;\n\n    // Verify both users exist\n    let verify_users_query = \"\n        SELECT id FROM users WHERE id = $1\n        UNION ALL\n        SELECT id FROM users WHERE id = $2\n    \";\n\n    let user_rows = transaction\n        .query(\n            verify_users_query,\n            &[&request.from_user_id, &request.to_user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Failed to verify users\");\n            warp::reject::custom(AppError::DatabaseError(\n                \"Failed to verify users\".to_string(),\n            ))\n        })?;\n\n    if user_rows.len() != 2 {\n        return Err(warp::reject::custom(AppError::NotFound(\n            \"One or both users not found\".to_string(),\n        )));\n    }\n\n    // Determine which humidors to transfer\n    let (count_cigars_query, transfer_humidors_query, delete_shares_query, query_params) =\n        if let Some(humidor_id) = request.humidor_id {\n            // Transfer single humidor\n            // Verify the humidor belongs to the from_user\n            let verify_query = \"SELECT id FROM humidors WHERE id = $1 AND user_id = $2\";\n            let verify_result = transaction\n                .query_opt(verify_query, &[&humidor_id, &request.from_user_id])\n                .await\n                .map_err(|e| {\n                    tracing::error!(error = %e, \"Failed to verify humidor ownership\");\n                    warp::reject::custom(AppError::DatabaseError(\n                        \"Failed to verify humidor ownership\".to_string(),\n                    ))\n                })?;\n\n            if verify_result.is_none() {\n                return Err(warp::reject::custom(AppError::NotFound(\n                    \"Humidor not found or does not belong to source user\".to_string(),\n                )));\n            }\n\n            (\n                \"SELECT COUNT(*) FROM cigars WHERE humidor_id = $1\",\n                \"UPDATE humidors SET user_id = $1, updated_at = NOW() WHERE id = $2 AND user_id = $3\",\n                \"DELETE FROM humidor_shares WHERE humidor_id = $1\",\n                vec![humidor_id],\n            )\n        } else {\n            // Transfer all humidors\n            (\n                \"SELECT COUNT(*) FROM cigars c INNER JOIN humidors h ON c.humidor_id = h.id WHERE h.user_id = $1\",\n                \"UPDATE humidors SET user_id = $1, updated_at = NOW() WHERE user_id = $2\",\n                \"DELETE FROM humidor_shares WHERE humidor_id IN (SELECT id FROM humidors WHERE user_id = $1)\",\n                vec![],\n            )\n        };\n\n    // Count cigars before transfer\n    let cigar_count_row = if request.humidor_id.is_some() {\n        transaction\n            .query_one(count_cigars_query, &[&query_params[0]])\n            .await\n    } else {\n        transaction\n            .query_one(count_cigars_query, &[&request.from_user_id])\n            .await\n    }\n    .map_err(|e| {\n        tracing::error!(error = %e, \"Failed to count cigars\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Failed to count cigars\".to_string(),\n        ))\n    })?;\n\n    let cigars_transferred: i64 = cigar_count_row.get(0);\n\n    // Transfer humidors\n    let humidors_transferred = if let Some(humidor_id) = request.humidor_id {\n        transaction\n            .execute(\n                transfer_humidors_query,\n                &[&request.to_user_id, &humidor_id, &request.from_user_id],\n            )\n            .await\n    } else {\n        transaction\n            .execute(\n                transfer_humidors_query,\n                &[&request.to_user_id, &request.from_user_id],\n            )\n            .await\n    }\n    .map_err(|e| {\n        tracing::error!(error = %e, \"Failed to transfer humidors\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Failed to transfer humidors\".to_string(),\n        ))\n    })?;\n\n    // Delete humidor shares\n    if let Some(humidor_id) = request.humidor_id {\n        transaction\n            .execute(delete_shares_query, &[&humidor_id])\n            .await\n    } else {\n        transaction\n            .execute(delete_shares_query, &[&request.to_user_id])\n            .await\n    }\n    .map_err(|e| {\n        tracing::error!(error = %e, \"Failed to clean up humidor shares\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Failed to clean up humidor shares\".to_string(),\n        ))\n    })?;\n\n    // Map organizer data for cigars being transferred\n    // For each organizer type, create new records for target user if needed\n    // and update cigar foreign keys to reference the new organizer IDs\n\n    // After humidors are transferred, they belong to to_user_id\n    // We need to find cigars in those humidors and update their organizer references\n    let humidor_filter = if let Some(humidor_id) = request.humidor_id {\n        format!(\"humidor_id = '{}'\", humidor_id)\n    } else {\n        // All humidors that were just transferred (now owned by to_user_id)\n        format!(\n            \"humidor_id IN (SELECT id FROM humidors WHERE user_id = '{}')\",\n            request.to_user_id\n        )\n    };\n\n    // Copy organizer data (brands)\n    // Step 1: Insert brands for target user (skip if already exist)\n    let insert_brands_query = format!(\n        \"INSERT INTO brands (user_id, name, country, website, description, created_at, updated_at)\n        SELECT DISTINCT $1::uuid, b.name, b.country, b.website, b.description, NOW(), NOW()\n        FROM cigars c\n        INNER JOIN brands b ON c.brand_id = b.id\n        WHERE c.{} AND b.user_id = $2::uuid AND b.name IS NOT NULL\n        ON CONFLICT (user_id, name) DO NOTHING\",\n        humidor_filter\n    );\n\n    let brands_inserted = transaction\n        .execute(\n            &insert_brands_query,\n            &[&request.to_user_id, &request.from_user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = ?e, query = %insert_brands_query, \"Failed to insert brands\");\n            warp::reject::custom(AppError::DatabaseError(format!(\n                \"Failed to copy brands: {:?}\",\n                e\n            )))\n        })?;\n\n    tracing::debug!(brands_inserted, \"Brands inserted for target user\");\n\n    // Step 2: Update cigars to reference target user's brands\n    let update_brands_query = format!(\n        \"UPDATE cigars c\n        SET brand_id = target_b.id\n        FROM brands old_b\n        JOIN brands target_b ON target_b.name = old_b.name AND target_b.user_id = $1::uuid\n        WHERE c.{} AND c.brand_id = old_b.id AND old_b.user_id = $2::uuid\",\n        humidor_filter\n    );\n\n    transaction\n        .execute(\n            &update_brands_query,\n            &[&request.to_user_id, &request.from_user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Failed to update brand references\");\n            warp::reject::custom(AppError::DatabaseError(\n                \"Failed to copy organizer data\".to_string(),\n            ))\n        })?;\n\n    // Map origins - Step 1: Insert origins for target user\n    let insert_origins_query = format!(\n        \"INSERT INTO origins (user_id, name, country, region, description, created_at, updated_at)\n        SELECT DISTINCT $1::uuid, o.name, o.country, o.region, o.description, NOW(), NOW()\n        FROM cigars c\n        INNER JOIN origins o ON c.origin_id = o.id\n        WHERE c.{} AND o.user_id = $2::uuid AND o.name IS NOT NULL\n        ON CONFLICT (user_id, name) DO NOTHING\",\n        humidor_filter\n    );\n\n    transaction\n        .execute(\n            &insert_origins_query,\n            &[&request.to_user_id, &request.from_user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = ?e, query = %insert_origins_query, \"Failed to insert origins\");\n            warp::reject::custom(AppError::DatabaseError(format!(\n                \"Failed to copy origins: {:?}\",\n                e\n            )))\n        })?;\n\n    // Map origins - Step 2: Update cigar foreign keys\n    let update_origins_query = format!(\n        \"UPDATE cigars c\n        SET origin_id = target_o.id\n        FROM origins old_o\n        INNER JOIN origins target_o ON target_o.name = old_o.name AND target_o.user_id = $1::uuid\n        WHERE c.{} AND c.origin_id = old_o.id AND old_o.user_id = $2::uuid\",\n        humidor_filter\n    );\n\n    transaction\n        .execute(\n            &update_origins_query,\n            &[&request.to_user_id, &request.from_user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Failed to map origins\");\n            warp::reject::custom(AppError::DatabaseError(\n                \"Failed to copy organizer data\".to_string(),\n            ))\n        })?;\n\n    // Map strengths - Step 1: Insert strengths for target user\n    let insert_strengths_query = format!(\n        \"INSERT INTO strengths (user_id, name, level, description, created_at, updated_at)\n        SELECT DISTINCT $1::uuid, s.name, s.level, s.description, NOW(), NOW()\n        FROM cigars c\n        INNER JOIN strengths s ON c.strength_id = s.id\n        WHERE c.{} AND s.user_id = $2::uuid AND s.name IS NOT NULL\n        ON CONFLICT (user_id, name) DO NOTHING\",\n        humidor_filter\n    );\n\n    transaction\n        .execute(&insert_strengths_query, &[&request.to_user_id, &request.from_user_id])\n        .await\n        .map_err(|e| {\n            tracing::error!(error = ?e, query = %insert_strengths_query, \"Failed to insert strengths\");\n            warp::reject::custom(AppError::DatabaseError(\n                format!(\"Failed to copy strengths: {:?}\", e)\n            ))\n        })?;\n\n    // Map strengths - Step 2: Update cigar foreign keys\n    let update_strengths_query = format!(\n        \"UPDATE cigars c\n        SET strength_id = target_s.id\n        FROM strengths old_s\n        INNER JOIN strengths target_s ON target_s.name = old_s.name AND target_s.user_id = $1::uuid\n        WHERE c.{} AND c.strength_id = old_s.id AND old_s.user_id = $2::uuid\",\n        humidor_filter\n    );\n\n    transaction\n        .execute(\n            &update_strengths_query,\n            &[&request.to_user_id, &request.from_user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Failed to map strengths\");\n            warp::reject::custom(AppError::DatabaseError(\n                \"Failed to copy organizer data\".to_string(),\n            ))\n        })?;\n\n    // Map sizes - Step 1: Insert sizes for target user\n    let insert_sizes_query = format!(\n        \"INSERT INTO sizes (user_id, name, length_inches, ring_gauge, description, created_at, updated_at)\n        SELECT DISTINCT $1::uuid, sz.name, sz.length_inches, sz.ring_gauge, sz.description, NOW(), NOW()\n        FROM cigars c\n        INNER JOIN sizes sz ON c.size_id = sz.id\n        WHERE c.{} AND sz.user_id = $2::uuid AND sz.name IS NOT NULL\n        ON CONFLICT (user_id, name) DO NOTHING\",\n        humidor_filter\n    );\n\n    transaction\n        .execute(\n            &insert_sizes_query,\n            &[&request.to_user_id, &request.from_user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = ?e, query = %insert_sizes_query, \"Failed to insert sizes\");\n            warp::reject::custom(AppError::DatabaseError(format!(\n                \"Failed to copy sizes: {:?}\",\n                e\n            )))\n        })?;\n\n    // Map sizes - Step 2: Update cigar foreign keys\n    let update_sizes_query = format!(\n        \"UPDATE cigars c\n        SET size_id = target_sz.id\n        FROM sizes old_sz\n        INNER JOIN sizes target_sz ON target_sz.name = old_sz.name AND target_sz.user_id = $1::uuid\n        WHERE c.{} AND c.size_id = old_sz.id AND old_sz.user_id = $2::uuid\",\n        humidor_filter\n    );\n\n    transaction\n        .execute(\n            &update_sizes_query,\n            &[&request.to_user_id, &request.from_user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Failed to map sizes\");\n            warp::reject::custom(AppError::DatabaseError(\n                \"Failed to copy organizer data\".to_string(),\n            ))\n        })?;\n\n    // Map ring_gauges - Step 1: Insert ring_gauges for target user\n    let insert_ring_gauges_query = format!(\n        \"INSERT INTO ring_gauges (user_id, gauge, description, common_names, created_at, updated_at)\n        SELECT DISTINCT $1::uuid, rg.gauge, rg.description, rg.common_names, NOW(), NOW()\n        FROM cigars c\n        INNER JOIN ring_gauges rg ON c.ring_gauge_id = rg.id\n        WHERE c.{} AND rg.user_id = $2::uuid\n        ON CONFLICT (user_id, gauge) DO NOTHING\",\n        humidor_filter\n    );\n\n    transaction\n        .execute(&insert_ring_gauges_query, &[&request.to_user_id, &request.from_user_id])\n        .await\n        .map_err(|e| {\n            tracing::error!(error = ?e, query = %insert_ring_gauges_query, \"Failed to insert ring_gauges\");\n            warp::reject::custom(AppError::DatabaseError(\n                format!(\"Failed to copy ring_gauges: {:?}\", e)\n            ))\n        })?;\n\n    // Map ring_gauges - Step 2: Update cigar foreign keys\n    let update_ring_gauges_query = format!(\n        \"UPDATE cigars c\n        SET ring_gauge_id = target_rg.id\n        FROM ring_gauges old_rg\n        INNER JOIN ring_gauges target_rg ON target_rg.gauge = old_rg.gauge AND target_rg.user_id = $1::uuid\n        WHERE c.{} AND c.ring_gauge_id = old_rg.id AND old_rg.user_id = $2::uuid\",\n        humidor_filter\n    );\n\n    transaction\n        .execute(\n            &update_ring_gauges_query,\n            &[&request.to_user_id, &request.from_user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Failed to map ring_gauges\");\n            warp::reject::custom(AppError::DatabaseError(\n                \"Failed to copy organizer data\".to_string(),\n            ))\n        })?;\n\n    // Commit transaction\n    transaction.commit().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to commit transaction\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Failed to commit ownership transfer\".to_string(),\n        ))\n    })?;\n\n    tracing::info!(\n        admin_id = %auth.user_id,\n        from_user_id = %request.from_user_id,\n        to_user_id = %request.to_user_id,\n        humidors_transferred = humidors_transferred,\n        cigars_transferred = cigars_transferred,\n        \"Ownership transferred successfully\"\n    );\n\n    Ok(warp::reply::json(&TransferOwnershipResponse {\n        humidors_transferred: humidors_transferred as i64,\n        cigars_transferred,\n    }))\n}\n\n/// Get humidors for a specific user (admin only)\npub async fn get_user_humidors(\n    user_id: Uuid,\n    _auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Verify user exists\n    let user_check_query = \"SELECT id FROM users WHERE id = $1\";\n    let user_exists = db\n        .query_opt(user_check_query, &[&user_id])\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Failed to verify user\");\n            warp::reject::custom(AppError::DatabaseError(\"Failed to verify user\".to_string()))\n        })?;\n\n    if user_exists.is_none() {\n        return Err(warp::reject::custom(AppError::NotFound(\n            \"User not found\".to_string(),\n        )));\n    }\n\n    // Get humidors owned by user with cigar count\n    let query = \"\n        SELECT \n            h.id, \n            h.user_id, \n            h.name, \n            h.description, \n            h.capacity, \n            h.target_humidity, \n            h.location, \n            h.image_url, \n            h.created_at, \n            h.updated_at,\n            COUNT(c.id) as cigar_count\n        FROM humidors h\n        LEFT JOIN cigars c ON h.id = c.humidor_id\n        WHERE h.user_id = $1\n        GROUP BY h.id, h.user_id, h.name, h.description, h.capacity, h.target_humidity, h.location, h.image_url, h.created_at, h.updated_at\n        ORDER BY h.created_at ASC\n    \";\n\n    match db.query(query, &[&user_id]).await {\n        Ok(rows) => {\n            let humidors: Vec<serde_json::Value> = rows\n                .iter()\n                .map(|row| {\n                    json!({\n                        \"id\": row.get::<_, Uuid>(\"id\"),\n                        \"user_id\": row.get::<_, Uuid>(\"user_id\"),\n                        \"name\": row.get::<_, String>(\"name\"),\n                        \"description\": row.get::<_, Option<String>>(\"description\"),\n                        \"capacity\": row.get::<_, Option<i32>>(\"capacity\"),\n                        \"target_humidity\": row.get::<_, Option<i32>>(\"target_humidity\"),\n                        \"location\": row.get::<_, Option<String>>(\"location\"),\n                        \"image_url\": row.get::<_, Option<String>>(\"image_url\"),\n                        \"cigar_count\": row.get::<_, i64>(\"cigar_count\"),\n                        \"created_at\": row.get::<_, chrono::DateTime<Utc>>(\"created_at\"),\n                        \"updated_at\": row.get::<_, chrono::DateTime<Utc>>(\"updated_at\")\n                    })\n                })\n                .collect();\n\n            Ok(warp::reply::json(&humidors))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, user_id = %user_id, \"Failed to fetch humidors\");\n            Err(warp::reject::custom(AppError::DatabaseError(\n                \"Failed to fetch humidors\".to_string(),\n            )))\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","auth.rs"],"content":"use crate::DbPool;\nuse crate::errors::AppError;\nuse crate::models::{\n    CreateHumidorRequest, Humidor, LoginRequest, LoginResponse, SetupRequest, SetupStatusResponse,\n    UserResponse,\n};\nuse chrono::Utc;\nuse serde_json::json;\nuse std::env;\nuse std::fs;\nuse uuid::Uuid;\nuse warp::Reply;\n\n// Authentication and JWT utilities\nuse bcrypt::{DEFAULT_COST, hash, verify};\nuse jsonwebtoken::{Algorithm, DecodingKey, EncodingKey, Header, Validation, decode, encode};\nuse serde::{Deserialize, Serialize};\n\n// Async-safe bcrypt operations using tokio::task::spawn_blocking\nasync fn hash_password(password: String) -> Result<String, bcrypt::BcryptError> {\n    tokio::task::spawn_blocking(move || hash(&password, DEFAULT_COST))\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Task join error during password hashing\");\n            bcrypt::BcryptError::InvalidCost(DEFAULT_COST.to_string())\n        })?\n}\n\nasync fn verify_password(password: String, hash_str: String) -> Result<bool, bcrypt::BcryptError> {\n    tokio::task::spawn_blocking(move || verify(&password, &hash_str))\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Task join error during password verification\");\n            bcrypt::BcryptError::InvalidHash(\"\".to_string())\n        })?\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Claims {\n    pub sub: String, // user id\n    pub username: String,\n    pub exp: usize, // expiration time (required)\n    pub iat: usize, // issued at time (for tracking)\n}\n\n/// Get JWT secret from Docker secrets or environment variable\n/// Docker secrets take precedence over environment variables\n/// Note: This function assumes the secret was validated at startup via validate_jwt_secret()\n/// If the secret is missing, this will return a default that will cause authentication to fail\nfn jwt_secret() -> String {\n    // Check custom path from JWT_SECRET_FILE first\n    if let Ok(custom_path) = env::var(\"JWT_SECRET_FILE\")\n        && let Ok(content) = fs::read_to_string(&custom_path)\n    {\n        return content.trim().to_string();\n    }\n\n    // Try Docker secret file\n    if let Ok(content) = fs::read_to_string(\"/run/secrets/jwt_secret\") {\n        return content.trim().to_string();\n    }\n\n    // Fall back to environment variable\n    // At this point, the secret should have been validated at startup\n    // If it's still missing, return a placeholder that will cause auth failures\n    env::var(\"JWT_SECRET\").unwrap_or_else(|_| {\n        tracing::error!(\n            \"JWT_SECRET not found - authentication will fail. \\\n             This should have been caught at startup validation.\"\n        );\n        // Return a value that will cause JWT operations to fail gracefully\n        \"INVALID_SECRET_NOT_CONFIGURED\".to_string()\n    })\n}\n\n// Setup endpoints\npub async fn get_setup_status(pool: DbPool) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let query = \"SELECT COUNT(*) FROM users WHERE is_admin = true\";\n\n    match db.query_one(query, &[]).await {\n        Ok(row) => {\n            let admin_count: i64 = row.get(0);\n            let needs_setup = admin_count == 0;\n\n            let response = SetupStatusResponse {\n                needs_setup,\n                has_admin: !needs_setup,\n            };\n\n            Ok(warp::reply::json(&response))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\n                \"error\": \"Failed to check setup status\"\n            })))\n        }\n    }\n}\n\npub async fn create_setup_user(\n    setup_req: SetupRequest,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Check if setup is still needed\n    let check_query = \"SELECT COUNT(*) FROM users WHERE is_admin = true\";\n    if let Ok(row) = db.query_one(check_query, &[]).await {\n        let admin_count: i64 = row.get(0);\n        if admin_count > 0 {\n            return Ok(warp::reply::with_status(\n                warp::reply::json(&json!({\n                    \"error\": \"Setup has already been completed\"\n                })),\n                warp::http::StatusCode::BAD_REQUEST,\n            )\n            .into_response());\n        }\n    }\n\n    // Hash password (using spawn_blocking to avoid blocking async runtime)\n    let password_hash = match hash_password(setup_req.user.password.clone()).await {\n        Ok(hash) => hash,\n        Err(e) => {\n            tracing::error!(error = %e, \"Password hashing error\");\n            return Ok(warp::reply::with_status(\n                warp::reply::json(&json!({\n                    \"error\": \"Failed to process password\"\n                })),\n                warp::http::StatusCode::INTERNAL_SERVER_ERROR,\n            )\n            .into_response());\n        }\n    };\n\n    let user_id = Uuid::new_v4();\n    let now = Utc::now();\n\n    let query = \"\n        INSERT INTO users (id, username, email, full_name, password_hash, is_admin, is_active, created_at, updated_at)\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n        RETURNING id, username, email, full_name, is_admin, is_active, created_at, updated_at\n    \";\n\n    match db\n        .query_one(\n            query,\n            &[\n                &user_id,\n                &setup_req.user.username,\n                &setup_req.user.email,\n                &setup_req.user.full_name,\n                &password_hash,\n                &true, // First user is admin\n                &true, // Active by default\n                &now,\n                &now,\n            ],\n        )\n        .await\n    {\n        Ok(row) => {\n            // Generate JWT token\n            let token = match generate_token(&user_id.to_string(), &setup_req.user.username) {\n                Ok(token) => token,\n                Err(e) => {\n                    tracing::error!(error = %e, \"Token generation error\");\n                    return Ok(warp::reply::with_status(\n                        warp::reply::json(&json!({\n                            \"error\": \"Failed to generate authentication token\"\n                        })),\n                        warp::http::StatusCode::INTERNAL_SERVER_ERROR,\n                    )\n                    .into_response());\n                }\n            };\n\n            let user_response = UserResponse {\n                id: row.get(\"id\"),\n                username: row.get(\"username\"),\n                email: row.get(\"email\"),\n                full_name: row.get(\"full_name\"),\n                is_admin: row.get(\"is_admin\"),\n                is_active: row.get(\"is_active\"),\n                created_at: row.get(\"created_at\"),\n                updated_at: row.get(\"updated_at\"),\n            };\n\n            // Create the first humidor\n            let humidor_id = Uuid::new_v4();\n            let humidor_query = \"\n                INSERT INTO humidors (id, user_id, name, description, capacity, target_humidity, location, created_at, updated_at)\n                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n            \";\n\n            if let Err(e) = db\n                .execute(\n                    humidor_query,\n                    &[\n                        &humidor_id,\n                        &user_id,\n                        &setup_req.humidor.name,\n                        &setup_req.humidor.description,\n                        &setup_req.humidor.capacity,\n                        &setup_req.humidor.target_humidity,\n                        &setup_req.humidor.location,\n                        &now,\n                        &now,\n                    ],\n                )\n                .await\n            {\n                tracing::error!(error = %e, \"Failed to create humidor\");\n                return Ok(warp::reply::with_status(\n                    warp::reply::json(&json!({\n                        \"error\": \"Failed to create humidor\"\n                    })),\n                    warp::http::StatusCode::INTERNAL_SERVER_ERROR,\n                )\n                .into_response());\n            }\n\n            // Seed default organizers for the new user\n            if let Err(e) = seed_default_organizers(&db, &user_id).await {\n                tracing::error!(error = %e, user_id = %user_id, \"Failed to seed default organizers\");\n                // Don't fail the setup if organizer seeding fails\n                // User can still create their own organizers\n            }\n\n            let response = json!({\n                \"user\": user_response,\n                \"token\": token,\n                \"humidor_id\": humidor_id.to_string()\n            });\n\n            Ok(warp::reply::json(&response).into_response())\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            if e.to_string().contains(\"duplicate key\") {\n                Ok(warp::reply::with_status(\n                    warp::reply::json(&json!({\n                        \"error\": \"Username or email already exists\"\n                    })),\n                    warp::http::StatusCode::CONFLICT,\n                )\n                .into_response())\n            } else {\n                Ok(warp::reply::with_status(\n                    warp::reply::json(&json!({\n                        \"error\": \"Failed to create user\"\n                    })),\n                    warp::http::StatusCode::INTERNAL_SERVER_ERROR,\n                )\n                .into_response())\n            }\n        }\n    }\n}\n\n// Regular authentication endpoints\npub async fn login_user(\n    login_req: LoginRequest,\n    pool: DbPool,\n    rate_limiter: crate::middleware::RateLimiter,\n    client_ip: Option<std::net::IpAddr>,\n) -> Result<impl Reply, warp::Rejection> {\n    // Get client IP (default to localhost if not available, e.g., in tests)\n    let ip = client_ip.unwrap_or_else(|| {\n        use std::net::{IpAddr, Ipv4Addr};\n        IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1))\n    });\n\n    // Check rate limit before processing login\n    if rate_limiter.is_rate_limited(ip).await {\n        tracing::warn!(\n            ip = %ip,\n            username = %login_req.username,\n            \"Login attempt blocked due to rate limiting\"\n        );\n\n        return Ok(warp::reply::with_status(\n            warp::reply::json(&json!({\n                \"error\": \"Too many failed login attempts. Please try again later.\"\n            })),\n            warp::http::StatusCode::TOO_MANY_REQUESTS,\n        )\n        .into_response());\n    }\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let query = \"\n        SELECT id, username, email, full_name, password_hash, is_admin, is_active, created_at, updated_at\n        FROM users \n        WHERE username = $1 OR email = $1\n    \";\n\n    match db.query_opt(query, &[&login_req.username]).await {\n        Ok(Some(row)) => {\n            let password_hash: String = row.get(\"password_hash\");\n            let is_active: bool = row.get(\"is_active\");\n\n            if !is_active {\n                return Ok(warp::reply::with_status(\n                    warp::reply::json(&json!({\n                        \"error\": \"Account is disabled\"\n                    })),\n                    warp::http::StatusCode::UNAUTHORIZED,\n                )\n                .into_response());\n            }\n\n            // Verify password (using spawn_blocking to avoid blocking async runtime)\n            match verify_password(login_req.password.clone(), password_hash).await {\n                Ok(true) => {\n                    let user_id: Uuid = row.get(\"id\");\n                    let username: String = row.get(\"username\");\n\n                    let token = match generate_token(&user_id.to_string(), &username) {\n                        Ok(token) => token,\n                        Err(e) => {\n                            tracing::error!(error = %e, \"Token generation error\");\n                            return Ok(warp::reply::with_status(\n                                warp::reply::json(&json!({\n                                    \"error\": \"Authentication failed\"\n                                })),\n                                warp::http::StatusCode::INTERNAL_SERVER_ERROR,\n                            )\n                            .into_response());\n                        }\n                    };\n\n                    let user_response = UserResponse {\n                        id: row.get(\"id\"),\n                        username: row.get(\"username\"),\n                        email: row.get(\"email\"),\n                        full_name: row.get(\"full_name\"),\n                        is_admin: row.get(\"is_admin\"),\n                        is_active: row.get(\"is_active\"),\n                        created_at: row.get(\"created_at\"),\n                        updated_at: row.get(\"updated_at\"),\n                    };\n\n                    let response = LoginResponse {\n                        user: user_response,\n                        token,\n                    };\n\n                    // Clear rate limit records on successful login\n                    rate_limiter.clear_attempts(ip).await;\n\n                    tracing::info!(\n                        ip = %ip,\n                        username = %login_req.username,\n                        user_id = %user_id,\n                        \"Successful login\"\n                    );\n\n                    Ok(warp::reply::json(&response).into_response())\n                }\n                Ok(false) => {\n                    // Record failed login attempt\n                    rate_limiter.record_attempt(ip).await;\n\n                    tracing::warn!(\n                        ip = %ip,\n                        username = %login_req.username,\n                        \"Failed login attempt - invalid password\"\n                    );\n\n                    Ok(warp::reply::with_status(\n                        warp::reply::json(&json!({\n                            \"error\": \"Invalid username or password\"\n                        })),\n                        warp::http::StatusCode::UNAUTHORIZED,\n                    )\n                    .into_response())\n                }\n                Err(e) => {\n                    tracing::error!(error = %e, \"Password verification error\");\n                    Ok(warp::reply::with_status(\n                        warp::reply::json(&json!({\n                            \"error\": \"Authentication failed\"\n                        })),\n                        warp::http::StatusCode::INTERNAL_SERVER_ERROR,\n                    )\n                    .into_response())\n                }\n            }\n        }\n        Ok(None) => {\n            // Record failed login attempt for non-existent user\n            rate_limiter.record_attempt(ip).await;\n\n            tracing::warn!(\n                ip = %ip,\n                username = %login_req.username,\n                \"Failed login attempt - user not found\"\n            );\n\n            Ok(warp::reply::with_status(\n                warp::reply::json(&json!({\n                    \"error\": \"Invalid username or password\"\n                })),\n                warp::http::StatusCode::UNAUTHORIZED,\n            )\n            .into_response())\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::with_status(\n                warp::reply::json(&json!({\n                    \"error\": \"Authentication failed\"\n                })),\n                warp::http::StatusCode::INTERNAL_SERVER_ERROR,\n            )\n            .into_response())\n        }\n    }\n}\n\n// Humidor endpoints for setup\n#[allow(dead_code)]\npub async fn create_humidor_for_setup(\n    humidor_req: CreateHumidorRequest,\n    user_id: String, // This would come from JWT auth middleware\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let humidor_id = Uuid::new_v4();\n    let user_uuid = match Uuid::parse_str(&user_id) {\n        Ok(uuid) => uuid,\n        Err(_) => {\n            return Ok(warp::reply::with_status(\n                warp::reply::json(&json!({\n                    \"error\": \"Invalid user ID\"\n                })),\n                warp::http::StatusCode::BAD_REQUEST,\n            )\n            .into_response());\n        }\n    };\n    let now = Utc::now();\n\n    let query = \"\n        INSERT INTO humidors (id, user_id, name, description, capacity, target_humidity, location, created_at, updated_at)\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n        RETURNING id, user_id, name, description, capacity, target_humidity, location, created_at, updated_at\n    \";\n\n    match db\n        .query_one(\n            query,\n            &[\n                &humidor_id,\n                &user_uuid,\n                &humidor_req.name,\n                &humidor_req.description,\n                &humidor_req.capacity,\n                &humidor_req.target_humidity,\n                &humidor_req.location,\n                &now,\n                &now,\n            ],\n        )\n        .await\n    {\n        Ok(row) => {\n            let humidor = Humidor {\n                id: row.get(\"id\"),\n                user_id: row.get(\"user_id\"),\n                name: row.get(\"name\"),\n                description: row.get(\"description\"),\n                capacity: row.get(\"capacity\"),\n                target_humidity: row.get(\"target_humidity\"),\n                location: row.get(\"location\"),\n                image_url: None, // No image during setup\n                created_at: row.get(\"created_at\"),\n                updated_at: row.get(\"updated_at\"),\n                is_owner: Some(true), // User creating during setup is owner\n                permission_level: Some(\"full\".to_string()),\n            };\n\n            Ok(warp::reply::json(&humidor).into_response())\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::with_status(\n                warp::reply::json(&json!({\n                    \"error\": \"Failed to create humidor\"\n                })),\n                warp::http::StatusCode::INTERNAL_SERVER_ERROR,\n            )\n            .into_response())\n        }\n    }\n}\n\n// JWT token utilities\nfn generate_token(user_id: &str, username: &str) -> Result<String, jsonwebtoken::errors::Error> {\n    // Get token lifetime from environment or use default of 2 hours\n    let token_lifetime_hours: i64 = env::var(\"JWT_TOKEN_LIFETIME_HOURS\")\n        .ok()\n        .and_then(|s| s.parse().ok())\n        .unwrap_or(2); // Default: 2 hours (more secure than 24)\n\n    let now = chrono::Utc::now();\n    let iat = now.timestamp() as usize;\n    let expiration = now\n        .checked_add_signed(chrono::Duration::hours(token_lifetime_hours))\n        .ok_or_else(|| {\n            tracing::error!(\"Failed to calculate token expiration timestamp\");\n            jsonwebtoken::errors::Error::from(jsonwebtoken::errors::ErrorKind::InvalidToken)\n        })?\n        .timestamp() as usize;\n\n    let claims = Claims {\n        sub: user_id.to_owned(),\n        username: username.to_owned(),\n        exp: expiration,\n        iat,\n    };\n\n    let header = Header::new(Algorithm::HS256);\n    let secret = jwt_secret();\n    let key = EncodingKey::from_secret(secret.as_bytes());\n\n    encode(&header, &claims, &key)\n}\n\npub fn verify_token(token: &str) -> Result<Claims, jsonwebtoken::errors::Error> {\n    let secret = jwt_secret();\n    let key = DecodingKey::from_secret(secret.as_bytes());\n    let validation = Validation::new(Algorithm::HS256);\n\n    decode::<Claims>(token, &key, &validation).map(|data| data.claims)\n}\n\n// User profile management\npub async fn get_current_user(\n    auth: crate::middleware::AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db.query_one(\n        \"SELECT id, username, email, full_name, is_admin, is_active, created_at, updated_at FROM users WHERE id = $1\",\n        &[&auth.user_id]\n    ).await {\n        Ok(row) => {\n            let user = UserResponse {\n                id: row.get(0),\n                username: row.get(1),\n                email: row.get(2),\n                full_name: row.get(3),\n                is_admin: row.get(4),\n                is_active: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n            };\n            Ok(warp::reply::json(&user))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\"error\": \"Failed to fetch user\"})))\n        }\n    }\n}\n\npub async fn update_current_user(\n    update_req: crate::models::UpdateUserRequest,\n    auth: crate::middleware::AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let mut updates = Vec::new();\n    let mut values: Vec<String> = Vec::new();\n    let mut param_index = 1;\n\n    if let Some(username) = &update_req.username {\n        updates.push(format!(\"username = ${}\", param_index));\n        values.push(username.clone());\n        param_index += 1;\n    }\n\n    if let Some(email) = &update_req.email {\n        updates.push(format!(\"email = ${}\", param_index));\n        values.push(email.clone());\n        param_index += 1;\n    }\n\n    if let Some(full_name) = &update_req.full_name {\n        updates.push(format!(\"full_name = ${}\", param_index));\n        values.push(full_name.clone());\n        param_index += 1;\n    }\n\n    if updates.is_empty() {\n        return Ok(warp::reply::json(\n            &json!({\"message\": \"No updates provided\"}),\n        ));\n    }\n\n    updates.push(format!(\"updated_at = ${}\", param_index));\n    let now = Utc::now();\n\n    let query = format!(\n        \"UPDATE users SET {} WHERE id = ${} RETURNING id, username, email, full_name, is_admin, is_active, created_at, updated_at\",\n        updates.join(\", \"),\n        param_index + 1\n    );\n\n    // Build parameters\n    let mut params: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> = Vec::new();\n    for value in &values {\n        params.push(value);\n    }\n    params.push(&now);\n    params.push(&auth.user_id);\n\n    match db.query_one(&query, &params).await {\n        Ok(row) => {\n            let user = UserResponse {\n                id: row.get(0),\n                username: row.get(1),\n                email: row.get(2),\n                full_name: row.get(3),\n                is_admin: row.get(4),\n                is_active: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n            };\n            Ok(warp::reply::json(&user))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to update user\"}),\n            ))\n        }\n    }\n}\n\npub async fn change_password(\n    password_req: crate::models::ChangePasswordRequest,\n    auth: crate::middleware::AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Get current password hash\n    match db\n        .query_one(\n            \"SELECT password_hash FROM users WHERE id = $1\",\n            &[&auth.user_id],\n        )\n        .await\n    {\n        Ok(row) => {\n            let current_hash: String = row.get(0);\n\n            // Verify current password (using spawn_blocking to avoid blocking async runtime)\n            match verify_password(password_req.current_password.clone(), current_hash).await {\n                Ok(valid) => {\n                    if !valid {\n                        return Ok(warp::reply::json(\n                            &json!({\"error\": \"Current password is incorrect\"}),\n                        ));\n                    }\n                }\n                Err(e) => {\n                    tracing::error!(error = %e, \"Password verification error\");\n                    return Ok(warp::reply::json(\n                        &json!({\"error\": \"Password verification failed\"}),\n                    ));\n                }\n            }\n\n            // Hash new password (using spawn_blocking to avoid blocking async runtime)\n            let new_hash = match hash_password(password_req.new_password.clone()).await {\n                Ok(h) => h,\n                Err(e) => {\n                    tracing::error!(error = %e, \"Password hashing error\");\n                    return Ok(warp::reply::json(\n                        &json!({\"error\": \"Failed to hash new password\"}),\n                    ));\n                }\n            };\n\n            // Update password\n            let now = Utc::now();\n            match db\n                .execute(\n                    \"UPDATE users SET password_hash = $1, updated_at = $2 WHERE id = $3\",\n                    &[&new_hash, &now, &auth.user_id],\n                )\n                .await\n            {\n                Ok(_) => Ok(warp::reply::json(\n                    &json!({\"message\": \"Password updated successfully\"}),\n                )),\n                Err(e) => {\n                    tracing::error!(error = %e, \"Database error\");\n                    Ok(warp::reply::json(\n                        &json!({\"error\": \"Failed to update password\"}),\n                    ))\n                }\n            }\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\"error\": \"Failed to fetch user\"})))\n        }\n    }\n}\n\n// Password Reset Handlers\nuse crate::models::{ForgotPasswordRequest, ResetPasswordRequest};\nuse crate::services::EmailService;\nuse rand::Rng;\n\n/// Generate a secure random token for password reset\nfn generate_reset_token() -> String {\n    rand::thread_rng()\n        .sample_iter(&rand::distributions::Alphanumeric)\n        .take(64)\n        .map(char::from)\n        .collect()\n}\n\n/// Handle forgot password request - generates token and sends reset email\npub async fn forgot_password(\n    request: ForgotPasswordRequest,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Look up user by email (case-insensitive)\n    let user_result = db\n        .query_opt(\n            \"SELECT id, username, email FROM users WHERE LOWER(email) = LOWER($1)\",\n            &[&request.email],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Database error checking user\");\n            warp::reject::reject()\n        })?;\n\n    // Don't reveal whether user exists (security best practice)\n    let user_row = match user_result {\n        Some(row) => row,\n        None => {\n            tracing::info!(\n                email = %request.email,\n                \"Password reset requested for non-existent email\"\n            );\n            return Ok(warp::reply::json(&json!({\n                \"message\": \"If that email exists, a password reset link has been sent\"\n            })));\n        }\n    };\n\n    let user_id: Uuid = user_row.get(0);\n\n    // Generate secure token\n    let token = generate_reset_token();\n    let token_id = Uuid::new_v4();\n    let now = Utc::now();\n\n    // Store token in database\n    db.execute(\n        \"INSERT INTO password_reset_tokens (id, user_id, token, created_at) VALUES ($1, $2, $3, $4)\",\n        &[&token_id, &user_id, &token, &now],\n    )\n    .await\n    .map_err(|e| {\n        tracing::error!(error = %e, \"Failed to store password reset token\");\n        warp::reject::reject()\n    })?;\n\n    // Send email with reset link\n    let base_url = env::var(\"BASE_URL\").unwrap_or_else(|_| \"http://localhost:9898\".to_string());\n    let reset_url = format!(\"{}/reset-password.html?token={}\", base_url, token);\n\n    // Try to send email, but don't fail if SMTP isn't configured\n    match EmailService::from_env() {\n        Ok(email_service) => {\n            if let Err(e) = email_service\n                .send_password_reset_email(&request.email, &reset_url)\n                .await\n            {\n                tracing::error!(error = %e, \"Failed to send password reset email\");\n                tracing::info!(reset_url = %reset_url, \"Password reset URL (for testing)\");\n            }\n        }\n        Err(e) => {\n            tracing::warn!(error = %e, \"Email service not configured\");\n            tracing::info!(reset_url = %reset_url, \"Password reset URL (for testing)\");\n        }\n    }\n\n    Ok(warp::reply::json(&json!({\n        \"message\": \"If that email exists, a password reset link has been sent\"\n    })))\n}\n\n/// Handle reset password request - validates token and updates password\npub async fn reset_password(\n    request: ResetPasswordRequest,\n    pool: DbPool,\n) -> Result<impl Reply, warp::Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Validate token and get user_id\n    let token_result = db\n        .query_opt(\n            \"SELECT user_id, created_at FROM password_reset_tokens WHERE token = $1\",\n            &[&request.token],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Database error checking token\");\n            warp::reject::reject()\n        })?;\n\n    let token_row = match token_result {\n        Some(row) => row,\n        None => {\n            tracing::warn!(\"Invalid or expired password reset token used\");\n            return Err(warp::reject::custom(AppError::BadRequest(\n                \"Invalid or expired reset token\".to_string(),\n            )));\n        }\n    };\n\n    let user_id: Uuid = token_row.get(0);\n    let created_at: chrono::DateTime<Utc> = token_row.get(1);\n\n    // Check if token is expired (30 minutes)\n    let expiration_duration = chrono::Duration::minutes(30);\n    if Utc::now().signed_duration_since(created_at) > expiration_duration {\n        // Delete expired token\n        db.execute(\n            \"DELETE FROM password_reset_tokens WHERE token = $1\",\n            &[&request.token],\n        )\n        .await\n        .ok();\n\n        return Err(warp::reject::custom(AppError::BadRequest(\n            \"Reset token has expired\".to_string(),\n        )));\n    }\n\n    // Hash new password\n    let password_hash = match hash_password(request.password.clone()).await {\n        Ok(h) => h,\n        Err(e) => {\n            tracing::error!(error = %e, \"Password hashing error\");\n            return Err(warp::reject::custom(AppError::InternalServerError(\n                \"Failed to hash password\".to_string(),\n            )));\n        }\n    };\n\n    // Update user's password\n    let now = Utc::now();\n    db.execute(\n        \"UPDATE users SET password_hash = $1, updated_at = $2 WHERE id = $3\",\n        &[&password_hash, &now, &user_id],\n    )\n    .await\n    .map_err(|e| {\n        tracing::error!(error = %e, \"Failed to update password\");\n        warp::reject::reject()\n    })?;\n\n    // Delete the used token\n    db.execute(\n        \"DELETE FROM password_reset_tokens WHERE token = $1\",\n        &[&request.token],\n    )\n    .await\n    .ok();\n\n    tracing::info!(user_id = %user_id, \"Password reset successful\");\n\n    Ok(warp::reply::json(&json!({\n        \"message\": \"Password has been reset successfully\"\n    })))\n}\n\n/// Check if email service is configured\npub async fn check_email_config() -> Result<impl Reply, warp::Rejection> {\n    let smtp_host = env::var(\"SMTP_HOST\").ok();\n    let smtp_user = env::var(\"SMTP_USER\").ok();\n    let smtp_password = env::var(\"SMTP_PASSWORD\").ok();\n\n    // Use pattern matching to safely check all conditions\n    let is_configured = matches!(\n        (&smtp_host, &smtp_user, &smtp_password),\n        (Some(h), Some(u), Some(p)) if !h.is_empty() && !u.is_empty() && !p.is_empty()\n    );\n\n    Ok(warp::reply::json(&json!({\n        \"email_configured\": is_configured\n    })))\n}\n\n/// Seed default organizers for a new user\npub async fn seed_default_organizers(\n    db: &deadpool_postgres::Client,\n    user_id: &Uuid,\n) -> Result<(), Box<dyn std::error::Error>> {\n    let now = Utc::now();\n\n    // Seed strengths\n    let strengths = vec![\n        (\"Mild\", 1, \"Light and smooth, perfect for beginners\"),\n        (\n            \"Medium-Mild\",\n            2,\n            \"Slightly more body than mild, still approachable\",\n        ),\n        (\"Medium\", 3, \"Balanced strength with good complexity\"),\n        (\"Medium-Full\", 4, \"Strong flavor with substantial body\"),\n        (\"Full\", 5, \"Bold and intense, for experienced smokers\"),\n    ];\n\n    for (name, level, desc) in strengths {\n        db.execute(\n            \"INSERT INTO strengths (id, user_id, name, level, description, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7)\",\n            &[&Uuid::new_v4(), user_id, &name, &level, &desc, &now, &now],\n        ).await?;\n    }\n\n    // Seed ring gauges\n    let ring_gauges = vec![\n        (38, \"Very thin gauge, quick smoke\"),\n        (42, \"Classic thin gauge\"),\n        (44, \"Standard corona size\"),\n        (46, \"Popular medium gauge\"),\n        (48, \"Medium-thick gauge\"),\n        (50, \"Classic robusto gauge\"),\n        (52, \"Thick robusto gauge\"),\n        (54, \"Toro gauge\"),\n        (56, \"Churchill gauge\"),\n        (58, \"Thick churchill\"),\n        (60, \"Very thick gauge\"),\n    ];\n\n    for (gauge, desc) in ring_gauges {\n        db.execute(\n            \"INSERT INTO ring_gauges (id, user_id, gauge, description, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6)\",\n            &[&Uuid::new_v4(), user_id, &gauge, &desc, &now, &now],\n        ).await?;\n    }\n\n    // Seed brands - Top 25 premium cigar brands\n    let brands = vec![\n        (\n            \"Arturo Fuente\",\n            \"Premium Dominican cigars, known for OpusX and Hemingway lines\",\n            \"Dominican Republic\",\n        ),\n        (\n            \"Davidoff\",\n            \"Luxury Swiss brand with premium tobacco\",\n            \"Switzerland\",\n        ),\n        (\n            \"Padron\",\n            \"Family-owned Nicaraguan brand known for quality and consistency\",\n            \"Nicaragua\",\n        ),\n        (\"Cohiba\", \"Iconic Cuban brand, flagship of Habanos\", \"Cuba\"),\n        (\n            \"Montecristo\",\n            \"One of the most recognized Cuban brands worldwide\",\n            \"Cuba\",\n        ),\n        (\n            \"Romeo y Julieta\",\n            \"Classic Cuban brand with wide range of vitolas\",\n            \"Cuba\",\n        ),\n        (\n            \"Oliva\",\n            \"Nicaraguan family business with consistent quality\",\n            \"Nicaragua\",\n        ),\n        (\n            \"My Father\",\n            \"Premium Nicaraguan brand by Jose 'Pepin' Garcia\",\n            \"Nicaragua\",\n        ),\n        (\n            \"Drew Estate\",\n            \"Innovative American brand, makers of Liga Privada and Acid\",\n            \"United States\",\n        ),\n        (\n            \"Rocky Patel\",\n            \"Popular brand with wide range of blends\",\n            \"Honduras\",\n        ),\n        (\n            \"Ashton\",\n            \"Premium brand with Dominican and Nicaraguan lines\",\n            \"United States\",\n        ),\n        (\n            \"Perdomo\",\n            \"Nicaraguan brand with extensive aging and quality control\",\n            \"Nicaragua\",\n        ),\n        (\n            \"Alec Bradley\",\n            \"Honduran brand known for Prensado and Tempus lines\",\n            \"Honduras\",\n        ),\n        (\n            \"Tatuaje\",\n            \"Boutique brand by Pete Johnson with Cuban-style blends\",\n            \"Nicaragua\",\n        ),\n        (\n            \"Liga Privada\",\n            \"Drew Estate's ultra-premium line\",\n            \"United States\",\n        ),\n        (\n            \"Partags\",\n            \"Historic Cuban brand with full-bodied character\",\n            \"Cuba\",\n        ),\n        (\n            \"Hoyo de Monterrey\",\n            \"Refined Cuban brand with balanced profiles\",\n            \"Cuba\",\n        ),\n        (\n            \"H. Upmann\",\n            \"Classic Cuban brand with elegant smoking experience\",\n            \"Cuba\",\n        ),\n        (\n            \"Bolivar\",\n            \"Strong Cuban brand for experienced smokers\",\n            \"Cuba\",\n        ),\n        (\n            \"La Flor Dominicana\",\n            \"Dominican boutique brand known for bold flavors\",\n            \"Dominican Republic\",\n        ),\n        (\n            \"CAO\",\n            \"Wide range of blends from mild to full-bodied\",\n            \"Nicaragua\",\n        ),\n        (\n            \"Punch\",\n            \"Traditional Cuban brand with consistent quality\",\n            \"Cuba\",\n        ),\n        (\n            \"Macanudo\",\n            \"Mild, smooth Dominican brand perfect for beginners\",\n            \"Dominican Republic\",\n        ),\n        (\n            \"Crowned Heads\",\n            \"Boutique brand with unique collaborations\",\n            \"Nicaragua\",\n        ),\n        (\n            \"Illusione\",\n            \"Small-batch Nicaraguan brand with exceptional quality\",\n            \"Nicaragua\",\n        ),\n    ];\n\n    for (name, desc, country) in brands {\n        db.execute(\n            \"INSERT INTO brands (id, user_id, name, description, country, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7)\",\n            &[&Uuid::new_v4(), user_id, &name, &desc, &country, &now, &now],\n        ).await?;\n    }\n\n    // Seed origins\n    let origins = vec![\n        (\n            \"Cuba\",\n            \"Cuba\",\n            \"Historic birthplace of premium cigars, known for rich flavor profiles\",\n        ),\n        (\n            \"Dominican Republic\",\n            \"Dominican Republic\",\n            \"World's largest cigar producer, known for smooth, mild to medium cigars\",\n        ),\n        (\n            \"Nicaragua\",\n            \"Nicaragua\",\n            \"Produces full-bodied, peppery cigars with bold flavors\",\n        ),\n        (\n            \"Honduras\",\n            \"Honduras\",\n            \"Known for robust, flavorful cigars with Cuban-seed tobacco\",\n        ),\n        (\n            \"Mexico\",\n            \"Mexico\",\n            \"Produces rich, earthy cigars with quality wrapper tobacco\",\n        ),\n        (\n            \"United States\",\n            \"United States\",\n            \"Home to premium brands and innovative blends\",\n        ),\n        (\n            \"Ecuador\",\n            \"Ecuador\",\n            \"Famous for high-quality Connecticut Shade wrapper tobacco\",\n        ),\n    ];\n\n    for (name, country, desc) in origins {\n        db.execute(\n            \"INSERT INTO origins (id, user_id, name, country, description, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7)\",\n            &[&Uuid::new_v4(), user_id, &name, &country, &desc, &now, &now],\n        ).await?;\n    }\n\n    // Seed sizes\n    let sizes = vec![\n        (\n            \"Petit Corona\",\n            4.5,\n            42,\n            \"Small classic size, 30-40 minute smoke\",\n        ),\n        (\n            \"Corona\",\n            5.5,\n            42,\n            \"Traditional Cuban size, balanced proportions\",\n        ),\n        (\"Robusto\", 5.0, 50, \"Most popular size, 45-60 minute smoke\"),\n        (\"Toro\", 6.0, 50, \"Popular modern size, well-balanced\"),\n        (\n            \"Churchill\",\n            7.0,\n            47,\n            \"Named after Winston Churchill, elegant size\",\n        ),\n        (\"Gordo\", 6.0, 60, \"Large ring gauge, cooler smoke\"),\n        (\"Lancero\", 7.5, 38, \"Long and thin, concentrated flavors\"),\n        (\"Torpedo\", 6.125, 52, \"Tapered head, concentrated flavors\"),\n    ];\n\n    for (name, length, gauge, desc) in sizes {\n        db.execute(\n            \"INSERT INTO sizes (id, user_id, name, length_inches, ring_gauge, description, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\",\n            &[&Uuid::new_v4(), user_id, &name, &length, &gauge, &desc, &now, &now],\n        ).await?;\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","backups.rs"],"content":"use crate::middleware::auth::AuthContext;\nuse crate::services::backup::{\n    BackupInfo, create_backup, delete_backup, list_backups, restore_backup,\n};\nuse bytes::Buf;\nuse deadpool_postgres::Pool as DbPool;\nuse futures::StreamExt;\nuse serde::Serialize;\nuse std::path::Path;\nuse warp::{Rejection, Reply};\n\n#[derive(Serialize)]\npub struct BackupsResponse {\n    pub backups: Vec<BackupInfo>,\n}\n\n#[derive(Serialize)]\npub struct MessageResponse {\n    pub message: String,\n}\n\npub async fn get_backups(_auth: AuthContext, _pool: DbPool) -> Result<impl Reply, Rejection> {\n    match list_backups() {\n        Ok(backups) => Ok(warp::reply::json(&BackupsResponse { backups })),\n        Err(e) => {\n            tracing::error!(error = %e, \"Error listing backups\");\n            Ok(warp::reply::json(&BackupsResponse {\n                backups: Vec::new(),\n            }))\n        }\n    }\n}\n\npub async fn create_backup_handler(\n    _auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::reject()\n    })?;\n\n    match create_backup(&db).await {\n        Ok(backup_name) => Ok(warp::reply::json(&MessageResponse {\n            message: format!(\"Backup created successfully: {}\", backup_name),\n        })),\n        Err(e) => {\n            tracing::error!(error = %e, \"Error creating backup\");\n            Ok(warp::reply::json(&MessageResponse {\n                message: format!(\"Error creating backup: {}\", e),\n            }))\n        }\n    }\n}\n\npub async fn download_backup(\n    filename: String,\n    _auth: AuthContext,\n    _pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let backups_dir = Path::new(\"backups\");\n    let backup_path = backups_dir.join(&filename);\n\n    // Security check: ensure the path is within backups directory\n    if !backup_path.starts_with(backups_dir) || !backup_path.exists() {\n        return Err(warp::reject::not_found());\n    }\n\n    // Read the file\n    match tokio::fs::read(&backup_path).await {\n        Ok(contents) => {\n            let response = warp::http::Response::builder()\n                .header(\"Content-Type\", \"application/zip\")\n                .header(\n                    \"Content-Disposition\",\n                    format!(\"attachment; filename=\\\"{}\\\"\", filename),\n                )\n                .body(contents)\n                .map_err(|e| {\n                    tracing::error!(error = %e, \"Failed to build HTTP response for backup download\");\n                    warp::reject::reject()\n                })?;\n            Ok(response)\n        }\n        Err(e) => {\n            tracing::error!(\n                filename = %filename,\n                error = %e,\n                \"Error reading backup file\"\n            );\n            Err(warp::reject::not_found())\n        }\n    }\n}\n\npub async fn delete_backup_handler(\n    filename: String,\n    _auth: AuthContext,\n    _pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    match delete_backup(&filename) {\n        Ok(()) => Ok(warp::reply::json(&MessageResponse {\n            message: format!(\"Backup {} deleted successfully\", filename),\n        })),\n        Err(e) => {\n            tracing::error!(error = %e, \"Error deleting backup\");\n            Ok(warp::reply::json(&MessageResponse {\n                message: format!(\"Error deleting backup: {}\", e),\n            }))\n        }\n    }\n}\n\npub async fn restore_backup_handler(\n    filename: String,\n    _auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::reject()\n    })?;\n\n    match restore_backup(&db, &filename).await {\n        Ok(()) => Ok(warp::reply::json(&MessageResponse {\n            message: \"Backup restored successfully. Please refresh the page.\".to_string(),\n        })),\n        Err(e) => {\n            tracing::error!(error = %e, \"Error restoring backup\");\n            Ok(warp::reply::json(&MessageResponse {\n                message: format!(\"Error restoring backup: {}\", e),\n            }))\n        }\n    }\n}\n\npub async fn upload_backup(\n    form: warp::multipart::FormData,\n    _auth: AuthContext,\n    _pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    use futures::StreamExt;\n\n    let backups_dir = Path::new(\"backups\");\n    std::fs::create_dir_all(backups_dir).map_err(|e| {\n        tracing::error!(error = %e, \"Failed to create backups directory\");\n        warp::reject::reject()\n    })?;\n\n    let mut parts = form;\n\n    while let Some(Ok(mut part)) = parts.next().await {\n        if part.name() == \"file\" {\n            let filename = part.filename().unwrap_or(\"backup.zip\").to_string();\n\n            // Security check: ensure it's a zip file\n            if !filename.ends_with(\".zip\") {\n                return Ok(warp::reply::json(&MessageResponse {\n                    message: \"Only .zip files are allowed\".to_string(),\n                }));\n            }\n\n            let backup_path = backups_dir.join(&filename);\n\n            // Security check: ensure the path is within backups directory\n            if !backup_path.starts_with(backups_dir) {\n                return Ok(warp::reply::json(&MessageResponse {\n                    message: \"Invalid filename\".to_string(),\n                }));\n            }\n\n            // Collect all data into a buffer\n            let mut buffer = Vec::new();\n            while let Some(Ok(mut chunk)) = part.data().await {\n                // Read all bytes from the Buf\n                while chunk.has_remaining() {\n                    let bytes = chunk.chunk();\n                    buffer.extend_from_slice(bytes);\n                    let len = bytes.len();\n                    chunk.advance(len);\n                }\n            }\n\n            // Write to file\n            tokio::fs::write(&backup_path, &buffer).await.map_err(|e| {\n                tracing::error!(error = %e, \"Error writing file\");\n                warp::reject::reject()\n            })?;\n\n            return Ok(warp::reply::json(&MessageResponse {\n                message: format!(\"Backup {} uploaded successfully\", filename),\n            }));\n        }\n    }\n\n    Ok(warp::reply::json(&MessageResponse {\n        message: \"No file provided\".to_string(),\n    }))\n}\n\n// Setup restore - upload and restore backup during initial setup (no auth required)\npub async fn setup_restore_backup(\n    mut form: warp::multipart::FormData,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let uploads_dir = Path::new(\"uploads\");\n\n    // Process multipart form data\n    while let Some(Ok(mut part)) = form.next().await {\n        if part.name() == \"file\" {\n            let filename = part\n                .filename()\n                .map(|s| s.to_string())\n                .unwrap_or_else(|| \"backup.zip\".to_string());\n\n            if !filename.ends_with(\".zip\") {\n                return Ok(warp::reply::json(&MessageResponse {\n                    message: \"Invalid file type. Only .zip files are allowed\".to_string(),\n                }));\n            }\n\n            let backup_path = uploads_dir.join(&filename);\n\n            // Security check: ensure the path is within uploads directory\n            if !backup_path.starts_with(uploads_dir) {\n                return Ok(warp::reply::json(&MessageResponse {\n                    message: \"Invalid filename\".to_string(),\n                }));\n            }\n\n            // Collect all data into a buffer\n            let mut buffer = Vec::new();\n            while let Some(Ok(mut chunk)) = part.data().await {\n                while chunk.has_remaining() {\n                    let bytes = chunk.chunk();\n                    buffer.extend_from_slice(bytes);\n                    let len = bytes.len();\n                    chunk.advance(len);\n                }\n            }\n\n            // Write to file\n            tokio::fs::write(&backup_path, &buffer).await.map_err(|e| {\n                tracing::error!(error = %e, \"Error writing file\");\n                warp::reject::reject()\n            })?;\n\n            // Now restore the backup\n            let db = pool.get().await.map_err(|e| {\n                tracing::error!(error = %e, \"Failed to get database connection\");\n                warp::reject::reject()\n            })?;\n\n            let backup_path_str = backup_path.to_str().ok_or_else(|| {\n                tracing::error!(\"Invalid path\");\n                warp::reject::reject()\n            })?;\n\n            // Convert error to String immediately to avoid Send issues across await\n            let result = restore_backup(&db, backup_path_str)\n                .await\n                .map_err(|e| format!(\"Error restoring backup: {}\", e));\n\n            // Clean up the uploaded file regardless of success/failure\n            let _ = tokio::fs::remove_file(&backup_path).await;\n\n            match result {\n                Ok(_) => {\n                    return Ok(warp::reply::json(&MessageResponse {\n                        message: \"Backup restored successfully\".to_string(),\n                    }));\n                }\n                Err(error_msg) => {\n                    tracing::error!(message = %error_msg, \"Backup error\");\n                    return Ok(warp::reply::json(&MessageResponse { message: error_msg }));\n                }\n            }\n        }\n    }\n\n    Ok(warp::reply::json(&MessageResponse {\n        message: \"No file provided\".to_string(),\n    }))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","brands.rs"],"content":"use chrono::Utc;\nuse serde_json::json;\nuse uuid::Uuid;\nuse warp::{Rejection, Reply};\n\nuse crate::{DbPool, errors::AppError, middleware::AuthContext, models::*, validation::Validate};\n\npub async fn get_brands(auth: AuthContext, pool: DbPool) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db.query(\n        \"SELECT id, user_id, name, description, country, website, created_at, updated_at FROM brands WHERE user_id = $1 ORDER BY name ASC\",\n        &[&auth.user_id]\n    ).await {\n        Ok(rows) => {\n            let mut brands = Vec::new();\n            for row in rows {\n                let brand = Brand {\n                    id: row.get(0),\n                    user_id: row.get(1),\n                    name: row.get(2),\n                    description: row.get(3),\n                    country: row.get(4),\n                    website: row.get(5),\n                    created_at: row.get(6),\n                    updated_at: row.get(7),\n                };\n                brands.push(brand);\n            }\n            Ok(warp::reply::json(&brands))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error fetching brands\");\n            Ok(warp::reply::json(&json!({\"error\": \"Failed to fetch brands\"})))\n        }\n    }\n}\n\npub async fn create_brand(\n    auth: AuthContext,\n    create_brand: CreateBrand,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate input\n    create_brand.validate().map_err(warp::reject::custom)?;\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let id = Uuid::new_v4();\n    let now = Utc::now();\n\n    match db\n        .query_one(\n            \"INSERT INTO brands (id, user_id, name, description, country, website, created_at, updated_at) \n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8) \n         RETURNING id, user_id, name, description, country, website, created_at, updated_at\",\n            &[\n                &id,\n                &auth.user_id,\n                &create_brand.name,\n                &create_brand.description,\n                &create_brand.country,\n                &create_brand.website,\n                &now,\n                &now,\n            ],\n        )\n        .await\n    {\n        Ok(row) => {\n            let brand = Brand {\n                id: row.get(0),\n                user_id: row.get(1),\n                name: row.get(2),\n                description: row.get(3),\n                country: row.get(4),\n                website: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n            };\n            Ok(warp::reply::json(&brand))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, brand_name = %create_brand.name, \"Database error creating brand\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to create brand\"}),\n            ))\n        }\n    }\n}\n\npub async fn update_brand(\n    id: Uuid,\n    auth: AuthContext,\n    update_brand: UpdateBrand,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate input\n    update_brand.validate().map_err(warp::reject::custom)?;\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let now = Utc::now();\n\n    match db\n        .query_opt(\n            \"UPDATE brands SET \n         name = COALESCE($2, name),\n         description = COALESCE($3, description),\n         country = COALESCE($4, country),\n         website = COALESCE($5, website),\n         updated_at = $6\n         WHERE id = $1 AND user_id = $7\n         RETURNING id, user_id, name, description, country, website, created_at, updated_at\",\n            &[\n                &id,\n                &update_brand.name,\n                &update_brand.description,\n                &update_brand.country,\n                &update_brand.website,\n                &now,\n                &auth.user_id,\n            ],\n        )\n        .await\n    {\n        Ok(Some(row)) => {\n            let brand = Brand {\n                id: row.get(0),\n                user_id: row.get(1),\n                name: row.get(2),\n                description: row.get(3),\n                country: row.get(4),\n                website: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n            };\n            Ok(warp::reply::json(&brand))\n        }\n        Ok(None) => Ok(warp::reply::json(\n            &json!({\"error\": \"Brand not found or unauthorized\"}),\n        )),\n        Err(e) => {\n            tracing::error!(error = %e, brand_id = %id, \"Database error updating brand\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to update brand\"}),\n            ))\n        }\n    }\n}\n\npub async fn delete_brand(\n    id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .execute(\n            \"DELETE FROM brands WHERE id = $1 AND user_id = $2\",\n            &[&id, &auth.user_id],\n        )\n        .await\n    {\n        Ok(rows_affected) => {\n            if rows_affected > 0 {\n                Ok(warp::reply::json(\n                    &json!({\"message\": \"Brand deleted successfully\"}),\n                ))\n            } else {\n                Ok(warp::reply::json(\n                    &json!({\"error\": \"Brand not found or unauthorized\"}),\n                ))\n            }\n        }\n        Err(e) => {\n            tracing::error!(error = %e, brand_id = %id, \"Database error deleting brand\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to delete brand\"}),\n            ))\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","cigars.rs"],"content":"use chrono::Utc;\nuse serde::Serialize;\nuse serde_json::json;\nuse uuid::Uuid;\nuse warp::{Rejection, Reply};\n\nuse crate::{\n    DbPool,\n    errors::AppError,\n    handlers::humidor_shares::{can_edit_humidor, can_view_humidor},\n    middleware::auth::AuthContext,\n    models::*,\n    validation::Validate,\n};\n\n#[derive(Debug, Serialize)]\npub struct CigarResponse {\n    pub cigars: Vec<CigarWithNames>,\n    pub total: i64,\n    pub page: i64,\n    pub page_size: i64,\n    pub total_pages: i64,\n}\n\n/// Helper function to verify that a humidor belongs to the authenticated user OR is shared with them with edit permissions\nasync fn verify_humidor_ownership(\n    pool: &DbPool,\n    humidor_id: Option<Uuid>,\n    user_id: Uuid,\n    require_edit: bool,\n) -> Result<(), AppError> {\n    if let Some(hid) = humidor_id {\n        // First check if user owns the humidor\n        let db = pool.get().await.map_err(|e| {\n            tracing::error!(error = %e, \"Failed to get database connection\");\n            AppError::DatabaseError(\"Failed to connect to database\".to_string())\n        })?;\n\n        let check_query = \"SELECT EXISTS(SELECT 1 FROM humidors WHERE id = $1 AND user_id = $2)\";\n        match db.query_one(check_query, &[&hid, &user_id]).await {\n            Ok(row) => {\n                let is_owner: bool = row.get(0);\n                if is_owner {\n                    return Ok(()); // Owner has full access\n                }\n            }\n            Err(e) => {\n                tracing::error!(error = %e, \"Failed to verify humidor ownership\");\n                return Err(AppError::DatabaseError(\n                    \"Failed to verify humidor access\".to_string(),\n                ));\n            }\n        }\n\n        // Not owner, check if it's shared with appropriate permissions\n        if require_edit {\n            if can_edit_humidor(pool, &user_id, &hid).await? {\n                return Ok(());\n            }\n        } else if can_view_humidor(pool, &user_id, &hid).await? {\n            return Ok(());\n        }\n\n        Err(AppError::Forbidden(\n            \"You do not have access to this humidor\".to_string(),\n        ))\n    } else {\n        // No humidor specified is okay for some operations (e.g., listing all cigars across humidors)\n        Ok(())\n    }\n}\n\n/// Helper function to verify that a cigar belongs to the authenticated user (through its humidor) OR is shared with them\nasync fn verify_cigar_ownership(\n    pool: &DbPool,\n    cigar_id: Uuid,\n    user_id: Uuid,\n    require_edit: bool,\n) -> Result<(), AppError> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        AppError::DatabaseError(\"Failed to connect to database\".to_string())\n    })?;\n\n    // Check if user owns the cigar through their humidor\n    let check_query = \"\n        SELECT EXISTS(\n            SELECT 1 FROM cigars c\n            INNER JOIN humidors h ON c.humidor_id = h.id\n            WHERE c.id = $1 AND h.user_id = $2\n        )\n    \";\n    match db.query_one(check_query, &[&cigar_id, &user_id]).await {\n        Ok(row) => {\n            let is_owner: bool = row.get(0);\n            if is_owner {\n                return Ok(()); // Owner has full access\n            }\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to verify cigar ownership\");\n            return Err(AppError::DatabaseError(\n                \"Failed to verify cigar access\".to_string(),\n            ));\n        }\n    }\n\n    // Check if cigar is in user's wish list (wish list cigars have NULL humidor_id)\n    let wish_list_query = \"\n        SELECT EXISTS(\n            SELECT 1 FROM wish_list\n            WHERE cigar_id = $1 AND user_id = $2\n        )\n    \";\n    match db.query_one(wish_list_query, &[&cigar_id, &user_id]).await {\n        Ok(row) => {\n            let in_wish_list: bool = row.get(0);\n            if in_wish_list {\n                return Ok(()); // User can access their wish list cigars\n            }\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to check wish list\");\n            return Err(AppError::DatabaseError(\n                \"Failed to verify cigar access\".to_string(),\n            ));\n        }\n    }\n\n    // Not owner or in wish list, get the humidor_id and check if it's shared\n    let humidor_query = \"SELECT humidor_id FROM cigars WHERE id = $1\";\n    match db.query_opt(humidor_query, &[&cigar_id]).await {\n        Ok(Some(row)) => {\n            let humidor_id: Option<Uuid> = row.get(0);\n\n            // If humidor_id is NULL, cigar doesn't belong to any humidor\n            if let Some(hum_id) = humidor_id {\n                // Check if humidor is shared with appropriate permissions\n                if require_edit {\n                    if can_edit_humidor(pool, &user_id, &hum_id).await? {\n                        return Ok(());\n                    }\n                } else if can_view_humidor(pool, &user_id, &hum_id).await? {\n                    return Ok(());\n                }\n            }\n        }\n        Ok(None) => {\n            return Err(AppError::NotFound(\"Cigar not found\".to_string()));\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to get cigar's humidor\");\n            return Err(AppError::DatabaseError(\n                \"Failed to verify cigar access\".to_string(),\n            ));\n        }\n    }\n\n    Err(AppError::Forbidden(\n        \"You do not have access to this cigar\".to_string(),\n    ))\n}\n\npub async fn get_cigars(\n    params: std::collections::HashMap<String, String>,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    use crate::errors::AppError;\n    use tokio_postgres::types::ToSql;\n\n    let start_time = std::time::Instant::now();\n\n    // Acquire a connection from the pool\n    let db = pool.get().await.map_err(|e| {\n        warp::reject::custom(AppError::DatabaseError(format!(\n            \"Connection pool error: {}\",\n            e\n        )))\n    })?;\n\n    // Parse pagination parameters\n    let page = params\n        .get(\"page\")\n        .and_then(|p| p.parse::<i64>().ok())\n        .unwrap_or(1)\n        .max(1); // Ensure page is at least 1\n\n    let page_size = params\n        .get(\"page_size\")\n        .and_then(|ps| ps.parse::<i64>().ok())\n        .unwrap_or(50)\n        .clamp(1, 100); // Allow 1-100 items per page\n\n    let offset = (page - 1) * page_size;\n\n    // Build query with JOINs to include organizer names from the humidor owner's organizers\n    // This ensures shared humidors display correctly even when the viewer doesn't have those organizers\n    let base_query = \"\n        SELECT \n            c.id, c.humidor_id, c.brand_id, c.name, c.size_id, c.strength_id, c.origin_id, \n            c.wrapper, c.binder, c.filler, c.price, c.purchase_date, c.notes, c.quantity, \n            c.ring_gauge_id, c.length, c.image_url, c.retail_link, c.is_active, c.created_at, c.updated_at,\n            b.name as brand_name, s.name as size_name, st.name as strength_name, \n            o.name as origin_name, rg.gauge as ring_gauge\n        FROM cigars c \n        INNER JOIN humidors h ON c.humidor_id = h.id \n        LEFT JOIN humidor_shares hs ON c.humidor_id = hs.humidor_id AND hs.shared_with_user_id = $1\n        LEFT JOIN brands b ON c.brand_id = b.id AND b.user_id = h.user_id\n        LEFT JOIN sizes s ON c.size_id = s.id AND s.user_id = h.user_id\n        LEFT JOIN strengths st ON c.strength_id = st.id AND st.user_id = h.user_id\n        LEFT JOIN origins o ON c.origin_id = o.id AND o.user_id = h.user_id\n        LEFT JOIN ring_gauges rg ON c.ring_gauge_id = rg.id AND rg.user_id = h.user_id\n    \";\n    let count_query = \"SELECT COUNT(*) FROM cigars c INNER JOIN humidors h ON c.humidor_id = h.id LEFT JOIN humidor_shares hs ON c.humidor_id = hs.humidor_id AND hs.shared_with_user_id = $1\";\n    let mut conditions = Vec::new();\n    let mut param_values: Vec<Box<dyn ToSql + Sync + Send>> = Vec::new();\n    let mut param_counter = 1;\n\n    // CRITICAL: Filter by user-owned humidors OR humidors shared with user\n    // $1 is already used in the LEFT JOIN above\n    conditions.push(format!(\n        \"(h.user_id = ${} OR hs.shared_with_user_id = ${})\",\n        param_counter, param_counter\n    ));\n    param_values.push(Box::new(auth.user_id));\n    param_counter += 1;\n\n    // Check for humidor_id filter\n    if let Some(humidor_id_str) = params.get(\"humidor_id\")\n        && let Ok(humidor_uuid) = Uuid::parse_str(humidor_id_str)\n    {\n        // Verify the humidor belongs to the user or is shared (view permission is enough)\n        if let Err(e) =\n            verify_humidor_ownership(&pool, Some(humidor_uuid), auth.user_id, false).await\n        {\n            return Err(warp::reject::custom(e));\n        }\n        conditions.push(format!(\"c.humidor_id = ${}\", param_counter));\n        param_values.push(Box::new(humidor_uuid));\n        param_counter += 1;\n    }\n\n    // Check for organizer filters (brand, size, origin, strength, ring_gauge)\n    if let Some(brand_id_str) = params.get(\"brand_id\")\n        && let Ok(brand_uuid) = Uuid::parse_str(brand_id_str)\n    {\n        conditions.push(format!(\"c.brand_id = ${}\", param_counter));\n        param_values.push(Box::new(brand_uuid));\n        param_counter += 1;\n    }\n    if let Some(size_id_str) = params.get(\"size_id\")\n        && let Ok(size_uuid) = Uuid::parse_str(size_id_str)\n    {\n        conditions.push(format!(\"c.size_id = ${}\", param_counter));\n        param_values.push(Box::new(size_uuid));\n        param_counter += 1;\n    }\n    if let Some(origin_id_str) = params.get(\"origin_id\")\n        && let Ok(origin_uuid) = Uuid::parse_str(origin_id_str)\n    {\n        conditions.push(format!(\"c.origin_id = ${}\", param_counter));\n        param_values.push(Box::new(origin_uuid));\n        param_counter += 1;\n    }\n    if let Some(strength_id_str) = params.get(\"strength_id\")\n        && let Ok(strength_uuid) = Uuid::parse_str(strength_id_str)\n    {\n        conditions.push(format!(\"c.strength_id = ${}\", param_counter));\n        param_values.push(Box::new(strength_uuid));\n        param_counter += 1;\n    }\n    if let Some(ring_gauge_id_str) = params.get(\"ring_gauge_id\")\n        && let Ok(ring_gauge_uuid) = Uuid::parse_str(ring_gauge_id_str)\n    {\n        conditions.push(format!(\"c.ring_gauge_id = ${}\", param_counter));\n        param_values.push(Box::new(ring_gauge_uuid));\n        param_counter += 1;\n    }\n\n    // Build WHERE clause\n    let where_clause = if conditions.is_empty() {\n        String::new()\n    } else {\n        format!(\" WHERE {}\", conditions.join(\" AND \"))\n    };\n\n    // Get total count with same filters\n    let total_count_query = format!(\"{}{}\", count_query, where_clause);\n\n    // Convert boxed parameters to references for query execution\n    let param_refs: Vec<&(dyn ToSql + Sync)> = param_values\n        .iter()\n        .map(|b| &**b as &(dyn ToSql + Sync))\n        .collect();\n\n    // Execute count query\n    let total = match db.query_one(&total_count_query, &param_refs[..]).await {\n        Ok(row) => row.get::<_, i64>(0),\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to get total count\");\n            return Err(warp::reject::custom(AppError::DatabaseError(\n                \"Failed to count cigars\".to_string(),\n            )));\n        }\n    };\n\n    let total_pages = (total as f64 / page_size as f64).ceil() as i64;\n\n    // Add pagination parameters to the param list\n    param_values.push(Box::new(page_size));\n    param_values.push(Box::new(offset));\n\n    // Rebuild param_refs with new values\n    let param_refs: Vec<&(dyn ToSql + Sync)> = param_values\n        .iter()\n        .map(|b| &**b as &(dyn ToSql + Sync))\n        .collect();\n\n    // Build the final query with pagination\n    let query = format!(\n        \"{}{} ORDER BY is_active DESC, created_at DESC LIMIT ${} OFFSET ${}\",\n        base_query,\n        where_clause,\n        param_counter,\n        param_counter + 1\n    );\n\n    match db.query(&query, &param_refs[..]).await {\n        Ok(rows) => {\n            let mut cigars = Vec::new();\n            for row in rows {\n                let cigar = Cigar {\n                    id: row.get(0),\n                    humidor_id: row.get(1),\n                    brand_id: row.get(2),\n                    name: row.get(3),\n                    size_id: row.get(4),\n                    strength_id: row.get(5),\n                    origin_id: row.get(6),\n                    wrapper: row.get(7),\n                    binder: row.get(8),\n                    filler: row.get(9),\n                    price: row.get(10),\n                    purchase_date: row.get(11),\n                    notes: row.get(12),\n                    quantity: row.get(13),\n                    ring_gauge_id: row.get(14),\n                    length: row.get(15),\n                    image_url: row.get(16),\n                    retail_link: row.get(17),\n                    is_active: row.get(18),\n                    created_at: row.get(19),\n                    updated_at: row.get(20),\n                };\n\n                let cigar_with_names = CigarWithNames {\n                    cigar,\n                    brand_name: row.get(21),\n                    size_name: row.get(22),\n                    strength_name: row.get(23),\n                    origin_name: row.get(24),\n                    ring_gauge: row.get(25),\n                };\n\n                cigars.push(cigar_with_names);\n            }\n\n            let elapsed = start_time.elapsed();\n            if elapsed.as_millis() > 100 {\n                tracing::warn!(\n                    duration_ms = elapsed.as_millis(),\n                    total_results = total,\n                    page = page,\n                    \"Slow query detected in get_cigars\"\n                );\n            } else {\n                tracing::debug!(\n                    duration_ms = elapsed.as_millis(),\n                    total_results = total,\n                    page = page,\n                    \"Query completed\"\n                );\n            }\n\n            let response = CigarResponse {\n                cigars,\n                total,\n                page,\n                page_size,\n                total_pages,\n            };\n\n            Ok(warp::reply::json(&response))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error fetching cigars\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to fetch cigars\"}),\n            ))\n        }\n    }\n}\n\npub async fn create_cigar(\n    create_cigar: CreateCigar,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate input\n    create_cigar.validate().map_err(warp::reject::custom)?;\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // CRITICAL: Verify the humidor belongs to the authenticated user or is shared with edit permission\n    verify_humidor_ownership(&pool, create_cigar.humidor_id, auth.user_id, true)\n        .await\n        .map_err(warp::reject::custom)?;\n\n    let id = Uuid::new_v4();\n    let now = Utc::now();\n\n    match db.query_one(\n        \"INSERT INTO cigars (id, humidor_id, brand_id, name, size_id, strength_id, origin_id, wrapper, binder, filler, price, purchase_date, notes, quantity, ring_gauge_id, length, image_url, retail_link, is_active, created_at, updated_at)\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, true, $19, $20)\n         RETURNING id, humidor_id, brand_id, name, size_id, strength_id, origin_id, wrapper, binder, filler, price, purchase_date, notes, quantity, ring_gauge_id, length, image_url, retail_link, is_active, created_at, updated_at\",\n        &[&id, &create_cigar.humidor_id, &create_cigar.brand_id, &create_cigar.name, &create_cigar.size_id, &create_cigar.strength_id, &create_cigar.origin_id,\n          &create_cigar.wrapper, &create_cigar.binder, &create_cigar.filler, &create_cigar.price, &create_cigar.purchase_date,\n          &create_cigar.notes, &create_cigar.quantity, &create_cigar.ring_gauge_id, &create_cigar.length, &create_cigar.image_url, &create_cigar.retail_link, &now, &now]\n    ).await {\n        Ok(row) => {\n            let cigar = Cigar {\n                id: row.get(0),\n                humidor_id: row.get(1),\n                brand_id: row.get(2),\n                name: row.get(3),\n                size_id: row.get(4),\n                strength_id: row.get(5),\n                origin_id: row.get(6),\n                wrapper: row.get(7),\n                binder: row.get(8),\n                filler: row.get(9),\n                price: row.get(10),\n                purchase_date: row.get(11),\n                notes: row.get(12),\n                quantity: row.get(13),\n                ring_gauge_id: row.get(14),\n                length: row.get(15),\n                image_url: row.get(16),\n                retail_link: row.get(17),\n                is_active: row.get(18),\n                created_at: row.get(19),\n                updated_at: row.get(20),\n            };\n            Ok(warp::reply::json(&cigar))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\"error\": \"Failed to create cigar\"})))\n        }\n    }\n}\n\npub async fn get_cigar(id: Uuid, auth: AuthContext, pool: DbPool) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // CRITICAL: Verify the cigar belongs to the user or is shared (view permission is enough)\n    verify_cigar_ownership(&pool, id, auth.user_id, false)\n        .await\n        .map_err(warp::reject::custom)?;\n\n    match db.query_one(\n        \"SELECT id, humidor_id, brand_id, name, size_id, strength_id, origin_id, wrapper, binder, filler, price, purchase_date, notes, quantity, ring_gauge_id, length, image_url, retail_link, is_active, created_at, updated_at FROM cigars WHERE id = $1\",\n        &[&id]\n    ).await {\n        Ok(row) => {\n            let cigar = Cigar {\n                id: row.get(0),\n                humidor_id: row.get(1),\n                brand_id: row.get(2),\n                name: row.get(3),\n                size_id: row.get(4),\n                strength_id: row.get(5),\n                origin_id: row.get(6),\n                wrapper: row.get(7),\n                binder: row.get(8),\n                filler: row.get(9),\n                price: row.get(10),\n                purchase_date: row.get(11),\n                notes: row.get(12),\n                quantity: row.get(13),\n                ring_gauge_id: row.get(14),\n                length: row.get(15),\n                image_url: row.get(16),\n                retail_link: row.get(17),\n                is_active: row.get(18),\n                created_at: row.get(19),\n                updated_at: row.get(20),\n            };\n            Ok(warp::reply::json(&cigar))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\"error\": \"Cigar not found\"})))\n        }\n    }\n}\n\npub async fn update_cigar(\n    id: Uuid,\n    update_cigar: UpdateCigar,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Debug log the request\n    tracing::info!(\n        \"update_cigar request: id={}, humidor_id={:?}, quantity={:?}, purchase_date={:?}\",\n        id,\n        update_cigar.humidor_id,\n        update_cigar.quantity,\n        update_cigar.purchase_date\n    );\n\n    // Validate input\n    update_cigar.validate().map_err(warp::reject::custom)?;\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // CRITICAL: Verify the cigar belongs to the user or is shared with edit permission\n    verify_cigar_ownership(&pool, id, auth.user_id, true)\n        .await\n        .map_err(warp::reject::custom)?;\n\n    // If updating humidor_id, verify the new humidor also belongs to the user or is shared with edit permission\n    if let Some(new_humidor_id) = update_cigar.humidor_id {\n        verify_humidor_ownership(&pool, Some(new_humidor_id), auth.user_id, true)\n            .await\n            .map_err(warp::reject::custom)?;\n    }\n\n    let now = Utc::now();\n\n    match db.query_one(\n        \"UPDATE cigars SET\n         humidor_id = COALESCE($2, humidor_id),\n         brand_id = COALESCE($3, brand_id),\n         name = COALESCE($4, name),\n         size_id = COALESCE($5, size_id),\n         strength_id = COALESCE($6, strength_id),\n         origin_id = COALESCE($7, origin_id),\n         wrapper = COALESCE($8, wrapper),\n         binder = COALESCE($9, binder),\n         filler = COALESCE($10, filler),\n         price = COALESCE($11, price),\n         purchase_date = COALESCE($12, purchase_date),\n         notes = COALESCE($13, notes),\n         quantity = COALESCE($14, quantity),\n         ring_gauge_id = COALESCE($15, ring_gauge_id),\n         length = COALESCE($16, length),\n         image_url = COALESCE($17, image_url),\n         retail_link = COALESCE($18, retail_link),\n         is_active = CASE\n             WHEN $14 IS NOT NULL AND $14 = 0 THEN false\n             WHEN $14 IS NOT NULL AND $14 > 0 THEN true\n             ELSE is_active\n         END,\n         updated_at = $19\n         WHERE id = $1\n         RETURNING id, humidor_id, brand_id, name, size_id, strength_id, origin_id, wrapper, binder, filler, price, purchase_date, notes, quantity, ring_gauge_id, length, image_url, retail_link, is_active, created_at, updated_at\",\n        &[&id, &update_cigar.humidor_id, &update_cigar.brand_id, &update_cigar.name, &update_cigar.size_id, &update_cigar.strength_id, &update_cigar.origin_id,\n          &update_cigar.wrapper, &update_cigar.binder, &update_cigar.filler, &update_cigar.price, &update_cigar.purchase_date,\n          &update_cigar.notes, &update_cigar.quantity, &update_cigar.ring_gauge_id, &update_cigar.length, &update_cigar.image_url, &update_cigar.retail_link, &now]\n    ).await {\n        Ok(row) => {\n            let cigar = Cigar {\n                id: row.get(0),\n                humidor_id: row.get(1),\n                brand_id: row.get(2),\n                name: row.get(3),\n                size_id: row.get(4),\n                strength_id: row.get(5),\n                origin_id: row.get(6),\n                wrapper: row.get(7),\n                binder: row.get(8),\n                filler: row.get(9),\n                price: row.get(10),\n                purchase_date: row.get(11),\n                notes: row.get(12),\n                quantity: row.get(13),\n                ring_gauge_id: row.get(14),\n                length: row.get(15),\n                image_url: row.get(16),\n                retail_link: row.get(17),\n                is_active: row.get(18),\n                created_at: row.get(19),\n                updated_at: row.get(20),\n            };\n            Ok(warp::reply::json(&cigar))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\"error\": \"Failed to update cigar\"})))\n        }\n    }\n}\n\npub async fn delete_cigar(\n    id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // CRITICAL: Verify the cigar belongs to the user or is shared with full permission (delete requires full)\n    // Check if user has manage permission (only owner or full shared access can delete)\n    let db_check = pool.get().await.map_err(|_e| {\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let humidor_query = \"SELECT humidor_id FROM cigars WHERE id = $1\";\n    let humidor_id: Uuid = match db_check.query_opt(humidor_query, &[&id]).await {\n        Ok(Some(row)) => row.get(0),\n        Ok(None) => {\n            return Err(warp::reject::custom(AppError::NotFound(\n                \"Cigar not found\".to_string(),\n            )));\n        }\n        Err(e) => {\n            return Err(warp::reject::custom(AppError::DatabaseError(format!(\n                \"Failed to find cigar: {}\",\n                e\n            ))));\n        }\n    };\n\n    // Check if user can manage (delete requires full permission)\n    use crate::handlers::humidor_shares::can_manage_humidor;\n    if !can_manage_humidor(&pool, &auth.user_id, &humidor_id)\n        .await\n        .map_err(warp::reject::custom)?\n    {\n        return Err(warp::reject::custom(AppError::Forbidden(\n            \"You do not have permission to delete cigars from this humidor\".to_string(),\n        )));\n    }\n\n    // Hard delete: actually remove the cigar from the database\n    // Note: favorites will keep snapshot data due to ON DELETE SET NULL on cigar_id\n    match db.execute(\"DELETE FROM cigars WHERE id = $1\", &[&id]).await {\n        Ok(rows_affected) => {\n            if rows_affected > 0 {\n                Ok(warp::reply::json(\n                    &json!({\"message\": \"Cigar deleted successfully\"}),\n                ))\n            } else {\n                Ok(warp::reply::json(&json!({\"error\": \"Cigar not found\"})))\n            }\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to delete cigar\"}),\n            ))\n        }\n    }\n}\n\n#[derive(serde::Deserialize)]\npub struct TransferCigarRequest {\n    destination_humidor_id: Uuid,\n    quantity: i32,\n}\n\npub async fn transfer_cigar(\n    id: Uuid,\n    transfer_req: TransferCigarRequest,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate quantity\n    if transfer_req.quantity <= 0 {\n        return Err(warp::reject::custom(AppError::ValidationError(\n            \"Quantity must be greater than 0\".to_string(),\n        )));\n    }\n\n    let mut db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Start a transaction for atomicity\n    let transaction = db.transaction().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to start transaction\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Failed to start transaction\".to_string(),\n        ))\n    })?;\n\n    // CRITICAL: Verify the source cigar belongs to the user or is shared with edit permission\n    verify_cigar_ownership(&pool, id, auth.user_id, true)\n        .await\n        .map_err(warp::reject::custom)?;\n\n    // Verify destination humidor belongs to user or is shared with edit permission\n    verify_humidor_ownership(\n        &pool,\n        Some(transfer_req.destination_humidor_id),\n        auth.user_id,\n        true,\n    )\n    .await\n    .map_err(warp::reject::custom)?;\n\n    // Get the source cigar (join with humidors to verify ownership)\n    let source_cigar_row = transaction\n        .query_one(\n            \"SELECT c.id, c.humidor_id, c.brand_id, c.name, c.size_id, c.strength_id, c.origin_id, \n                    c.wrapper, c.binder, c.filler, c.price, c.purchase_date, c.notes, c.quantity, \n                    c.ring_gauge_id, c.length, c.image_url, c.retail_link, c.is_active, h.user_id\n             FROM cigars c\n             INNER JOIN humidors h ON c.humidor_id = h.id\n             WHERE c.id = $1 AND h.user_id = $2\",\n            &[&id, &auth.user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Failed to fetch source cigar\");\n            warp::reject::custom(AppError::NotFound(\"Cigar not found\".to_string()))\n        })?;\n\n    let source_humidor_id: Option<Uuid> = source_cigar_row.get(1);\n    let current_quantity: i32 = source_cigar_row.get(13);\n\n    // Verify quantity to transfer is valid\n    if transfer_req.quantity > current_quantity {\n        return Err(warp::reject::custom(AppError::ValidationError(format!(\n            \"Cannot transfer {} cigars. Only {} available.\",\n            transfer_req.quantity, current_quantity\n        ))));\n    }\n\n    // Prevent transferring to the same humidor\n    if source_humidor_id == Some(transfer_req.destination_humidor_id) {\n        return Err(warp::reject::custom(AppError::ValidationError(\n            \"Cannot transfer to the same humidor\".to_string(),\n        )));\n    }\n\n    let now = Utc::now();\n\n    // For now, skip checking for duplicates - just create a new cigar\n    // This can be enhanced later to merge duplicates\n    let existing_cigar: Option<tokio_postgres::Row> = None;\n\n    if let Some(existing_row) = existing_cigar {\n        // Cigar already exists in destination - just update quantity\n        let existing_id: Uuid = existing_row.get(0);\n        let existing_quantity: i32 = existing_row.get(1);\n        let new_quantity = existing_quantity + transfer_req.quantity;\n\n        transaction\n            .execute(\n                \"UPDATE cigars SET quantity = $1, updated_at = $2 WHERE id = $3\",\n                &[&new_quantity, &now, &existing_id],\n            )\n            .await\n            .map_err(|e| {\n                tracing::error!(error = %e, \"Failed to update destination cigar quantity\");\n                warp::reject::custom(AppError::DatabaseError(\n                    \"Failed to update destination cigar\".to_string(),\n                ))\n            })?;\n    } else {\n        // Create new cigar in destination humidor\n        transaction\n            .execute(\n                \"INSERT INTO cigars (id, humidor_id, brand_id, name, size_id, strength_id, origin_id, \n                                    wrapper, binder, filler, price, purchase_date, notes, quantity, \n                                    ring_gauge_id, length, image_url, retail_link, is_active, created_at, updated_at)\n                 VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)\",\n                &[\n                    &Uuid::new_v4(),\n                    &transfer_req.destination_humidor_id,\n                    &source_cigar_row.get::<_, Option<Uuid>>(2),   // brand_id\n                    &source_cigar_row.get::<_, String>(3),         // name\n                    &source_cigar_row.get::<_, Option<Uuid>>(4),   // size_id\n                    &source_cigar_row.get::<_, Option<Uuid>>(5),   // strength_id\n                    &source_cigar_row.get::<_, Option<Uuid>>(6),   // origin_id\n                    &source_cigar_row.get::<_, Option<String>>(7), // wrapper\n                    &source_cigar_row.get::<_, Option<String>>(8), // binder\n                    &source_cigar_row.get::<_, Option<String>>(9), // filler\n                    &source_cigar_row.get::<_, Option<f64>>(10),   // price\n                    &source_cigar_row.get::<_, Option<chrono::DateTime<Utc>>>(11), // purchase_date\n                    &source_cigar_row.get::<_, Option<String>>(12), // notes\n                    &transfer_req.quantity,\n                    &source_cigar_row.get::<_, Option<Uuid>>(14),  // ring_gauge_id\n                    &source_cigar_row.get::<_, Option<f64>>(15),   // length\n                    &source_cigar_row.get::<_, Option<String>>(16), // image_url\n                    &source_cigar_row.get::<_, Option<String>>(17), // retail_link\n                    &true, // is_active\n                    &now,\n                    &now,\n                ],\n            )\n            .await\n            .map_err(|e| {\n                tracing::error!(error = %e, \"Failed to create destination cigar\");\n                warp::reject::custom(AppError::DatabaseError(\n                    \"Failed to create destination cigar\".to_string(),\n                ))\n            })?;\n    }\n\n    // Update or delete source cigar\n    let new_source_quantity = current_quantity - transfer_req.quantity;\n    if new_source_quantity == 0 {\n        // Delete the source cigar if quantity reaches 0\n        transaction\n            .execute(\"DELETE FROM cigars WHERE id = $1\", &[&id])\n            .await\n            .map_err(|e| {\n                tracing::error!(error = %e, \"Failed to delete source cigar\");\n                warp::reject::custom(AppError::DatabaseError(\n                    \"Failed to remove source cigar\".to_string(),\n                ))\n            })?;\n    } else {\n        // Update source cigar quantity\n        transaction\n            .execute(\n                \"UPDATE cigars SET quantity = $1, updated_at = $2 WHERE id = $3\",\n                &[&new_source_quantity, &now, &id],\n            )\n            .await\n            .map_err(|e| {\n                tracing::error!(error = %e, \"Failed to update source cigar quantity\");\n                warp::reject::custom(AppError::DatabaseError(\n                    \"Failed to update source cigar\".to_string(),\n                ))\n            })?;\n    }\n\n    // Commit transaction\n    transaction.commit().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to commit transaction\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Failed to commit transfer\".to_string(),\n        ))\n    })?;\n\n    Ok(warp::reply::json(&json!({\n        \"message\": \"Cigar transferred successfully\",\n        \"transferred_quantity\": transfer_req.quantity\n    })))\n}\n\n#[derive(serde::Deserialize)]\npub struct ScrapeRequest {\n    url: String,\n}\n\npub async fn scrape_cigar_url(\n    body: ScrapeRequest,\n    _auth: AuthContext,\n) -> Result<impl Reply, Rejection> {\n    use crate::services::scrape_cigar_url;\n\n    match scrape_cigar_url(&body.url).await {\n        Ok(data) => Ok(warp::reply::json(&data)),\n        Err(e) => {\n            tracing::error!(error = %e, \"Scraping error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to scrape cigar information\"}),\n            ))\n        }\n    }\n}\n\n/// Get a random cigar recommendation\n/// GET /api/v1/cigars/recommend?humidor_id={optional}&preference_type={optional}&preference_value={optional}\npub async fn get_random_cigar(\n    params: std::collections::HashMap<String, String>,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    use crate::models::{CigarWithNames, RecommendCigarResponse};\n    use warp::http::StatusCode;\n    use warp::reply;\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let user_id = auth.user_id;\n\n    // Parse optional humidor_id filter\n    let humidor_id_filter = params\n        .get(\"humidor_id\")\n        .and_then(|s| Uuid::parse_str(s).ok());\n\n    // Parse optional preference parameters\n    let preference_type = params.get(\"preference_type\").map(|s| s.as_str());\n    let preference_value = params.get(\"preference_value\").cloned();\n\n    // If humidor_id provided, verify access\n    if let Some(hid) = humidor_id_filter {\n        verify_humidor_ownership(&pool, Some(hid), user_id, false)\n            .await\n            .map_err(warp::reject::custom)?;\n    }\n\n    // Build query to get random cigar with optional preference filter\n    // IMPORTANT: Only select cigars with quantity > 0 and is_active = true\n    let preference_filter = match (preference_type, preference_value.as_ref()) {\n        (Some(\"brand\"), Some(val)) => format!(\" AND b.name = '{}'\", val.replace(\"'\", \"''\")),\n        (Some(\"size\"), Some(val)) => format!(\" AND s.name = '{}'\", val.replace(\"'\", \"''\")),\n        (Some(\"origin\"), Some(val)) => format!(\" AND o.name = '{}'\", val.replace(\"'\", \"''\")),\n        (Some(\"strength\"), Some(val)) => format!(\" AND st.name = '{}'\", val.replace(\"'\", \"''\")),\n        (Some(\"ring_gauge\"), Some(val)) => {\n            if let Ok(gauge_val) = val.parse::<i32>() {\n                format!(\" AND rg.gauge = {}\", gauge_val)\n            } else {\n                String::new()\n            }\n        }\n        _ => String::new(),\n    };\n\n    let query = if humidor_id_filter.is_some() {\n        // Single humidor\n        format!(\n            \"SELECT c.id, c.humidor_id, c.name, b.name as brand_name, s.name as size_name,\n                    st.name as strength_name, o.name as origin_name, c.wrapper, c.binder, c.filler,\n                    c.quantity, c.notes, c.purchase_date, c.price as purchase_price, c.retail_link,\n                    c.created_at, c.updated_at, c.is_active,\n                    rg.gauge as ring_gauge, c.length, st.level as strength_score, c.image_url,\n                    c.brand_id, c.size_id, c.strength_id, c.origin_id, c.ring_gauge_id\n             FROM cigars c\n             LEFT JOIN brands b ON c.brand_id = b.id\n             LEFT JOIN sizes s ON c.size_id = s.id\n             LEFT JOIN strengths st ON c.strength_id = st.id\n             LEFT JOIN origins o ON c.origin_id = o.id\n             LEFT JOIN ring_gauges rg ON c.ring_gauge_id = rg.id\n             INNER JOIN humidors h ON c.humidor_id = h.id\n             WHERE c.humidor_id = $1 \n               AND c.quantity > 0 \n               AND c.is_active = true{}\n             ORDER BY RANDOM()\n             LIMIT 1\",\n            preference_filter\n        )\n    } else {\n        // All user's humidors + shared humidors\n        format!(\n            \"SELECT c.id, c.humidor_id, c.name, b.name as brand_name, s.name as size_name,\n                    st.name as strength_name, o.name as origin_name, c.wrapper, c.binder, c.filler,\n                    c.quantity, c.notes, c.purchase_date, c.price as purchase_price, c.retail_link,\n                    c.created_at, c.updated_at, c.is_active,\n                    rg.gauge as ring_gauge, c.length, st.level as strength_score, c.image_url,\n                    c.brand_id, c.size_id, c.strength_id, c.origin_id, c.ring_gauge_id\n             FROM cigars c\n             LEFT JOIN brands b ON c.brand_id = b.id\n             LEFT JOIN sizes s ON c.size_id = s.id\n             LEFT JOIN strengths st ON c.strength_id = st.id\n             LEFT JOIN origins o ON c.origin_id = o.id\n             LEFT JOIN ring_gauges rg ON c.ring_gauge_id = rg.id\n             INNER JOIN humidors h ON c.humidor_id = h.id\n             LEFT JOIN humidor_shares hs ON h.id = hs.humidor_id AND hs.shared_with_user_id = $1\n             WHERE (h.user_id = $1 OR hs.id IS NOT NULL)\n               AND c.quantity > 0 \n               AND c.is_active = true{}\n             ORDER BY RANDOM()\n             LIMIT 1\",\n            preference_filter\n        )\n    };\n\n    // Also get total count of eligible cigars with preference filter\n    let count_query = if humidor_id_filter.is_some() {\n        format!(\n            \"SELECT COUNT(*) FROM cigars c\n             LEFT JOIN brands b ON c.brand_id = b.id\n             LEFT JOIN sizes s ON c.size_id = s.id\n             LEFT JOIN strengths st ON c.strength_id = st.id\n             LEFT JOIN origins o ON c.origin_id = o.id\n             LEFT JOIN ring_gauges rg ON c.ring_gauge_id = rg.id\n             INNER JOIN humidors h ON c.humidor_id = h.id\n             WHERE c.humidor_id = $1 \n               AND c.quantity > 0 \n               AND c.is_active = true{}\",\n            preference_filter\n        )\n    } else {\n        format!(\n            \"SELECT COUNT(*) FROM cigars c\n             LEFT JOIN brands b ON c.brand_id = b.id\n             LEFT JOIN sizes s ON c.size_id = s.id\n             LEFT JOIN strengths st ON c.strength_id = st.id\n             LEFT JOIN origins o ON c.origin_id = o.id\n             LEFT JOIN ring_gauges rg ON c.ring_gauge_id = rg.id\n             INNER JOIN humidors h ON c.humidor_id = h.id\n             LEFT JOIN humidor_shares hs ON h.id = hs.humidor_id AND hs.shared_with_user_id = $1\n             WHERE (h.user_id = $1 OR hs.id IS NOT NULL)\n               AND c.quantity > 0 \n               AND c.is_active = true{}\",\n            preference_filter\n        )\n    };\n\n    // Execute queries\n    let count_result = if let Some(hid) = humidor_id_filter {\n        db.query_one(&count_query, &[&hid]).await\n    } else {\n        db.query_one(&count_query, &[&user_id]).await\n    };\n\n    let eligible_count: i64 = match count_result {\n        Ok(row) => row.get(0),\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to count eligible cigars\");\n            return Err(warp::reject::custom(AppError::DatabaseError(\n                \"Failed to count cigars\".to_string(),\n            )));\n        }\n    };\n\n    // Execute random selection\n    let cigar_result = if let Some(hid) = humidor_id_filter {\n        db.query_opt(&query, &[&hid]).await\n    } else {\n        db.query_opt(&query, &[&user_id]).await\n    };\n\n    match cigar_result {\n        Ok(Some(row)) => {\n            // Extract cigar data from row with better error handling\n            let cigar = CigarWithNames {\n                cigar: Cigar {\n                    id: row.get(\"id\"),\n                    humidor_id: row.get(\"humidor_id\"),\n                    brand_id: row.get(\"brand_id\"),\n                    name: row.get(\"name\"),\n                    size_id: row.get(\"size_id\"),\n                    strength_id: row.get(\"strength_id\"),\n                    origin_id: row.get(\"origin_id\"),\n                    wrapper: row.get(\"wrapper\"),\n                    binder: row.get(\"binder\"),\n                    filler: row.get(\"filler\"),\n                    price: row.get(\"purchase_price\"),\n                    purchase_date: row.get(\"purchase_date\"),\n                    notes: row.get(\"notes\"),\n                    quantity: row.get(\"quantity\"),\n                    ring_gauge_id: row.get(\"ring_gauge_id\"),\n                    length: row.get(\"length\"),\n                    image_url: row.get(\"image_url\"),\n                    retail_link: row.get(\"retail_link\"),\n                    is_active: row.get(\"is_active\"),\n                    created_at: row.get(\"created_at\"),\n                    updated_at: row.get(\"updated_at\"),\n                },\n                brand_name: row.get(\"brand_name\"),\n                size_name: row.get(\"size_name\"),\n                strength_name: row.get(\"strength_name\"),\n                origin_name: row.get(\"origin_name\"),\n                ring_gauge: row.get(\"ring_gauge\"),\n            };\n\n            let message = if eligible_count > 1 {\n                format!(\n                    \"How about this one? ({} other options available)\",\n                    eligible_count - 1\n                )\n            } else {\n                \"This is your only available cigar!\".to_string()\n            };\n\n            Ok(reply::with_status(\n                reply::json(&RecommendCigarResponse {\n                    cigar: Some(cigar),\n                    eligible_count,\n                    message,\n                }),\n                StatusCode::OK,\n            ))\n        }\n        Ok(None) => {\n            // No cigars available\n            Ok(reply::with_status(\n                reply::json(&RecommendCigarResponse {\n                    cigar: None,\n                    eligible_count: 0,\n                    message: \"No cigars available for recommendation\".to_string(),\n                }),\n                StatusCode::OK,\n            ))\n        }\n        Err(e) => {\n            tracing::error!(error = ?e, \"Failed to get random cigar - database query error\");\n            Err(warp::reject::custom(AppError::DatabaseError(\n                \"Failed to get recommendation\".to_string(),\n            )))\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","favorites.rs"],"content":"use chrono::Utc;\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\nuse warp::{Rejection, Reply, reply::json};\n\nuse crate::{DbPool, errors::AppError, middleware::auth::AuthContext};\n\n#[derive(Debug, Serialize)]\npub struct FavoriteResponse {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub cigar_id: Uuid,\n    pub created_at: chrono::DateTime<Utc>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct AddFavoriteRequest {\n    pub cigar_id: Uuid,\n}\n\n// Get all favorites for the current user\npub async fn get_favorites(auth: AuthContext, pool: DbPool) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let rows = db\n        .query(\n            \"SELECT f.id, f.user_id, f.cigar_id, f.created_at,\n                c.id as c_id, c.humidor_id, c.brand_id, c.name, c.size_id, c.strength_id,\n                c.origin_id, c.wrapper, c.binder, c.filler, c.price, c.purchase_date,\n                c.notes, c.quantity, c.ring_gauge_id, c.length, c.image_url,\n                c.created_at as c_created_at, c.updated_at as c_updated_at, c.is_active,\n                f.snapshot_name, f.snapshot_brand_id, f.snapshot_size_id,\n                f.snapshot_strength_id, f.snapshot_origin_id,\n                f.snapshot_ring_gauge_id, f.snapshot_image_url\n         FROM favorites f\n         LEFT JOIN cigars c ON f.cigar_id = c.id\n         WHERE f.user_id = $1\n         ORDER BY f.created_at DESC\",\n            &[&auth.user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Database error getting favorites\");\n            warp::reject::reject()\n        })?;\n\n    let favorites: Vec<serde_json::Value> = rows.iter().map(|row| {\n        let cigar_id: Option<Uuid> = row.get(2);\n        let cigar_exists: Option<Uuid> = row.get(4); // c.id will be null if cigar doesn't exist\n\n        serde_json::json!({\n            \"id\": row.get::<_, Uuid>(0),\n            \"user_id\": row.get::<_, Uuid>(1),\n            \"cigar_id\": cigar_id,\n            \"created_at\": row.get::<_, chrono::DateTime<Utc>>(3),\n            \"cigar\": if cigar_exists.is_some() {\n                // Cigar still exists, return live data\n                let is_active: bool = row.get(23);\n                serde_json::json!({\n                    \"id\": row.get::<_, Uuid>(4),\n                    \"humidor_id\": row.get::<_, Option<Uuid>>(5),\n                    \"brand_id\": row.get::<_, Option<Uuid>>(6),\n                    \"name\": row.get::<_, String>(7),\n                    \"size_id\": row.get::<_, Option<Uuid>>(8),\n                    \"strength_id\": row.get::<_, Option<Uuid>>(9),\n                    \"origin_id\": row.get::<_, Option<Uuid>>(10),\n                    \"wrapper\": row.get::<_, Option<String>>(11),\n                    \"binder\": row.get::<_, Option<String>>(12),\n                    \"filler\": row.get::<_, Option<String>>(13),\n                    \"price\": row.get::<_, Option<f64>>(14),\n                    \"purchase_date\": row.get::<_, Option<chrono::DateTime<Utc>>>(15),\n                    \"notes\": row.get::<_, Option<String>>(16),\n                    \"quantity\": row.get::<_, i32>(17),\n                    \"ring_gauge_id\": row.get::<_, Option<Uuid>>(18),\n                    \"length\": row.get::<_, Option<f64>>(19),\n                    \"image_url\": row.get::<_, Option<String>>(20),\n                    \"created_at\": row.get::<_, chrono::DateTime<Utc>>(21),\n                    \"updated_at\": row.get::<_, chrono::DateTime<Utc>>(22),\n                    \"out_of_stock\": !is_active\n                })\n            } else {\n                // Cigar deleted, return snapshot data\n                serde_json::json!({\n                    \"id\": cigar_id,\n                    \"humidor_id\": serde_json::Value::Null,\n                    \"brand_id\": row.get::<_, Option<Uuid>>(25),\n                    \"name\": row.get::<_, Option<String>>(24).unwrap_or_else(|| \"Unknown Cigar\".to_string()),\n                    \"size_id\": row.get::<_, Option<Uuid>>(26),\n                    \"strength_id\": row.get::<_, Option<Uuid>>(27),\n                    \"origin_id\": row.get::<_, Option<Uuid>>(28),\n                    \"wrapper\": serde_json::Value::Null,\n                    \"binder\": serde_json::Value::Null,\n                    \"filler\": serde_json::Value::Null,\n                    \"price\": serde_json::Value::Null,\n                    \"purchase_date\": serde_json::Value::Null,\n                    \"notes\": serde_json::Value::Null,\n                    \"quantity\": 0,\n                    \"ring_gauge_id\": row.get::<_, Option<Uuid>>(29),\n                    \"length\": serde_json::Value::Null,\n                    \"image_url\": row.get::<_, Option<String>>(30),\n                    \"created_at\": serde_json::Value::Null,\n                    \"updated_at\": serde_json::Value::Null,\n                    \"out_of_stock\": true\n                })\n            }\n        })\n    }).collect();\n\n    Ok(json(&favorites))\n}\n\n// Add a cigar to favorites\npub async fn add_favorite(\n    request: AddFavoriteRequest,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    let id = Uuid::new_v4();\n    let now = Utc::now();\n\n    // CRITICAL: Verify the cigar belongs to the user (through its humidor)\n    // First, get the cigar data AND verify ownership via humidor\n    let cigar = db\n        .query_opt(\n            \"SELECT c.name, c.brand_id, c.size_id, c.strength_id, c.origin_id, c.ring_gauge_id, c.image_url\n             FROM cigars c\n             INNER JOIN humidors h ON c.humidor_id = h.id\n             WHERE c.id = $1 AND h.user_id = $2\",\n            &[&request.cigar_id, &auth.user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\n                cigar_id = %request.cigar_id,\n                error = %e,\n                \"Database error fetching cigar for snapshot\"\n            );\n            warp::reject::reject()\n        })?;\n\n    let cigar = match cigar {\n        Some(row) => row,\n        None => {\n            tracing::warn!(\n                cigar_id = %request.cigar_id,\n                user_id = %auth.user_id,\n                \"Attempted to favorite non-existent or unauthorized cigar\"\n            );\n            return Err(warp::reject::custom(AppError::Forbidden(\n                \"You do not have access to this cigar\".to_string(),\n            )));\n        }\n    };\n\n    let snapshot_name: String = cigar.get(0);\n    let snapshot_brand_id: Option<Uuid> = cigar.get(1);\n    let snapshot_size_id: Option<Uuid> = cigar.get(2);\n    let snapshot_strength_id: Option<Uuid> = cigar.get(3);\n    let snapshot_origin_id: Option<Uuid> = cigar.get(4);\n    let snapshot_ring_gauge_id: Option<Uuid> = cigar.get(5);\n    let snapshot_image_url: Option<String> = cigar.get(6);\n\n    match db\n        .query_one(\n            \"INSERT INTO favorites (id, user_id, cigar_id, created_at,\n                                snapshot_name, snapshot_brand_id, snapshot_size_id,\n                                snapshot_strength_id, snapshot_origin_id,\n                                snapshot_ring_gauge_id, snapshot_image_url)\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)\n         ON CONFLICT (user_id, cigar_id) DO NOTHING\n         RETURNING id, user_id, cigar_id, created_at\",\n            &[\n                &id,\n                &auth.user_id,\n                &request.cigar_id,\n                &now,\n                &snapshot_name,\n                &snapshot_brand_id,\n                &snapshot_size_id,\n                &snapshot_strength_id,\n                &snapshot_origin_id,\n                &snapshot_ring_gauge_id,\n                &snapshot_image_url,\n            ],\n        )\n        .await\n    {\n        Ok(row) => {\n            let favorite = FavoriteResponse {\n                id: row.get(0),\n                user_id: row.get(1),\n                cigar_id: row.get(2),\n                created_at: row.get(3),\n            };\n            Ok(warp::reply::with_status(\n                json(&favorite),\n                warp::http::StatusCode::CREATED,\n            ))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error adding favorite\");\n            Err(warp::reject::reject())\n        }\n    }\n}\n\n// Remove a cigar from favorites\n// Accepts either cigar_id or favorite_id (for deleted cigars)\npub async fn remove_favorite(\n    id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    // Try to delete by cigar_id first\n    let rows_deleted = db\n        .execute(\n            \"DELETE FROM favorites WHERE user_id = $1 AND cigar_id = $2\",\n            &[&auth.user_id, &id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Database error removing favorite by cigar_id\");\n            warp::reject::reject()\n        })?;\n\n    // If no rows deleted, try deleting by favorite id (for orphaned favorites)\n    if rows_deleted == 0 {\n        db.execute(\n            \"DELETE FROM favorites WHERE user_id = $1 AND id = $2\",\n            &[&auth.user_id, &id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(error = %e, \"Database error removing favorite by id\");\n            warp::reject::reject()\n        })?;\n    }\n\n    Ok(warp::reply::with_status(\n        json(&serde_json::json!({\"message\": \"Favorite removed\"})),\n        warp::http::StatusCode::OK,\n    ))\n}\n\n// Check if a cigar is favorited\npub async fn is_favorite(\n    cigar_id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .query_opt(\n            \"SELECT id FROM favorites WHERE user_id = $1 AND cigar_id = $2\",\n            &[&auth.user_id, &cigar_id],\n        )\n        .await\n    {\n        Ok(row) => {\n            let is_favorite = row.is_some();\n            Ok(json(&serde_json::json!({\"is_favorite\": is_favorite})))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error checking favorite\");\n            Err(warp::reject::reject())\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","humidor_shares.rs"],"content":"use crate::errors::AppError;\nuse crate::middleware::auth::AuthContext;\nuse crate::models::{\n    HumidorShareResponse, HumidorSharesListResponse, PermissionLevel, ShareHumidorRequest,\n    SharedHumidorInfo, SharedHumidorsResponse, UpdateSharePermissionRequest, UserInfo,\n};\nuse deadpool_postgres::Pool;\nuse std::str::FromStr;\nuse uuid::Uuid;\nuse warp::{Rejection, Reply, reject, reply};\n\n/// Helper function to get user's permission level for a humidor\n/// Returns None if user has no access (not owner, not shared)\npub async fn get_user_permission_level(\n    pool: &Pool,\n    user_id: &Uuid,\n    humidor_id: &Uuid,\n) -> Result<Option<PermissionLevel>, AppError> {\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        AppError::DatabaseError(\"Failed to connect to database\".to_string())\n    })?;\n\n    // Check if user is the owner\n    let owner_check = client\n        .query_opt(\n            \"SELECT id FROM humidors WHERE id = $1 AND user_id = $2\",\n            &[humidor_id, user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to check humidor ownership: {}\", e);\n            AppError::DatabaseError(\"Failed to check ownership\".to_string())\n        })?;\n\n    if owner_check.is_some() {\n        // Owner has full permissions\n        return Ok(Some(PermissionLevel::Full));\n    }\n\n    // Check if humidor is shared with user\n    let share_result = client\n        .query_opt(\n            \"SELECT permission_level FROM humidor_shares \n             WHERE humidor_id = $1 AND shared_with_user_id = $2\",\n            &[humidor_id, user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to check humidor share: {}\", e);\n            AppError::DatabaseError(\"Failed to check share permission\".to_string())\n        })?;\n\n    if let Some(row) = share_result {\n        let permission_str: String = row.get(0);\n        let permission =\n            PermissionLevel::from_str(&permission_str).map_err(AppError::ValidationError)?;\n        return Ok(Some(permission));\n    }\n\n    Ok(None)\n}\n\n/// Helper function to check if user can view a humidor\npub async fn can_view_humidor(\n    pool: &Pool,\n    user_id: &Uuid,\n    humidor_id: &Uuid,\n) -> Result<bool, AppError> {\n    let permission = get_user_permission_level(pool, user_id, humidor_id).await?;\n    Ok(permission.is_some_and(|p| p.can_view()))\n}\n\n/// Helper function to check if user can edit a humidor (add/update cigars)\npub async fn can_edit_humidor(\n    pool: &Pool,\n    user_id: &Uuid,\n    humidor_id: &Uuid,\n) -> Result<bool, AppError> {\n    let permission = get_user_permission_level(pool, user_id, humidor_id).await?;\n    Ok(permission.is_some_and(|p| p.can_edit()))\n}\n\n/// Helper function to check if user can manage a humidor (delete cigars, manage shares)\npub async fn can_manage_humidor(\n    pool: &Pool,\n    user_id: &Uuid,\n    humidor_id: &Uuid,\n) -> Result<bool, AppError> {\n    let permission = get_user_permission_level(pool, user_id, humidor_id).await?;\n    Ok(permission.is_some_and(|p| p.can_manage()))\n}\n\n/// Helper function to check if user is the owner of a humidor\npub async fn is_humidor_owner(\n    pool: &Pool,\n    user_id: &Uuid,\n    humidor_id: &Uuid,\n) -> Result<bool, AppError> {\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        AppError::DatabaseError(\"Failed to connect to database\".to_string())\n    })?;\n\n    let result = client\n        .query_opt(\n            \"SELECT id FROM humidors WHERE id = $1 AND user_id = $2\",\n            &[humidor_id, user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to check humidor ownership: {}\", e);\n            AppError::DatabaseError(\"Failed to check ownership\".to_string())\n        })?;\n\n    Ok(result.is_some())\n}\n\n/// Share a humidor with another user\n/// POST /api/v1/humidors/:id/share\npub async fn share_humidor(\n    humidor_id: Uuid,\n    auth: AuthContext,\n    request: ShareHumidorRequest,\n    pool: Pool,\n) -> Result<impl Reply, Rejection> {\n    tracing::info!(\n        \"User {} sharing humidor {} with user {} (permission: {:?})\",\n        auth.user_id,\n        humidor_id,\n        request.user_id,\n        request.permission_level\n    );\n\n    // Verify user is the owner of the humidor\n    if !is_humidor_owner(&pool, &auth.user_id, &humidor_id)\n        .await\n        .map_err(reject::custom)?\n    {\n        tracing::warn!(\n            \"User {} attempted to share humidor {} they don't own\",\n            auth.user_id,\n            humidor_id\n        );\n        return Err(reject::custom(AppError::Forbidden(\n            \"You do not have permission to share this humidor\".to_string(),\n        )));\n    }\n\n    // Cannot share with yourself\n    if request.user_id == auth.user_id {\n        return Err(reject::custom(AppError::ValidationError(\n            \"Cannot share humidor with yourself\".to_string(),\n        )));\n    }\n\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        reject::custom(AppError::DatabaseError(\n            \"Failed to connect to database\".to_string(),\n        ))\n    })?;\n\n    // Verify the target user exists and is active\n    let user_exists = client\n        .query_opt(\n            \"SELECT id FROM users WHERE id = $1 AND is_active = true\",\n            &[&request.user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to check user existence: {}\", e);\n            reject::custom(AppError::DatabaseError(\"Failed to verify user\".to_string()))\n        })?;\n\n    if user_exists.is_none() {\n        return Err(reject::custom(AppError::NotFound(\n            \"User not found or inactive\".to_string(),\n        )));\n    }\n\n    // Insert or update the share\n    let share_id = Uuid::new_v4();\n    let permission_str = request.permission_level.as_str();\n\n    client\n        .execute(\n            \"INSERT INTO humidor_shares (id, humidor_id, shared_with_user_id, shared_by_user_id, permission_level)\n             VALUES ($1, $2, $3, $4, $5)\n             ON CONFLICT (humidor_id, shared_with_user_id) \n             DO UPDATE SET permission_level = $5, updated_at = NOW()\",\n            &[\n                &share_id,\n                &humidor_id,\n                &request.user_id,\n                &auth.user_id,\n                &permission_str,\n            ],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to create humidor share: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to share humidor\".to_string(),\n            ))\n        })?;\n\n    tracing::info!(\n        \"Successfully shared humidor {} with user {}\",\n        humidor_id,\n        request.user_id\n    );\n\n    Ok(reply::with_status(\n        reply::json(&serde_json::json!({\n            \"message\": \"Humidor shared successfully\",\n            \"share_id\": share_id\n        })),\n        warp::http::StatusCode::CREATED,\n    ))\n}\n\n/// Revoke access to a shared humidor\n/// DELETE /api/v1/humidors/:id/share/:user_id\npub async fn revoke_share(\n    humidor_id: Uuid,\n    user_id: Uuid,\n    auth: AuthContext,\n    pool: Pool,\n) -> Result<impl Reply, Rejection> {\n    tracing::info!(\n        \"User {} revoking access to humidor {} from user {}\",\n        auth.user_id,\n        humidor_id,\n        user_id\n    );\n\n    // Verify user is the owner of the humidor\n    if !is_humidor_owner(&pool, &auth.user_id, &humidor_id)\n        .await\n        .map_err(reject::custom)?\n    {\n        tracing::warn!(\n            \"User {} attempted to revoke share for humidor {} they don't own\",\n            auth.user_id,\n            humidor_id\n        );\n        return Err(reject::custom(AppError::Forbidden(\n            \"You do not have permission to manage shares for this humidor\".to_string(),\n        )));\n    }\n\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        reject::custom(AppError::DatabaseError(\n            \"Failed to connect to database\".to_string(),\n        ))\n    })?;\n\n    let rows_affected = client\n        .execute(\n            \"DELETE FROM humidor_shares WHERE humidor_id = $1 AND shared_with_user_id = $2\",\n            &[&humidor_id, &user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to revoke humidor share: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to revoke share\".to_string(),\n            ))\n        })?;\n\n    if rows_affected == 0 {\n        return Err(reject::custom(AppError::NotFound(\n            \"Share not found\".to_string(),\n        )));\n    }\n\n    tracing::info!(\n        \"Successfully revoked access to humidor {} from user {}\",\n        humidor_id,\n        user_id\n    );\n\n    Ok(reply::with_status(\n        reply::json(&serde_json::json!({\n            \"message\": \"Share revoked successfully\"\n        })),\n        warp::http::StatusCode::OK,\n    ))\n}\n\n/// Update permission level for a shared humidor\n/// PATCH /api/v1/humidors/:id/share/:user_id\npub async fn update_share_permission(\n    humidor_id: Uuid,\n    user_id: Uuid,\n    auth: AuthContext,\n    request: UpdateSharePermissionRequest,\n    pool: Pool,\n) -> Result<impl Reply, Rejection> {\n    tracing::info!(\n        \"User {} updating share permission for humidor {} user {} to {:?}\",\n        auth.user_id,\n        humidor_id,\n        user_id,\n        request.permission_level\n    );\n\n    // Verify user is the owner of the humidor\n    if !is_humidor_owner(&pool, &auth.user_id, &humidor_id)\n        .await\n        .map_err(reject::custom)?\n    {\n        tracing::warn!(\n            \"User {} attempted to update share for humidor {} they don't own\",\n            auth.user_id,\n            humidor_id\n        );\n        return Err(reject::custom(AppError::Forbidden(\n            \"You do not have permission to manage shares for this humidor\".to_string(),\n        )));\n    }\n\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        reject::custom(AppError::DatabaseError(\n            \"Failed to connect to database\".to_string(),\n        ))\n    })?;\n\n    let permission_str = request.permission_level.as_str();\n    let rows_affected = client\n        .execute(\n            \"UPDATE humidor_shares SET permission_level = $1, updated_at = NOW() \n             WHERE humidor_id = $2 AND shared_with_user_id = $3\",\n            &[&permission_str, &humidor_id, &user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to update share permission: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to update permission\".to_string(),\n            ))\n        })?;\n\n    if rows_affected == 0 {\n        return Err(reject::custom(AppError::NotFound(\n            \"Share not found\".to_string(),\n        )));\n    }\n\n    tracing::info!(\n        \"Successfully updated share permission for humidor {} user {}\",\n        humidor_id,\n        user_id\n    );\n\n    Ok(reply::json(&serde_json::json!({\n        \"message\": \"Permission updated successfully\"\n    })))\n}\n\n/// Get list of users a humidor is shared with\n/// GET /api/v1/humidors/:id/shares\npub async fn get_humidor_shares(\n    humidor_id: Uuid,\n    auth: AuthContext,\n    pool: Pool,\n) -> Result<impl Reply, Rejection> {\n    tracing::debug!(\n        \"User {} fetching shares for humidor {}\",\n        auth.user_id,\n        humidor_id\n    );\n\n    // Verify user has access to the humidor (owner or has share)\n    if !can_view_humidor(&pool, &auth.user_id, &humidor_id)\n        .await\n        .map_err(reject::custom)?\n    {\n        return Err(reject::custom(AppError::Forbidden(\n            \"You do not have access to this humidor\".to_string(),\n        )));\n    }\n\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        reject::custom(AppError::DatabaseError(\n            \"Failed to connect to database\".to_string(),\n        ))\n    })?;\n\n    let rows = client\n        .query(\n            \"SELECT hs.id, hs.humidor_id, hs.permission_level, hs.created_at, hs.updated_at,\n                    u_with.id, u_with.username, u_with.email, u_with.full_name,\n                    u_by.id, u_by.username, u_by.email, u_by.full_name\n             FROM humidor_shares hs\n             INNER JOIN users u_with ON hs.shared_with_user_id = u_with.id\n             INNER JOIN users u_by ON hs.shared_by_user_id = u_by.id\n             WHERE hs.humidor_id = $1\n             ORDER BY hs.created_at DESC\",\n            &[&humidor_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to fetch humidor shares: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to fetch shares\".to_string(),\n            ))\n        })?;\n\n    let shares: Vec<HumidorShareResponse> = rows\n        .iter()\n        .map(|row| {\n            let permission_str: String = row.get(2);\n            let permission =\n                PermissionLevel::from_str(&permission_str).unwrap_or(PermissionLevel::View);\n\n            HumidorShareResponse {\n                id: row.get(0),\n                humidor_id: row.get(1),\n                shared_with_user: UserInfo {\n                    id: row.get(5),\n                    username: row.get(6),\n                    email: row.get(7),\n                    full_name: row.get(8),\n                },\n                shared_by_user: UserInfo {\n                    id: row.get(9),\n                    username: row.get(10),\n                    email: row.get(11),\n                    full_name: row.get(12),\n                },\n                permission_level: permission,\n                created_at: row.get(3),\n                updated_at: row.get(4),\n            }\n        })\n        .collect();\n\n    let total = shares.len();\n\n    let response = HumidorSharesListResponse { shares, total };\n\n    tracing::info!(\n        \"Returning {} shares for humidor {}\",\n        response.total,\n        humidor_id\n    );\n    tracing::debug!(\"Response structure: {:?}\", response);\n\n    Ok(reply::json(&response))\n}\n\n/// Get list of humidors shared with the current user\n/// GET /api/v1/humidors/shared\npub async fn get_shared_humidors(auth: AuthContext, pool: Pool) -> Result<impl Reply, Rejection> {\n    tracing::debug!(\"User {} fetching shared humidors\", auth.user_id);\n\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        reject::custom(AppError::DatabaseError(\n            \"Failed to connect to database\".to_string(),\n        ))\n    })?;\n\n    let rows = client\n        .query(\n            \"SELECT h.id, h.name, h.description, hs.permission_level, hs.created_at,\n                    u.id, u.username, u.email, u.full_name,\n                    COUNT(c.id) as cigar_count\n             FROM humidor_shares hs\n             INNER JOIN humidors h ON hs.humidor_id = h.id\n             INNER JOIN users u ON h.user_id = u.id\n             LEFT JOIN cigars c ON c.humidor_id = h.id\n             WHERE hs.shared_with_user_id = $1\n             GROUP BY h.id, h.name, h.description, hs.permission_level, hs.created_at,\n                      u.id, u.username, u.email, u.full_name\n             ORDER BY hs.created_at DESC\",\n            &[&auth.user_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to fetch shared humidors: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to fetch shared humidors\".to_string(),\n            ))\n        })?;\n\n    let humidors: Vec<SharedHumidorInfo> = rows\n        .iter()\n        .map(|row| {\n            let permission_str: String = row.get(3);\n            let permission =\n                PermissionLevel::from_str(&permission_str).unwrap_or(PermissionLevel::View);\n\n            SharedHumidorInfo {\n                id: row.get(0),\n                name: row.get(1),\n                description: row.get(2),\n                owner: UserInfo {\n                    id: row.get(5),\n                    username: row.get(6),\n                    email: row.get(7),\n                    full_name: row.get(8),\n                },\n                permission_level: permission,\n                shared_at: row.get(4),\n                cigar_count: row.get(9),\n            }\n        })\n        .collect();\n\n    let total = humidors.len();\n\n    Ok(reply::json(&SharedHumidorsResponse { humidors, total }))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","humidors.rs"],"content":"use crate::DbPool;\nuse crate::handlers::humidor_shares::can_view_humidor;\nuse crate::middleware::AuthContext;\nuse crate::models::{CreateHumidorRequest, Humidor, UpdateHumidorRequest};\nuse crate::validation::Validate;\nuse serde_json::json;\nuse std::convert::Infallible;\nuse uuid::Uuid;\nuse warp::{Reply, http::StatusCode, reply};\n\npub async fn get_humidors(auth: AuthContext, pool: DbPool) -> Result<impl Reply, Infallible> {\n    let db = match pool.get().await {\n        Ok(conn) => conn,\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to get database connection\");\n            return Ok(reply::with_status(\n                reply::json(&json!({\"error\": \"Database connection failed\"})),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ));\n        }\n    };\n\n    let user_id = auth.user_id;\n\n    // Get humidors owned by user UNION with humidors shared with user\n    let query = \"\n        SELECT DISTINCT h.id, h.user_id, h.name, h.description, h.capacity, h.target_humidity, h.location, h.image_url, h.created_at, h.updated_at,\n               CASE WHEN h.user_id = $1 THEN true ELSE false END as is_owner,\n               COALESCE(hs.permission_level, 'full') as permission_level\n        FROM humidors h\n        LEFT JOIN humidor_shares hs ON h.id = hs.humidor_id AND hs.shared_with_user_id = $1\n        WHERE h.user_id = $1 OR hs.shared_with_user_id = $1\n        ORDER BY h.created_at ASC\n    \";\n\n    match db.query(query, &[&user_id]).await {\n        Ok(rows) => {\n            let humidors: Vec<Humidor> = rows\n                .iter()\n                .map(|row| Humidor {\n                    id: row.get(0),\n                    user_id: row.get(1),\n                    name: row.get(2),\n                    description: row.get(3),\n                    capacity: row.get(4),\n                    target_humidity: row.get(5),\n                    location: row.get(6),\n                    image_url: row.get(7),\n                    created_at: row.get(8),\n                    updated_at: row.get(9),\n                    is_owner: Some(row.get(10)),\n                    permission_level: Some(row.get(11)),\n                })\n                .collect();\n\n            Ok(reply::with_status(reply::json(&humidors), StatusCode::OK))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            let error_response = json!({\n                \"error\": \"Failed to fetch humidors\",\n                \"details\": e.to_string()\n            });\n            Ok(reply::with_status(\n                reply::json(&error_response),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ))\n        }\n    }\n}\n\npub async fn get_humidor(\n    id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Infallible> {\n    let db = match pool.get().await {\n        Ok(conn) => conn,\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to get database connection\");\n            return Ok(reply::with_status(\n                reply::json(&json!({\"error\": \"Database connection failed\"})),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ));\n        }\n    };\n\n    let user_id = auth.user_id;\n\n    // Check if user can view this humidor (owner or has share access)\n    match can_view_humidor(&pool, &user_id, &id).await {\n        Ok(true) => {\n            // User has access, fetch the humidor\n            let query = \"\n                SELECT id, user_id, name, description, capacity, target_humidity, location, image_url, created_at, updated_at\n                FROM humidors \n                WHERE id = $1\n            \";\n\n            match db.query_opt(query, &[&id]).await {\n                Ok(Some(row)) => {\n                    let humidor = Humidor {\n                        id: row.get(0),\n                        user_id: row.get(1),\n                        name: row.get(2),\n                        description: row.get(3),\n                        capacity: row.get(4),\n                        target_humidity: row.get(5),\n                        location: row.get(6),\n                        image_url: row.get(7),\n                        created_at: row.get(8),\n                        updated_at: row.get(9),\n                        is_owner: None,\n                        permission_level: None,\n                    };\n\n                    Ok(reply::with_status(reply::json(&humidor), StatusCode::OK))\n                }\n                Ok(None) => {\n                    let error_response = json!({\n                        \"error\": \"Humidor not found\"\n                    });\n                    Ok(reply::with_status(\n                        reply::json(&error_response),\n                        StatusCode::NOT_FOUND,\n                    ))\n                }\n                Err(e) => {\n                    tracing::error!(error = %e, \"Database error\");\n                    let error_response = json!({\n                        \"error\": \"Failed to fetch humidor\",\n                        \"details\": e.to_string()\n                    });\n                    Ok(reply::with_status(\n                        reply::json(&error_response),\n                        StatusCode::INTERNAL_SERVER_ERROR,\n                    ))\n                }\n            }\n        }\n        Ok(false) => {\n            // User does not have access\n            let error_response = json!({\n                \"error\": \"Forbidden: You do not have access to this humidor\"\n            });\n            Ok(reply::with_status(\n                reply::json(&error_response),\n                StatusCode::FORBIDDEN,\n            ))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to check humidor access\");\n            let error_response = json!({\n                \"error\": \"Failed to check access\"\n            });\n            Ok(reply::with_status(\n                reply::json(&error_response),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ))\n        }\n    }\n}\n\npub async fn create_humidor(\n    request: CreateHumidorRequest,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Infallible> {\n    let db = match pool.get().await {\n        Ok(conn) => conn,\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to get database connection\");\n            return Ok(reply::with_status(\n                reply::json(&json!({\"error\": \"Database connection failed\"})),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ));\n        }\n    };\n\n    // Validate input\n    if let Err(e) = request.validate() {\n        return Ok(reply::with_status(\n            reply::json(&json!({\"error\": e.to_string()})),\n            StatusCode::BAD_REQUEST,\n        ));\n    }\n\n    let user_id = auth.user_id;\n    let humidor_id = Uuid::new_v4();\n    let now = chrono::Utc::now();\n\n    let query = \"\n        INSERT INTO humidors (id, user_id, name, description, capacity, target_humidity, location, image_url, created_at, updated_at)\n        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n        RETURNING id, user_id, name, description, capacity, target_humidity, location, image_url, created_at, updated_at\n    \";\n\n    match db\n        .query_one(\n            query,\n            &[\n                &humidor_id,\n                &user_id,\n                &request.name,\n                &request.description,\n                &request.capacity,\n                &request.target_humidity,\n                &request.location,\n                &request.image_url,\n                &now,\n                &now,\n            ],\n        )\n        .await\n    {\n        Ok(row) => {\n            let humidor = Humidor {\n                id: row.get(0),\n                user_id: row.get(1),\n                name: row.get(2),\n                description: row.get(3),\n                capacity: row.get(4),\n                target_humidity: row.get(5),\n                location: row.get(6),\n                image_url: row.get(7),\n                created_at: row.get(8),\n                updated_at: row.get(9),\n                is_owner: Some(true), // User creating is always owner\n                permission_level: Some(\"full\".to_string()),\n            };\n\n            Ok(reply::with_status(\n                reply::json(&humidor),\n                StatusCode::CREATED,\n            ))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            let error_response = json!({\n                \"error\": \"Failed to create humidor\",\n                \"details\": e.to_string()\n            });\n            Ok(reply::with_status(\n                reply::json(&error_response),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ))\n        }\n    }\n}\n\npub async fn update_humidor(\n    id: Uuid,\n    request: UpdateHumidorRequest,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Infallible> {\n    let db = match pool.get().await {\n        Ok(conn) => conn,\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to get database connection\");\n            return Ok(reply::with_status(\n                reply::json(&json!({\"error\": \"Database connection failed\"})),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ));\n        }\n    };\n\n    // Validate input\n    if let Err(e) = request.validate() {\n        return Ok(reply::with_status(\n            reply::json(&json!({\"error\": e.to_string()})),\n            StatusCode::BAD_REQUEST,\n        ));\n    }\n\n    let user_id = auth.user_id;\n    let now = chrono::Utc::now();\n\n    let query = \"\n        UPDATE humidors \n        SET name = $3, description = $4, capacity = $5, target_humidity = $6, location = $7, image_url = $8, updated_at = $9\n        WHERE id = $1 AND user_id = $2\n        RETURNING id, user_id, name, description, capacity, target_humidity, location, image_url, created_at, updated_at\n    \";\n\n    match db\n        .query_opt(\n            query,\n            &[\n                &id,\n                &user_id,\n                &request.name,\n                &request.description,\n                &request.capacity,\n                &request.target_humidity,\n                &request.location,\n                &request.image_url,\n                &now,\n            ],\n        )\n        .await\n    {\n        Ok(Some(row)) => {\n            let humidor = Humidor {\n                id: row.get(0),\n                user_id: row.get(1),\n                name: row.get(2),\n                description: row.get(3),\n                capacity: row.get(4),\n                target_humidity: row.get(5),\n                location: row.get(6),\n                image_url: row.get(7),\n                created_at: row.get(8),\n                updated_at: row.get(9),\n                is_owner: None, // Not needed for update response\n                permission_level: None,\n            };\n\n            Ok(reply::with_status(reply::json(&humidor), StatusCode::OK))\n        }\n        Ok(None) => {\n            let error_response = json!({\n                \"error\": \"Humidor not found\"\n            });\n            Ok(reply::with_status(\n                reply::json(&error_response),\n                StatusCode::NOT_FOUND,\n            ))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            let error_response = json!({\n                \"error\": \"Failed to update humidor\",\n                \"details\": e.to_string()\n            });\n            Ok(reply::with_status(\n                reply::json(&error_response),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ))\n        }\n    }\n}\n\npub async fn delete_humidor(\n    id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Infallible> {\n    let db = match pool.get().await {\n        Ok(conn) => conn,\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to get database connection\");\n            return Ok(reply::with_status(\n                reply::json(&json!({\"error\": \"Database connection failed\"})),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ));\n        }\n    };\n\n    let user_id = auth.user_id;\n    let query = \"DELETE FROM humidors WHERE id = $1 AND user_id = $2\";\n\n    match db.execute(query, &[&id, &user_id]).await {\n        Ok(rows_affected) => {\n            if rows_affected == 0 {\n                let error_response = json!({\n                    \"error\": \"Humidor not found\"\n                });\n                Ok(reply::with_status(\n                    reply::json(&error_response),\n                    StatusCode::NOT_FOUND,\n                ))\n            } else {\n                let success_response = json!({\n                    \"message\": \"Humidor deleted successfully\"\n                });\n                Ok(reply::with_status(\n                    reply::json(&success_response),\n                    StatusCode::OK,\n                ))\n            }\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            let error_response = json!({\n                \"error\": \"Failed to delete humidor\",\n                \"details\": e.to_string()\n            });\n            Ok(reply::with_status(\n                reply::json(&error_response),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ))\n        }\n    }\n}\n\npub async fn get_humidor_cigars(\n    humidor_id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Infallible> {\n    let db = match pool.get().await {\n        Ok(conn) => conn,\n        Err(e) => {\n            tracing::error!(error = %e, \"Failed to get database connection\");\n            return Ok(reply::with_status(\n                reply::json(&json!({\"error\": \"Database connection failed\"})),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ));\n        }\n    };\n\n    let user_id = auth.user_id;\n    // First verify the humidor belongs to the user\n    let humidor_check = \"SELECT id FROM humidors WHERE id = $1 AND user_id = $2\";\n    match db.query_opt(humidor_check, &[&humidor_id, &user_id]).await {\n        Ok(Some(_)) => {\n            // Humidor exists and belongs to user, get cigars\n            let query = \"\n                SELECT c.id, c.humidor_id, c.brand, c.name, c.size, c.wrapper, \n                       c.strength, c.origin, c.price, c.purchase_date, c.notes, c.quantity, \n                       c.ring_gauge, c.length, c.created_at, c.updated_at\n                FROM cigars c \n                WHERE c.humidor_id = $1\n                ORDER BY c.created_at DESC\n            \";\n\n            match db.query(query, &[&humidor_id]).await {\n                Ok(rows) => {\n                    let cigars: Vec<serde_json::Value> = rows\n                        .iter()\n                        .map(|row| json!({\n                            \"id\": row.get::<_, Uuid>(0),\n                            \"humidor_id\": row.get::<_, Option<Uuid>>(1),\n                            \"brand\": row.get::<_, String>(2),\n                            \"name\": row.get::<_, String>(3),\n                            \"size\": row.get::<_, String>(4),\n                            \"wrapper\": row.get::<_, Option<String>>(5),\n                            \"strength\": row.get::<_, String>(6),\n                            \"origin\": row.get::<_, String>(7),\n                            \"price\": row.get::<_, Option<f64>>(8),\n                            \"purchase_date\": row.get::<_, Option<chrono::DateTime<chrono::Utc>>>(9),\n                            \"notes\": row.get::<_, Option<String>>(10),\n                            \"quantity\": row.get::<_, i32>(11),\n                            \"ring_gauge\": row.get::<_, Option<i32>>(12),\n                            \"length\": row.get::<_, Option<f64>>(13),\n                            \"created_at\": row.get::<_, chrono::DateTime<chrono::Utc>>(14),\n                            \"updated_at\": row.get::<_, chrono::DateTime<chrono::Utc>>(15),\n                        }))\n                        .collect();\n\n                    Ok(reply::with_status(reply::json(&cigars), StatusCode::OK))\n                }\n                Err(e) => {\n                    tracing::error!(error = %e, \"Database error\");\n                    let error_response = json!({\n                        \"error\": \"Failed to fetch cigars\",\n                        \"details\": e.to_string()\n                    });\n                    Ok(reply::with_status(\n                        reply::json(&error_response),\n                        StatusCode::INTERNAL_SERVER_ERROR,\n                    ))\n                }\n            }\n        }\n        Ok(None) => {\n            let error_response = json!({\n                \"error\": \"Humidor not found\"\n            });\n            Ok(reply::with_status(\n                reply::json(&error_response),\n                StatusCode::NOT_FOUND,\n            ))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            let error_response = json!({\n                \"error\": \"Failed to verify humidor access\",\n                \"details\": e.to_string()\n            });\n            Ok(reply::with_status(\n                reply::json(&error_response),\n                StatusCode::INTERNAL_SERVER_ERROR,\n            ))\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","images.rs"],"content":"use crate::DbPool;\r\nuse crate::middleware::AuthContext;\r\nuse bytes::Buf;\r\nuse futures::StreamExt;\r\nuse serde_json::json;\r\nuse std::convert::Infallible;\r\nuse std::path::PathBuf;\r\nuse tokio::fs;\r\nuse tokio::io::AsyncWriteExt;\r\nuse uuid::Uuid;\r\nuse warp::{multipart::FormData, Reply, http::StatusCode, reply};\r\n\r\n/// Maximum file size: 5MB\r\nconst MAX_FILE_SIZE: u64 = 5 * 1024 * 1024;\r\n\r\n/// Allowed image MIME types\r\nconst ALLOWED_TYPES: &[&str] = &[\r\n    \"image/jpeg\",\r\n    \"image/jpg\",\r\n    \"image/png\",\r\n    \"image/gif\",\r\n    \"image/webp\",\r\n];\r\n\r\n/// Upload directory path\r\nconst UPLOAD_DIR: &str = \"/app/uploads\";\r\n\r\n/// Handle image upload from multipart form data\r\npub async fn upload_image(\r\n    mut form: FormData,\r\n    _auth: AuthContext,\r\n    _pool: DbPool,\r\n) -> Result<impl Reply, Infallible> {\r\n    tracing::info!(\"Image upload request received\");\r\n    \r\n    // Ensure upload directory exists\r\n    if let Err(e) = fs::create_dir_all(UPLOAD_DIR).await {\r\n        tracing::error!(error = %e, \"Failed to create upload directory\");\r\n        return Ok(reply::with_status(\r\n            reply::json(&json!({\"error\": \"Failed to create upload directory\"})),\r\n            StatusCode::INTERNAL_SERVER_ERROR,\r\n        ));\r\n    }\r\n\r\n    let mut file_data: Option<Vec<u8>> = None;\r\n    let mut file_extension: Option<String> = None;\r\n\r\n    // Process multipart form data\r\n    while let Some(Ok(mut part)) = form.next().await {\r\n        let name = part.name().to_string();\r\n        tracing::info!(part_name = %name, \"Processing multipart part\");\r\n\r\n        if name == \"image\" {\r\n            // Get content type from the part and validate\r\n            let content_type = part.content_type().map(|s| s.to_string());\r\n            tracing::info!(content_type = ?content_type, \"Image part content type\");\r\n\r\n            if let Some(ref ct) = content_type {\r\n                if !ALLOWED_TYPES.contains(&ct.as_str()) {\r\n                    tracing::warn!(content_type = %ct, \"Invalid image type uploaded\");\r\n                    return Ok(reply::with_status(\r\n                        reply::json(&json!({\r\n                            \"error\": \"Invalid image type. Allowed: JPEG, PNG, GIF, WebP\"\r\n                        })),\r\n                        StatusCode::BAD_REQUEST,\r\n                    ));\r\n                }\r\n\r\n                // Determine file extension from MIME type\r\n                file_extension = Some(match ct.as_str() {\r\n                    \"image/jpeg\" | \"image/jpg\" => \"jpg\",\r\n                    \"image/png\" => \"png\",\r\n                    \"image/gif\" => \"gif\",\r\n                    \"image/webp\" => \"webp\",\r\n                    _ => \"jpg\", // fallback\r\n                }.to_string());\r\n            } else {\r\n                return Ok(reply::with_status(\r\n                    reply::json(&json!({\"error\": \"Missing content type\"})),\r\n                    StatusCode::BAD_REQUEST,\r\n                ));\r\n            }\r\n\r\n            // Read file data with size limit\r\n            let mut buffer = Vec::new();\r\n            while let Some(Ok(mut chunk)) = part.data().await {\r\n                while chunk.has_remaining() {\r\n                    if (buffer.len() + chunk.remaining()) as u64 > MAX_FILE_SIZE {\r\n                        tracing::warn!(\"File size exceeds maximum allowed\");\r\n                        return Ok(reply::with_status(\r\n                            reply::json(&json!({\"error\": \"File size exceeds 5MB limit\"})),\r\n                            StatusCode::BAD_REQUEST,\r\n                        ));\r\n                    }\r\n                    let bytes = chunk.chunk();\r\n                    buffer.extend_from_slice(bytes);\r\n                    let len = bytes.len();\r\n                    chunk.advance(len);\r\n                }\r\n            }\r\n\r\n            let buffer_len = buffer.len();\r\n            file_data = Some(buffer);\r\n            tracing::info!(size = buffer_len, \"Image data received\");\r\n        }\r\n    }\r\n\r\n    tracing::info!(has_data = file_data.is_some(), \"Finished processing multipart form\");\r\n\r\n    // Validate we received file data\r\n    let data = match file_data {\r\n        Some(d) if !d.is_empty() => d,\r\n        _ => {\r\n            tracing::warn!(\"No image data received\");\r\n            return Ok(reply::with_status(\r\n                reply::json(&json!({\"error\": \"No image file provided\"})),\r\n                StatusCode::BAD_REQUEST,\r\n            ));\r\n        }\r\n    };\r\n\r\n    let ext = file_extension.unwrap_or_else(|| \"jpg\".to_string());\r\n\r\n    // Generate unique filename\r\n    let filename = format!(\"{}.{}\", Uuid::new_v4(), ext);\r\n    let file_path = PathBuf::from(UPLOAD_DIR).join(&filename);\r\n\r\n    // Write file to disk\r\n    match fs::File::create(&file_path).await {\r\n        Ok(mut file) => {\r\n            if let Err(e) = file.write_all(&data).await {\r\n                tracing::error!(error = %e, path = ?file_path, \"Failed to write image file\");\r\n                return Ok(reply::with_status(\r\n                    reply::json(&json!({\"error\": \"Failed to save image\"})),\r\n                    StatusCode::INTERNAL_SERVER_ERROR,\r\n                ));\r\n            }\r\n        }\r\n        Err(e) => {\r\n            tracing::error!(error = %e, path = ?file_path, \"Failed to create image file\");\r\n            return Ok(reply::with_status(\r\n                reply::json(&json!({\"error\": \"Failed to create image file\"})),\r\n                StatusCode::INTERNAL_SERVER_ERROR,\r\n            ));\r\n        }\r\n    }\r\n\r\n    tracing::info!(filename = %filename, size = data.len(), \"Image uploaded successfully\");\r\n\r\n    // Return URL to access the uploaded image\r\n    Ok(reply::with_status(\r\n        reply::json(&json!({\r\n            \"url\": format!(\"/uploads/{}\", filename),\r\n            \"filename\": filename,\r\n            \"size\": data.len()\r\n        })),\r\n        StatusCode::OK,\r\n    ))\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","mod.rs"],"content":"pub mod admin;\r\npub mod auth;\r\npub mod backups;\r\npub mod brands;\r\npub mod cigars;\r\npub mod favorites;\r\npub mod humidor_shares;\r\npub mod humidors;\r\npub mod origins;\r\npub mod public_shares;\r\npub mod ring_gauges;\r\npub mod sizes;\r\npub mod strengths;\r\npub mod wish_list;\r\n\r\n// Re-export handler functions with specific names to avoid conflicts\r\npub use auth::{\r\n    change_password, check_email_config, create_setup_user, forgot_password, get_current_user,\r\n    get_setup_status, login_user, reset_password, update_current_user,\r\n};\r\npub use cigars::{\r\n    create_cigar, delete_cigar, get_cigar, get_cigars, get_random_cigar, scrape_cigar_url,\r\n    transfer_cigar, update_cigar,\r\n};\r\n\r\npub use brands::{create_brand, delete_brand, get_brands, update_brand};\r\n\r\npub use sizes::{create_size, delete_size, get_sizes, update_size};\r\n\r\npub use origins::{create_origin, delete_origin, get_origins, update_origin};\r\n\r\npub use strengths::{create_strength, delete_strength, get_strengths, update_strength};\r\n\r\npub use ring_gauges::{create_ring_gauge, delete_ring_gauge, get_ring_gauges, update_ring_gauge};\r\n\r\npub use humidors::{\r\n    create_humidor, delete_humidor, get_humidor, get_humidor_cigars, get_humidors, update_humidor,\r\n};\r\n\r\npub use humidor_shares::{\r\n    get_humidor_shares, get_shared_humidors, revoke_share, share_humidor, update_share_permission,\r\n};\r\n\r\npub use public_shares::{\r\n    create_public_share, delete_public_share, get_public_humidor, get_public_share,\r\n    get_public_shares, revoke_public_share,\r\n};\r\n\r\npub use favorites::{add_favorite, get_favorites, is_favorite, remove_favorite};\r\n\r\npub use wish_list::{\r\n    add_to_wish_list, check_wish_list, get_wish_list, remove_from_wish_list, update_wish_list_notes,\r\n};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","origins.rs"],"content":"use chrono::Utc;\nuse serde_json::json;\nuse uuid::Uuid;\nuse warp::{Rejection, Reply};\n\nuse crate::{DbPool, errors::AppError, middleware::AuthContext, models::*, validation::Validate};\n\npub async fn get_origins(auth: AuthContext, pool: DbPool) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db.query(\n        \"SELECT id, user_id, name, country, region, description, created_at, updated_at FROM origins WHERE user_id = $1 ORDER BY country ASC\",\n        &[&auth.user_id]\n    ).await {\n        Ok(rows) => {\n            let mut origins = Vec::new();\n            for row in rows {\n                let origin = Origin {\n                    id: row.get(0),\n                    user_id: row.get(1),\n                    name: row.get(2),\n                    country: row.get(3),\n                    region: row.get(4),\n                    description: row.get(5),\n                    created_at: row.get(6),\n                    updated_at: row.get(7),\n                };\n                origins.push(origin);\n            }\n            Ok(warp::reply::json(&origins))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\"error\": \"Failed to fetch origins\"})))\n        }\n    }\n}\n\npub async fn create_origin(\n    auth: AuthContext,\n    create_origin: CreateOrigin,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate input\n    create_origin.validate().map_err(warp::reject::custom)?;\n\n    let id = Uuid::new_v4();\n    let now = Utc::now();\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .query_one(\n            \"INSERT INTO origins (id, user_id, name, country, region, description, created_at, updated_at) \n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8) \n         RETURNING id, user_id, name, country, region, description, created_at, updated_at\",\n            &[\n                &id,\n                &auth.user_id,\n                &create_origin.name,\n                &create_origin.country,\n                &create_origin.region,\n                &create_origin.description,\n                &now,\n                &now,\n            ],\n        )\n        .await\n    {\n        Ok(row) => {\n            let origin = Origin {\n                id: row.get(0),\n                user_id: row.get(1),\n                name: row.get(2),\n                country: row.get(3),\n                region: row.get(4),\n                description: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n            };\n            Ok(warp::reply::json(&origin))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to create origin\"}),\n            ))\n        }\n    }\n}\n\npub async fn update_origin(\n    id: Uuid,\n    auth: AuthContext,\n    update_origin: UpdateOrigin,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate input\n    update_origin.validate().map_err(warp::reject::custom)?;\n\n    let now = Utc::now();\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .query_opt(\n            \"UPDATE origins SET \n         name = COALESCE($2, name),\n         country = COALESCE($3, country),\n         region = COALESCE($4, region),\n         description = COALESCE($5, description),\n         updated_at = $6\n         WHERE id = $1 AND user_id = $7\n         RETURNING id, user_id, name, country, region, description, created_at, updated_at\",\n            &[\n                &id,\n                &update_origin.name,\n                &update_origin.country,\n                &update_origin.region,\n                &update_origin.description,\n                &now,\n                &auth.user_id,\n            ],\n        )\n        .await\n    {\n        Ok(Some(row)) => {\n            let origin = Origin {\n                id: row.get(0),\n                user_id: row.get(1),\n                name: row.get(2),\n                country: row.get(3),\n                region: row.get(4),\n                description: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n            };\n            Ok(warp::reply::json(&origin))\n        }\n        Ok(None) => Ok(warp::reply::json(\n            &json!({\"error\": \"Origin not found or unauthorized\"}),\n        )),\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to update origin\"}),\n            ))\n        }\n    }\n}\n\npub async fn delete_origin(\n    id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .execute(\n            \"DELETE FROM origins WHERE id = $1 AND user_id = $2\",\n            &[&id, &auth.user_id],\n        )\n        .await\n    {\n        Ok(rows_affected) => {\n            if rows_affected > 0 {\n                Ok(warp::reply::json(\n                    &json!({\"message\": \"Origin deleted successfully\"}),\n                ))\n            } else {\n                Ok(warp::reply::json(\n                    &json!({\"error\": \"Origin not found or unauthorized\"}),\n                ))\n            }\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to delete origin\"}),\n            ))\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","public_shares.rs"],"content":"use crate::errors::AppError;\nuse crate::middleware::auth::AuthContext;\nuse crate::models::{\n    CreatePublicShareRequest, PublicCigarResponse, PublicHumidorResponse, PublicShareResponse,\n    PublicUserInfo,\n};\nuse deadpool_postgres::Pool;\nuse std::env;\nuse uuid::Uuid;\nuse warp::{Rejection, Reply, reject, reply};\n\nuse super::humidor_shares::is_humidor_owner;\n\n/// Create or update public share for a humidor\n/// POST /api/v1/humidors/:id/public-share\npub async fn create_public_share(\n    humidor_id: Uuid,\n    auth: AuthContext,\n    request: CreatePublicShareRequest,\n    pool: Pool,\n) -> Result<impl Reply, Rejection> {\n    tracing::info!(\n        \"User {} creating public share for humidor {}\",\n        auth.user_id,\n        humidor_id\n    );\n\n    // Verify user is the owner of the humidor\n    if !is_humidor_owner(&pool, &auth.user_id, &humidor_id)\n        .await\n        .map_err(reject::custom)?\n    {\n        tracing::warn!(\n            \"User {} attempted to create public share for humidor {} they don't own\",\n            auth.user_id,\n            humidor_id\n        );\n        return Err(reject::custom(AppError::Forbidden(\n            \"You do not have permission to create a public share for this humidor\".to_string(),\n        )));\n    }\n\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        reject::custom(AppError::DatabaseError(\n            \"Failed to connect to database\".to_string(),\n        ))\n    })?;\n\n    let token_id = Uuid::new_v4();\n\n    // Determine expiration: never_expires = NULL, custom date, or default 30 days\n    let expires_at = if request.never_expires {\n        None\n    } else if let Some(custom_date) = request.expires_at {\n        Some(custom_date)\n    } else {\n        // Default: 30 days from now\n        Some(chrono::Utc::now() + chrono::Duration::days(30))\n    };\n\n    // Insert new public share (allows multiple shares per humidor)\n    let row = client\n        .query_one(\n            \"INSERT INTO public_humidor_shares (id, humidor_id, created_by_user_id, expires_at, include_favorites, include_wish_list, label, created_at)\n             VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())\n             RETURNING created_at\",\n            &[&token_id, &humidor_id, &auth.user_id, &expires_at, &request.include_favorites, &request.include_wish_list, &request.label],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to create public share: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to create public share\".to_string(),\n            ))\n        })?;\n\n    let created_at = row.get(0);\n\n    // Get domain from environment or use localhost for development\n    let domain = env::var(\"DOMAIN\").unwrap_or_else(|_| \"localhost:9898\".to_string());\n    let protocol = if domain.contains(\"localhost\") {\n        \"http\"\n    } else {\n        \"https\"\n    };\n    let share_url = format!(\"{}://{}/shared/humidors/{}\", protocol, domain, token_id);\n\n    tracing::info!(\n        \"Successfully created public share for humidor {} with token {} (expires: {:?})\",\n        humidor_id,\n        token_id,\n        expires_at\n    );\n\n    Ok(reply::with_status(\n        reply::json(&PublicShareResponse {\n            token_id,\n            share_url,\n            expires_at,\n            created_at,\n            include_favorites: request.include_favorites,\n            include_wish_list: request.include_wish_list,\n            label: request.label,\n        }),\n        warp::http::StatusCode::CREATED,\n    ))\n}\n\n/// Get all public shares for a humidor\n/// GET /api/v1/humidors/:id/public-shares\npub async fn get_public_shares(\n    humidor_id: Uuid,\n    auth: AuthContext,\n    pool: Pool,\n) -> Result<impl Reply, Rejection> {\n    tracing::debug!(\n        \"User {} fetching public shares for humidor {}\",\n        auth.user_id,\n        humidor_id\n    );\n\n    // Verify user is the owner (or has full permission to manage shares)\n    if !is_humidor_owner(&pool, &auth.user_id, &humidor_id)\n        .await\n        .map_err(reject::custom)?\n    {\n        return Err(reject::custom(AppError::Forbidden(\n            \"You do not have permission to view public share settings\".to_string(),\n        )));\n    }\n\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        reject::custom(AppError::DatabaseError(\n            \"Failed to connect to database\".to_string(),\n        ))\n    })?;\n\n    // Fetch all active public shares (check expiration if set)\n    let rows = client\n        .query(\n            \"SELECT id, expires_at, created_at, include_favorites, include_wish_list, label \n             FROM public_humidor_shares \n             WHERE humidor_id = $1 AND (expires_at IS NULL OR expires_at > NOW())\n             ORDER BY created_at DESC\",\n            &[&humidor_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to fetch public shares: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to fetch public shares\".to_string(),\n            ))\n        })?;\n\n    let domain = env::var(\"DOMAIN\").unwrap_or_else(|_| \"localhost:9898\".to_string());\n    let protocol = if domain.contains(\"localhost\") {\n        \"http\"\n    } else {\n        \"https\"\n    };\n\n    let shares: Vec<PublicShareResponse> = rows\n        .iter()\n        .map(|row| {\n            let token_id: Uuid = row.get(0);\n            let expires_at: Option<chrono::DateTime<chrono::Utc>> = row.get(1);\n            let created_at = row.get(2);\n            let include_favorites: bool = row.get(3);\n            let include_wish_list: bool = row.get(4);\n            let label: Option<String> = row.get(5);\n\n            let share_url = format!(\"{}://{}/shared/humidors/{}\", protocol, domain, token_id);\n\n            PublicShareResponse {\n                token_id,\n                share_url,\n                expires_at,\n                created_at,\n                include_favorites,\n                include_wish_list,\n                label,\n            }\n        })\n        .collect();\n\n    Ok(reply::json(&shares))\n}\n\n/// Get current public share information for a humidor (kept for backward compatibility)\n/// GET /api/v1/humidors/:id/public-share\npub async fn get_public_share(\n    humidor_id: Uuid,\n    auth: AuthContext,\n    pool: Pool,\n) -> Result<impl Reply, Rejection> {\n    tracing::debug!(\n        \"User {} fetching public share for humidor {}\",\n        auth.user_id,\n        humidor_id\n    );\n\n    // Verify user is the owner (or has full permission to manage shares)\n    if !is_humidor_owner(&pool, &auth.user_id, &humidor_id)\n        .await\n        .map_err(reject::custom)?\n    {\n        return Err(reject::custom(AppError::Forbidden(\n            \"You do not have permission to view public share settings\".to_string(),\n        )));\n    }\n\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        reject::custom(AppError::DatabaseError(\n            \"Failed to connect to database\".to_string(),\n        ))\n    })?;\n\n    // Fetch most recent active public share (check expiration if set)\n    let row = client\n        .query_opt(\n            \"SELECT id, expires_at, created_at, include_favorites, include_wish_list, label \n             FROM public_humidor_shares \n             WHERE humidor_id = $1 AND (expires_at IS NULL OR expires_at > NOW())\n             ORDER BY created_at DESC\n             LIMIT 1\",\n            &[&humidor_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to fetch public share: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to fetch public share\".to_string(),\n            ))\n        })?;\n\n    match row {\n        Some(row) => {\n            let token_id: Uuid = row.get(0);\n            let expires_at: Option<chrono::DateTime<chrono::Utc>> = row.get(1);\n            let created_at = row.get(2);\n            let include_favorites: bool = row.get(3);\n            let include_wish_list: bool = row.get(4);\n            let label: Option<String> = row.get(5);\n\n            let domain = env::var(\"DOMAIN\").unwrap_or_else(|_| \"localhost:9898\".to_string());\n            let protocol = if domain.contains(\"localhost\") {\n                \"http\"\n            } else {\n                \"https\"\n            };\n            let share_url = format!(\"{}://{}/shared/humidors/{}\", protocol, domain, token_id);\n\n            Ok(reply::json(&PublicShareResponse {\n                token_id,\n                share_url,\n                expires_at,\n                created_at,\n                include_favorites,\n                include_wish_list,\n                label,\n            }))\n        }\n        None => {\n            // Check if expired share exists and clean it up\n            let _ = client\n                .execute(\n                    \"DELETE FROM public_humidor_shares \n                     WHERE humidor_id = $1 AND expires_at <= NOW()\",\n                    &[&humidor_id],\n                )\n                .await;\n\n            Err(reject::custom(AppError::NotFound(\n                \"No active public share found\".to_string(),\n            )))\n        }\n    }\n}\n\n/// Revoke public share for a humidor\n/// DELETE /api/v1/humidors/:id/public-share\npub async fn revoke_public_share(\n    humidor_id: Uuid,\n    auth: AuthContext,\n    pool: Pool,\n) -> Result<impl Reply, Rejection> {\n    tracing::info!(\n        \"User {} revoking all public shares for humidor {}\",\n        auth.user_id,\n        humidor_id\n    );\n\n    // Verify user is the owner\n    if !is_humidor_owner(&pool, &auth.user_id, &humidor_id)\n        .await\n        .map_err(reject::custom)?\n    {\n        return Err(reject::custom(AppError::Forbidden(\n            \"You do not have permission to revoke the public shares\".to_string(),\n        )));\n    }\n\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        reject::custom(AppError::DatabaseError(\n            \"Failed to connect to database\".to_string(),\n        ))\n    })?;\n\n    let rows_affected = client\n        .execute(\n            \"DELETE FROM public_humidor_shares WHERE humidor_id = $1\",\n            &[&humidor_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to delete public shares: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to revoke public shares\".to_string(),\n            ))\n        })?;\n\n    if rows_affected == 0 {\n        return Err(reject::custom(AppError::NotFound(\n            \"No public shares found to revoke\".to_string(),\n        )));\n    }\n\n    tracing::info!(\n        \"Successfully revoked {} public share(s) for humidor {}\",\n        rows_affected,\n        humidor_id\n    );\n\n    Ok(reply::with_status(\n        reply::json(&serde_json::json!({\n            \"message\": format!(\"Revoked {} public share(s) successfully\", rows_affected)\n        })),\n        warp::http::StatusCode::OK,\n    ))\n}\n\n/// Delete a specific public share by token ID\n/// DELETE /api/v1/humidors/:id/public-shares/:token_id\npub async fn delete_public_share(\n    humidor_id: Uuid,\n    token_id: Uuid,\n    auth: AuthContext,\n    pool: Pool,\n) -> Result<impl Reply, Rejection> {\n    tracing::info!(\n        \"User {} deleting public share {} for humidor {}\",\n        auth.user_id,\n        token_id,\n        humidor_id\n    );\n\n    // Verify user is the owner\n    if !is_humidor_owner(&pool, &auth.user_id, &humidor_id)\n        .await\n        .map_err(reject::custom)?\n    {\n        return Err(reject::custom(AppError::Forbidden(\n            \"You do not have permission to delete this public share\".to_string(),\n        )));\n    }\n\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        reject::custom(AppError::DatabaseError(\n            \"Failed to connect to database\".to_string(),\n        ))\n    })?;\n\n    let rows_affected = client\n        .execute(\n            \"DELETE FROM public_humidor_shares WHERE id = $1 AND humidor_id = $2\",\n            &[&token_id, &humidor_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to delete public share: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to delete public share\".to_string(),\n            ))\n        })?;\n\n    if rows_affected == 0 {\n        return Err(reject::custom(AppError::NotFound(\n            \"Public share not found\".to_string(),\n        )));\n    }\n\n    tracing::info!(\"Successfully deleted public share {}\", token_id);\n\n    Ok(reply::with_status(\n        reply::json(&serde_json::json!({\n            \"message\": \"Public share deleted successfully\"\n        })),\n        warp::http::StatusCode::OK,\n    ))\n}\n\n/// Get humidor data via public share token (NO AUTHENTICATION REQUIRED)\n/// GET /api/v1/shared/humidors/:token\npub async fn get_public_humidor(token_id: Uuid, pool: Pool) -> Result<impl Reply, Rejection> {\n    tracing::info!(\"Public access request for token {}\", token_id);\n\n    let client = pool.get().await.map_err(|e| {\n        tracing::error!(\"Failed to get database connection: {}\", e);\n        reject::custom(AppError::DatabaseError(\n            \"Failed to connect to database\".to_string(),\n        ))\n    })?;\n\n    // Verify token exists and is not expired, and get include flags\n    let token_row = client\n        .query_opt(\n            \"SELECT humidor_id, include_favorites, include_wish_list \n             FROM public_humidor_shares \n             WHERE id = $1 AND (expires_at IS NULL OR expires_at > NOW())\",\n            &[&token_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to check share token: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to verify token\".to_string(),\n            ))\n        })?;\n\n    let (humidor_id, include_favorites, include_wish_list): (Uuid, bool, bool) = match token_row {\n        Some(row) => (row.get(0), row.get(1), row.get(2)),\n        None => {\n            // Cleanup expired token if it exists\n            let _ = client\n                .execute(\n                    \"DELETE FROM public_humidor_shares \n                     WHERE id = $1 AND expires_at <= NOW()\",\n                    &[&token_id],\n                )\n                .await;\n\n            tracing::warn!(\"Invalid or expired token access attempt: {}\", token_id);\n            return Err(reject::custom(AppError::NotFound(\n                \"Share link not found or has expired\".to_string(),\n            )));\n        }\n    };\n\n    // Fetch humidor details WITHOUT user_id filter (bypass ownership check)\n    let humidor_row = client\n        .query_opt(\n            \"SELECT h.id, h.name, h.description, h.image_url, h.created_at,\n                    u.username, u.email, u.full_name, u.id as user_id\n             FROM humidors h\n             INNER JOIN users u ON h.user_id = u.id\n             WHERE h.id = $1\",\n            &[&humidor_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to fetch humidor: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to fetch humidor\".to_string(),\n            ))\n        })?;\n\n    let humidor_row = match humidor_row {\n        Some(row) => row,\n        None => {\n            tracing::error!(\"Humidor {} not found for valid token\", humidor_id);\n            return Err(reject::custom(AppError::NotFound(\n                \"Humidor not found\".to_string(),\n            )));\n        }\n    };\n\n    // Fetch cigars in humidor WITHOUT user_id filter\n    // Join with organizer tables to get display names\n    let cigar_rows = client\n        .query(\n            \"SELECT c.id, c.name, b.name as brand, o.name as origin, c.wrapper, s.name as strength,\n                    rg.gauge as ring_gauge, c.length as length_inches, c.quantity, c.notes, c.retail_link, c.image_url\n             FROM cigars c\n             LEFT JOIN brands b ON c.brand_id = b.id\n             LEFT JOIN origins o ON c.origin_id = o.id\n             LEFT JOIN strengths s ON c.strength_id = s.id\n             LEFT JOIN ring_gauges rg ON c.ring_gauge_id = rg.id\n             WHERE c.humidor_id = $1 AND c.is_active = true\n             ORDER BY c.name\",\n            &[&humidor_id],\n        )\n        .await\n        .map_err(|e| {\n            tracing::error!(\"Failed to fetch cigars: {}\", e);\n            reject::custom(AppError::DatabaseError(\n                \"Failed to fetch cigars\".to_string(),\n            ))\n        })?;\n\n    // Build response\n    let cigars: Vec<PublicCigarResponse> = cigar_rows\n        .iter()\n        .map(|row| PublicCigarResponse {\n            id: row.get(0),\n            name: row.get(1),\n            brand: row.get(2),\n            origin: row.get(3),\n            wrapper: row.get(4),\n            strength: row.get(5),\n            ring_gauge: row.get(6),\n            length_inches: row.get(7),\n            quantity: row.get(8),\n            notes: row.get(9),\n            retail_link: row.get(10),\n            image_url: row.get(11),\n        })\n        .collect();\n\n    // Get user_id for favorites/wishlist queries\n    let user_id: Uuid = humidor_row.get(8);\n\n    // Fetch favorites if requested\n    let favorites = if include_favorites {\n        let fav_rows = client\n            .query(\n                \"SELECT c.id, c.name, b.name as brand, o.name as origin, c.wrapper, s.name as strength,\n                        rg.gauge as ring_gauge, c.length as length_inches, c.quantity, c.notes, c.retail_link, c.image_url\n                 FROM favorites f\n                 INNER JOIN cigars c ON f.cigar_id = c.id\n                 LEFT JOIN brands b ON c.brand_id = b.id\n                 LEFT JOIN origins o ON c.origin_id = o.id\n                 LEFT JOIN strengths s ON c.strength_id = s.id\n                 LEFT JOIN ring_gauges rg ON c.ring_gauge_id = rg.id\n                 WHERE f.user_id = $1 AND c.is_active = true\n                 ORDER BY c.name\",\n                &[&user_id],\n            )\n            .await\n            .map_err(|e| {\n                tracing::error!(\"Failed to fetch favorites: {}\", e);\n                reject::custom(AppError::DatabaseError(\"Failed to fetch favorites\".to_string()))\n            })?;\n\n        Some(\n            fav_rows\n                .iter()\n                .map(|row| PublicCigarResponse {\n                    id: row.get(0),\n                    name: row.get(1),\n                    brand: row.get(2),\n                    origin: row.get(3),\n                    wrapper: row.get(4),\n                    strength: row.get(5),\n                    ring_gauge: row.get(6),\n                    length_inches: row.get(7),\n                    quantity: row.get(8),\n                    notes: row.get(9),\n                    retail_link: row.get(10),\n                    image_url: row.get(11),\n                })\n                .collect::<Vec<_>>(),\n        )\n    } else {\n        None\n    };\n\n    // Fetch wish list if requested\n    let wish_list = if include_wish_list {\n        let wish_rows = client\n            .query(\n                \"SELECT c.id, c.name, b.name as brand, o.name as origin, c.wrapper, s.name as strength,\n                        rg.gauge as ring_gauge, c.length as length_inches, 0 as quantity, c.notes, c.retail_link, c.image_url\n                 FROM wish_list w\n                 INNER JOIN cigars c ON w.cigar_id = c.id\n                 LEFT JOIN brands b ON c.brand_id = b.id\n                 LEFT JOIN origins o ON c.origin_id = o.id\n                 LEFT JOIN strengths s ON c.strength_id = s.id\n                 LEFT JOIN ring_gauges rg ON c.ring_gauge_id = rg.id\n                 WHERE w.user_id = $1 AND c.is_active = true\n                 ORDER BY c.name\",\n                &[&user_id],\n            )\n            .await\n            .map_err(|e| {\n                tracing::error!(\"Failed to fetch wish list: {}\", e);\n                reject::custom(AppError::DatabaseError(\"Failed to fetch wish list\".to_string()))\n            })?;\n\n        Some(\n            wish_rows\n                .iter()\n                .map(|row| PublicCigarResponse {\n                    id: row.get(0),\n                    name: row.get(1),\n                    brand: row.get(2),\n                    origin: row.get(3),\n                    wrapper: row.get(4),\n                    strength: row.get(5),\n                    ring_gauge: row.get(6),\n                    length_inches: row.get(7),\n                    quantity: row.get(8), // 0 for wishlist items\n                    notes: row.get(9),\n                    retail_link: row.get(10),\n                    image_url: row.get(11),\n                })\n                .collect::<Vec<_>>(),\n        )\n    } else {\n        None\n    };\n\n    let humidor = PublicHumidorResponse {\n        id: humidor_row.get(0),\n        name: humidor_row.get(1),\n        description: humidor_row.get(2),\n        image_url: humidor_row.get(3),\n        created_at: humidor_row.get(4),\n        owner: PublicUserInfo {\n            username: humidor_row.get(5),\n            full_name: humidor_row.get(7),\n        },\n        cigar_count: cigars.len(),\n        cigars,\n        favorites,\n        wish_list,\n    };\n\n    tracing::info!(\n        \"Successfully served public humidor {} via token {}\",\n        humidor_id,\n        token_id\n    );\n\n    Ok(reply::json(&humidor))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","ring_gauges.rs"],"content":"use chrono::Utc;\nuse serde_json::json;\nuse uuid::Uuid;\nuse warp::{Rejection, Reply};\n\nuse crate::{DbPool, errors::AppError, middleware::AuthContext, models::*, validation::Validate};\n\npub async fn get_ring_gauges(auth: AuthContext, pool: DbPool) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db.query(\n        \"SELECT id, user_id, gauge, description, common_names, created_at, updated_at FROM ring_gauges WHERE user_id = $1 ORDER BY gauge ASC\",\n        &[&auth.user_id]\n    ).await {\n        Ok(rows) => {\n            let mut ring_gauges = Vec::new();\n            for row in rows {\n                let ring_gauge = RingGauge {\n                    id: row.get(0),\n                    user_id: row.get(1),\n                    gauge: row.get(2),\n                    description: row.get(3),\n                    common_names: row.get(4),\n                    created_at: row.get(5),\n                    updated_at: row.get(6),\n                };\n                ring_gauges.push(ring_gauge);\n            }\n            Ok(warp::reply::json(&ring_gauges))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\"error\": \"Failed to fetch ring gauges\"})))\n        }\n    }\n}\n\npub async fn create_ring_gauge(\n    auth: AuthContext,\n    create_ring_gauge: CreateRingGauge,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate input\n    create_ring_gauge.validate().map_err(warp::reject::custom)?;\n\n    let id = Uuid::new_v4();\n    let now = Utc::now();\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db.query_one(\n        \"INSERT INTO ring_gauges (id, user_id, gauge, description, common_names, created_at, updated_at) \n         VALUES ($1, $2, $3, $4, $5, $6, $7) \n         RETURNING id, user_id, gauge, description, common_names, created_at, updated_at\",\n        &[&id, &auth.user_id, &create_ring_gauge.gauge, &create_ring_gauge.description, &create_ring_gauge.common_names, &now, &now]\n    ).await {\n        Ok(row) => {\n            let ring_gauge = RingGauge {\n                id: row.get(0),\n                user_id: row.get(1),\n                gauge: row.get(2),\n                description: row.get(3),\n                common_names: row.get(4),\n                created_at: row.get(5),\n                updated_at: row.get(6),\n            };\n            Ok(warp::reply::json(&ring_gauge))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\"error\": \"Failed to create ring gauge\"})))\n        }\n    }\n}\n\npub async fn update_ring_gauge(\n    id: Uuid,\n    auth: AuthContext,\n    update_ring_gauge: UpdateRingGauge,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate input\n    update_ring_gauge.validate().map_err(warp::reject::custom)?;\n\n    let now = Utc::now();\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .query_opt(\n            \"UPDATE ring_gauges SET \n         gauge = COALESCE($2, gauge),\n         description = COALESCE($3, description),\n         common_names = COALESCE($4, common_names),\n         updated_at = $5\n         WHERE id = $1 AND user_id = $6\n         RETURNING id, user_id, gauge, description, common_names, created_at, updated_at\",\n            &[\n                &id,\n                &update_ring_gauge.gauge,\n                &update_ring_gauge.description,\n                &update_ring_gauge.common_names,\n                &now,\n                &auth.user_id,\n            ],\n        )\n        .await\n    {\n        Ok(Some(row)) => {\n            let ring_gauge = RingGauge {\n                id: row.get(0),\n                user_id: row.get(1),\n                gauge: row.get(2),\n                description: row.get(3),\n                common_names: row.get(4),\n                created_at: row.get(5),\n                updated_at: row.get(6),\n            };\n            Ok(warp::reply::json(&ring_gauge))\n        }\n        Ok(None) => Ok(warp::reply::json(\n            &json!({\"error\": \"Ring gauge not found or unauthorized\"}),\n        )),\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to update ring gauge\"}),\n            ))\n        }\n    }\n}\n\npub async fn delete_ring_gauge(\n    id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .execute(\n            \"DELETE FROM ring_gauges WHERE id = $1 AND user_id = $2\",\n            &[&id, &auth.user_id],\n        )\n        .await\n    {\n        Ok(rows_affected) => {\n            if rows_affected > 0 {\n                Ok(warp::reply::json(\n                    &json!({\"message\": \"Ring gauge deleted successfully\"}),\n                ))\n            } else {\n                Ok(warp::reply::json(\n                    &json!({\"error\": \"Ring gauge not found or unauthorized\"}),\n                ))\n            }\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to delete ring gauge\"}),\n            ))\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","sizes.rs"],"content":"use chrono::Utc;\nuse serde_json::json;\nuse uuid::Uuid;\nuse warp::{Rejection, Reply};\n\nuse crate::{DbPool, errors::AppError, middleware::AuthContext, models::*, validation::Validate};\n\npub async fn get_sizes(auth: AuthContext, pool: DbPool) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db.query(\n        \"SELECT id, user_id, name, length_inches, ring_gauge, description, created_at, updated_at FROM sizes WHERE user_id = $1 ORDER BY name ASC\",\n        &[&auth.user_id]\n    ).await {\n        Ok(rows) => {\n            let mut sizes = Vec::new();\n            for row in rows {\n                let size = Size {\n                    id: row.get(0),\n                    user_id: row.get(1),\n                    name: row.get(2),\n                    length_inches: row.get(3),\n                    ring_gauge: row.get(4),\n                    description: row.get(5),\n                    created_at: row.get(6),\n                    updated_at: row.get(7),\n                };\n                sizes.push(size);\n            }\n            Ok(warp::reply::json(&sizes))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\"error\": \"Failed to fetch sizes\"})))\n        }\n    }\n}\n\npub async fn create_size(\n    auth: AuthContext,\n    create_size: CreateSize,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate input\n    create_size.validate().map_err(warp::reject::custom)?;\n\n    let id = Uuid::new_v4();\n    let now = Utc::now();\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db.query_one(\n        \"INSERT INTO sizes (id, user_id, name, length_inches, ring_gauge, description, created_at, updated_at) \n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8) \n         RETURNING id, user_id, name, length_inches, ring_gauge, description, created_at, updated_at\",\n        &[&id, &auth.user_id, &create_size.name, &create_size.length_inches, &create_size.ring_gauge, &create_size.description, &now, &now]\n    ).await {\n        Ok(row) => {\n            let size = Size {\n                id: row.get(0),\n                user_id: row.get(1),\n                name: row.get(2),\n                length_inches: row.get(3),\n                ring_gauge: row.get(4),\n                description: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n            };\n            Ok(warp::reply::json(&size))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\"error\": \"Failed to create size\"})))\n        }\n    }\n}\n\npub async fn update_size(\n    id: Uuid,\n    auth: AuthContext,\n    update_size: UpdateSize,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate input\n    update_size.validate().map_err(warp::reject::custom)?;\n\n    let now = Utc::now();\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .query_opt(\n            \"UPDATE sizes SET \n         name = COALESCE($2, name),\n         length_inches = COALESCE($3, length_inches),\n         ring_gauge = COALESCE($4, ring_gauge),\n         description = COALESCE($5, description),\n         updated_at = $6\n         WHERE id = $1 AND user_id = $7\n         RETURNING id, user_id, name, length_inches, ring_gauge, description, created_at, updated_at\",\n            &[\n                &id,\n                &update_size.name,\n                &update_size.length_inches,\n                &update_size.ring_gauge,\n                &update_size.description,\n                &now,\n                &auth.user_id,\n            ],\n        )\n        .await\n    {\n        Ok(Some(row)) => {\n            let size = Size {\n                id: row.get(0),\n                user_id: row.get(1),\n                name: row.get(2),\n                length_inches: row.get(3),\n                ring_gauge: row.get(4),\n                description: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n            };\n            Ok(warp::reply::json(&size))\n        }\n        Ok(None) => {\n            Ok(warp::reply::json(&json!({\"error\": \"Size not found or unauthorized\"})))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to update size\"}),\n            ))\n        }\n    }\n}\n\npub async fn delete_size(\n    id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .execute(\n            \"DELETE FROM sizes WHERE id = $1 AND user_id = $2\",\n            &[&id, &auth.user_id],\n        )\n        .await\n    {\n        Ok(rows_affected) => {\n            if rows_affected > 0 {\n                Ok(warp::reply::json(\n                    &json!({\"message\": \"Size deleted successfully\"}),\n                ))\n            } else {\n                Ok(warp::reply::json(\n                    &json!({\"error\": \"Size not found or unauthorized\"}),\n                ))\n            }\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to delete size\"}),\n            ))\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","strengths.rs"],"content":"use chrono::Utc;\nuse serde_json::json;\nuse uuid::Uuid;\nuse warp::{Rejection, Reply};\n\nuse crate::{DbPool, errors::AppError, middleware::AuthContext, models::*, validation::Validate};\n\npub async fn get_strengths(auth: AuthContext, pool: DbPool) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db.query(\n        \"SELECT id, user_id, name, level, description, created_at, updated_at FROM strengths WHERE user_id = $1 ORDER BY level ASC\",\n        &[&auth.user_id]\n    ).await {\n        Ok(rows) => {\n            let mut strengths = Vec::new();\n            for row in rows {\n                let strength = Strength {\n                    id: row.get(0),\n                    user_id: row.get(1),\n                    name: row.get(2),\n                    level: row.get(3),\n                    description: row.get(4),\n                    created_at: row.get(5),\n                    updated_at: row.get(6),\n                };\n                strengths.push(strength);\n            }\n            Ok(warp::reply::json(&strengths))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(&json!({\"error\": \"Failed to fetch strengths\"})))\n        }\n    }\n}\n\npub async fn create_strength(\n    auth: AuthContext,\n    create_strength: CreateStrength,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate input\n    create_strength.validate().map_err(warp::reject::custom)?;\n\n    let id = Uuid::new_v4();\n    let now = Utc::now();\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .query_one(\n            \"INSERT INTO strengths (id, user_id, name, level, description, created_at, updated_at) \n         VALUES ($1, $2, $3, $4, $5, $6, $7) \n         RETURNING id, user_id, name, level, description, created_at, updated_at\",\n            &[\n                &id,\n                &auth.user_id,\n                &create_strength.name,\n                &create_strength.level,\n                &create_strength.description,\n                &now,\n                &now,\n            ],\n        )\n        .await\n    {\n        Ok(row) => {\n            let strength = Strength {\n                id: row.get(0),\n                user_id: row.get(1),\n                name: row.get(2),\n                level: row.get(3),\n                description: row.get(4),\n                created_at: row.get(5),\n                updated_at: row.get(6),\n            };\n            Ok(warp::reply::json(&strength))\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to create strength\"}),\n            ))\n        }\n    }\n}\n\npub async fn update_strength(\n    id: Uuid,\n    auth: AuthContext,\n    update_strength: UpdateStrength,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    // Validate input\n    update_strength.validate().map_err(warp::reject::custom)?;\n\n    let now = Utc::now();\n\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .query_opt(\n            \"UPDATE strengths SET \n         name = COALESCE($2, name),\n         level = COALESCE($3, level),\n         description = COALESCE($4, description),\n         updated_at = $5\n         WHERE id = $1 AND user_id = $6\n         RETURNING id, user_id, name, level, description, created_at, updated_at\",\n            &[\n                &id,\n                &update_strength.name,\n                &update_strength.level,\n                &update_strength.description,\n                &now,\n                &auth.user_id,\n            ],\n        )\n        .await\n    {\n        Ok(Some(row)) => {\n            let strength = Strength {\n                id: row.get(0),\n                user_id: row.get(1),\n                name: row.get(2),\n                level: row.get(3),\n                description: row.get(4),\n                created_at: row.get(5),\n                updated_at: row.get(6),\n            };\n            Ok(warp::reply::json(&strength))\n        }\n        Ok(None) => Ok(warp::reply::json(\n            &json!({\"error\": \"Strength not found or unauthorized\"}),\n        )),\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to update strength\"}),\n            ))\n        }\n    }\n}\n\npub async fn delete_strength(\n    id: Uuid,\n    auth: AuthContext,\n    pool: DbPool,\n) -> Result<impl Reply, Rejection> {\n    let db = pool.get().await.map_err(|e| {\n        tracing::error!(error = %e, \"Failed to get database connection\");\n        warp::reject::custom(AppError::DatabaseError(\n            \"Database connection failed\".to_string(),\n        ))\n    })?;\n\n    match db\n        .execute(\n            \"DELETE FROM strengths WHERE id = $1 AND user_id = $2\",\n            &[&id, &auth.user_id],\n        )\n        .await\n    {\n        Ok(rows_affected) => {\n            if rows_affected > 0 {\n                Ok(warp::reply::json(\n                    &json!({\"message\": \"Strength deleted successfully\"}),\n                ))\n            } else {\n                Ok(warp::reply::json(\n                    &json!({\"error\": \"Strength not found or unauthorized\"}),\n                ))\n            }\n        }\n        Err(e) => {\n            tracing::error!(error = %e, \"Database error\");\n            Ok(warp::reply::json(\n                &json!({\"error\": \"Failed to delete strength\"}),\n            ))\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","handlers","wish_list.rs"],"content":"use chrono::Utc;\r\nuse serde::{Deserialize, Serialize};\r\nuse uuid::Uuid;\r\nuse warp::{Rejection, Reply, reply::json};\r\n\r\nuse crate::{DbPool, errors::AppError, middleware::auth::AuthContext};\r\n\r\n#[derive(Debug, Serialize)]\r\npub struct WishListResponse {\r\n    pub id: Uuid,\r\n    pub user_id: Uuid,\r\n    pub cigar_id: Uuid,\r\n    pub notes: Option<String>,\r\n    pub created_at: chrono::DateTime<Utc>,\r\n}\r\n\r\n#[derive(Debug, Deserialize)]\r\npub struct AddWishListRequest {\r\n    pub cigar_id: Uuid,\r\n    pub notes: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Deserialize)]\r\npub struct UpdateWishListNotesRequest {\r\n    pub notes: Option<String>,\r\n}\r\n\r\n// Get all wish list items for the current user\r\npub async fn get_wish_list(auth: AuthContext, pool: DbPool) -> Result<impl Reply, Rejection> {\r\n    let db = pool.get().await.map_err(|e| {\r\n        tracing::error!(error = %e, \"Failed to get database connection\");\r\n        warp::reject::custom(AppError::DatabaseError(\r\n            \"Database connection failed\".to_string(),\r\n        ))\r\n    })?;\r\n\r\n    let rows = db\r\n        .query(\r\n            \"SELECT w.id, w.user_id, w.cigar_id, w.notes, w.created_at,\r\n                c.id as c_id, c.humidor_id, c.brand_id, c.name, c.size_id, c.strength_id,\r\n                c.origin_id, c.wrapper, c.binder, c.filler, c.price, c.purchase_date,\r\n                c.notes as c_notes, c.quantity, c.ring_gauge_id, c.length, c.image_url,\r\n                c.retail_link, c.created_at as c_created_at, c.updated_at as c_updated_at, c.is_active\r\n         FROM wish_list w\r\n         LEFT JOIN cigars c ON w.cigar_id = c.id\r\n         WHERE w.user_id = $1\r\n         ORDER BY w.created_at DESC\",\r\n            &[&auth.user_id],\r\n        )\r\n        .await\r\n        .map_err(|e| {\r\n            tracing::error!(error = %e, \"Database error getting wish list\");\r\n            warp::reject::reject()\r\n        })?;\r\n\r\n    let wish_list: Vec<serde_json::Value> = rows\r\n        .iter()\r\n        .map(|row| {\r\n            let cigar_exists: Option<Uuid> = row.get(5); // c.id will be null if cigar doesn't exist\r\n\r\n            serde_json::json!({\r\n                \"id\": row.get::<_, Uuid>(0),\r\n                \"user_id\": row.get::<_, Uuid>(1),\r\n                \"cigar_id\": row.get::<_, Uuid>(2),\r\n                \"notes\": row.get::<_, Option<String>>(3),\r\n                \"created_at\": row.get::<_, chrono::DateTime<Utc>>(4),\r\n                \"cigar\": if cigar_exists.is_some() {\r\n                    let is_active: bool = row.get(25);\r\n                    serde_json::json!({\r\n                        \"id\": row.get::<_, Uuid>(5),\r\n                        \"humidor_id\": row.get::<_, Option<Uuid>>(6),\r\n                        \"brand_id\": row.get::<_, Option<Uuid>>(7),\r\n                        \"name\": row.get::<_, String>(8),\r\n                        \"size_id\": row.get::<_, Option<Uuid>>(9),\r\n                        \"strength_id\": row.get::<_, Option<Uuid>>(10),\r\n                        \"origin_id\": row.get::<_, Option<Uuid>>(11),\r\n                        \"wrapper\": row.get::<_, Option<String>>(12),\r\n                        \"binder\": row.get::<_, Option<String>>(13),\r\n                        \"filler\": row.get::<_, Option<String>>(14),\r\n                        \"price\": row.get::<_, Option<f64>>(15),\r\n                        \"purchase_date\": row.get::<_, Option<chrono::DateTime<Utc>>>(16),\r\n                        \"notes\": row.get::<_, Option<String>>(17),\r\n                        \"quantity\": row.get::<_, i32>(18),\r\n                        \"ring_gauge_id\": row.get::<_, Option<Uuid>>(19),\r\n                        \"length\": row.get::<_, Option<f64>>(20),\r\n                        \"image_url\": row.get::<_, Option<String>>(21),\r\n                        \"retail_link\": row.get::<_, Option<String>>(22),\r\n                        \"created_at\": row.get::<_, chrono::DateTime<Utc>>(23),\r\n                        \"updated_at\": row.get::<_, chrono::DateTime<Utc>>(24),\r\n                        \"out_of_stock\": !is_active\r\n                    })\r\n                } else {\r\n                    serde_json::json!(null)\r\n                }\r\n            })\r\n        })\r\n        .collect();\r\n\r\n    Ok(json(&wish_list))\r\n}\r\n\r\n// Add a cigar to wish list\r\npub async fn add_to_wish_list(\r\n    request: AddWishListRequest,\r\n    auth: AuthContext,\r\n    pool: DbPool,\r\n) -> Result<impl Reply, Rejection> {\r\n    tracing::debug!(\"add_to_wish_list handler called\");\r\n    tracing::debug!(user_id = %auth.user_id, \"Processing wish list request\");\r\n    tracing::debug!(cigar_id = %request.cigar_id, \"Adding cigar to wish list\");\r\n\r\n    let db = pool.get().await.map_err(|e| {\r\n        tracing::error!(error = %e, \"Failed to get database connection\");\r\n        warp::reject::custom(AppError::DatabaseError(\r\n            \"Database connection failed\".to_string(),\r\n        ))\r\n    })?;\r\n\r\n    let id = Uuid::new_v4();\r\n    let now = Utc::now();\r\n\r\n    // Parse cigar_id from string to ensure it's a proper Uuid type\r\n    let cigar_id = Uuid::parse_str(&request.cigar_id.to_string()).map_err(|e| {\r\n        tracing::error!(error = %e, \"Invalid cigar_id format\");\r\n        warp::reject::custom(AppError::ValidationError(\r\n            \"Invalid cigar ID format\".to_string(),\r\n        ))\r\n    })?;\r\n\r\n    // Check if cigar exists\r\n    let cigar_exists = db\r\n        .query_opt(\"SELECT id FROM cigars WHERE id = $1\", &[&cigar_id])\r\n        .await\r\n        .map_err(|e| {\r\n            tracing::error!(error = %e, \"Database error checking cigar\");\r\n            warp::reject::reject()\r\n        })?;\r\n\r\n    if cigar_exists.is_none() {\r\n        tracing::warn!(cigar_id = %cigar_id, \"Cigar not found\");\r\n        return Err(warp::reject::custom(AppError::NotFound(\r\n            \"Cigar not found\".to_string(),\r\n        )));\r\n    }\r\n\r\n    // Insert the wish list item with notes\r\n    let result = db\r\n        .query_opt(\r\n            \"INSERT INTO wish_list (id, user_id, cigar_id, notes, created_at)\r\n         VALUES ($1, $2, $3, $4, $5)\r\n         ON CONFLICT (user_id, cigar_id) DO NOTHING\r\n         RETURNING id, user_id, cigar_id, notes, created_at\",\r\n            &[\r\n                &id,\r\n                &auth.user_id,\r\n                &cigar_id,\r\n                &request.notes.as_deref(),\r\n                &now,\r\n            ],\r\n        )\r\n        .await\r\n        .map_err(|e| {\r\n            tracing::error!(error = %e, \"Database error adding to wish list\");\r\n            warp::reject::reject()\r\n        })?;\r\n\r\n    // If insert succeeded, return the new item\r\n    if let Some(row) = result {\r\n        let wish_list_item = WishListResponse {\r\n            id: row.get(0),\r\n            user_id: row.get(1),\r\n            cigar_id: row.get(2),\r\n            notes: row.get(3),\r\n            created_at: row.get(4),\r\n        };\r\n        Ok(warp::reply::with_status(\r\n            json(&wish_list_item),\r\n            warp::http::StatusCode::CREATED,\r\n        ))\r\n    } else {\r\n        // Item already exists (conflict), fetch and return it\r\n        match db\r\n            .query_one(\r\n                \"SELECT id, user_id, cigar_id, notes, created_at\r\n             FROM wish_list\r\n             WHERE user_id = $1 AND cigar_id = $2\",\r\n                &[&auth.user_id, &request.cigar_id],\r\n            )\r\n            .await\r\n        {\r\n            Ok(row) => {\r\n                let wish_list_item = WishListResponse {\r\n                    id: row.get(0),\r\n                    user_id: row.get(1),\r\n                    cigar_id: row.get(2),\r\n                    notes: row.get(3),\r\n                    created_at: row.get(4),\r\n                };\r\n                Ok(warp::reply::with_status(\r\n                    json(&wish_list_item),\r\n                    warp::http::StatusCode::OK,\r\n                ))\r\n            }\r\n            Err(e) => {\r\n                tracing::error!(error = %e, \"Database error fetching existing wish list item\");\r\n                Err(warp::reject::reject())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Remove a cigar from wish list\r\npub async fn remove_from_wish_list(\r\n    cigar_id: Uuid,\r\n    auth: AuthContext,\r\n    pool: DbPool,\r\n) -> Result<impl Reply, Rejection> {\r\n    let db = pool.get().await.map_err(|e| {\r\n        tracing::error!(error = %e, \"Failed to get database connection\");\r\n        warp::reject::custom(AppError::DatabaseError(\r\n            \"Database connection failed\".to_string(),\r\n        ))\r\n    })?;\r\n\r\n    let rows_deleted = db\r\n        .execute(\r\n            \"DELETE FROM wish_list WHERE user_id = $1 AND cigar_id = $2\",\r\n            &[&auth.user_id, &cigar_id],\r\n        )\r\n        .await\r\n        .map_err(|e| {\r\n            tracing::error!(error = %e, \"Database error removing from wish list\");\r\n            warp::reject::reject()\r\n        })?;\r\n\r\n    if rows_deleted == 0 {\r\n        return Err(warp::reject::custom(AppError::NotFound(\r\n            \"Wish list item not found\".to_string(),\r\n        )));\r\n    }\r\n\r\n    Ok(warp::reply::with_status(\r\n        json(&serde_json::json!({\"message\": \"Removed from wish list\"})),\r\n        warp::http::StatusCode::OK,\r\n    ))\r\n}\r\n\r\n// Check if a cigar is in wish list\r\npub async fn check_wish_list(\r\n    cigar_id: Uuid,\r\n    auth: AuthContext,\r\n    pool: DbPool,\r\n) -> Result<impl Reply, Rejection> {\r\n    let db = pool.get().await.map_err(|e| {\r\n        tracing::error!(error = %e, \"Failed to get database connection\");\r\n        warp::reject::custom(AppError::DatabaseError(\r\n            \"Database connection failed\".to_string(),\r\n        ))\r\n    })?;\r\n\r\n    match db\r\n        .query_opt(\r\n            \"SELECT id FROM wish_list WHERE user_id = $1 AND cigar_id = $2\",\r\n            &[&auth.user_id, &cigar_id],\r\n        )\r\n        .await\r\n    {\r\n        Ok(row) => {\r\n            let in_wish_list = row.is_some();\r\n            Ok(json(&serde_json::json!({\"in_wish_list\": in_wish_list})))\r\n        }\r\n        Err(e) => {\r\n            tracing::error!(error = %e, \"Database error checking wish list\");\r\n            Err(warp::reject::reject())\r\n        }\r\n    }\r\n}\r\n\r\n// Update wish list notes\r\npub async fn update_wish_list_notes(\r\n    cigar_id: Uuid,\r\n    request: UpdateWishListNotesRequest,\r\n    auth: AuthContext,\r\n    pool: DbPool,\r\n) -> Result<impl Reply, Rejection> {\r\n    let db = pool.get().await.map_err(|e| {\r\n        tracing::error!(error = %e, \"Failed to get database connection\");\r\n        warp::reject::custom(AppError::DatabaseError(\r\n            \"Database connection failed\".to_string(),\r\n        ))\r\n    })?;\r\n\r\n    match db\r\n        .query_opt(\r\n            \"UPDATE wish_list SET notes = $1 \r\n             WHERE user_id = $2 AND cigar_id = $3\r\n             RETURNING id, user_id, cigar_id, notes, created_at\",\r\n            &[&request.notes, &auth.user_id, &cigar_id],\r\n        )\r\n        .await\r\n    {\r\n        Ok(Some(row)) => {\r\n            let wish_list_item = WishListResponse {\r\n                id: row.get(0),\r\n                user_id: row.get(1),\r\n                cigar_id: row.get(2),\r\n                notes: row.get(3),\r\n                created_at: row.get(4),\r\n            };\r\n            Ok(json(&wish_list_item))\r\n        }\r\n        Ok(None) => Err(warp::reject::custom(AppError::NotFound(\r\n            \"Wish list item not found\".to_string(),\r\n        ))),\r\n        Err(e) => {\r\n            tracing::error!(error = %e, \"Database error updating wish list notes\");\r\n            Err(warp::reject::reject())\r\n        }\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","lib.rs"],"content":"// Library exports for integration testing\n// This allows tests to access internal modules\n\npub mod errors;\npub mod handlers;\npub mod middleware;\npub mod models;\npub mod routes;\npub mod services;\npub mod validation;\n\n// Re-export commonly used types\npub use errors::AppError;\npub use middleware::{AuthContext, RateLimiter};\npub use validation::{validate_email, validate_length, validate_positive};\n\n// Export DbPool type for handlers\nuse deadpool_postgres::Pool;\npub type DbPool = Pool;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","main.rs"],"content":"#![recursion_limit = \"256\"]\n\nmod errors;\nmod handlers;\nmod middleware;\nmod models;\nmod routes;\nmod services;\nmod validation;\n\nuse anyhow::bail;\nuse deadpool_postgres::{Config, ManagerConfig, Pool, RecyclingMethod, Runtime};\nuse metrics_exporter_prometheus::PrometheusBuilder;\nuse middleware::{RateLimiter, handle_rejection};\nuse once_cell::sync::Lazy;\nuse refinery::embed_migrations;\nuse std::env;\nuse std::fs;\nuse std::time::Instant;\nuse tokio_postgres::NoTls;\nuse tracing_subscriber::{EnvFilter, layer::SubscriberExt, util::SubscriberInitExt};\nuse warp::log;\nuse warp::{Filter, Reply};\n\n// Track application startup time for uptime calculation\nstatic STARTUP_TIME: Lazy<Instant> = Lazy::new(Instant::now);\n\n// Embed migrations from the migrations directory\nembed_migrations!(\"migrations\");\n\ntype DbPool = Pool;\n\n/// Read a secret from Docker secrets or fall back to environment variable\n/// Docker secrets are mounted at /run/secrets/<secret_name>\nfn read_secret(secret_name: &str, env_var: &str) -> Option<String> {\n    // Check if a custom secret file path is provided via environment variable\n    let file_env_var = format!(\"{}_FILE\", env_var);\n    if let Ok(custom_path) = env::var(&file_env_var)\n        && let Ok(content) = fs::read_to_string(&custom_path)\n    {\n        tracing::debug!(\n            secret_name = secret_name,\n            path = custom_path,\n            source = \"custom_file\",\n            \"Successfully read secret from custom file path\"\n        );\n        return Some(content.trim().to_string());\n    }\n\n    let secret_path = format!(\"/run/secrets/{}\", secret_name);\n\n    // Try Docker secret file first\n    if let Ok(content) = fs::read_to_string(&secret_path) {\n        tracing::debug!(\n            secret_name = secret_name,\n            source = \"docker_secret\",\n            \"Successfully read secret from file\"\n        );\n        return Some(content.trim().to_string());\n    }\n\n    // Try persisted auto-generated secret\n    let persisted_path = format!(\"/app/data/{}\", secret_name);\n    if let Ok(content) = fs::read_to_string(&persisted_path) {\n        tracing::debug!(\n            secret_name = secret_name,\n            source = \"persisted_file\",\n            \"Successfully read secret from persisted file\"\n        );\n        return Some(content.trim().to_string());\n    }\n\n    // Fall back to environment variable\n    if let Ok(value) = env::var(env_var)\n        && !value.trim().is_empty()\n    {\n        tracing::debug!(\n            secret_name = secret_name,\n            env_var = env_var,\n            source = \"environment\",\n            \"Successfully read secret from environment\"\n        );\n        return Some(value);\n    }\n\n    tracing::warn!(\n        secret_name = secret_name,\n        env_var = env_var,\n        \"Failed to read secret from both Docker secrets and environment\"\n    );\n    None\n}\n\n/// Get or generate JWT secret at startup\nfn get_or_generate_jwt_secret() -> anyhow::Result<String> {\n    // Try to read existing secret\n    if let Some(secret) = read_secret(\"jwt_secret\", \"JWT_SECRET\") {\n        // Validate minimum length for cryptographic security\n        if secret.len() < 32 {\n            bail!(\n                \"JWT_SECRET must be at least 32 characters for cryptographic security. \\\n                 Current length: {}. Generate a secure secret with: openssl rand -base64 32\",\n                secret.len()\n            );\n        }\n        tracing::info!(\"Using existing JWT secret\");\n        return Ok(secret);\n    }\n\n    // No secret found - auto-generate and persist one\n    tracing::warn!(\"No JWT_SECRET found. Auto-generating and persisting a random secret.\");\n\n    use rand::Rng;\n    let secret: String = rand::thread_rng()\n        .sample_iter(&rand::distributions::Alphanumeric)\n        .take(64)\n        .map(char::from)\n        .collect();\n\n    // Try to persist the secret to a file for future runs\n    let secret_path = \"/app/data/jwt_secret\";\n    if let Err(e) = fs::write(secret_path, &secret) {\n        tracing::warn!(\n            error = %e,\n            \"Failed to persist auto-generated JWT secret. Tokens will be invalidated on restart.\"\n        );\n    } else {\n        tracing::info!(\n            path = secret_path,\n            \"Auto-generated JWT secret persisted successfully\"\n        );\n    }\n\n    Ok(secret)\n}\n\n/// Validate database connection at startup - fail fast if database is unreachable\nasync fn validate_database_connection(pool: &DbPool) -> anyhow::Result<()> {\n    match pool.get().await {\n        Ok(client) => {\n            // Test query to verify database is actually working\n            match client.query_one(\"SELECT 1 as test\", &[]).await {\n                Ok(_) => {\n                    tracing::info!(\"Database connection validated successfully\");\n                    Ok(())\n                }\n                Err(e) => {\n                    bail!(\n                        \"Database connection test query failed: {}. \\\n                         Verify database is running and schema is initialized.\",\n                        e\n                    );\n                }\n            }\n        }\n        Err(e) => {\n            bail!(\n                \"Failed to acquire database connection from pool: {}. \\\n                 Check DATABASE_URL configuration and verify PostgreSQL is running.\",\n                e\n            );\n        }\n    }\n}\n\n/// Validate SMTP configuration if email service is enabled\nfn validate_smtp_config() -> anyhow::Result<()> {\n    // Check if SMTP is intended to be used\n    let smtp_enabled = env::var(\"SMTP_ENABLED\")\n        .unwrap_or_else(|_| \"false\".to_string())\n        .to_lowercase()\n        == \"true\";\n\n    if !smtp_enabled {\n        tracing::info!(\"SMTP email service disabled (SMTP_ENABLED=false or not set)\");\n        return Ok(());\n    }\n\n    // If SMTP is enabled, validate required configuration\n    let mut missing = Vec::new();\n\n    if env::var(\"SMTP_HOST\").is_err() {\n        missing.push(\"SMTP_HOST\");\n    }\n    if env::var(\"SMTP_PORT\").is_err() {\n        missing.push(\"SMTP_PORT\");\n    }\n    if env::var(\"SMTP_USERNAME\").is_err() {\n        missing.push(\"SMTP_USERNAME\");\n    }\n    if env::var(\"SMTP_PASSWORD\").is_err() {\n        missing.push(\"SMTP_PASSWORD\");\n    }\n    if env::var(\"SMTP_FROM\").is_err() {\n        missing.push(\"SMTP_FROM\");\n    }\n\n    if !missing.is_empty() {\n        bail!(\n            \"SMTP is enabled but required configuration is missing: {}. \\\n             Either set SMTP_ENABLED=false or provide all SMTP configuration variables.\",\n            missing.join(\", \")\n        );\n    }\n\n    tracing::info!(\n        smtp_host = env::var(\"SMTP_HOST\").unwrap(),\n        smtp_port = env::var(\"SMTP_PORT\").unwrap(),\n        smtp_from = env::var(\"SMTP_FROM\").unwrap(),\n        \"SMTP configuration validated successfully\"\n    );\n\n    Ok(())\n}\n\n/// Comprehensive startup configuration validation - fail fast with clear errors\nasync fn validate_environment(pool: &DbPool) -> anyhow::Result<()> {\n    tracing::info!(\"Starting environment validation...\");\n\n    // Validate JWT secret\n    tracing::debug!(\"Validating JWT secret configuration...\");\n    get_or_generate_jwt_secret()?;\n\n    // Validate database connectivity\n    tracing::debug!(\"Validating database connection...\");\n    validate_database_connection(pool).await?;\n\n    // Validate SMTP configuration if enabled\n    tracing::debug!(\"Validating SMTP configuration...\");\n    validate_smtp_config()?;\n\n    tracing::info!(\" All environment validations passed successfully\");\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    dotenvy::dotenv().ok();\n\n    // Enhanced structured logging with JSON format\n    tracing_subscriber::registry()\n        .with(\n            EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| \"humidor=info,warp=info,refinery=info\".into()),\n        )\n        .with(\n            tracing_subscriber::fmt::layer()\n                .with_target(true)\n                .with_thread_ids(true)\n                .with_line_number(true)\n                .json(),\n        )\n        .init();\n\n    tracing::info!(\n        app_name = \"humidor\",\n        version = env!(\"CARGO_PKG_VERSION\"),\n        \"Starting Humidor application\"\n    );\n\n    // Initialize Prometheus metrics exporter\n    let metrics_handle = PrometheusBuilder::new()\n        .install_recorder()\n        .expect(\"Failed to install Prometheus recorder\");\n\n    tracing::info!(\"Metrics collection initialized with Prometheus exporter\");\n\n    // Build DATABASE_URL from secrets or environment\n    let database_url = if let Ok(template) = env::var(\"DATABASE_URL_TEMPLATE\") {\n        // Using Docker secrets - read username and password from secret files\n        let db_user =\n            read_secret(\"db_user\", \"DB_USER\").unwrap_or_else(|| \"humidor_user\".to_string());\n        let db_password =\n            read_secret(\"db_password\", \"DB_PASSWORD\").unwrap_or_else(|| \"humidor_pass\".to_string());\n\n        template\n            .replace(\"{{DB_USER}}\", &db_user)\n            .replace(\"{{DB_PASSWORD}}\", &db_password)\n    } else {\n        // Fall back to DATABASE_URL environment variable or default\n        env::var(\"DATABASE_URL\").unwrap_or_else(|_| {\n            \"postgresql://humidor_user:humidor_pass@localhost:5432/humidor_db\".to_string()\n        })\n    };\n\n    // Create connection pool configuration\n    tracing::info!(\n        max_connections = 20,\n        recycling_method = \"Fast\",\n        \"Creating database connection pool\"\n    );\n\n    let mut config = Config::new();\n    config.url = Some(database_url.clone());\n    config.manager = Some(ManagerConfig {\n        recycling_method: RecyclingMethod::Fast,\n    });\n\n    // Create the pool with a maximum of 20 connections\n    let pool = config.create_pool(Some(Runtime::Tokio1), NoTls)?;\n\n    // Test the connection and run migrations\n    let mut client = pool.get().await?;\n    tracing::info!(\n        pool_status = \"connected\",\n        \"Database connection pool created successfully\"\n    );\n\n    // Run database migrations using refinery\n    tracing::info!(\"Running database migrations...\");\n    match migrations::runner().run_async(&mut **client).await {\n        Ok(report) => {\n            tracing::info!(\n                applied_migrations = report.applied_migrations().len(),\n                \"Database migrations completed successfully\"\n            );\n        }\n        Err(e) => {\n            tracing::error!(\n                error = %e,\n                \"Database migrations failed\"\n            );\n            return Err(e.into());\n        }\n    }\n\n    // Drop the migration client back to the pool\n    drop(client);\n\n    // Use the pool for all handlers\n    let db_pool = pool;\n\n    // Validate all environment configuration before accepting requests\n    // This ensures the application fails fast with clear error messages\n    // if any required configuration is missing or invalid\n    validate_environment(&db_pool).await?;\n\n    // Get server port from environment\n    let port: u16 = env::var(\"PORT\")\n        .ok()\n        .and_then(|p| p.parse().ok())\n        .unwrap_or(9898);\n\n    tracing::info!(\n        port = port,\n        environment = env::var(\"RUST_ENV\").unwrap_or_else(|_| \"development\".to_string()),\n        \"Configuring server\"\n    );\n\n    // Initialize rate limiter for authentication (5 attempts per 15 minutes)\n    let rate_limiter = RateLimiter::default();\n\n    // Spawn cleanup task to remove expired rate limit entries\n    rate_limiter.clone().spawn_cleanup_task();\n\n    tracing::info!(\n        max_attempts = 5,\n        window_minutes = 15,\n        \"Rate limiter initialized for authentication endpoints\"\n    );\n\n    // Spawn background task to clean up expired password reset tokens\n    let cleanup_pool = db_pool.clone();\n    tokio::spawn(async move {\n        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(3600)); // Run every hour\n\n        loop {\n            interval.tick().await;\n\n            match cleanup_pool.get().await {\n                Ok(client) => {\n                    // Delete tokens older than 30 minutes\n                    let result = client\n                        .execute(\n                            \"DELETE FROM password_reset_tokens WHERE created_at < NOW() - INTERVAL '30 minutes'\",\n                            &[],\n                        )\n                        .await;\n\n                    match result {\n                        Ok(deleted_count) => {\n                            if deleted_count > 0 {\n                                tracing::info!(\n                                    deleted_tokens = deleted_count,\n                                    \"Cleaned up expired password reset tokens\"\n                                );\n                            } else {\n                                tracing::debug!(\"No expired password reset tokens to clean up\");\n                            }\n                        }\n                        Err(e) => {\n                            tracing::error!(\n                                error = %e,\n                                \"Failed to clean up expired password reset tokens\"\n                            );\n                        }\n                    }\n                }\n                Err(e) => {\n                    tracing::error!(\n                        error = %e,\n                        \"Failed to get database connection for token cleanup\"\n                    );\n                }\n            }\n        }\n    });\n\n    tracing::info!(\n        cleanup_interval_minutes = 60,\n        token_expiration_minutes = 30,\n        \"Password reset token cleanup task initialized\"\n    );\n\n    // Request logging middleware with structured logging and metrics\n    fn log_requests() -> log::Log<impl Fn(log::Info) + Copy> {\n        warp::log::custom(|info| {\n            let path = info.path();\n            let method = info.method().as_str();\n            let status = info.status().as_u16();\n            let duration = info.elapsed();\n\n            tracing::info!(\n                method = %method,\n                path = %path,\n                status = %status,\n                duration_ms = %duration.as_millis(),\n                remote_addr = ?info.remote_addr(),\n                \"request completed\"\n            );\n\n            // Record metrics for this request\n            middleware::record_response_metrics(path, method, status, duration);\n        })\n    }\n\n    // Serve static files with cache headers\n    // Cache control can be configured via STATIC_CACHE_MAX_AGE env var\n    // Default: short cache for development, use STATIC_CACHE_MAX_AGE=31536000 for production\n    let cache_max_age = env::var(\"STATIC_CACHE_MAX_AGE\")\n        .ok()\n        .and_then(|v| v.parse::<u32>().ok())\n        .unwrap_or(300); // Default: 5 minutes\n\n    let cache_control = if cache_max_age > 86400 {\n        // > 1 day: use immutable for long-term caching\n        format!(\"public, max-age={}, immutable\", cache_max_age)\n    } else {\n        // <= 1 day: regular cache with revalidation\n        format!(\"public, max-age={}\", cache_max_age)\n    };\n\n    // Service worker with special header to allow root scope\n    let sw_route = warp::path!(\"static\" / \"sw.js\")\n        .and(warp::get())\n        .and(warp::fs::file(\"static/sw.js\"))\n        .with(warp::reply::with::header(\"Service-Worker-Allowed\", \"/\"))\n        .with(warp::reply::with::header(\n            \"Cache-Control\",\n            cache_control.clone(),\n        ));\n\n    let static_files = warp::path(\"static\")\n        .and(warp::fs::dir(\"static\"))\n        .with(warp::reply::with::header(\"Cache-Control\", cache_control));\n\n    // Create all API routes using route modules\n    let auth_routes = routes::create_auth_routes(db_pool.clone(), rate_limiter.clone()).boxed();\n    let admin_routes = routes::create_admin_routes(db_pool.clone()).boxed();\n    let user_routes = routes::create_user_routes(db_pool.clone()).boxed();\n    let cigar_routes = routes::create_cigar_routes(db_pool.clone()).boxed();\n    let organizer_routes = routes::create_organizer_routes(db_pool.clone()).boxed();\n    let humidor_routes = routes::create_humidor_routes(db_pool.clone()).boxed();\n    let favorite_routes = routes::create_favorite_routes(db_pool.clone()).boxed();\n    let backup_routes = routes::create_backup_routes(db_pool.clone()).boxed();\n    let public_share_routes = routes::create_public_share_routes(db_pool.clone()).boxed();\n\n    // Combine all API routes\n    let api = auth_routes\n        .or(admin_routes)\n        .or(user_routes)\n        .or(cigar_routes)\n        .or(organizer_routes)\n        .or(humidor_routes)\n        .or(favorite_routes)\n        .or(backup_routes)\n        .or(public_share_routes); // No auth required for public shares\n\n    // Health check endpoint (no auth required)\n    let health = warp::path(\"health\")\n        .and(warp::get())\n        .and(routes::helpers::with_db(db_pool.clone()))\n        .and_then(health_check);\n\n    // Metrics endpoint (no auth required) - Prometheus scraping\n    let metrics_route = warp::path(\"metrics\").and(warp::get()).map(move || {\n        let metrics = metrics_handle.render();\n        warp::reply::with_header(metrics, \"Content-Type\", \"text/plain; version=0.0.4\")\n    });\n\n    // Root route\n    let root = warp::path::end().and(warp::get()).and_then(serve_index);\n\n    // Setup route\n    let setup = warp::path(\"setup.html\")\n        .and(warp::get())\n        .and_then(serve_setup);\n\n    // Login route\n    let login = warp::path(\"login.html\")\n        .and(warp::get())\n        .and_then(serve_login);\n\n    // Password reset page routes\n    let forgot_password_page = warp::path(\"forgot-password.html\")\n        .and(warp::get())\n        .and_then(serve_forgot_password);\n\n    let reset_password_page = warp::path(\"reset-password.html\")\n        .and(warp::get())\n        .and_then(serve_reset_password);\n\n    // Public shared humidor page (no auth)\n    let shared_humidor_page = warp::path(\"shared\")\n        .and(warp::path(\"humidors\"))\n        .and(warp::path::param::<String>()) // token UUID\n        .and(warp::path::end())\n        .and(warp::get())\n        .and_then(serve_shared_humidor);\n\n    // Configure CORS with smart defaults\n    //\n    // Auto-detection logic:\n    //   - No CORS_MODE set  permissive mode (works with any IP/domain)\n    //   - CORS_MODE=strict  requires ALLOWED_ORIGINS to be set\n    //   - CORS_MODE=permissive  explicitly allows all origins\n    //\n    // This makes the app \"just work\" for self-hosted environments while\n    // still supporting strict mode for production deployments.\n\n    let cors_mode = env::var(\"CORS_MODE\")\n        .unwrap_or_else(|_| \"permissive\".to_string())\n        .to_lowercase();\n\n    let cors = match cors_mode.as_str() {\n        \"permissive\" => {\n            tracing::info!(\n                \"CORS: Permissive mode - allowing all origins. \\\n                 Perfect for self-hosted environments with dynamic IPs.\"\n            );\n\n            warp::cors()\n                .allow_any_origin()\n                .allow_headers(vec![\"content-type\", \"authorization\"])\n                .allow_methods(vec![\"GET\", \"POST\", \"PUT\", \"DELETE\"])\n                .allow_credentials(true)\n        }\n\n        \"strict\" => {\n            let raw_origins = env::var(\"ALLOWED_ORIGINS\").expect(\n                \"CORS_MODE=strict requires ALLOWED_ORIGINS environment variable. \\\n                     Example: ALLOWED_ORIGINS=https://yourdomain.com,https://www.yourdomain.com \\\n                     Or use CORS_MODE=permissive (default) to allow any origin.\",\n            );\n\n            // Validate and filter CORS origins\n            let allowed_origins: Vec<String> = raw_origins\n                .split(',')\n                .map(|s| s.trim().to_string())\n                .filter(|s| !s.is_empty())\n                .filter_map(|origin| {\n                    if origin.starts_with(\"http://\") || origin.starts_with(\"https://\") {\n                        // Basic URL validation - ensure no path, query, or fragment\n                        if origin.contains('?')\n                            || origin.contains('#')\n                            || origin.matches('/').count() > 2\n                        {\n                            tracing::error!(\n                                origin = %origin,\n                                \"Invalid CORS origin: must not contain path, query, or fragment. \\\n                                 Expected format: http(s)://domain:port\"\n                            );\n                            None\n                        } else {\n                            Some(origin)\n                        }\n                    } else {\n                        tracing::error!(\n                            origin = %origin,\n                            \"Invalid CORS origin: must start with http:// or https://\"\n                        );\n                        None\n                    }\n                })\n                .collect();\n\n            if allowed_origins.is_empty() {\n                panic!(\n                    \"CORS_MODE=strict but no valid origins in ALLOWED_ORIGINS. \\\n                     Set valid origins or use CORS_MODE=permissive.\"\n                );\n            }\n\n            tracing::info!(\n                mode = \"strict\",\n                allowed_origins = ?allowed_origins,\n                \"CORS: Strict mode - only allowing specified origins\"\n            );\n\n            warp::cors()\n                .allow_origins(allowed_origins.iter().map(|s| s.as_str()))\n                .allow_headers(vec![\"content-type\", \"authorization\"])\n                .allow_methods(vec![\"GET\", \"POST\", \"PUT\", \"DELETE\"])\n                .allow_credentials(true)\n        }\n\n        mode => {\n            tracing::warn!(\n                mode = %mode,\n                \"Unknown CORS_MODE '{}'. Defaulting to permissive mode.\", mode\n            );\n\n            warp::cors()\n                .allow_any_origin()\n                .allow_headers(vec![\"content-type\", \"authorization\"])\n                .allow_methods(vec![\"GET\", \"POST\", \"PUT\", \"DELETE\"])\n                .allow_credentials(true)\n        }\n    };\n\n    let routes = health\n        .or(metrics_route)\n        .or(root)\n        .or(setup)\n        .or(login)\n        .or(forgot_password_page)\n        .or(reset_password_page)\n        .or(shared_humidor_page)\n        .or(sw_route)  // Service worker route must come before static_files\n        .or(static_files)\n        .or(api)\n        .with(log_requests())\n        .recover(handle_rejection)\n        .with(cors)\n        .map(|reply| warp::reply::with_header(reply, \"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains; preload\"))\n        .map(|reply| warp::reply::with_header(reply, \"X-Content-Type-Options\", \"nosniff\"))\n        .map(|reply| warp::reply::with_header(reply, \"X-Frame-Options\", \"DENY\"))\n        .map(|reply| warp::reply::with_header(reply, \"X-XSS-Protection\", \"1; mode=block\"))\n        // CSP that allows browser extensions (like Bitwarden) while maintaining security\n        // Extensions use chrome-extension://, moz-extension://, or safari-web-extension:// schemes\n        .map(|reply| warp::reply::with_header(reply, \"Content-Security-Policy\", \"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdn.jsdelivr.net; img-src 'self' data: https: chrome-extension: moz-extension: safari-web-extension:; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net; connect-src 'self' https://fonts.googleapis.com https://fonts.gstatic.com https://cdn.jsdelivr.net; frame-ancestors 'none'\"))\n        .map(|reply| warp::reply::with_header(reply, \"Referrer-Policy\", \"no-referrer-when-downgrade\"))\n        .map(|reply| warp::reply::with_header(reply, \"Permissions-Policy\", \"geolocation=(), microphone=(), camera=()\"));\n\n    let port = env::var(\"PORT\")\n        .unwrap_or_else(|_| \"3000\".to_string())\n        .parse::<u16>()\n        .unwrap_or(3000);\n\n    tracing::info!(\n        addr = %format!(\"0.0.0.0:{}\", port),\n        port = port,\n        url = %format!(\"http://127.0.0.1:{}\", port),\n        \"Server started successfully, listening for connections\"\n    );\n\n    warp::serve(routes).run(([0, 0, 0, 0], port)).await;\n\n    Ok(())\n}\n\nasync fn serve_index() -> Result<impl Reply, warp::Rejection> {\n    match tokio::fs::read_to_string(\"static/index.html\").await {\n        Ok(content) => {\n            // Inject setup check script into the HTML\n            let setup_script = r#\"\n<script>\n// Check if setup is needed and redirect to setup page\n// Skip check if user is already authenticated\nconst hasToken = localStorage.getItem('humidor_token');\nif (!hasToken) {\n    fetch('/api/v1/setup/status')\n        .then(response => response.json())\n        .then(data => {\n            if (data.needs_setup) {\n                // Only redirect if we're not already on the setup page\n                if (!window.location.pathname.includes('setup.html')) {\n                    window.location.href = '/setup.html';\n                }\n            }\n        })\n        .catch(error => {\n            console.error('Failed to check setup status:', error);\n        });\n}\n</script>\n\"#;\n\n            // Insert the script before the closing </body> tag\n            let modified_content = content.replace(\"</body>\", &format!(\"{}</body>\", setup_script));\n            Ok(warp::reply::html(modified_content))\n        }\n        Err(_) => {\n            // Fallback content with setup check\n            let fallback_html = r#\"\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Humidor Inventory</title>\n</head>\n<body>\n    <h1>Humidor Inventory</h1>\n    <p>Welcome to your cigar inventory system!</p>\n    <script>\n    // Check if user is authenticated before setup redirect\n    const hasToken = localStorage.getItem('humidor_token');\n    if (!hasToken) {\n        fetch('/api/v1/setup/status')\n            .then(response => response.json())\n            .then(data => {\n                if (data.needs_setup) {\n                    window.location.href = '/setup.html';\n                }\n            })\n            .catch(error => {\n                console.error('Failed to check setup status:', error);\n            });\n    }\n    </script>\n</body>\n</html>\n\"#;\n            Ok(warp::reply::html(fallback_html.to_string()))\n        }\n    }\n}\n\nasync fn serve_setup() -> Result<impl Reply, warp::Rejection> {\n    match tokio::fs::read_to_string(\"static/setup.html\").await {\n        Ok(content) => Ok(warp::reply::html(content).into_response()),\n        Err(_) => Ok(warp::reply::with_status(\n            warp::reply::html(\"<h1>Setup Not Found</h1>\".to_string()),\n            warp::http::StatusCode::NOT_FOUND,\n        )\n        .into_response()),\n    }\n}\n\nasync fn serve_login() -> Result<impl Reply, warp::Rejection> {\n    match tokio::fs::read_to_string(\"static/login.html\").await {\n        Ok(content) => Ok(warp::reply::html(content).into_response()),\n        Err(_) => Ok(warp::reply::with_status(\n            warp::reply::html(\"<h1>Login Not Found</h1>\".to_string()),\n            warp::http::StatusCode::NOT_FOUND,\n        )\n        .into_response()),\n    }\n}\n\nasync fn serve_forgot_password() -> Result<impl Reply, warp::Rejection> {\n    match tokio::fs::read_to_string(\"static/forgot-password.html\").await {\n        Ok(content) => Ok(warp::reply::html(content).into_response()),\n        Err(_) => Ok(warp::reply::with_status(\n            warp::reply::html(\"<h1>Forgot Password Not Found</h1>\".to_string()),\n            warp::http::StatusCode::NOT_FOUND,\n        )\n        .into_response()),\n    }\n}\n\nasync fn serve_reset_password() -> Result<impl Reply, warp::Rejection> {\n    match tokio::fs::read_to_string(\"static/reset-password.html\").await {\n        Ok(content) => Ok(warp::reply::html(content).into_response()),\n        Err(_) => Ok(warp::reply::with_status(\n            warp::reply::html(\"<h1>Reset Password Not Found</h1>\".to_string()),\n            warp::http::StatusCode::NOT_FOUND,\n        )\n        .into_response()),\n    }\n}\n\nasync fn serve_shared_humidor(_token: String) -> Result<impl Reply, warp::Rejection> {\n    // Serve the main index.html for public shares\n    // The app.js will detect the /shared/humidors/:token URL and load public data\n    match tokio::fs::read_to_string(\"static/index.html\").await {\n        Ok(content) => Ok(warp::reply::html(content).into_response()),\n        Err(_) => Ok(warp::reply::with_status(\n            warp::reply::html(\"<h1>Application Error</h1>\".to_string()),\n            warp::http::StatusCode::INTERNAL_SERVER_ERROR,\n        )\n        .into_response()),\n    }\n}\n\n/// Enhanced health check endpoint with database connectivity verification\nasync fn health_check(pool: DbPool) -> Result<impl Reply, warp::Rejection> {\n    use chrono::Utc;\n    use std::time::Duration;\n\n    let version = env!(\"CARGO_PKG_VERSION\");\n    let uptime = STARTUP_TIME.elapsed();\n    let timestamp = Utc::now();\n\n    // Measure database response time\n    let db_check_start = Instant::now();\n    let db_result = tokio::time::timeout(Duration::from_secs(5), async {\n        match pool.get().await {\n            Ok(client) => {\n                // Ping database with a simple query\n                match client.query_one(\"SELECT 1 as health_check\", &[]).await {\n                    Ok(_) => Ok(()),\n                    Err(e) => {\n                        tracing::error!(error = %e, \"Database query failed during health check\");\n                        Err(())\n                    }\n                }\n            }\n            Err(e) => {\n                tracing::error!(error = %e, \"Failed to get database connection from pool\");\n                Err(())\n            }\n        }\n    })\n    .await;\n\n    let db_response_time_ms = db_check_start.elapsed().as_millis() as u64;\n\n    // Get pool statistics\n    let pool_status = pool.status();\n    let pool_stats = serde_json::json!({\n        \"size\": pool_status.size,\n        \"available\": pool_status.available,\n        \"max_size\": pool_status.max_size,\n    });\n\n    // Record database pool metrics\n    middleware::metrics::record_db_pool_metrics(\n        pool_status.size,\n        pool_status.available,\n        pool_status.max_size,\n    );\n\n    // Determine overall health status\n    let (status, http_status_code, db_status) = match db_result {\n        Ok(Ok(())) => (\"healthy\", warp::http::StatusCode::OK, \"connected\"),\n        Ok(Err(_)) => (\n            \"unhealthy\",\n            warp::http::StatusCode::SERVICE_UNAVAILABLE,\n            \"query_failed\",\n        ),\n        Err(_) => (\n            \"unhealthy\",\n            warp::http::StatusCode::SERVICE_UNAVAILABLE,\n            \"timeout\",\n        ),\n    };\n\n    let response = serde_json::json!({\n        \"status\": status,\n        \"version\": version,\n        \"service\": \"humidor\",\n        \"timestamp\": timestamp.to_rfc3339(),\n        \"uptime_seconds\": uptime.as_secs(),\n        \"checks\": {\n            \"database\": {\n                \"status\": db_status,\n                \"response_time_ms\": db_response_time_ms,\n                \"connection_pool\": pool_stats\n            }\n        }\n    });\n\n    Ok(warp::reply::with_status(\n        warp::reply::json(&response),\n        http_status_code,\n    ))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","middleware","auth.rs"],"content":"use crate::DbPool;\nuse crate::errors::AppError;\nuse crate::handlers::auth::verify_token;\nuse crate::models::UserResponse;\nuse std::convert::Infallible;\nuse uuid::Uuid;\nuse warp::{Filter, Rejection, reject};\n\n// Authentication context that gets passed to handlers\n#[derive(Debug, Clone)]\npub struct AuthContext {\n    pub user_id: Uuid,\n    #[allow(dead_code)]\n    pub username: String,\n    pub user: Option<UserResponse>,\n}\n\nimpl AuthContext {\n    pub fn new(user_id: Uuid, username: String) -> Self {\n        Self {\n            user_id,\n            username,\n            user: None,\n        }\n    }\n\n    pub fn with_user(mut self, user: UserResponse) -> Self {\n        self.user = Some(user);\n        self\n    }\n\n    /// Check if the current user is an admin\n    pub fn is_admin(&self) -> bool {\n        self.user.as_ref().map(|u| u.is_admin).unwrap_or(false)\n    }\n\n    /// Get a reference to the user data if available\n    #[allow(dead_code)]\n    pub fn get_user(&self) -> Result<&UserResponse, AppError> {\n        self.user.as_ref().ok_or(AppError::Unauthorized)\n    }\n}\n\n// Extract token from Authorization header or cookie\nfn extract_token_from_headers(headers: &warp::http::HeaderMap) -> Option<String> {\n    // First, try Authorization header\n    if let Some(auth_header) = headers.get(warp::http::header::AUTHORIZATION)\n        && let Ok(auth_str) = auth_header.to_str()\n        && let Some(stripped) = auth_str.strip_prefix(\"Bearer \")\n    {\n        return Some(stripped.to_string());\n    }\n\n    // Then try cookie\n    if let Some(cookie_header) = headers.get(warp::http::header::COOKIE)\n        && let Ok(cookie_str) = cookie_header.to_str()\n    {\n        for cookie in cookie_str.split(';') {\n            let cookie = cookie.trim();\n            if let Some(token) = cookie.strip_prefix(\"auth_token=\") {\n                return Some(token.to_string());\n            }\n        }\n    }\n\n    None\n}\n\n// Middleware that extracts and validates JWT token\npub fn with_auth() -> impl Filter<Extract = (AuthContext,), Error = Rejection> + Clone {\n    warp::header::headers_cloned().and_then(|headers: warp::http::HeaderMap| async move {\n        let token = extract_token_from_headers(&headers)\n            .ok_or_else(|| reject::custom(AppError::Unauthorized))?;\n\n        let claims = verify_token(&token).map_err(|_| reject::custom(AppError::Unauthorized))?;\n\n        let user_id =\n            Uuid::parse_str(&claims.sub).map_err(|_| reject::custom(AppError::Unauthorized))?;\n\n        Ok::<AuthContext, Rejection>(AuthContext::new(user_id, claims.username))\n    })\n}\n\n// Middleware that includes user data from database\npub fn with_current_user(\n    pool: DbPool,\n) -> impl Filter<Extract = (AuthContext,), Error = Rejection> + Clone {\n    with_auth()\n        .and(warp::any().map(move || pool.clone()))\n        .and_then(|auth_ctx: AuthContext, pool: DbPool| async move {\n            // Get connection from pool\n            let db = match pool.get().await {\n                Ok(conn) => conn,\n                Err(e) => {\n                    tracing::error!(\n                        error = %e,\n                        user_id = %auth_ctx.user_id,\n                        \"Failed to get database connection in auth middleware\"\n                    );\n                    return Err(reject::custom(AppError::Unauthorized));\n                }\n            };\n\n            // Fetch user data from database\n            let query = \"\n                SELECT id, username, email, full_name, is_admin, is_active, created_at, updated_at\n                FROM users \n                WHERE id = $1 AND is_active = true\n            \";\n\n            match db.query_opt(query, &[&auth_ctx.user_id]).await {\n                Ok(Some(row)) => {\n                    let user = UserResponse {\n                        id: row.get(\"id\"),\n                        username: row.get(\"username\"),\n                        email: row.get(\"email\"),\n                        full_name: row.get(\"full_name\"),\n                        is_admin: row.get(\"is_admin\"),\n                        is_active: row.get(\"is_active\"),\n                        created_at: row.get(\"created_at\"),\n                        updated_at: row.get(\"updated_at\"),\n                    };\n\n                    Ok(auth_ctx.with_user(user))\n                }\n                Ok(None) => Err(reject::custom(AppError::Unauthorized)),\n                Err(e) => {\n                    tracing::error!(\n                        error = %e,\n                        user_id = %auth_ctx.user_id,\n                        \"Database error in auth middleware\"\n                    );\n                    Err(reject::custom(AppError::Unauthorized))\n                }\n            }\n        })\n}\n\n// Optional auth that doesn't fail if no token is present\n#[allow(dead_code)]\npub fn with_optional_auth()\n-> impl Filter<Extract = (Option<AuthContext>,), Error = Infallible> + Clone {\n    warp::header::headers_cloned().map(|headers: warp::http::HeaderMap| {\n        let token = match extract_token_from_headers(&headers) {\n            Some(token) => token,\n            None => return None,\n        };\n\n        match verify_token(&token) {\n            Ok(claims) => match Uuid::parse_str(&claims.sub) {\n                Ok(user_id) => Some(AuthContext::new(user_id, claims.username)),\n                Err(_) => None,\n            },\n            Err(_) => None,\n        }\n    })\n}\n\n// Combined middleware for admin routes: auth + user data + admin check\n// Use this for endpoints that require admin privileges\npub fn with_admin(\n    pool: DbPool,\n) -> impl Filter<Extract = (AuthContext,), Error = Rejection> + Clone {\n    with_current_user(pool).and_then(|auth_ctx: AuthContext| async move {\n        if auth_ctx.is_admin() {\n            Ok(auth_ctx)\n        } else {\n            tracing::warn!(\n                user_id = %auth_ctx.user_id,\n                username = %auth_ctx.username,\n                \"Non-admin user attempted to access admin endpoint\"\n            );\n            Err(reject::custom(AppError::Forbidden(\n                \"Admin privileges required\".to_string(),\n            )))\n        }\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","middleware","metrics.rs"],"content":"/// Record HTTP response metrics\npub fn record_response_metrics(\n    path: &str,\n    method: &str,\n    status: u16,\n    duration: std::time::Duration,\n) {\n    // Record response time\n    metrics::histogram!(\n        \"http_request_duration_seconds\",\n        \"method\" => method.to_string(),\n        \"endpoint\" => path.to_string(),\n        \"status\" => status.to_string()\n    )\n    .record(duration.as_secs_f64());\n\n    // Record status code distribution\n    metrics::counter!(\n        \"http_responses_total\",\n        \"method\" => method.to_string(),\n        \"endpoint\" => path.to_string(),\n        \"status\" => status.to_string()\n    )\n    .increment(1);\n\n    // Record error count separately\n    if status >= 400 {\n        metrics::counter!(\n            \"http_errors_total\",\n            \"method\" => method.to_string(),\n            \"endpoint\" => path.to_string(),\n            \"status\" => status.to_string()\n        )\n        .increment(1);\n    }\n}\n\n/// Record database pool metrics\npub fn record_db_pool_metrics(size: usize, available: usize, max_size: usize) {\n    metrics::gauge!(\"db_pool_connections_active\").set((size - available) as f64);\n    metrics::gauge!(\"db_pool_connections_idle\").set(available as f64);\n    metrics::gauge!(\"db_pool_connections_max\").set(max_size as f64);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","middleware","mod.rs"],"content":"pub mod auth;\npub mod metrics;\npub mod rate_limiter;\n\npub use auth::{AuthContext, with_current_user};\npub use metrics::record_response_metrics;\npub use rate_limiter::RateLimiter;\n\n// Re-export the error handler from errors module\npub use crate::errors::handle_rejection;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","middleware","rate_limiter.rs"],"content":"use std::collections::HashMap;\nuse std::net::IpAddr;\nuse std::sync::Arc;\nuse std::time::{Duration, SystemTime};\nuse tokio::sync::RwLock;\n\n/// Rate limiter for authentication attempts\n/// Uses a sliding window algorithm to track failed login attempts per IP address\n#[derive(Clone)]\npub struct RateLimiter {\n    /// Map of IP address to list of attempt timestamps\n    attempts: Arc<RwLock<HashMap<IpAddr, Vec<SystemTime>>>>,\n    /// Maximum number of failed attempts allowed within the time window\n    max_attempts: usize,\n    /// Time window in seconds for tracking attempts\n    window_secs: u64,\n}\n\nimpl RateLimiter {\n    /// Create a new rate limiter with the given configuration\n    /// Default: 5 attempts per 15 minutes (900 seconds)\n    pub fn new(max_attempts: usize, window_secs: u64) -> Self {\n        Self {\n            attempts: Arc::new(RwLock::new(HashMap::new())),\n            max_attempts,\n            window_secs,\n        }\n    }\n}\n\nimpl Default for RateLimiter {\n    fn default() -> Self {\n        Self::new(5, 900)\n    }\n}\n\nimpl RateLimiter {\n    /// Check if an IP address is currently rate limited\n    /// Returns true if the IP has exceeded the rate limit\n    pub async fn is_rate_limited(&self, ip: IpAddr) -> bool {\n        let mut attempts = self.attempts.write().await;\n\n        // Get or create the attempt list for this IP\n        let ip_attempts = attempts.entry(ip).or_insert_with(Vec::new);\n\n        // Remove expired attempts (outside the time window)\n        let cutoff_time = SystemTime::now() - Duration::from_secs(self.window_secs);\n        ip_attempts.retain(|&attempt_time| attempt_time > cutoff_time);\n\n        // Check if we've exceeded the limit\n        ip_attempts.len() >= self.max_attempts\n    }\n\n    /// Record a failed login attempt for an IP address\n    pub async fn record_attempt(&self, ip: IpAddr) {\n        let mut attempts = self.attempts.write().await;\n\n        // Get or create the attempt list for this IP\n        let ip_attempts = attempts.entry(ip).or_insert_with(Vec::new);\n\n        // Add the current attempt\n        ip_attempts.push(SystemTime::now());\n\n        tracing::debug!(\n            ip = %ip,\n            attempt_count = ip_attempts.len(),\n            \"Recorded failed login attempt\"\n        );\n    }\n\n    /// Clear rate limit records for an IP address (called on successful login)\n    pub async fn clear_attempts(&self, ip: IpAddr) {\n        let mut attempts = self.attempts.write().await;\n\n        if attempts.remove(&ip).is_some() {\n            tracing::debug!(ip = %ip, \"Cleared rate limit records after successful login\");\n        }\n    }\n\n    /// Cleanup task to periodically remove expired entries\n    /// Should be spawned as a background task\n    pub async fn cleanup_expired(&self) {\n        let mut attempts = self.attempts.write().await;\n        let cutoff_time = SystemTime::now() - Duration::from_secs(self.window_secs);\n\n        // Remove IPs with no recent attempts\n        attempts.retain(|_, ip_attempts| {\n            ip_attempts.retain(|&attempt_time| attempt_time > cutoff_time);\n            !ip_attempts.is_empty()\n        });\n\n        tracing::debug!(\n            remaining_ips = attempts.len(),\n            \"Cleaned up expired rate limit entries\"\n        );\n    }\n\n    /// Spawn a background cleanup task that runs periodically\n    /// Cleans up expired entries every 5 minutes\n    pub fn spawn_cleanup_task(self) {\n        tokio::spawn(async move {\n            let mut interval = tokio::time::interval(Duration::from_secs(300)); // 5 minutes\n\n            loop {\n                interval.tick().await;\n                self.cleanup_expired().await;\n            }\n        });\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::net::{IpAddr, Ipv4Addr};\n\n    #[tokio::test]\n    async fn test_rate_limiter_basic() {\n        let limiter = RateLimiter::new(3, 10); // 3 attempts in 10 seconds\n        let ip = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n\n        // Should not be limited initially\n        assert!(!limiter.is_rate_limited(ip).await);\n\n        // Record 3 attempts\n        for _ in 0..3 {\n            limiter.record_attempt(ip).await;\n        }\n\n        // Should now be limited\n        assert!(limiter.is_rate_limited(ip).await);\n\n        // Clear and should not be limited\n        limiter.clear_attempts(ip).await;\n        assert!(!limiter.is_rate_limited(ip).await);\n    }\n\n    #[tokio::test]\n    async fn test_rate_limiter_expiry() {\n        let limiter = RateLimiter::new(2, 1); // 2 attempts in 1 second\n        let ip = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n\n        // Record 2 attempts\n        limiter.record_attempt(ip).await;\n        limiter.record_attempt(ip).await;\n\n        // Should be limited\n        assert!(limiter.is_rate_limited(ip).await);\n\n        // Wait for expiry\n        tokio::time::sleep(Duration::from_secs(2)).await;\n\n        // Should not be limited anymore\n        assert!(!limiter.is_rate_limited(ip).await);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","brand.rs"],"content":"use crate::validation::{Validate, ValidationResult, validate_length, validate_url};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Brand {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub name: String,\n    pub description: Option<String>,\n    pub country: Option<String>,\n    pub website: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct CreateBrand {\n    pub name: String,\n    pub description: Option<String>,\n    pub country: Option<String>,\n    pub website: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct UpdateBrand {\n    pub name: Option<String>,\n    pub description: Option<String>,\n    pub country: Option<String>,\n    pub website: Option<String>,\n}\n\nimpl Validate for CreateBrand {\n    fn validate(&self) -> ValidationResult<()> {\n        validate_length(&self.name, \"Name\", 1, 100)?;\n\n        if let Some(desc) = &self.description {\n            validate_length(desc, \"Description\", 0, 500)?;\n        }\n        if let Some(country) = &self.country {\n            validate_length(country, \"Country\", 1, 100)?;\n        }\n        if let Some(website) = &self.website {\n            validate_url(website)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl Validate for UpdateBrand {\n    fn validate(&self) -> ValidationResult<()> {\n        if let Some(name) = &self.name {\n            validate_length(name, \"Name\", 1, 100)?;\n        }\n        if let Some(desc) = &self.description {\n            validate_length(desc, \"Description\", 0, 500)?;\n        }\n        if let Some(country) = &self.country {\n            validate_length(country, \"Country\", 1, 100)?;\n        }\n        if let Some(website) = &self.website {\n            validate_url(website)?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","cigar.rs"],"content":"use crate::validation::{\r\n    Validate, ValidationResult, validate_length, validate_non_negative, validate_positive,\r\n};\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\nuse uuid::Uuid;\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Cigar {\r\n    pub id: Uuid,\r\n    pub humidor_id: Option<Uuid>,\r\n    pub brand_id: Option<Uuid>,\r\n    pub name: String,\r\n    pub size_id: Option<Uuid>,\r\n    pub strength_id: Option<Uuid>,\r\n    pub origin_id: Option<Uuid>,\r\n    pub wrapper: Option<String>,\r\n    pub binder: Option<String>,\r\n    pub filler: Option<String>,\r\n    pub price: Option<f64>,\r\n    pub purchase_date: Option<DateTime<Utc>>,\r\n    pub notes: Option<String>,\r\n    pub quantity: i32,\r\n    pub ring_gauge_id: Option<Uuid>,\r\n    pub length: Option<f64>,\r\n    pub image_url: Option<String>,\r\n    pub retail_link: Option<String>,\r\n    pub is_active: bool,\r\n    pub created_at: DateTime<Utc>,\r\n    pub updated_at: DateTime<Utc>,\r\n}\r\n\r\n/// Enhanced cigar response with organizer names included for display\r\n/// This avoids the need for the frontend to look up organizers separately,\r\n/// which is important for shared humidors where the viewing user may not have\r\n/// the same organizers as the humidor owner\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct CigarWithNames {\r\n    #[serde(flatten)]\r\n    pub cigar: Cigar,\r\n    pub brand_name: Option<String>,\r\n    pub size_name: Option<String>,\r\n    pub strength_name: Option<String>,\r\n    pub origin_name: Option<String>,\r\n    pub ring_gauge: Option<i32>,\r\n}\r\n\r\n#[derive(Debug, Deserialize)]\r\npub struct CreateCigar {\r\n    pub brand_id: Option<Uuid>,\r\n    pub name: String,\r\n    pub size_id: Option<Uuid>,\r\n    pub strength_id: Option<Uuid>,\r\n    pub origin_id: Option<Uuid>,\r\n    pub wrapper: Option<String>,\r\n    pub binder: Option<String>,\r\n    pub filler: Option<String>,\r\n    pub price: Option<f64>,\r\n    pub purchase_date: Option<DateTime<Utc>>,\r\n    pub notes: Option<String>,\r\n    pub quantity: i32,\r\n    pub ring_gauge_id: Option<Uuid>,\r\n    pub length: Option<f64>,\r\n    pub humidor_id: Option<Uuid>,\r\n    pub image_url: Option<String>,\r\n    pub retail_link: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Deserialize)]\r\npub struct UpdateCigar {\r\n    pub brand_id: Option<Uuid>,\r\n    pub name: Option<String>,\r\n    pub size_id: Option<Uuid>,\r\n    pub strength_id: Option<Uuid>,\r\n    pub origin_id: Option<Uuid>,\r\n    pub wrapper: Option<String>,\r\n    pub binder: Option<String>,\r\n    pub filler: Option<String>,\r\n    pub price: Option<f64>,\r\n    pub purchase_date: Option<DateTime<Utc>>,\r\n    pub notes: Option<String>,\r\n    pub quantity: Option<i32>,\r\n    pub ring_gauge_id: Option<Uuid>,\r\n    pub length: Option<f64>,\r\n    pub humidor_id: Option<Uuid>,\r\n    pub image_url: Option<String>,\r\n    pub retail_link: Option<String>,\r\n}\r\n\r\nimpl Validate for CreateCigar {\r\n    fn validate(&self) -> ValidationResult<()> {\r\n        validate_length(&self.name, \"Name\", 1, 100)?;\r\n        validate_positive(self.quantity, \"Quantity\")?;\r\n\r\n        if let Some(wrapper) = &self.wrapper {\r\n            validate_length(wrapper, \"Wrapper\", 1, 100)?;\r\n        }\r\n        if let Some(binder) = &self.binder {\r\n            validate_length(binder, \"Binder\", 1, 100)?;\r\n        }\r\n        if let Some(filler) = &self.filler {\r\n            validate_length(filler, \"Filler\", 1, 100)?;\r\n        }\r\n        if let Some(notes) = &self.notes {\r\n            validate_length(notes, \"Notes\", 0, 1500)?;\r\n        }\r\n        // UUIDs don't need string length validation\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl Validate for UpdateCigar {\r\n    fn validate(&self) -> ValidationResult<()> {\r\n        if let Some(name) = &self.name {\r\n            validate_length(name, \"Name\", 1, 100)?;\r\n        }\r\n        if let Some(quantity) = self.quantity {\r\n            validate_non_negative(quantity, \"Quantity\")?;\r\n        }\r\n        // UUIDs don't need string length validation\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize)]\r\npub struct RecommendCigarResponse {\r\n    /// The recommended cigar (None if no cigars available)\r\n    pub cigar: Option<CigarWithNames>,\r\n    /// Total count of eligible cigars\r\n    pub eligible_count: i64,\r\n    /// Context message for the user\r\n    pub message: String,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","humidor.rs"],"content":"use crate::validation::{\n    Validate, ValidationResult, validate_length, validate_positive, validate_required,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Humidor {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub name: String,\n    pub description: Option<String>,\n    pub capacity: Option<i32>,\n    pub target_humidity: Option<i32>,\n    pub location: Option<String>,\n    pub image_url: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub is_owner: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub permission_level: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct CreateHumidorRequest {\n    pub name: String,\n    pub description: Option<String>,\n    pub capacity: Option<i32>,\n    pub target_humidity: Option<i32>,\n    pub location: Option<String>,\n    pub image_url: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct UpdateHumidorRequest {\n    pub name: Option<String>,\n    pub description: Option<String>,\n    pub capacity: Option<i32>,\n    pub target_humidity: Option<i32>,\n    pub location: Option<String>,\n    pub image_url: Option<String>,\n}\n\nimpl Validate for CreateHumidorRequest {\n    fn validate(&self) -> ValidationResult<()> {\n        validate_required(&self.name, \"name\")?;\n        validate_length(&self.name, \"name\", 1, 100)?;\n\n        if let Some(desc) = &self.description\n            && !desc.is_empty()\n        {\n            validate_length(desc, \"description\", 1, 500)?;\n        }\n\n        if let Some(capacity) = self.capacity {\n            validate_positive(capacity, \"capacity\")?;\n            if capacity > 10000 {\n                return Err(crate::errors::AppError::ValidationError(\n                    \"capacity must not exceed 10000\".to_string(),\n                ));\n            }\n        }\n\n        if let Some(humidity) = self.target_humidity\n            && !(50..=85).contains(&humidity)\n        {\n            return Err(crate::errors::AppError::ValidationError(\n                \"target_humidity must be between 50 and 85\".to_string(),\n            ));\n        }\n\n        if let Some(location) = &self.location\n            && !location.is_empty()\n        {\n            validate_length(location, \"location\", 1, 200)?;\n        }\n\n        if let Some(image_url) = &self.image_url\n            && !image_url.is_empty()\n        {\n            // Allow up to 20MB of base64 data (~26.7 million chars)\n            // Actual limit enforced by Warp body size (10MB JSON payload)\n            validate_length(image_url, \"image_url\", 1, 30_000_000)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl Validate for UpdateHumidorRequest {\n    fn validate(&self) -> ValidationResult<()> {\n        if let Some(name) = &self.name {\n            validate_required(name, \"name\")?;\n            validate_length(name, \"name\", 1, 100)?;\n        }\n\n        if let Some(desc) = &self.description\n            && !desc.is_empty()\n        {\n            validate_length(desc, \"description\", 1, 500)?;\n        }\n\n        if let Some(capacity) = self.capacity {\n            validate_positive(capacity, \"capacity\")?;\n            if capacity > 10000 {\n                return Err(crate::errors::AppError::ValidationError(\n                    \"capacity must not exceed 10000\".to_string(),\n                ));\n            }\n        }\n\n        if let Some(humidity) = self.target_humidity\n            && !(50..=85).contains(&humidity)\n        {\n            return Err(crate::errors::AppError::ValidationError(\n                \"target_humidity must be between 50 and 85\".to_string(),\n            ));\n        }\n\n        if let Some(location) = &self.location\n            && !location.is_empty()\n        {\n            validate_length(location, \"location\", 1, 200)?;\n        }\n\n        if let Some(image_url) = &self.image_url\n            && !image_url.is_empty()\n        {\n            // Allow up to 20MB of base64 data (~26.7 million chars)\n            // Actual limit enforced by Warp body size (10MB JSON payload)\n            validate_length(image_url, \"image_url\", 1, 30_000_000)?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","humidor_share.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::str::FromStr;\nuse uuid::Uuid;\n\n/// Permission level for shared humidor access\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\npub enum PermissionLevel {\n    /// Read-only access to view cigars in the humidor\n    View,\n    /// Can add and edit cigars (but not delete)\n    Edit,\n    /// Full access: add, edit, delete cigars and manage sharing\n    Full,\n}\n\nimpl PermissionLevel {\n    pub fn as_str(&self) -> &str {\n        match self {\n            PermissionLevel::View => \"view\",\n            PermissionLevel::Edit => \"edit\",\n            PermissionLevel::Full => \"full\",\n        }\n    }\n\n    /// Check if this permission level allows viewing\n    pub fn can_view(&self) -> bool {\n        matches!(\n            self,\n            PermissionLevel::View | PermissionLevel::Edit | PermissionLevel::Full\n        )\n    }\n\n    /// Check if this permission level allows editing (add/update cigars)\n    pub fn can_edit(&self) -> bool {\n        matches!(self, PermissionLevel::Edit | PermissionLevel::Full)\n    }\n\n    /// Check if this permission level allows full management (including delete and sharing)\n    pub fn can_manage(&self) -> bool {\n        matches!(self, PermissionLevel::Full)\n    }\n}\n\nimpl FromStr for PermissionLevel {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s.to_lowercase().as_str() {\n            \"view\" => Ok(PermissionLevel::View),\n            \"edit\" => Ok(PermissionLevel::Edit),\n            \"full\" => Ok(PermissionLevel::Full),\n            _ => Err(format!(\"Invalid permission level: {}\", s)),\n        }\n    }\n}\n\n/// Database model for a humidor share\n#[allow(dead_code)]\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HumidorShare {\n    pub id: Uuid,\n    pub humidor_id: Uuid,\n    pub shared_with_user_id: Uuid,\n    pub shared_by_user_id: Uuid,\n    pub permission_level: PermissionLevel,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n/// Request to share a humidor with a user\n#[derive(Debug, Deserialize)]\npub struct ShareHumidorRequest {\n    pub user_id: Uuid,\n    pub permission_level: PermissionLevel,\n}\n\n/// Request to update share permissions\n#[derive(Debug, Deserialize)]\npub struct UpdateSharePermissionRequest {\n    pub permission_level: PermissionLevel,\n}\n\n/// Response containing share information\n#[derive(Debug, Serialize)]\npub struct HumidorShareResponse {\n    pub id: Uuid,\n    pub humidor_id: Uuid,\n    pub shared_with_user: UserInfo,\n    pub shared_by_user: UserInfo,\n    pub permission_level: PermissionLevel,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n/// User information included in share responses\n#[derive(Debug, Serialize)]\npub struct UserInfo {\n    pub id: Uuid,\n    pub username: String,\n    pub email: String,\n    pub full_name: Option<String>,\n}\n\n/// Response containing a list of shares for a humidor\n#[derive(Debug, Serialize)]\npub struct HumidorSharesListResponse {\n    pub shares: Vec<HumidorShareResponse>,\n    pub total: usize,\n}\n\n/// Response containing humidors shared with the current user\n#[derive(Debug, Serialize)]\npub struct SharedHumidorsResponse {\n    pub humidors: Vec<SharedHumidorInfo>,\n    pub total: usize,\n}\n\n/// Information about a humidor shared with the user\n#[derive(Debug, Serialize)]\npub struct SharedHumidorInfo {\n    pub id: Uuid,\n    pub name: String,\n    pub description: Option<String>,\n    pub owner: UserInfo,\n    pub permission_level: PermissionLevel,\n    pub shared_at: DateTime<Utc>,\n    pub cigar_count: i64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","mod.rs"],"content":"pub mod brand;\npub mod cigar;\npub mod humidor;\npub mod humidor_share;\npub mod origin;\npub mod password_reset;\npub mod public_share;\npub mod ring_gauge;\npub mod size;\npub mod strength;\npub mod user;\n\npub use brand::*;\npub use cigar::*;\npub use humidor::*;\npub use humidor_share::*;\npub use origin::*;\npub use password_reset::*;\npub use public_share::*;\npub use ring_gauge::*;\npub use size::*;\npub use strength::*;\npub use user::*;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","origin.rs"],"content":"use crate::validation::{Validate, ValidationResult, validate_length, validate_required};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Origin {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub name: String,\n    pub country: String,\n    pub region: Option<String>,\n    pub description: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct CreateOrigin {\n    pub name: String,\n    pub country: String,\n    pub region: Option<String>,\n    pub description: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct UpdateOrigin {\n    pub name: Option<String>,\n    pub country: Option<String>,\n    pub region: Option<String>,\n    pub description: Option<String>,\n}\n\nimpl Validate for CreateOrigin {\n    fn validate(&self) -> ValidationResult<()> {\n        validate_required(&self.name, \"name\")?;\n        validate_length(&self.name, \"name\", 1, 100)?;\n\n        validate_required(&self.country, \"country\")?;\n        validate_length(&self.country, \"country\", 1, 100)?;\n\n        if let Some(region) = &self.region\n            && !region.is_empty()\n        {\n            validate_length(region, \"region\", 1, 100)?;\n        }\n\n        if let Some(desc) = &self.description\n            && !desc.is_empty()\n        {\n            validate_length(desc, \"description\", 1, 500)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl Validate for UpdateOrigin {\n    fn validate(&self) -> ValidationResult<()> {\n        if let Some(name) = &self.name {\n            validate_required(name, \"name\")?;\n            validate_length(name, \"name\", 1, 100)?;\n        }\n\n        if let Some(country) = &self.country {\n            validate_required(country, \"country\")?;\n            validate_length(country, \"country\", 1, 100)?;\n        }\n\n        if let Some(region) = &self.region\n            && !region.is_empty()\n        {\n            validate_length(region, \"region\", 1, 100)?;\n        }\n\n        if let Some(desc) = &self.description\n            && !desc.is_empty()\n        {\n            validate_length(desc, \"description\", 1, 500)?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","password_reset.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[allow(dead_code)] // Used for database queries but not directly constructed\npub struct PasswordResetToken {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub token: String,\n    pub created_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct ForgotPasswordRequest {\n    pub email: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct ResetPasswordRequest {\n    pub token: String,\n    pub password: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","public_share.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n/// Request to create a public share link\n#[derive(Debug, Deserialize)]\npub struct CreatePublicShareRequest {\n    /// Optional expiration date. If None, defaults to 30 days from now.\n    /// To make permanent, explicitly pass a very far future date or set a flag\n    pub expires_at: Option<DateTime<Utc>>,\n    /// If true, link never expires (overrides expires_at)\n    #[serde(default)]\n    pub never_expires: bool,\n    /// Include favorites in the public share\n    #[serde(default)]\n    pub include_favorites: bool,\n    /// Include wish list in the public share\n    #[serde(default)]\n    pub include_wish_list: bool,\n    /// Optional label to identify this share\n    pub label: Option<String>,\n}\n\n/// Response containing public share information\n#[derive(Debug, Serialize)]\npub struct PublicShareResponse {\n    pub token_id: Uuid,\n    pub share_url: String,\n    pub expires_at: Option<DateTime<Utc>>,\n    pub created_at: DateTime<Utc>,\n    pub include_favorites: bool,\n    pub include_wish_list: bool,\n    pub label: Option<String>,\n}\n\n/// Public humidor data returned for valid share tokens (no authentication required)\n#[derive(Debug, Serialize)]\npub struct PublicHumidorResponse {\n    pub id: Uuid,\n    pub name: String,\n    pub description: Option<String>,\n    pub image_url: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub owner: PublicUserInfo,\n    pub cigars: Vec<PublicCigarResponse>,\n    pub cigar_count: usize,\n    pub favorites: Option<Vec<PublicCigarResponse>>,\n    pub wish_list: Option<Vec<PublicCigarResponse>>,\n}\n\n/// User information included in public responses (limited data for privacy)\n#[derive(Debug, Serialize)]\npub struct PublicUserInfo {\n    pub username: String,\n    pub full_name: Option<String>,\n}\n\n/// Cigar information for public sharing\n#[derive(Debug, Serialize)]\npub struct PublicCigarResponse {\n    pub id: Uuid,\n    pub name: String,\n    pub brand: Option<String>,\n    pub origin: Option<String>,\n    pub wrapper: Option<String>,\n    pub strength: Option<String>,\n    pub ring_gauge: Option<i32>,\n    pub length_inches: Option<f64>,\n    pub quantity: i32,\n    pub notes: Option<String>,\n    pub retail_link: Option<String>,\n    pub image_url: Option<String>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","ring_gauge.rs"],"content":"use crate::validation::{\n    Validate, ValidationResult, validate_length, validate_positive, validate_range,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RingGauge {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub gauge: i32,\n    pub description: Option<String>,\n    pub common_names: Option<Vec<String>>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct CreateRingGauge {\n    pub gauge: i32,\n    pub description: Option<String>,\n    pub common_names: Option<Vec<String>>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct UpdateRingGauge {\n    pub gauge: Option<i32>,\n    pub description: Option<String>,\n    pub common_names: Option<Vec<String>>,\n}\n\nimpl Validate for CreateRingGauge {\n    fn validate(&self) -> ValidationResult<()> {\n        validate_positive(self.gauge, \"gauge\")?;\n        validate_range(self.gauge, \"gauge\", 20, 100)?;\n\n        if let Some(desc) = &self.description\n            && !desc.is_empty()\n        {\n            validate_length(desc, \"description\", 1, 500)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl Validate for UpdateRingGauge {\n    fn validate(&self) -> ValidationResult<()> {\n        if let Some(gauge) = self.gauge {\n            validate_positive(gauge, \"gauge\")?;\n            validate_range(gauge, \"gauge\", 20, 100)?;\n        }\n\n        if let Some(desc) = &self.description\n            && !desc.is_empty()\n        {\n            validate_length(desc, \"description\", 1, 500)?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","size.rs"],"content":"use crate::validation::{\n    Validate, ValidationResult, validate_length, validate_positive, validate_range,\n    validate_range_f64, validate_required,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Size {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub name: String,\n    pub length_inches: Option<f64>,\n    pub ring_gauge: Option<i32>,\n    pub description: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct CreateSize {\n    pub name: String,\n    pub length_inches: Option<f64>,\n    pub ring_gauge: Option<i32>,\n    pub description: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct UpdateSize {\n    pub name: Option<String>,\n    pub length_inches: Option<f64>,\n    pub ring_gauge: Option<i32>,\n    pub description: Option<String>,\n}\n\nimpl Validate for CreateSize {\n    fn validate(&self) -> ValidationResult<()> {\n        validate_required(&self.name, \"name\")?;\n        validate_length(&self.name, \"name\", 1, 100)?;\n\n        if let Some(length) = self.length_inches {\n            validate_range_f64(length, 3.0, 12.0, \"length_inches\")?;\n        }\n\n        if let Some(gauge) = self.ring_gauge {\n            validate_positive(gauge, \"ring_gauge\")?;\n            validate_range(gauge, \"ring_gauge\", 20, 100)?;\n        }\n\n        if let Some(desc) = &self.description {\n            validate_length(desc, \"description\", 1, 500)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl Validate for UpdateSize {\n    fn validate(&self) -> ValidationResult<()> {\n        if let Some(name) = &self.name {\n            validate_required(name, \"name\")?;\n            validate_length(name, \"name\", 1, 100)?;\n        }\n\n        if let Some(length) = self.length_inches {\n            validate_range_f64(length, 3.0, 12.0, \"length_inches\")?;\n        }\n\n        if let Some(gauge) = self.ring_gauge {\n            validate_positive(gauge, \"ring_gauge\")?;\n            validate_range(gauge, \"ring_gauge\", 20, 100)?;\n        }\n\n        if let Some(desc) = &self.description {\n            validate_length(desc, \"description\", 1, 500)?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","strength.rs"],"content":"use crate::validation::{Validate, ValidationResult, validate_length, validate_required};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Strength {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub name: String,\n    pub level: i32,\n    pub description: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct CreateStrength {\n    pub name: String,\n    pub level: i32,\n    pub description: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct UpdateStrength {\n    pub name: Option<String>,\n    pub level: Option<i32>,\n    pub description: Option<String>,\n}\n\nimpl Validate for CreateStrength {\n    fn validate(&self) -> ValidationResult<()> {\n        validate_required(&self.name, \"name\")?;\n        validate_length(&self.name, \"name\", 1, 100)?;\n\n        if self.level < 1 || self.level > 5 {\n            return Err(crate::errors::AppError::ValidationError(\n                \"level must be between 1 and 5\".to_string(),\n            ));\n        }\n\n        if let Some(desc) = &self.description\n            && !desc.is_empty()\n        {\n            validate_length(desc, \"description\", 1, 500)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl Validate for UpdateStrength {\n    fn validate(&self) -> ValidationResult<()> {\n        if let Some(name) = &self.name {\n            validate_required(name, \"name\")?;\n            validate_length(name, \"name\", 1, 100)?;\n        }\n\n        if let Some(level) = self.level\n            && !(1..=5).contains(&level)\n        {\n            return Err(crate::errors::AppError::ValidationError(\n                \"level must be between 1 and 5\".to_string(),\n            ));\n        }\n\n        if let Some(desc) = &self.description\n            && !desc.is_empty()\n        {\n            validate_length(desc, \"description\", 1, 500)?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","models","user.rs"],"content":"use crate::models::humidor::CreateHumidorRequest;\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct User {\n    pub id: Uuid,\n    pub username: String,\n    pub email: String,\n    pub full_name: String,\n    pub password_hash: String,\n    pub is_admin: bool,\n    pub is_active: bool,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct CreateUserRequest {\n    pub username: String,\n    pub email: String,\n    pub full_name: String,\n    pub password: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct LoginRequest {\n    pub username: String,\n    pub password: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct UserResponse {\n    pub id: Uuid,\n    pub username: String,\n    pub email: String,\n    pub full_name: String,\n    pub is_admin: bool,\n    pub is_active: bool,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Serialize)]\npub struct LoginResponse {\n    pub user: UserResponse,\n    pub token: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct UpdateUserRequest {\n    pub username: Option<String>,\n    pub email: Option<String>,\n    pub full_name: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct ChangePasswordRequest {\n    pub current_password: String,\n    pub new_password: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SetupStatusResponse {\n    pub needs_setup: bool,\n    pub has_admin: bool,\n}\n\n#[derive(Debug, Deserialize)]\npub struct SetupRequest {\n    pub user: CreateUserRequest,\n    pub humidor: CreateHumidorRequest,\n}\n\n// Admin user management models\n#[derive(Debug, Deserialize)]\npub struct AdminCreateUserRequest {\n    pub username: String,\n    pub email: String,\n    pub full_name: String,\n    pub password: String,\n    pub is_admin: bool,\n    pub is_active: bool,\n}\n\n#[derive(Debug, Deserialize)]\npub struct AdminUpdateUserRequest {\n    pub username: Option<String>,\n    pub email: Option<String>,\n    pub full_name: Option<String>,\n    pub is_admin: Option<bool>,\n    pub is_active: Option<bool>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct AdminChangePasswordRequest {\n    pub new_password: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct AdminToggleActiveRequest {\n    pub is_active: bool,\n}\n\n#[derive(Debug, Deserialize)]\npub struct TransferOwnershipRequest {\n    pub from_user_id: Uuid,\n    pub to_user_id: Uuid,\n    pub humidor_id: Option<Uuid>, // If provided, only transfer this humidor\n}\n\n#[derive(Debug, Serialize)]\npub struct TransferOwnershipResponse {\n    pub humidors_transferred: i64,\n    pub cigars_transferred: i64,\n}\n\n#[derive(Debug, Serialize)]\npub struct UserListResponse {\n    pub users: Vec<UserResponse>,\n    pub total: i64,\n    pub page: i32,\n    pub per_page: i32,\n}\n\nimpl From<User> for UserResponse {\n    fn from(user: User) -> Self {\n        UserResponse {\n            id: user.id,\n            username: user.username,\n            email: user.email,\n            full_name: user.full_name,\n            is_admin: user.is_admin,\n            is_active: user.is_active,\n            created_at: user.created_at,\n            updated_at: user.updated_at,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","routes","admin.rs"],"content":"use super::helpers::{json_body, with_db};\nuse crate::DbPool;\nuse crate::handlers::admin;\nuse crate::middleware::auth::with_admin;\nuse uuid::Uuid;\nuse warp::Filter;\n\n/// Create all admin-only routes\n/// All routes require admin authentication via with_admin() middleware\npub fn create_admin_routes(\n    db_pool: DbPool,\n) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {\n    // GET /api/v1/admin/users?page=1&per_page=20\n    let list_users = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"admin\"))\n        .and(warp::path(\"users\"))\n        .and(warp::get())\n        .and(warp::path::end())\n        .and(with_admin(db_pool.clone()))\n        .and(warp::query::<std::collections::HashMap<String, String>>())\n        .and(with_db(db_pool.clone()))\n        .and_then(\n            |auth, query: std::collections::HashMap<String, String>, pool| async move {\n                let page = query.get(\"page\").and_then(|p| p.parse::<i32>().ok());\n                let per_page = query.get(\"per_page\").and_then(|pp| pp.parse::<i32>().ok());\n\n                admin::list_users(auth, page, per_page, pool).await\n            },\n        );\n\n    // GET /api/v1/admin/users/:id\n    let get_user = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"admin\"))\n        .and(warp::path(\"users\"))\n        .and(warp::path::param::<Uuid>())\n        .and(warp::get())\n        .and(warp::path::end())\n        .and(with_admin(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(admin::get_user);\n\n    // POST /api/v1/admin/users\n    let create_user = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"admin\"))\n        .and(warp::path(\"users\"))\n        .and(warp::post())\n        .and(warp::path::end())\n        .and(json_body())\n        .and(with_admin(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(admin::create_user);\n\n    // PUT /api/v1/admin/users/:id\n    let update_user = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"admin\"))\n        .and(warp::path(\"users\"))\n        .and(warp::path::param::<Uuid>())\n        .and(warp::put())\n        .and(warp::path::end())\n        .and(json_body())\n        .and(with_admin(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(admin::update_user);\n\n    // DELETE /api/v1/admin/users/:id\n    let delete_user = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"admin\"))\n        .and(warp::path(\"users\"))\n        .and(warp::path::param::<Uuid>())\n        .and(warp::delete())\n        .and(warp::path::end())\n        .and(with_admin(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(admin::delete_user);\n\n    // PATCH /api/v1/admin/users/:id/password\n    let change_password = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"admin\"))\n        .and(warp::path(\"users\"))\n        .and(warp::path::param::<Uuid>())\n        .and(warp::path(\"password\"))\n        .and(warp::patch())\n        .and(warp::path::end())\n        .and(json_body())\n        .and(with_admin(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(admin::change_user_password);\n\n    // PATCH /api/v1/admin/users/:id/active\n    let toggle_active = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"admin\"))\n        .and(warp::path(\"users\"))\n        .and(warp::path::param::<Uuid>())\n        .and(warp::path(\"active\"))\n        .and(warp::patch())\n        .and(warp::path::end())\n        .and(json_body())\n        .and(with_admin(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(admin::toggle_active);\n\n    // POST /api/v1/admin/transfer-ownership\n    let transfer_ownership = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"admin\"))\n        .and(warp::path(\"transfer-ownership\"))\n        .and(warp::post())\n        .and(warp::path::end())\n        .and(json_body())\n        .and(with_admin(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(admin::transfer_ownership);\n\n    // GET /api/v1/admin/users/:id/humidors\n    let get_user_humidors = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"admin\"))\n        .and(warp::path(\"users\"))\n        .and(warp::path::param::<Uuid>())\n        .and(warp::path(\"humidors\"))\n        .and(warp::get())\n        .and(warp::path::end())\n        .and(with_admin(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(admin::get_user_humidors);\n\n    list_users\n        .or(create_user)\n        .or(get_user)\n        .or(update_user)\n        .or(delete_user)\n        .or(toggle_active)\n        .or(change_password)\n        .or(transfer_ownership)\n        .or(get_user_humidors)\n        .boxed()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","routes","auth.rs"],"content":"use super::helpers::{json_body, with_client_ip, with_db, with_rate_limiter};\nuse crate::DbPool;\nuse crate::handlers;\nuse crate::middleware::RateLimiter;\nuse warp::Filter;\n\n/// Create all authentication-related routes\npub fn create_auth_routes(\n    db_pool: DbPool,\n    rate_limiter: RateLimiter,\n) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {\n    let get_setup_status = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"setup\"))\n        .and(warp::path(\"status\"))\n        .and(warp::get())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_setup_status);\n\n    let create_setup_user = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"setup\"))\n        .and(warp::path(\"user\"))\n        .and(warp::post())\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::create_setup_user);\n\n    let login_user = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"auth\"))\n        .and(warp::path(\"login\"))\n        .and(warp::post())\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and(with_rate_limiter(rate_limiter))\n        .and(with_client_ip())\n        .and_then(handlers::login_user);\n\n    let forgot_password = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"auth\"))\n        .and(warp::path(\"forgot-password\"))\n        .and(warp::post())\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::forgot_password);\n\n    let reset_password = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"auth\"))\n        .and(warp::path(\"reset-password\"))\n        .and(warp::post())\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::reset_password);\n\n    let email_config_status = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"auth\"))\n        .and(warp::path(\"email-config\"))\n        .and(warp::get())\n        .and_then(handlers::check_email_config);\n\n    get_setup_status\n        .or(create_setup_user)\n        .or(login_user)\n        .or(forgot_password)\n        .or(reset_password)\n        .or(email_config_status)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","routes","backups.rs"],"content":"use super::helpers::{with_current_user, with_db};\nuse crate::DbPool;\nuse crate::handlers;\nuse warp::Filter;\n\n/// Create all backup/restore-related routes (requires authentication except setup_restore)\npub fn create_backup_routes(\n    db_pool: DbPool,\n) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {\n    let get_backups = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"backups\"))\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::backups::get_backups);\n\n    let create_backup = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"backups\"))\n        .and(warp::path::end())\n        .and(warp::post())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::backups::create_backup_handler);\n\n    let download_backup = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"backups\"))\n        .and(warp::path::param())\n        .and(warp::path(\"download\"))\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::backups::download_backup);\n\n    let delete_backup = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"backups\"))\n        .and(warp::path::param())\n        .and(warp::path::end())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::backups::delete_backup_handler);\n\n    let restore_backup = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"backups\"))\n        .and(warp::path::param())\n        .and(warp::path(\"restore\"))\n        .and(warp::path::end())\n        .and(warp::post())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::backups::restore_backup_handler);\n\n    let upload_backup = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"backups\"))\n        .and(warp::path(\"upload\"))\n        .and(warp::path::end())\n        .and(warp::post())\n        .and(warp::multipart::form().max_length(100_000_000)) // 100MB max\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::backups::upload_backup);\n\n    // Setup restore (no authentication required - used during initial setup)\n    let setup_restore = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"setup\"))\n        .and(warp::path(\"restore\"))\n        .and(warp::post())\n        .and(warp::multipart::form().max_length(100_000_000)) // 100MB max\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::backups::setup_restore_backup);\n\n    get_backups\n        .or(create_backup)\n        .or(download_backup)\n        .or(delete_backup)\n        .or(restore_backup)\n        .or(upload_backup)\n        .or(setup_restore)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","routes","cigars.rs"],"content":"use super::helpers::{json_body, with_current_user, with_db, with_uuid};\r\nuse crate::DbPool;\r\nuse crate::handlers;\r\nuse warp::Filter;\r\n\r\n/// Create all cigar-related routes (requires authentication)\r\npub fn create_cigar_routes(\r\n    db_pool: DbPool,\r\n) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {\r\n    let get_cigars = warp::path(\"api\")\r\n        .and(warp::path(\"v1\"))\r\n        .and(warp::path(\"cigars\"))\r\n        .and(warp::path::end())\r\n        .and(warp::get())\r\n        .and(warp::query::<std::collections::HashMap<String, String>>())\r\n        .and(with_current_user(db_pool.clone()))\r\n        .and(with_db(db_pool.clone()))\r\n        .and_then(handlers::get_cigars);\r\n\r\n    let create_cigar = warp::path(\"api\")\r\n        .and(warp::path(\"v1\"))\r\n        .and(warp::path(\"cigars\"))\r\n        .and(warp::path::end())\r\n        .and(warp::post())\r\n        .and(json_body())\r\n        .and(with_current_user(db_pool.clone()))\r\n        .and(with_db(db_pool.clone()))\r\n        .and_then(handlers::create_cigar);\r\n\r\n    let scrape_cigar = warp::path(\"api\")\r\n        .and(warp::path(\"v1\"))\r\n        .and(warp::path(\"cigars\"))\r\n        .and(warp::path(\"scrape\"))\r\n        .and(warp::path::end())\r\n        .and(warp::post())\r\n        .and(json_body())\r\n        .and(with_current_user(db_pool.clone()))\r\n        .and_then(handlers::scrape_cigar_url);\r\n\r\n    let get_cigar = warp::path(\"api\")\r\n        .and(warp::path(\"v1\"))\r\n        .and(warp::path(\"cigars\"))\r\n        .and(with_uuid())\r\n        .and(warp::path::end())\r\n        .and(warp::get())\r\n        .and(with_current_user(db_pool.clone()))\r\n        .and(with_db(db_pool.clone()))\r\n        .and_then(handlers::get_cigar);\r\n\r\n    let update_cigar = warp::path(\"api\")\r\n        .and(warp::path(\"v1\"))\r\n        .and(warp::path(\"cigars\"))\r\n        .and(with_uuid())\r\n        .and(warp::path::end())\r\n        .and(warp::put())\r\n        .and(json_body())\r\n        .and(with_current_user(db_pool.clone()))\r\n        .and(with_db(db_pool.clone()))\r\n        .and_then(handlers::update_cigar);\r\n\r\n    let delete_cigar = warp::path(\"api\")\r\n        .and(warp::path(\"v1\"))\r\n        .and(warp::path(\"cigars\"))\r\n        .and(with_uuid())\r\n        .and(warp::path::end())\r\n        .and(warp::delete())\r\n        .and(with_current_user(db_pool.clone()))\r\n        .and(with_db(db_pool.clone()))\r\n        .and_then(handlers::delete_cigar);\r\n\r\n    let transfer_cigar = warp::path(\"api\")\r\n        .and(warp::path(\"v1\"))\r\n        .and(warp::path(\"cigars\"))\r\n        .and(with_uuid())\r\n        .and(warp::path(\"transfer\"))\r\n        .and(warp::path::end())\r\n        .and(warp::post())\r\n        .and(json_body())\r\n        .and(with_current_user(db_pool.clone()))\r\n        .and(with_db(db_pool.clone()))\r\n        .and_then(handlers::transfer_cigar);\r\n\r\n    let recommend_cigar = warp::path(\"api\")\r\n        .and(warp::path(\"v1\"))\r\n        .and(warp::path(\"cigars\"))\r\n        .and(warp::path(\"recommend\"))\r\n        .and(warp::path::end())\r\n        .and(warp::get())\r\n        .and(warp::query::<std::collections::HashMap<String, String>>())\r\n        .and(with_current_user(db_pool.clone()))\r\n        .and(with_db(db_pool.clone()))\r\n        .and_then(handlers::get_random_cigar);\r\n\r\n    // Order matters! More specific routes (with additional path segments) must come first\r\n    scrape_cigar\r\n        .or(recommend_cigar)\r\n        .or(transfer_cigar) // Must come before update/delete/get that only have UUID\r\n        .or(create_cigar)\r\n        .or(update_cigar)\r\n        .or(delete_cigar)\r\n        .or(get_cigar)\r\n        .or(get_cigars)\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","routes","favorites.rs"],"content":"use super::helpers::{json_body, with_current_user, with_db, with_uuid};\nuse crate::DbPool;\nuse crate::handlers;\nuse warp::Filter;\n\n/// Create all favorites and wish list routes (requires authentication)\npub fn create_favorite_routes(\n    db_pool: DbPool,\n) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {\n    // Favorites routes\n    let get_favorites = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"favorites\"))\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_favorites);\n\n    let add_favorite = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"favorites\"))\n        .and(warp::path::end())\n        .and(warp::post())\n        .and(json_body())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::add_favorite);\n\n    let remove_favorite = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"favorites\"))\n        .and(with_uuid())\n        .and(warp::path::end())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::remove_favorite);\n\n    let check_favorite = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"favorites\"))\n        .and(with_uuid())\n        .and(warp::path(\"check\"))\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::is_favorite);\n\n    // Wish List routes\n    let get_wish_list = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"wish_list\"))\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_wish_list);\n\n    let add_to_wish_list = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"wish_list\"))\n        .and(warp::path::end())\n        .and(warp::post())\n        .and(json_body())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::add_to_wish_list);\n\n    let remove_from_wish_list = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"wish_list\"))\n        .and(with_uuid())\n        .and(warp::path::end())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::remove_from_wish_list);\n\n    let check_wish_list = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"wish_list\"))\n        .and(with_uuid())\n        .and(warp::path(\"check\"))\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::check_wish_list);\n\n    let update_wish_list_notes = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"wish_list\"))\n        .and(with_uuid())\n        .and(warp::path::end())\n        .and(warp::put())\n        .and(json_body())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::update_wish_list_notes);\n\n    // Must come before remove_favorite (more specific route)\n    check_favorite\n        .or(get_favorites)\n        .or(add_favorite)\n        .or(remove_favorite)\n        .or(check_wish_list) // Must come before remove_from_wish_list (more specific route)\n        .or(update_wish_list_notes) // Must come before remove_from_wish_list (both have UUID path)\n        .or(get_wish_list)\n        .or(add_to_wish_list)\n        .or(remove_from_wish_list)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","routes","helpers.rs"],"content":"use crate::DbPool;\nuse crate::middleware::RateLimiter;\nuse std::net::IpAddr;\nuse warp::Filter;\n\n// Re-export commonly used middleware and types\npub use crate::middleware::with_current_user;\n\n#[derive(Debug)]\npub struct InvalidUuid;\nimpl warp::reject::Reject for InvalidUuid {}\n\n/// Helper function to pass database pool to handlers\npub fn with_db(\n    db: DbPool,\n) -> impl Filter<Extract = (DbPool,), Error = std::convert::Infallible> + Clone {\n    warp::any().map(move || db.clone())\n}\n\n/// Helper function to pass rate limiter to handlers\npub fn with_rate_limiter(\n    limiter: RateLimiter,\n) -> impl Filter<Extract = (RateLimiter,), Error = std::convert::Infallible> + Clone {\n    warp::any().map(move || limiter.clone())\n}\n\n/// Helper function to extract client IP address\npub fn with_client_ip()\n-> impl Filter<Extract = (Option<IpAddr>,), Error = std::convert::Infallible> + Clone {\n    warp::addr::remote().map(|addr: Option<std::net::SocketAddr>| addr.map(|socket| socket.ip()))\n}\n\n/// Helper function to extract UUID from path\npub fn with_uuid() -> impl Filter<Extract = (uuid::Uuid,), Error = warp::Rejection> + Copy {\n    warp::path::param::<String>().and_then(|id: String| async move {\n        uuid::Uuid::parse_str(&id).map_err(|_| warp::reject::custom(InvalidUuid))\n    })\n}\n\n/// Helper function to parse JSON body with size limit\n/// Limit: 10MB for JSON payloads to accommodate base64-encoded images\n/// (5MB image becomes ~6.7MB when base64 encoded)\npub fn json_body<T: Send + serde::de::DeserializeOwned>()\n-> impl Filter<Extract = (T,), Error = warp::Rejection> + Clone {\n    warp::body::content_length_limit(10 * 1024 * 1024) // 10MB\n        .and(warp::body::json())\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","routes","humidors.rs"],"content":"use super::helpers::{json_body, with_current_user, with_db, with_uuid};\nuse crate::DbPool;\nuse crate::handlers;\nuse warp::Filter;\n\n/// Create all humidor-related routes (requires authentication)\npub fn create_humidor_routes(\n    db_pool: DbPool,\n) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {\n    let get_humidors = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_humidors);\n\n    let get_humidor = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_humidor);\n\n    let create_humidor = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(warp::post())\n        .and(json_body())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::create_humidor);\n\n    let update_humidor = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::put())\n        .and(json_body())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::update_humidor);\n\n    let delete_humidor = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::delete_humidor);\n\n    let get_humidor_cigars = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::path(\"cigars\"))\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_humidor_cigars);\n\n    // Humidor sharing routes\n    let get_shared_humidors = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(warp::path(\"shared\"))\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_shared_humidors);\n\n    let get_humidor_shares = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::path(\"shares\"))\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_humidor_shares);\n\n    let share_humidor = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::path(\"share\"))\n        .and(warp::path::end())\n        .and(warp::post())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::share_humidor);\n\n    let revoke_share = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::path(\"share\"))\n        .and(with_uuid())\n        .and(warp::path::end())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::revoke_share);\n\n    let update_share_permission = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::path(\"share\"))\n        .and(with_uuid())\n        .and(warp::path::end())\n        .and(warp::patch())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::update_share_permission);\n\n    // Public share routes (authenticated)\n    let create_public_share = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::path(\"public-share\"))\n        .and(warp::path::end())\n        .and(warp::post())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::create_public_share);\n\n    // Get all public shares for a humidor\n    let get_public_shares = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::path(\"public-shares\"))\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_public_shares);\n\n    // Delete a specific public share\n    let delete_public_share = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid()) // humidor_id\n        .and(warp::path(\"public-shares\"))\n        .and(with_uuid()) // token_id\n        .and(warp::path::end())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::delete_public_share);\n\n    let get_public_share = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::path(\"public-share\"))\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_public_share);\n\n    let revoke_public_share = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid())\n        .and(warp::path(\"public-share\"))\n        .and(warp::path::end())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::revoke_public_share);\n\n    // Must come before get_humidor (more specific route)\n    get_humidors\n        .or(get_shared_humidors) // More specific, should come early\n        .or(get_humidor_cigars)\n        .or(get_humidor_shares)\n        .or(share_humidor)\n        .or(revoke_share)\n        .or(update_share_permission)\n        .or(create_public_share)\n        .or(get_public_shares)\n        .or(delete_public_share)\n        .or(get_public_share)\n        .or(revoke_public_share)\n        .or(create_humidor)\n        .or(update_humidor)\n        .or(delete_humidor)\n        .or(get_humidor) // Less specific, should be last\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","routes","mod.rs"],"content":"pub mod helpers;\n\npub mod admin;\npub mod auth;\npub mod backups;\npub mod cigars;\npub mod favorites;\npub mod humidors;\npub mod organizers;\npub mod public_shares;\npub mod users;\n\npub use admin::create_admin_routes;\npub use auth::create_auth_routes;\npub use backups::create_backup_routes;\npub use cigars::create_cigar_routes;\npub use favorites::create_favorite_routes;\npub use humidors::create_humidor_routes;\npub use organizers::create_organizer_routes;\npub use public_shares::create_public_share_routes;\npub use users::create_user_routes;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","routes","organizers.rs"],"content":"use super::helpers::{json_body, with_current_user, with_db, with_uuid};\nuse crate::DbPool;\nuse crate::handlers;\nuse warp::Filter;\n\n/// Create all organizer routes (brands, origins, sizes, strengths, ring gauges)\n/// These routes now require authentication as they are user-specific\npub fn create_organizer_routes(\n    db_pool: DbPool,\n) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {\n    // Brand routes\n    let get_brands = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"brands\"))\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_brands);\n\n    let create_brand = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"brands\"))\n        .and(warp::post())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::create_brand);\n\n    let update_brand = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"brands\"))\n        .and(with_uuid())\n        .and(warp::put())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::update_brand);\n\n    let delete_brand = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"brands\"))\n        .and(with_uuid())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::delete_brand);\n\n    // Size routes\n    let get_sizes = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"sizes\"))\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_sizes);\n\n    let create_size = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"sizes\"))\n        .and(warp::post())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::create_size);\n\n    let update_size = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"sizes\"))\n        .and(with_uuid())\n        .and(warp::put())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::update_size);\n\n    let delete_size = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"sizes\"))\n        .and(with_uuid())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::delete_size);\n\n    // Origin routes\n    let get_origins = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"origins\"))\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_origins);\n\n    let create_origin = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"origins\"))\n        .and(warp::post())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::create_origin);\n\n    let update_origin = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"origins\"))\n        .and(with_uuid())\n        .and(warp::put())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::update_origin);\n\n    let delete_origin = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"origins\"))\n        .and(with_uuid())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::delete_origin);\n\n    // Strength routes\n    let get_strengths = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"strengths\"))\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_strengths);\n\n    let create_strength = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"strengths\"))\n        .and(warp::post())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::create_strength);\n\n    let update_strength = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"strengths\"))\n        .and(with_uuid())\n        .and(warp::put())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::update_strength);\n\n    let delete_strength = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"strengths\"))\n        .and(with_uuid())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::delete_strength);\n\n    // Ring gauge routes\n    let get_ring_gauges = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"ring-gauges\"))\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_ring_gauges);\n\n    let create_ring_gauge = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"ring-gauges\"))\n        .and(warp::post())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::create_ring_gauge);\n\n    let update_ring_gauge = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"ring-gauges\"))\n        .and(with_uuid())\n        .and(warp::put())\n        .and(with_current_user(db_pool.clone()))\n        .and(json_body())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::update_ring_gauge);\n\n    let delete_ring_gauge = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"ring-gauges\"))\n        .and(with_uuid())\n        .and(warp::delete())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::delete_ring_gauge);\n\n    get_brands\n        .or(create_brand)\n        .or(update_brand)\n        .or(delete_brand)\n        .or(get_sizes)\n        .or(create_size)\n        .or(update_size)\n        .or(delete_size)\n        .or(get_origins)\n        .or(create_origin)\n        .or(update_origin)\n        .or(delete_origin)\n        .or(get_strengths)\n        .or(create_strength)\n        .or(update_strength)\n        .or(delete_strength)\n        .or(get_ring_gauges)\n        .or(create_ring_gauge)\n        .or(update_ring_gauge)\n        .or(delete_ring_gauge)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","routes","public_shares.rs"],"content":"use super::helpers::{with_db, with_uuid};\nuse crate::DbPool;\nuse crate::handlers;\nuse warp::Filter;\n\n/// Create public share routes (NO AUTHENTICATION REQUIRED)\n/// These routes allow anonymous access to shared humidors via token\npub fn create_public_share_routes(\n    db_pool: DbPool,\n) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {\n    // GET /api/v1/shared/humidors/:token\n    // Public access to humidor data via share token\n    warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"shared\"))\n        .and(warp::path(\"humidors\"))\n        .and(with_uuid()) // This is the token UUID\n        .and(warp::path::end())\n        .and(warp::get())\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_public_humidor)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","routes","users.rs"],"content":"use super::helpers::{json_body, with_current_user, with_db};\nuse crate::DbPool;\nuse crate::handlers;\nuse warp::Filter;\n\n/// Create all user profile-related routes (requires authentication)\npub fn create_user_routes(\n    db_pool: DbPool,\n) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {\n    let get_current_user = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"users\"))\n        .and(warp::path(\"self\"))\n        .and(warp::get())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::get_current_user);\n\n    let update_current_user = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"users\"))\n        .and(warp::path(\"self\"))\n        .and(warp::put())\n        .and(json_body())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::update_current_user);\n\n    let change_password = warp::path(\"api\")\n        .and(warp::path(\"v1\"))\n        .and(warp::path(\"users\"))\n        .and(warp::path(\"password\"))\n        .and(warp::put())\n        .and(json_body())\n        .and(with_current_user(db_pool.clone()))\n        .and(with_db(db_pool.clone()))\n        .and_then(handlers::change_password);\n\n    get_current_user.or(update_current_user).or(change_password)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","services","backup.rs"],"content":"use chrono::Utc;\nuse serde::{Deserialize, Serialize};\nuse std::fs::{self, File};\nuse std::io::{Read, Write};\nuse std::path::Path;\nuse tokio_postgres::Client;\nuse zip::write::FileOptions;\nuse zip::{CompressionMethod, ZipArchive, ZipWriter};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BackupInfo {\n    pub name: String,\n    pub date: String,\n    pub size: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BackupMetadata {\n    pub version: String,\n    pub created_at: String,\n    pub database_type: String,\n}\n\npub async fn create_backup(db: &Client) -> Result<String, Box<dyn std::error::Error>> {\n    // Create backups directory if it doesn't exist\n    let backups_dir = Path::new(\"backups\");\n    fs::create_dir_all(backups_dir)?;\n\n    // Generate timestamped backup filename\n    let timestamp = Utc::now().format(\"%Y.%m.%d.%H.%M.%S\").to_string();\n    let backup_name = format!(\"humidor_{}.zip\", timestamp);\n    let backup_path = backups_dir.join(&backup_name);\n\n    // Create ZIP file\n    let file = File::create(&backup_path)?;\n    let mut zip = ZipWriter::new(file);\n    let options = FileOptions::default()\n        .compression_method(CompressionMethod::Deflated)\n        .unix_permissions(0o755);\n\n    // Export database to JSON\n    let database_json = export_database(db).await?;\n\n    // Add metadata\n    let metadata = BackupMetadata {\n        version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        created_at: Utc::now().to_rfc3339(),\n        database_type: \"postgresql\".to_string(),\n    };\n\n    zip.start_file(\"metadata.json\", options)?;\n    zip.write_all(serde_json::to_string_pretty(&metadata)?.as_bytes())?;\n\n    // Add database JSON\n    zip.start_file(\"database.json\", options)?;\n    zip.write_all(serde_json::to_string_pretty(&database_json)?.as_bytes())?;\n\n    // Add uploaded images if they exist\n    let uploads_dir = Path::new(\"uploads\");\n    if uploads_dir.exists() {\n        add_directory_to_zip(&mut zip, uploads_dir, \"uploads\", options)?;\n    }\n\n    zip.finish()?;\n\n    Ok(backup_name)\n}\n\npub async fn restore_backup(\n    db: &Client,\n    backup_name: &str,\n) -> Result<(), Box<dyn std::error::Error>> {\n    // Check if backup_name is a full path or just a filename\n    let backup_path = if backup_name.contains(\"/\") || backup_name.contains(\"\\\\\") {\n        // It's a full path\n        Path::new(backup_name).to_path_buf()\n    } else {\n        // It's just a filename, look in backups directory\n        let backups_dir = Path::new(\"backups\");\n        backups_dir.join(backup_name)\n    };\n\n    if !backup_path.exists() {\n        return Err(\"Backup file not found\".into());\n    }\n\n    // Open ZIP file\n    let file = File::open(&backup_path)?;\n    let mut archive = ZipArchive::new(file)?;\n\n    // Read and validate metadata\n    let metadata: BackupMetadata = {\n        let mut metadata_file = archive.by_name(\"metadata.json\")?;\n        let mut contents = String::new();\n        metadata_file.read_to_string(&mut contents)?;\n        serde_json::from_str(&contents)?\n    };\n\n    tracing::info!(\n        backup_created_at = %metadata.created_at,\n        backup_version = %metadata.version,\n        \"Restoring backup\"\n    );\n\n    // Read database JSON\n    let database_json: serde_json::Value = {\n        let mut db_file = archive.by_name(\"database.json\")?;\n        let mut contents = String::new();\n        db_file.read_to_string(&mut contents)?;\n        serde_json::from_str(&contents)?\n    };\n\n    // Restore database\n    import_database(db, &database_json).await?;\n\n    // Restore uploads directory\n    let uploads_dir = Path::new(\"uploads\");\n    if uploads_dir.exists() {\n        fs::remove_dir_all(uploads_dir)?;\n    }\n    fs::create_dir_all(uploads_dir)?;\n\n    // Extract files\n    for i in 0..archive.len() {\n        let mut file = archive.by_index(i)?;\n        let outpath = file.mangled_name();\n\n        if file.name().starts_with(\"uploads/\") {\n            if file.is_dir() {\n                fs::create_dir_all(&outpath)?;\n            } else {\n                if let Some(p) = outpath.parent()\n                    && !p.exists()\n                {\n                    fs::create_dir_all(p)?;\n                }\n                let mut outfile = File::create(&outpath)?;\n                std::io::copy(&mut file, &mut outfile)?;\n            }\n        }\n    }\n\n    Ok(())\n}\n\npub fn list_backups() -> Result<Vec<BackupInfo>, Box<dyn std::error::Error>> {\n    let backups_dir = Path::new(\"backups\");\n\n    if !backups_dir.exists() {\n        fs::create_dir_all(backups_dir)?;\n        return Ok(Vec::new());\n    }\n\n    let mut backups = Vec::new();\n\n    for entry in fs::read_dir(backups_dir)? {\n        let entry = entry?;\n        let path = entry.path();\n\n        if path.extension().and_then(|s| s.to_str()) == Some(\"zip\") {\n            let metadata = fs::metadata(&path)?;\n            let size = format_size(metadata.len());\n            let modified = metadata.modified()?;\n            let datetime: chrono::DateTime<Utc> = modified.into();\n\n            backups.push(BackupInfo {\n                name: entry.file_name().to_string_lossy().to_string(),\n                date: datetime.to_rfc3339(),\n                size,\n            });\n        }\n    }\n\n    // Sort by date, newest first\n    backups.sort_by(|a, b| b.date.cmp(&a.date));\n\n    Ok(backups)\n}\n\npub fn delete_backup(backup_name: &str) -> Result<(), Box<dyn std::error::Error>> {\n    let backups_dir = Path::new(\"backups\");\n    let backup_path = backups_dir.join(backup_name);\n\n    if !backup_path.exists() || !backup_path.is_file() {\n        return Err(\"Backup file not found\".into());\n    }\n\n    // Security check: ensure the path is within backups directory\n    if !backup_path.starts_with(backups_dir) {\n        return Err(\"Invalid backup path\".into());\n    }\n\n    fs::remove_file(backup_path)?;\n    Ok(())\n}\n\nasync fn export_database(db: &Client) -> Result<serde_json::Value, Box<dyn std::error::Error>> {\n    let mut export = serde_json::Map::new();\n\n    // Export all tables using pg_dump-like approach\n    // For now, we'll use a simple approach: export as JSON strings\n    let tables = vec![\n        \"users\",\n        \"humidors\",\n        \"brands\",\n        \"sizes\",\n        \"ring_gauges\",\n        \"strengths\",\n        \"origins\",\n        \"cigars\",\n        \"favorites\",\n        \"wish_list\",\n    ];\n\n    for table in tables {\n        // Use json_agg to aggregate rows as JSON (returns text, not jsonb)\n        let query = format!(\n            \"SELECT COALESCE(json_agg(row_to_json(t)), '[]'::json)::text FROM {} t\",\n            table\n        );\n        let row = db.query_one(&query, &[]).await?;\n\n        // Get the JSON value as a string and parse it\n        let json_str: String = row.get(0);\n        let table_data: serde_json::Value = serde_json::from_str(&json_str)?;\n\n        export.insert(table.to_string(), table_data);\n    }\n\n    Ok(serde_json::Value::Object(export))\n}\n\nasync fn import_database(\n    db: &Client,\n    data: &serde_json::Value,\n) -> Result<(), Box<dyn std::error::Error>> {\n    let obj = data.as_object().ok_or(\"Invalid database JSON\")?;\n\n    // Disable foreign key checks temporarily\n    db.execute(\"SET CONSTRAINTS ALL DEFERRED\", &[]).await?;\n\n    // Clear existing data (in reverse order of dependencies)\n    let tables = vec![\n        \"wish_list\",\n        \"favorites\",\n        \"cigars\",\n        \"origins\",\n        \"strengths\",\n        \"ring_gauges\",\n        \"sizes\",\n        \"brands\",\n        \"humidors\",\n        \"users\",\n    ];\n\n    for table in &tables {\n        let query = format!(\"TRUNCATE TABLE {} RESTART IDENTITY CASCADE\", table);\n        db.execute(&query, &[]).await?;\n    }\n\n    // Import data (in order of dependencies)\n    let import_order = vec![\n        \"users\",\n        \"humidors\",\n        \"brands\",\n        \"sizes\",\n        \"ring_gauges\",\n        \"strengths\",\n        \"origins\",\n        \"cigars\",\n        \"favorites\",\n        \"wish_list\",\n    ];\n\n    for table in import_order {\n        if let Some(rows) = obj.get(table).and_then(|v| v.as_array()) {\n            for row in rows {\n                // Convert JSON object to INSERT statement\n                import_row(db, table, row).await?;\n            }\n        }\n    }\n\n    Ok(())\n}\n\nasync fn import_row(\n    db: &Client,\n    table: &str,\n    row: &serde_json::Value,\n) -> Result<(), Box<dyn std::error::Error>> {\n    // Use parameterized query to prevent SQL injection\n    // PostgreSQL's tokio-postgres driver handles proper escaping\n    let query = format!(\n        \"INSERT INTO {} SELECT * FROM json_populate_record(NULL::{}, $1::json)\",\n        table, table\n    );\n\n    // Convert to JSON value - the driver will serialize it safely\n    let json_value = row.clone();\n\n    tracing::debug!(\n        table = %table,\n        row_preview = %serde_json::to_string(&json_value)\n            .unwrap_or_default()\n            .chars()\n            .take(100)\n            .collect::<String>(),\n        \"Importing row into table\"\n    );\n\n    match db.execute(&query, &[&json_value]).await {\n        Ok(count) => {\n            tracing::debug!(\n                table = %table,\n                rows_inserted = count,\n                \"Successfully inserted row\"\n            );\n            Ok(())\n        }\n        Err(e) => {\n            tracing::error!(\n                table = %table,\n                error = %e,\n                \"Failed to insert row during backup restore\"\n            );\n            Err(Box::new(e))\n        }\n    }\n}\n\nfn add_directory_to_zip(\n    zip: &mut ZipWriter<File>,\n    dir: &Path,\n    prefix: &str,\n    options: FileOptions,\n) -> Result<(), Box<dyn std::error::Error>> {\n    for entry in fs::read_dir(dir)? {\n        let entry = entry?;\n        let path = entry.path();\n        let name = path.strip_prefix(dir.parent().unwrap_or(dir))?;\n        let zip_path = format!(\"{}/{}\", prefix, name.display());\n\n        if path.is_file() {\n            zip.start_file(&zip_path, options)?;\n            let mut file = File::open(&path)?;\n            let mut buffer = Vec::new();\n            file.read_to_end(&mut buffer)?;\n            zip.write_all(&buffer)?;\n        } else if path.is_dir() {\n            zip.add_directory(&zip_path, options)?;\n            add_directory_to_zip(zip, &path, prefix, options)?;\n        }\n    }\n\n    Ok(())\n}\n\nfn format_size(bytes: u64) -> String {\n    const KB: u64 = 1024;\n    const MB: u64 = KB * 1024;\n    const GB: u64 = MB * 1024;\n\n    if bytes >= GB {\n        format!(\"{:.2} GB\", bytes as f64 / GB as f64)\n    } else if bytes >= MB {\n        format!(\"{:.2} MB\", bytes as f64 / MB as f64)\n    } else if bytes >= KB {\n        format!(\"{:.2} KB\", bytes as f64 / KB as f64)\n    } else {\n        format!(\"{} B\", bytes)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","services","email.rs"],"content":"use anyhow::Result;\nuse lettre::{\n    SmtpTransport, Transport,\n    message::{Message, header::ContentType},\n    transport::smtp::authentication::Credentials,\n};\nuse std::env;\n\npub struct EmailService {\n    smtp_host: String,\n    smtp_port: u16,\n    smtp_user: String,\n    smtp_password: String,\n    from_email: String,\n}\n\nimpl EmailService {\n    pub fn from_env() -> Result<Self> {\n        Ok(EmailService {\n            smtp_host: env::var(\"SMTP_HOST\").unwrap_or_else(|_| \"smtp.gmail.com\".to_string()),\n            smtp_port: env::var(\"SMTP_PORT\")\n                .ok()\n                .and_then(|p| p.parse().ok())\n                .unwrap_or(587),\n            smtp_user: env::var(\"SMTP_USER\")?,\n            smtp_password: env::var(\"SMTP_PASSWORD\")?,\n            from_email: env::var(\"SMTP_FROM_EMAIL\")?,\n        })\n    }\n\n    pub async fn send_password_reset_email(&self, to_email: &str, reset_url: &str) -> Result<()> {\n        let html_body = format!(\n            r#\"\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <style>\n        body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}\n        .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}\n        .header {{ background: linear-gradient(135deg, #8B6914 0%, #D4AF37 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }}\n        .content {{ background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }}\n        .button {{ display: inline-block; background: #D4AF37; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; font-weight: bold; }}\n        .button:hover {{ background: #8B6914; }}\n        .footer {{ text-align: center; color: #666; font-size: 0.9em; margin-top: 20px; }}\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1> Password Reset Request</h1>\n        </div>\n        <div class=\"content\">\n            <p>Hello,</p>\n            <p>You have requested to reset your password for your Humidor account. Click the button below to reset your password:</p>\n            <p style=\"text-align: center;\">\n                <a href=\"{}\" class=\"button\">Reset Password</a>\n            </p>\n            <p>Or copy and paste this link into your browser:</p>\n            <p style=\"word-break: break-all; background: white; padding: 10px; border-radius: 5px;\">{}</p>\n            <p><strong>This link will expire in 30 minutes for security reasons.</strong></p>\n            <p>If you didn't request a password reset, please ignore this email. Your password will remain unchanged.</p>\n            <div class=\"footer\">\n                <p> 2025 Humidor - Cigar Inventory Management</p>\n            </div>\n        </div>\n    </div>\n</body>\n</html>\n            \"#,\n            reset_url, reset_url\n        );\n\n        let email = Message::builder()\n            .from(self.from_email.parse()?)\n            .to(to_email.parse()?)\n            .subject(\"Reset Your Humidor Password\")\n            .header(ContentType::TEXT_HTML)\n            .body(html_body)?;\n\n        let creds = Credentials::new(self.smtp_user.clone(), self.smtp_password.clone());\n\n        let mailer = SmtpTransport::relay(&self.smtp_host)?\n            .port(self.smtp_port)\n            .credentials(creds)\n            .build();\n\n        mailer.send(&email)?;\n\n        tracing::info!(\n            recipient = %to_email,\n            subject = \"Reset Your Humidor Password\",\n            \"Password reset email sent successfully\"\n        );\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","services","mod.rs"],"content":"pub mod backup;\npub mod email;\n\nuse regex::Regex;\nuse scraper::{Html, Selector};\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\npub use email::EmailService;\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct ScrapedCigarData {\n    pub brand: Option<String>,\n    pub name: Option<String>,\n    pub size: Option<String>,\n    pub length: Option<String>,\n    pub ring_gauge: Option<String>,\n    pub strength: Option<String>,\n    pub origin: Option<String>,\n    pub wrapper: Option<String>,\n}\n\nimpl ScrapedCigarData {\n    fn new() -> Self {\n        Self {\n            brand: None,\n            name: None,\n            size: None,\n            length: None,\n            ring_gauge: None,\n            strength: None,\n            origin: None,\n            wrapper: None,\n        }\n    }\n}\n\npub struct CigarScraper {\n    client: reqwest::Client,\n}\n\nimpl Default for CigarScraper {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl CigarScraper {\n    pub fn new() -> Self {\n        let client = reqwest::Client::builder()\n            .timeout(Duration::from_secs(15))\n            .user_agent(\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\")\n            .build()\n            .unwrap_or_else(|e| {\n                tracing::error!(error = %e, \"Failed to build HTTP client, using default\");\n                reqwest::Client::new()\n            });\n\n        Self { client }\n    }\n\n    pub async fn scrape(&self, url: &str) -> Result<ScrapedCigarData, Box<dyn std::error::Error>> {\n        // Fetch HTML\n        let html = self.fetch_html(url).await?;\n        let document = Html::parse_document(&html);\n\n        // Determine which scraper to use based on URL\n        if url.contains(\"cigaraficionado.com\") {\n            self.scrape_cigar_aficionado(&document, url)\n        } else if url.contains(\"famous-smoke.com\") || url.contains(\"famous\") {\n            self.scrape_famous_smoke(&document, url)\n        } else if url.contains(\"cigarsinternational.com\") {\n            self.scrape_cigars_international(&document, url)\n        } else if url.contains(\"jrcigars.com\") {\n            self.scrape_jr_cigars(&document, url)\n        } else {\n            self.scrape_generic(&document, url)\n        }\n    }\n\n    async fn fetch_html(&self, url: &str) -> Result<String, Box<dyn std::error::Error>> {\n        let response = self.client.get(url).send().await?;\n        let html = response.text().await?;\n        Ok(html)\n    }\n\n    fn clean_text(&self, text: &str) -> Option<String> {\n        let cleaned = text.trim().to_string();\n        if cleaned.is_empty() {\n            None\n        } else {\n            Some(cleaned)\n        }\n    }\n\n    fn extract_brand_and_name(&self, full_name: &str) -> (Option<String>, Option<String>) {\n        // Try to split on common separators\n        if let Some((brand, name)) = full_name.split_once(\" - \") {\n            return (self.clean_text(brand), self.clean_text(name));\n        }\n\n        if let Some((brand, name)) = full_name.split_once(\" by \") {\n            return (self.clean_text(brand), self.clean_text(name));\n        }\n\n        // Try splitting on first word\n        let words: Vec<&str> = full_name.split_whitespace().collect();\n        if words.len() > 1 {\n            return (\n                self.clean_text(words[0]),\n                self.clean_text(&words[1..].join(\" \")),\n            );\n        }\n\n        (None, self.clean_text(full_name))\n    }\n\n    fn extract_size_info(&self, text: &str) -> (Option<String>, Option<String>) {\n        // Look for size pattern like \"6 x 52\" or \"6.5 x 52\"\n        // Regex pattern is known to be valid, so this should never fail\n        let size_re = match Regex::new(r\"(\\d+\\.?\\d*)\\s*x\\s*(\\d+)\") {\n            Ok(re) => re,\n            Err(e) => {\n                tracing::error!(error = %e, \"Failed to compile size regex - this should never happen\");\n                return (None, None);\n            }\n        };\n\n        if let Some(caps) = size_re.captures(text) {\n            return (Some(caps[1].to_string()), Some(caps[2].to_string()));\n        }\n        (None, None)\n    }\n\n    fn extract_strength(&self, text: &str) -> Option<String> {\n        let text_lower = text.to_lowercase();\n        for strength in &[\"medium-full\", \"medium full\", \"full\", \"medium\", \"mild\"] {\n            if text_lower.contains(strength) {\n                return Some(\n                    match *strength {\n                        \"medium-full\" | \"medium full\" => \"Medium-Full\",\n                        \"full\" => \"Full\",\n                        \"medium\" => \"Medium\",\n                        \"mild\" => \"Mild\",\n                        _ => strength,\n                    }\n                    .to_string(),\n                );\n            }\n        }\n        None\n    }\n\n    fn extract_origin(&self, text: &str) -> Option<String> {\n        let text_lower = text.to_lowercase();\n        for origin in &[\n            \"nicaragua\",\n            \"dominican republic\",\n            \"honduras\",\n            \"cuba\",\n            \"ecuador\",\n            \"connecticut\",\n            \"mexico\",\n        ] {\n            if text_lower.contains(origin) {\n                return Some(\n                    match *origin {\n                        \"nicaragua\" => \"Nicaragua\",\n                        \"dominican republic\" => \"Dominican Republic\",\n                        \"honduras\" => \"Honduras\",\n                        \"cuba\" => \"Cuba\",\n                        \"ecuador\" => \"Ecuador\",\n                        \"connecticut\" => \"Connecticut\",\n                        \"mexico\" => \"Mexico\",\n                        _ => origin,\n                    }\n                    .to_string(),\n                );\n            }\n        }\n        None\n    }\n\n    fn scrape_cigar_aficionado(\n        &self,\n        document: &Html,\n        _url: &str,\n    ) -> Result<ScrapedCigarData, Box<dyn std::error::Error>> {\n        let mut result = ScrapedCigarData::new();\n\n        // Try to find title\n        if let Ok(selector) = Selector::parse(\"h1.entry-title, h1\")\n            && let Some(title) = document.select(&selector).next()\n        {\n            let full_name = title.text().collect::<String>();\n            let (brand, name) = self.extract_brand_and_name(&full_name);\n            result.brand = brand;\n            result.name = name;\n        }\n\n        // Look through all text for details\n        let body_text = document.root_element().text().collect::<String>();\n\n        let (length, ring_gauge) = self.extract_size_info(&body_text);\n        result.length = length;\n        result.ring_gauge = ring_gauge;\n\n        result.strength = self.extract_strength(&body_text);\n        result.origin = self.extract_origin(&body_text);\n\n        // Look for wrapper info\n        if let Some(pos) = body_text.to_lowercase().find(\"wrapper\") {\n            let wrapper_text = &body_text[pos..pos.saturating_add(100).min(body_text.len())];\n            if let Some(line) = wrapper_text.lines().next() {\n                result.wrapper = self.clean_text(\n                    line.trim_start_matches(\"wrapper\")\n                        .trim_start_matches(\":\")\n                        .trim(),\n                );\n            }\n        }\n\n        Ok(result)\n    }\n\n    fn scrape_famous_smoke(\n        &self,\n        document: &Html,\n        _url: &str,\n    ) -> Result<ScrapedCigarData, Box<dyn std::error::Error>> {\n        let mut result = ScrapedCigarData::new();\n\n        // Try multiple h1 selectors\n        let title_selectors = vec![\"h1.product-name\", \"h1.product-title\", \"h1\"];\n\n        for selector_str in title_selectors {\n            if let Ok(selector) = Selector::parse(selector_str)\n                && let Some(title) = document.select(&selector).next()\n            {\n                let full_name = title.text().collect::<String>().trim().to_string();\n                if !full_name.is_empty() {\n                    let (brand, name) = self.extract_brand_and_name(&full_name);\n                    result.brand = brand;\n                    result.name = name;\n                    break;\n                }\n            }\n        }\n\n        // Look for product specifications/attributes\n        let spec_selectors = vec![\n            \".product-specs\",\n            \".product-attributes\",\n            \".specifications\",\n            \"table.specs\",\n        ];\n\n        for selector_str in spec_selectors {\n            if let Ok(selector) = Selector::parse(selector_str)\n                && let Some(specs) = document.select(&selector).next()\n            {\n                let specs_text = specs.text().collect::<String>();\n\n                let (length, ring_gauge) = self.extract_size_info(&specs_text);\n                if length.is_some() {\n                    result.length = length;\n                    result.ring_gauge = ring_gauge;\n                }\n\n                if result.strength.is_none() {\n                    result.strength = self.extract_strength(&specs_text);\n                }\n\n                if result.origin.is_none() {\n                    result.origin = self.extract_origin(&specs_text);\n                }\n            }\n        }\n\n        // Fall back to body text\n        if result.length.is_none() || result.strength.is_none() || result.origin.is_none() {\n            let body_text = document.root_element().text().collect::<String>();\n\n            if result.length.is_none() {\n                let (length, ring_gauge) = self.extract_size_info(&body_text);\n                result.length = length;\n                result.ring_gauge = ring_gauge;\n            }\n\n            if result.strength.is_none() {\n                result.strength = self.extract_strength(&body_text);\n            }\n\n            if result.origin.is_none() {\n                result.origin = self.extract_origin(&body_text);\n            }\n        }\n\n        Ok(result)\n    }\n\n    fn scrape_cigars_international(\n        &self,\n        document: &Html,\n        _url: &str,\n    ) -> Result<ScrapedCigarData, Box<dyn std::error::Error>> {\n        let mut result = ScrapedCigarData::new();\n\n        // Try multiple selectors for product title\n        let title_selectors = vec![\n            \"h1.product-name\",\n            \"h1.product-title\",\n            \"h1[itemprop='name']\",\n            \".product-info h1\",\n            \"h1\",\n        ];\n\n        for selector_str in title_selectors {\n            if let Ok(selector) = Selector::parse(selector_str)\n                && let Some(title) = document.select(&selector).next()\n            {\n                let full_name = title.text().collect::<String>().trim().to_string();\n                if !full_name.is_empty() {\n                    let (brand, name) = self.extract_brand_and_name(&full_name);\n                    result.brand = brand;\n                    result.name = name;\n                    break;\n                }\n            }\n        }\n\n        // Look for structured product details\n        let detail_selectors = vec![\n            \".product-details\",\n            \".product-info\",\n            \".product-specifications\",\n            \".product-attributes\",\n        ];\n\n        for selector_str in detail_selectors {\n            if let Ok(selector) = Selector::parse(selector_str)\n                && let Some(details) = document.select(&selector).next()\n            {\n                let details_text = details.text().collect::<String>();\n\n                // Extract size, strength, origin from details\n                let (length, ring_gauge) = self.extract_size_info(&details_text);\n                if length.is_some() {\n                    result.length = length;\n                    result.ring_gauge = ring_gauge;\n                }\n\n                if result.strength.is_none() {\n                    result.strength = self.extract_strength(&details_text);\n                }\n\n                if result.origin.is_none() {\n                    result.origin = self.extract_origin(&details_text);\n                }\n            }\n        }\n\n        // Fall back to searching all body text if we didn't find details\n        let body_text = document.root_element().text().collect::<String>();\n\n        if result.length.is_none() {\n            let (length, ring_gauge) = self.extract_size_info(&body_text);\n            result.length = length;\n            result.ring_gauge = ring_gauge;\n        }\n\n        if result.strength.is_none() {\n            result.strength = self.extract_strength(&body_text);\n        }\n\n        if result.origin.is_none() {\n            result.origin = self.extract_origin(&body_text);\n        }\n\n        Ok(result)\n    }\n\n    fn scrape_jr_cigars(\n        &self,\n        document: &Html,\n        _url: &str,\n    ) -> Result<ScrapedCigarData, Box<dyn std::error::Error>> {\n        let mut result = ScrapedCigarData::new();\n\n        // Try to find product title\n        let title_selectors = vec![\"h1.product-title\", \"h1.prod-title\", \"h1\"];\n\n        for selector_str in title_selectors {\n            if let Ok(selector) = Selector::parse(selector_str)\n                && let Some(title) = document.select(&selector).next()\n            {\n                let full_name = title.text().collect::<String>().trim().to_string();\n                if !full_name.is_empty() {\n                    let (brand, name) = self.extract_brand_and_name(&full_name);\n                    result.brand = brand;\n                    result.name = name;\n                    break;\n                }\n            }\n        }\n\n        // Look for detailed specs\n        let detail_selectors = vec![\".product-details\", \".prod-specs\", \".specifications\"];\n\n        for selector_str in detail_selectors {\n            if let Ok(selector) = Selector::parse(selector_str)\n                && let Some(details) = document.select(&selector).next()\n            {\n                let details_text = details.text().collect::<String>();\n\n                let (length, ring_gauge) = self.extract_size_info(&details_text);\n                if length.is_some() {\n                    result.length = length;\n                    result.ring_gauge = ring_gauge;\n                }\n\n                if result.strength.is_none() {\n                    result.strength = self.extract_strength(&details_text);\n                }\n\n                if result.origin.is_none() {\n                    result.origin = self.extract_origin(&details_text);\n                }\n            }\n        }\n\n        // Fall back to all text\n        let body_text = document.root_element().text().collect::<String>();\n\n        if result.length.is_none() {\n            let (length, ring_gauge) = self.extract_size_info(&body_text);\n            result.length = length;\n            result.ring_gauge = ring_gauge;\n        }\n\n        if result.strength.is_none() {\n            result.strength = self.extract_strength(&body_text);\n        }\n\n        if result.origin.is_none() {\n            result.origin = self.extract_origin(&body_text);\n        }\n\n        Ok(result)\n    }\n\n    fn scrape_generic(\n        &self,\n        document: &Html,\n        _url: &str,\n    ) -> Result<ScrapedCigarData, Box<dyn std::error::Error>> {\n        let mut result = ScrapedCigarData::new();\n\n        // Try to find any h1 as product name\n        if let Ok(selector) = Selector::parse(\"h1\")\n            && let Some(title) = document.select(&selector).next()\n        {\n            let full_name = title.text().collect::<String>();\n            let (brand, name) = self.extract_brand_and_name(&full_name);\n            result.brand = brand;\n            result.name = name;\n        }\n\n        // Scrape all text\n        let body_text = document.root_element().text().collect::<String>();\n        let (length, ring_gauge) = self.extract_size_info(&body_text);\n        result.length = length;\n        result.ring_gauge = ring_gauge;\n        result.strength = self.extract_strength(&body_text);\n        result.origin = self.extract_origin(&body_text);\n\n        Ok(result)\n    }\n}\n\npub async fn scrape_cigar_url(url: &str) -> Result<ScrapedCigarData, Box<dyn std::error::Error>> {\n    tracing::debug!(url = %url, \"Starting cigar scrape\");\n\n    let scraper = CigarScraper::new();\n    let result = scraper.scrape(url).await?;\n\n    tracing::info!(\n        brand = ?result.brand,\n        name = ?result.name,\n        size = ?result.size,\n        length = ?result.length,\n        ring_gauge = ?result.ring_gauge,\n        strength = ?result.strength,\n        origin = ?result.origin,\n        wrapper = ?result.wrapper,\n        \"Cigar scrape completed successfully\"\n    );\n\n    Ok(result)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","src","validation.rs"],"content":"use crate::errors::AppError;\n\n/// Validation result type\npub type ValidationResult<T> = Result<T, AppError>;\n\n/// Validate string length\npub fn validate_length(\n    value: &str,\n    field_name: &str,\n    min: usize,\n    max: usize,\n) -> ValidationResult<()> {\n    let len = value.len();\n    if len < min {\n        return Err(AppError::ValidationError(format!(\n            \"{} must be at least {} characters\",\n            field_name, min\n        )));\n    }\n    if len > max {\n        return Err(AppError::ValidationError(format!(\n            \"{} must be at most {} characters\",\n            field_name, max\n        )));\n    }\n    Ok(())\n}\n\n/// Validate required string field\npub fn validate_required(value: &str, field_name: &str) -> ValidationResult<()> {\n    if value.trim().is_empty() {\n        Err(AppError::ValidationError(format!(\n            \"{} is required\",\n            field_name\n        )))\n    } else {\n        Ok(())\n    }\n}\n\n/// Validate range for f64\npub fn validate_range_f64(\n    value: f64,\n    min: f64,\n    max: f64,\n    field_name: &str,\n) -> ValidationResult<()> {\n    if value >= min && value <= max {\n        Ok(())\n    } else {\n        Err(AppError::ValidationError(format!(\n            \"{} must be between {} and {}\",\n            field_name, min, max\n        )))\n    }\n}\n\n/// Validate email format\n#[allow(dead_code)]\npub fn validate_email(email: &str) -> ValidationResult<()> {\n    // This regex pattern is well-tested and should never fail to compile\n    let email_regex = regex::Regex::new(\n        r\"^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$\"\n    ).map_err(|e| {\n        // This should never happen with a valid regex pattern\n        tracing::error!(error = %e, \"Failed to compile email regex - this indicates a code error\");\n        AppError::InternalServerError(\"Email validation regex compilation failed\".to_string())\n    })?;\n\n    if email_regex.is_match(email) {\n        Ok(())\n    } else {\n        Err(AppError::ValidationError(\n            \"Invalid email format\".to_string(),\n        ))\n    }\n}\n\n/// Validate positive integer\npub fn validate_positive(value: i32, field_name: &str) -> ValidationResult<()> {\n    if value > 0 {\n        Ok(())\n    } else {\n        Err(AppError::ValidationError(format!(\n            \"{} must be greater than 0\",\n            field_name\n        )))\n    }\n}\n\n/// Validate that a value is non-negative (allows 0)\npub fn validate_non_negative(value: i32, field_name: &str) -> ValidationResult<()> {\n    if value >= 0 {\n        Ok(())\n    } else {\n        Err(AppError::ValidationError(format!(\n            \"{} must be 0 or greater\",\n            field_name\n        )))\n    }\n}\n\n/// Validate range\npub fn validate_range(value: i32, field_name: &str, min: i32, max: i32) -> ValidationResult<()> {\n    if value >= min && value <= max {\n        Ok(())\n    } else {\n        Err(AppError::ValidationError(format!(\n            \"{} must be between {} and {}\",\n            field_name, min, max\n        )))\n    }\n}\n\n/// Validate URL format\npub fn validate_url(url: &str) -> ValidationResult<()> {\n    if url.is_empty() {\n        return Ok(());\n    }\n\n    if url.starts_with(\"http://\") || url.starts_with(\"https://\") {\n        Ok(())\n    } else {\n        Err(AppError::ValidationError(\n            \"URL must start with http:// or https://\".to_string(),\n        ))\n    }\n}\n\n/// Trait for validatable models\npub trait Validate {\n    fn validate(&self) -> ValidationResult<()>;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_validate_length() {\n        assert!(validate_length(\"test\", \"field\", 1, 10).is_ok());\n        assert!(validate_length(\"\", \"field\", 1, 10).is_err());\n        assert!(validate_length(\"toolongvalue\", \"field\", 1, 5).is_err());\n    }\n\n    #[test]\n    fn test_validate_email() {\n        assert!(validate_email(\"test@example.com\").is_ok());\n        assert!(validate_email(\"invalid-email\").is_err());\n        assert!(validate_email(\"@example.com\").is_err());\n    }\n\n    #[test]\n    fn test_validate_positive() {\n        assert!(validate_positive(1, \"field\").is_ok());\n        assert!(validate_positive(0, \"field\").is_err());\n        assert!(validate_positive(-1, \"field\").is_err());\n    }\n\n    #[test]\n    fn test_validate_range() {\n        assert!(validate_range(5, \"field\", 1, 10).is_ok());\n        assert!(validate_range(0, \"field\", 1, 10).is_err());\n        assert!(validate_range(11, \"field\", 1, 10).is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","target","debug","build","mime_guess-46d44181a4d4c19c","out","mime_types_generated.rs"],"content":"static REV_MAPPINGS: &'static [(UniCase<&'static str>, TopLevelExts)] = &[(UniCase::ascii(\"application\"), TopLevelExts { start: 0, end: 941, subs: &[(UniCase::ascii(\"acad\"), (0, 1)),(UniCase::ascii(\"andrew-inset\"), (1, 2)),(UniCase::ascii(\"annodex\"), (2, 3)),(UniCase::ascii(\"applixware\"), (3, 4)),(UniCase::ascii(\"atom+xml\"), (4, 5)),(UniCase::ascii(\"atomcat+xml\"), (5, 6)),(UniCase::ascii(\"atomsvc+xml\"), (6, 7)),(UniCase::ascii(\"bdoc\"), (7, 8)),(UniCase::ascii(\"ccxml+xml\"), (8, 9)),(UniCase::ascii(\"cdmi-capability\"), (9, 10)),(UniCase::ascii(\"cdmi-container\"), (10, 11)),(UniCase::ascii(\"cdmi-domain\"), (11, 12)),(UniCase::ascii(\"cdmi-object\"), (12, 13)),(UniCase::ascii(\"cdmi-queue\"), (13, 14)),(UniCase::ascii(\"cu-seeme\"), (14, 15)),(UniCase::ascii(\"dash+xml\"), (15, 16)),(UniCase::ascii(\"davmount+xml\"), (16, 17)),(UniCase::ascii(\"directx\"), (17, 18)),(UniCase::ascii(\"docbook+xml\"), (18, 19)),(UniCase::ascii(\"dssc+der\"), (19, 20)),(UniCase::ascii(\"dssc+xml\"), (20, 21)),(UniCase::ascii(\"emma+xml\"), (21, 22)),(UniCase::ascii(\"envoy\"), (22, 23)),(UniCase::ascii(\"epub+zip\"), (23, 24)),(UniCase::ascii(\"etl\"), (24, 25)),(UniCase::ascii(\"exi\"), (25, 26)),(UniCase::ascii(\"font-sfnt\"), (26, 28)),(UniCase::ascii(\"font-tdpfr\"), (28, 29)),(UniCase::ascii(\"font-woff\"), (29, 30)),(UniCase::ascii(\"fractals\"), (30, 31)),(UniCase::ascii(\"fsharp-script\"), (31, 33)),(UniCase::ascii(\"futuresplash\"), (33, 34)),(UniCase::ascii(\"geo+json\"), (34, 35)),(UniCase::ascii(\"gml+xml\"), (35, 36)),(UniCase::ascii(\"gpx+xml\"), (36, 37)),(UniCase::ascii(\"gxf\"), (37, 38)),(UniCase::ascii(\"gzip\"), (38, 39)),(UniCase::ascii(\"hjson\"), (39, 40)),(UniCase::ascii(\"hta\"), (40, 41)),(UniCase::ascii(\"hyperstudio\"), (41, 42)),(UniCase::ascii(\"inkml+xml\"), (42, 44)),(UniCase::ascii(\"internet-property-stream\"), (44, 45)),(UniCase::ascii(\"ipfix\"), (45, 46)),(UniCase::ascii(\"java-archive\"), (46, 49)),(UniCase::ascii(\"java-serialized-object\"), (49, 50)),(UniCase::ascii(\"javascript\"), (50, 51)),(UniCase::ascii(\"json\"), (51, 52)),(UniCase::ascii(\"json5\"), (52, 53)),(UniCase::ascii(\"jsonml+json\"), (53, 54)),(UniCase::ascii(\"ld+json\"), (54, 55)),(UniCase::ascii(\"liquidmotion\"), (55, 57)),(UniCase::ascii(\"lost+xml\"), (57, 58)),(UniCase::ascii(\"mac-binhex40\"), (58, 59)),(UniCase::ascii(\"mac-compactpro\"), (59, 60)),(UniCase::ascii(\"mads+xml\"), (60, 61)),(UniCase::ascii(\"manifest+json\"), (61, 62)),(UniCase::ascii(\"marc\"), (62, 63)),(UniCase::ascii(\"marcxml+xml\"), (63, 64)),(UniCase::ascii(\"mathematica\"), (64, 67)),(UniCase::ascii(\"mathml+xml\"), (67, 68)),(UniCase::ascii(\"mbox\"), (68, 69)),(UniCase::ascii(\"mediaservercontrol+xml\"), (69, 70)),(UniCase::ascii(\"metalink+xml\"), (70, 71)),(UniCase::ascii(\"metalink4+xml\"), (71, 72)),(UniCase::ascii(\"mets+xml\"), (72, 73)),(UniCase::ascii(\"mods+xml\"), (73, 74)),(UniCase::ascii(\"mp21\"), (74, 76)),(UniCase::ascii(\"mp4\"), (76, 77)),(UniCase::ascii(\"mpeg\"), (77, 78)),(UniCase::ascii(\"ms-vsi\"), (78, 79)),(UniCase::ascii(\"msaccess\"), (79, 86)),(UniCase::ascii(\"msaccess.addin\"), (86, 87)),(UniCase::ascii(\"msaccess.cab\"), (87, 88)),(UniCase::ascii(\"msaccess.ftemplate\"), (88, 89)),(UniCase::ascii(\"msaccess.runtime\"), (89, 90)),(UniCase::ascii(\"msaccess.webapplication\"), (90, 91)),(UniCase::ascii(\"msword\"), (91, 95)),(UniCase::ascii(\"mxf\"), (95, 96)),(UniCase::ascii(\"n-quads\"), (96, 97)),(UniCase::ascii(\"n-triples\"), (97, 98)),(UniCase::ascii(\"octet-stream\"), (98, 169)),(UniCase::ascii(\"oda\"), (169, 170)),(UniCase::ascii(\"oebps-package+xml\"), (170, 171)),(UniCase::ascii(\"ogg\"), (171, 172)),(UniCase::ascii(\"olescript\"), (172, 173)),(UniCase::ascii(\"omdoc+xml\"), (173, 174)),(UniCase::ascii(\"onenote\"), (174, 180)),(UniCase::ascii(\"opensearchdescription+xml\"), (180, 181)),(UniCase::ascii(\"oxps\"), (181, 182)),(UniCase::ascii(\"patch-ops-error+xml\"), (182, 183)),(UniCase::ascii(\"pdf\"), (183, 184)),(UniCase::ascii(\"pgp-encrypted\"), (184, 185)),(UniCase::ascii(\"pgp-signature\"), (185, 187)),(UniCase::ascii(\"pics-rules\"), (187, 188)),(UniCase::ascii(\"pkcs10\"), (188, 189)),(UniCase::ascii(\"pkcs7-mime\"), (189, 191)),(UniCase::ascii(\"pkcs7-signature\"), (191, 192)),(UniCase::ascii(\"pkcs8\"), (192, 193)),(UniCase::ascii(\"pkix-attr-cert\"), (193, 194)),(UniCase::ascii(\"pkix-crl\"), (194, 195)),(UniCase::ascii(\"pkix-pkipath\"), (195, 196)),(UniCase::ascii(\"pkixcmp\"), (196, 197)),(UniCase::ascii(\"postscript\"), (197, 200)),(UniCase::ascii(\"PowerShell\"), (200, 201)),(UniCase::ascii(\"prs.cww\"), (201, 202)),(UniCase::ascii(\"pskc+xml\"), (202, 203)),(UniCase::ascii(\"raml+yaml\"), (203, 204)),(UniCase::ascii(\"rat-file\"), (204, 205)),(UniCase::ascii(\"rdf+xml\"), (205, 206)),(UniCase::ascii(\"reginfo+xml\"), (206, 207)),(UniCase::ascii(\"relax-ng-compact-syntax\"), (207, 208)),(UniCase::ascii(\"resource-lists+xml\"), (208, 209)),(UniCase::ascii(\"resource-lists-diff+xml\"), (209, 210)),(UniCase::ascii(\"rpki-ghostbusters\"), (210, 211)),(UniCase::ascii(\"rpki-manifest\"), (211, 212)),(UniCase::ascii(\"rpki-roa\"), (212, 213)),(UniCase::ascii(\"rsd+xml\"), (213, 214)),(UniCase::ascii(\"rss+xml\"), (214, 215)),(UniCase::ascii(\"rtf\"), (215, 216)),(UniCase::ascii(\"sbml+xml\"), (216, 217)),(UniCase::ascii(\"scvp-cv-request\"), (217, 218)),(UniCase::ascii(\"scvp-cv-response\"), (218, 219)),(UniCase::ascii(\"scvp-vp-request\"), (219, 220)),(UniCase::ascii(\"scvp-vp-response\"), (220, 221)),(UniCase::ascii(\"sdp\"), (221, 222)),(UniCase::ascii(\"set-payment-initiation\"), (222, 223)),(UniCase::ascii(\"set-registration-initiation\"), (223, 224)),(UniCase::ascii(\"shf+xml\"), (224, 225)),(UniCase::ascii(\"smil+xml\"), (225, 226)),(UniCase::ascii(\"sparql-query\"), (226, 227)),(UniCase::ascii(\"sparql-results+xml\"), (227, 228)),(UniCase::ascii(\"srgs\"), (228, 229)),(UniCase::ascii(\"srgs+xml\"), (229, 230)),(UniCase::ascii(\"sru+xml\"), (230, 231)),(UniCase::ascii(\"ssdl+xml\"), (231, 232)),(UniCase::ascii(\"ssml+xml\"), (232, 233)),(UniCase::ascii(\"step\"), (233, 235)),(UniCase::ascii(\"streamingmedia\"), (235, 236)),(UniCase::ascii(\"tei+xml\"), (236, 238)),(UniCase::ascii(\"thraud+xml\"), (238, 239)),(UniCase::ascii(\"timestamped-data\"), (239, 240)),(UniCase::ascii(\"trig\"), (240, 241)),(UniCase::ascii(\"vnd.3gpp.pic-bw-large\"), (241, 242)),(UniCase::ascii(\"vnd.3gpp.pic-bw-small\"), (242, 243)),(UniCase::ascii(\"vnd.3gpp.pic-bw-var\"), (243, 244)),(UniCase::ascii(\"vnd.3gpp2.tcap\"), (244, 245)),(UniCase::ascii(\"vnd.3m.post-it-notes\"), (245, 246)),(UniCase::ascii(\"vnd.accpac.simply.aso\"), (246, 247)),(UniCase::ascii(\"vnd.accpac.simply.imp\"), (247, 248)),(UniCase::ascii(\"vnd.acucobol\"), (248, 249)),(UniCase::ascii(\"vnd.acucorp\"), (249, 251)),(UniCase::ascii(\"vnd.adobe.air-application-installer-package+zip\"), (251, 252)),(UniCase::ascii(\"vnd.adobe.formscentral.fcdt\"), (252, 253)),(UniCase::ascii(\"vnd.adobe.fxp\"), (253, 255)),(UniCase::ascii(\"vnd.adobe.xdp+xml\"), (255, 256)),(UniCase::ascii(\"vnd.adobe.xfdf\"), (256, 257)),(UniCase::ascii(\"vnd.ahead.space\"), (257, 258)),(UniCase::ascii(\"vnd.airzip.filesecure.azf\"), (258, 259)),(UniCase::ascii(\"vnd.airzip.filesecure.azs\"), (259, 260)),(UniCase::ascii(\"vnd.amazon.ebook\"), (260, 261)),(UniCase::ascii(\"vnd.americandynamics.acc\"), (261, 262)),(UniCase::ascii(\"vnd.amiga.ami\"), (262, 263)),(UniCase::ascii(\"vnd.android.package-archive\"), (263, 264)),(UniCase::ascii(\"vnd.anser-web-certificate-issue-initiation\"), (264, 265)),(UniCase::ascii(\"vnd.anser-web-funds-transfer-initiation\"), (265, 266)),(UniCase::ascii(\"vnd.antix.game-component\"), (266, 267)),(UniCase::ascii(\"vnd.apache.parquet\"), (267, 268)),(UniCase::ascii(\"vnd.apple.installer+xml\"), (268, 269)),(UniCase::ascii(\"vnd.apple.pkpass\"), (269, 270)),(UniCase::ascii(\"vnd.aristanetworks.swi\"), (270, 271)),(UniCase::ascii(\"vnd.astraea-software.iota\"), (271, 272)),(UniCase::ascii(\"vnd.audiograph\"), (272, 273)),(UniCase::ascii(\"vnd.blueice.multipass\"), (273, 274)),(UniCase::ascii(\"vnd.bmi\"), (274, 275)),(UniCase::ascii(\"vnd.businessobjects\"), (275, 276)),(UniCase::ascii(\"vnd.chemdraw+xml\"), (276, 277)),(UniCase::ascii(\"vnd.chipnuts.karaoke-mmd\"), (277, 278)),(UniCase::ascii(\"vnd.cinderella\"), (278, 279)),(UniCase::ascii(\"vnd.citationstyles.style+xml\"), (279, 280)),(UniCase::ascii(\"vnd.claymore\"), (280, 281)),(UniCase::ascii(\"vnd.cloanto.rp9\"), (281, 282)),(UniCase::ascii(\"vnd.clonk.c4group\"), (282, 287)),(UniCase::ascii(\"vnd.cluetrust.cartomobile-config\"), (287, 288)),(UniCase::ascii(\"vnd.cluetrust.cartomobile-config-pkg\"), (288, 289)),(UniCase::ascii(\"vnd.commonspace\"), (289, 290)),(UniCase::ascii(\"vnd.contact.cmsg\"), (290, 291)),(UniCase::ascii(\"vnd.cosmocaller\"), (291, 292)),(UniCase::ascii(\"vnd.crick.clicker\"), (292, 293)),(UniCase::ascii(\"vnd.crick.clicker.keyboard\"), (293, 294)),(UniCase::ascii(\"vnd.crick.clicker.palette\"), (294, 295)),(UniCase::ascii(\"vnd.crick.clicker.template\"), (295, 296)),(UniCase::ascii(\"vnd.crick.clicker.wordbank\"), (296, 297)),(UniCase::ascii(\"vnd.criticaltools.wbs+xml\"), (297, 298)),(UniCase::ascii(\"vnd.cups-ppd\"), (298, 299)),(UniCase::ascii(\"vnd.curl.car\"), (299, 300)),(UniCase::ascii(\"vnd.curl.pcurl\"), (300, 301)),(UniCase::ascii(\"vnd.dart\"), (301, 302)),(UniCase::ascii(\"vnd.data-vision.rdz\"), (302, 303)),(UniCase::ascii(\"vnd.dece.data\"), (303, 307)),(UniCase::ascii(\"vnd.dece.ttml+xml\"), (307, 309)),(UniCase::ascii(\"vnd.dece.unspecified\"), (309, 311)),(UniCase::ascii(\"vnd.dece.zip\"), (311, 313)),(UniCase::ascii(\"vnd.denovo.fcselayout-link\"), (313, 314)),(UniCase::ascii(\"vnd.dna\"), (314, 315)),(UniCase::ascii(\"vnd.dolby.mlp\"), (315, 316)),(UniCase::ascii(\"vnd.dpgraph\"), (316, 317)),(UniCase::ascii(\"vnd.dreamfactory\"), (317, 318)),(UniCase::ascii(\"vnd.ds-keypoint\"), (318, 319)),(UniCase::ascii(\"vnd.dvb.ait\"), (319, 320)),(UniCase::ascii(\"vnd.dynageo\"), (320, 321)),(UniCase::ascii(\"vnd.ecowin.chart\"), (321, 322)),(UniCase::ascii(\"vnd.enliven\"), (322, 323)),(UniCase::ascii(\"vnd.epson.esf\"), (323, 324)),(UniCase::ascii(\"vnd.epson.msf\"), (324, 325)),(UniCase::ascii(\"vnd.epson.quickanime\"), (325, 326)),(UniCase::ascii(\"vnd.epson.salt\"), (326, 327)),(UniCase::ascii(\"vnd.epson.ssf\"), (327, 328)),(UniCase::ascii(\"vnd.eszigno3+xml\"), (328, 330)),(UniCase::ascii(\"vnd.ezpix-album\"), (330, 331)),(UniCase::ascii(\"vnd.ezpix-package\"), (331, 332)),(UniCase::ascii(\"vnd.fdf\"), (332, 333)),(UniCase::ascii(\"vnd.fdsn.mseed\"), (333, 334)),(UniCase::ascii(\"vnd.fdsn.seed\"), (334, 336)),(UniCase::ascii(\"vnd.flographit\"), (336, 337)),(UniCase::ascii(\"vnd.fluxtime.clip\"), (337, 338)),(UniCase::ascii(\"vnd.framemaker\"), (338, 342)),(UniCase::ascii(\"vnd.frogans.fnc\"), (342, 343)),(UniCase::ascii(\"vnd.frogans.ltf\"), (343, 344)),(UniCase::ascii(\"vnd.fsc.weblaunch\"), (344, 345)),(UniCase::ascii(\"vnd.fujitsu.oasys\"), (345, 346)),(UniCase::ascii(\"vnd.fujitsu.oasys2\"), (346, 347)),(UniCase::ascii(\"vnd.fujitsu.oasys3\"), (347, 348)),(UniCase::ascii(\"vnd.fujitsu.oasysgp\"), (348, 349)),(UniCase::ascii(\"vnd.fujitsu.oasysprs\"), (349, 350)),(UniCase::ascii(\"vnd.fujixerox.ddd\"), (350, 351)),(UniCase::ascii(\"vnd.fujixerox.docuworks\"), (351, 352)),(UniCase::ascii(\"vnd.fujixerox.docuworks.binder\"), (352, 353)),(UniCase::ascii(\"vnd.fuzzysheet\"), (353, 354)),(UniCase::ascii(\"vnd.genomatix.tuxedo\"), (354, 355)),(UniCase::ascii(\"vnd.geogebra.file\"), (355, 356)),(UniCase::ascii(\"vnd.geogebra.tool\"), (356, 357)),(UniCase::ascii(\"vnd.geometry-explorer\"), (357, 359)),(UniCase::ascii(\"vnd.geonext\"), (359, 360)),(UniCase::ascii(\"vnd.geoplan\"), (360, 361)),(UniCase::ascii(\"vnd.geospace\"), (361, 362)),(UniCase::ascii(\"vnd.gmx\"), (362, 363)),(UniCase::ascii(\"vnd.google-apps.document\"), (363, 364)),(UniCase::ascii(\"vnd.google-apps.presentation\"), (364, 365)),(UniCase::ascii(\"vnd.google-apps.spreadsheet\"), (365, 366)),(UniCase::ascii(\"vnd.google-earth.kml+xml\"), (366, 367)),(UniCase::ascii(\"vnd.google-earth.kmz\"), (367, 368)),(UniCase::ascii(\"vnd.grafeq\"), (368, 370)),(UniCase::ascii(\"vnd.groove-account\"), (370, 371)),(UniCase::ascii(\"vnd.groove-help\"), (371, 372)),(UniCase::ascii(\"vnd.groove-identity-message\"), (372, 373)),(UniCase::ascii(\"vnd.groove-injector\"), (373, 374)),(UniCase::ascii(\"vnd.groove-tool-message\"), (374, 375)),(UniCase::ascii(\"vnd.groove-tool-template\"), (375, 376)),(UniCase::ascii(\"vnd.groove-vcard\"), (376, 377)),(UniCase::ascii(\"vnd.hal+xml\"), (377, 378)),(UniCase::ascii(\"vnd.handheld-entertainment+xml\"), (378, 379)),(UniCase::ascii(\"vnd.hbci\"), (379, 380)),(UniCase::ascii(\"vnd.hhe.lesson-player\"), (380, 381)),(UniCase::ascii(\"vnd.hp-hpgl\"), (381, 382)),(UniCase::ascii(\"vnd.hp-hpid\"), (382, 383)),(UniCase::ascii(\"vnd.hp-hps\"), (383, 384)),(UniCase::ascii(\"vnd.hp-jlyt\"), (384, 385)),(UniCase::ascii(\"vnd.hp-pcl\"), (385, 386)),(UniCase::ascii(\"vnd.hp-pclxl\"), (386, 387)),(UniCase::ascii(\"vnd.hydrostatix.sof-data\"), (387, 388)),(UniCase::ascii(\"vnd.ibm.minipay\"), (388, 389)),(UniCase::ascii(\"vnd.ibm.modcap\"), (389, 392)),(UniCase::ascii(\"vnd.ibm.rights-management\"), (392, 393)),(UniCase::ascii(\"vnd.ibm.secure-container\"), (393, 394)),(UniCase::ascii(\"vnd.iccprofile\"), (394, 396)),(UniCase::ascii(\"vnd.igloader\"), (396, 397)),(UniCase::ascii(\"vnd.immervision-ivp\"), (397, 398)),(UniCase::ascii(\"vnd.immervision-ivu\"), (398, 399)),(UniCase::ascii(\"vnd.insors.igm\"), (399, 400)),(UniCase::ascii(\"vnd.intercon.formnet\"), (400, 402)),(UniCase::ascii(\"vnd.intergeo\"), (402, 403)),(UniCase::ascii(\"vnd.intu.qbo\"), (403, 404)),(UniCase::ascii(\"vnd.intu.qfx\"), (404, 405)),(UniCase::ascii(\"vnd.ipunplugged.rcprofile\"), (405, 406)),(UniCase::ascii(\"vnd.irepository.package+xml\"), (406, 407)),(UniCase::ascii(\"vnd.is-xpr\"), (407, 408)),(UniCase::ascii(\"vnd.isac.fcs\"), (408, 409)),(UniCase::ascii(\"vnd.jam\"), (409, 410)),(UniCase::ascii(\"vnd.jcp.javame.midlet-rms\"), (410, 411)),(UniCase::ascii(\"vnd.jisp\"), (411, 412)),(UniCase::ascii(\"vnd.joost.joda-archive\"), (412, 413)),(UniCase::ascii(\"vnd.kahootz\"), (413, 415)),(UniCase::ascii(\"vnd.kde.karbon\"), (415, 416)),(UniCase::ascii(\"vnd.kde.kchart\"), (416, 417)),(UniCase::ascii(\"vnd.kde.kformula\"), (417, 418)),(UniCase::ascii(\"vnd.kde.kivio\"), (418, 419)),(UniCase::ascii(\"vnd.kde.kontour\"), (419, 420)),(UniCase::ascii(\"vnd.kde.kpresenter\"), (420, 422)),(UniCase::ascii(\"vnd.kde.kspread\"), (422, 423)),(UniCase::ascii(\"vnd.kde.kword\"), (423, 425)),(UniCase::ascii(\"vnd.kenameaapp\"), (425, 426)),(UniCase::ascii(\"vnd.kidspiration\"), (426, 427)),(UniCase::ascii(\"vnd.kinar\"), (427, 429)),(UniCase::ascii(\"vnd.koan\"), (429, 432)),(UniCase::ascii(\"vnd.kodak-descriptor\"), (432, 433)),(UniCase::ascii(\"vnd.las.las+xml\"), (433, 434)),(UniCase::ascii(\"vnd.llamagraphics.life-balance.desktop\"), (434, 435)),(UniCase::ascii(\"vnd.llamagraphics.life-balance.exchange+xml\"), (435, 436)),(UniCase::ascii(\"vnd.lotus-1-2-3\"), (436, 437)),(UniCase::ascii(\"vnd.lotus-approach\"), (437, 438)),(UniCase::ascii(\"vnd.lotus-freelance\"), (438, 439)),(UniCase::ascii(\"vnd.lotus-notes\"), (439, 440)),(UniCase::ascii(\"vnd.lotus-organizer\"), (440, 441)),(UniCase::ascii(\"vnd.lotus-screencam\"), (441, 442)),(UniCase::ascii(\"vnd.lotus-wordpro\"), (442, 443)),(UniCase::ascii(\"vnd.macports.portpkg\"), (443, 444)),(UniCase::ascii(\"vnd.mcd\"), (444, 445)),(UniCase::ascii(\"vnd.medcalcdata\"), (445, 446)),(UniCase::ascii(\"vnd.mediastation.cdkey\"), (446, 447)),(UniCase::ascii(\"vnd.mfer\"), (447, 448)),(UniCase::ascii(\"vnd.mfmp\"), (448, 449)),(UniCase::ascii(\"vnd.micrografx.flo\"), (449, 450)),(UniCase::ascii(\"vnd.micrografx.igx\"), (450, 451)),(UniCase::ascii(\"vnd.mif\"), (451, 452)),(UniCase::ascii(\"vnd.mobius.daf\"), (452, 453)),(UniCase::ascii(\"vnd.mobius.dis\"), (453, 454)),(UniCase::ascii(\"vnd.mobius.mbk\"), (454, 455)),(UniCase::ascii(\"vnd.mobius.mqy\"), (455, 456)),(UniCase::ascii(\"vnd.mobius.msl\"), (456, 457)),(UniCase::ascii(\"vnd.mobius.plc\"), (457, 458)),(UniCase::ascii(\"vnd.mobius.txf\"), (458, 459)),(UniCase::ascii(\"vnd.mophun.application\"), (459, 460)),(UniCase::ascii(\"vnd.mophun.certificate\"), (460, 461)),(UniCase::ascii(\"vnd.mozilla.xul+xml\"), (461, 462)),(UniCase::ascii(\"vnd.ms-artgalry\"), (462, 463)),(UniCase::ascii(\"vnd.ms-excel\"), (463, 473)),(UniCase::ascii(\"vnd.ms-excel.addin.macroEnabled.12\"), (473, 474)),(UniCase::ascii(\"vnd.ms-excel.sheet.binary.macroEnabled.12\"), (474, 475)),(UniCase::ascii(\"vnd.ms-excel.sheet.macroEnabled.12\"), (475, 476)),(UniCase::ascii(\"vnd.ms-excel.template.macroEnabled.12\"), (476, 477)),(UniCase::ascii(\"vnd.ms-fontobject\"), (477, 478)),(UniCase::ascii(\"vnd.ms-htmlhelp\"), (478, 479)),(UniCase::ascii(\"vnd.ms-ims\"), (479, 480)),(UniCase::ascii(\"vnd.ms-lrm\"), (480, 481)),(UniCase::ascii(\"vnd.ms-mediapackage\"), (481, 482)),(UniCase::ascii(\"vnd.ms-office.calx\"), (482, 483)),(UniCase::ascii(\"vnd.ms-officetheme\"), (483, 484)),(UniCase::ascii(\"vnd.ms-outlook\"), (484, 486)),(UniCase::ascii(\"vnd.ms-pki.certstore\"), (486, 487)),(UniCase::ascii(\"vnd.ms-pki.pko\"), (487, 488)),(UniCase::ascii(\"vnd.ms-pki.seccat\"), (488, 489)),(UniCase::ascii(\"vnd.ms-pki.stl\"), (489, 490)),(UniCase::ascii(\"vnd.ms-powerpoint\"), (490, 495)),(UniCase::ascii(\"vnd.ms-powerpoint.addin.macroEnabled.12\"), (495, 496)),(UniCase::ascii(\"vnd.ms-powerpoint.presentation.macroEnabled.12\"), (496, 497)),(UniCase::ascii(\"vnd.ms-powerpoint.slide.macroEnabled.12\"), (497, 498)),(UniCase::ascii(\"vnd.ms-powerpoint.slideshow.macroEnabled.12\"), (498, 499)),(UniCase::ascii(\"vnd.ms-powerpoint.template.macroEnabled.12\"), (499, 500)),(UniCase::ascii(\"vnd.ms-project\"), (500, 502)),(UniCase::ascii(\"vnd.ms-visio.viewer\"), (502, 503)),(UniCase::ascii(\"vnd.ms-word.document.macroEnabled.12\"), (503, 504)),(UniCase::ascii(\"vnd.ms-word.template.macroEnabled.12\"), (504, 505)),(UniCase::ascii(\"vnd.ms-works\"), (505, 509)),(UniCase::ascii(\"vnd.ms-wpl\"), (509, 510)),(UniCase::ascii(\"vnd.ms-xpsdocument\"), (510, 511)),(UniCase::ascii(\"vnd.mseq\"), (511, 512)),(UniCase::ascii(\"vnd.musician\"), (512, 513)),(UniCase::ascii(\"vnd.muvee.style\"), (513, 514)),(UniCase::ascii(\"vnd.mynfc\"), (514, 515)),(UniCase::ascii(\"vnd.neurolanguage.nlu\"), (515, 516)),(UniCase::ascii(\"vnd.nitf\"), (516, 518)),(UniCase::ascii(\"vnd.noblenet-directory\"), (518, 519)),(UniCase::ascii(\"vnd.noblenet-sealer\"), (519, 520)),(UniCase::ascii(\"vnd.noblenet-web\"), (520, 521)),(UniCase::ascii(\"vnd.nokia.n-gage.data\"), (521, 522)),(UniCase::ascii(\"vnd.nokia.n-gage.symbian.install\"), (522, 523)),(UniCase::ascii(\"vnd.nokia.radio-preset\"), (523, 524)),(UniCase::ascii(\"vnd.nokia.radio-presets\"), (524, 525)),(UniCase::ascii(\"vnd.novadigm.edm\"), (525, 526)),(UniCase::ascii(\"vnd.novadigm.edx\"), (526, 527)),(UniCase::ascii(\"vnd.novadigm.ext\"), (527, 528)),(UniCase::ascii(\"vnd.oasis.opendocument.chart\"), (528, 529)),(UniCase::ascii(\"vnd.oasis.opendocument.chart-template\"), (529, 530)),(UniCase::ascii(\"vnd.oasis.opendocument.database\"), (530, 531)),(UniCase::ascii(\"vnd.oasis.opendocument.formula\"), (531, 532)),(UniCase::ascii(\"vnd.oasis.opendocument.formula-template\"), (532, 533)),(UniCase::ascii(\"vnd.oasis.opendocument.graphics\"), (533, 534)),(UniCase::ascii(\"vnd.oasis.opendocument.graphics-template\"), (534, 535)),(UniCase::ascii(\"vnd.oasis.opendocument.image\"), (535, 536)),(UniCase::ascii(\"vnd.oasis.opendocument.image-template\"), (536, 537)),(UniCase::ascii(\"vnd.oasis.opendocument.presentation\"), (537, 538)),(UniCase::ascii(\"vnd.oasis.opendocument.presentation-template\"), (538, 539)),(UniCase::ascii(\"vnd.oasis.opendocument.spreadsheet\"), (539, 540)),(UniCase::ascii(\"vnd.oasis.opendocument.spreadsheet-template\"), (540, 541)),(UniCase::ascii(\"vnd.oasis.opendocument.text\"), (541, 542)),(UniCase::ascii(\"vnd.oasis.opendocument.text-master\"), (542, 543)),(UniCase::ascii(\"vnd.oasis.opendocument.text-template\"), (543, 544)),(UniCase::ascii(\"vnd.oasis.opendocument.text-web\"), (544, 545)),(UniCase::ascii(\"vnd.olpc-sugar\"), (545, 546)),(UniCase::ascii(\"vnd.oma.dd2+xml\"), (546, 547)),(UniCase::ascii(\"vnd.openofficeorg.extension\"), (547, 548)),(UniCase::ascii(\"vnd.openxmlformats-officedocument.presentationml.presentation\"), (548, 549)),(UniCase::ascii(\"vnd.openxmlformats-officedocument.presentationml.slide\"), (549, 550)),(UniCase::ascii(\"vnd.openxmlformats-officedocument.presentationml.slideshow\"), (550, 551)),(UniCase::ascii(\"vnd.openxmlformats-officedocument.presentationml.template\"), (551, 552)),(UniCase::ascii(\"vnd.openxmlformats-officedocument.spreadsheetml.sheet\"), (552, 553)),(UniCase::ascii(\"vnd.openxmlformats-officedocument.spreadsheetml.template\"), (553, 554)),(UniCase::ascii(\"vnd.openxmlformats-officedocument.wordprocessingml.document\"), (554, 555)),(UniCase::ascii(\"vnd.openxmlformats-officedocument.wordprocessingml.template\"), (555, 556)),(UniCase::ascii(\"vnd.osgeo.mapguide.package\"), (556, 557)),(UniCase::ascii(\"vnd.osgi.dp\"), (557, 558)),(UniCase::ascii(\"vnd.osgi.subsystem\"), (558, 559)),(UniCase::ascii(\"vnd.palm\"), (559, 562)),(UniCase::ascii(\"vnd.pawaafile\"), (562, 563)),(UniCase::ascii(\"vnd.pg.format\"), (563, 564)),(UniCase::ascii(\"vnd.pg.osasli\"), (564, 565)),(UniCase::ascii(\"vnd.picsel\"), (565, 566)),(UniCase::ascii(\"vnd.pmi.widget\"), (566, 567)),(UniCase::ascii(\"vnd.pocketlearn\"), (567, 568)),(UniCase::ascii(\"vnd.powerbuilder6\"), (568, 569)),(UniCase::ascii(\"vnd.previewsystems.box\"), (569, 570)),(UniCase::ascii(\"vnd.proteus.magazine\"), (570, 571)),(UniCase::ascii(\"vnd.publishare-delta-tree\"), (571, 572)),(UniCase::ascii(\"vnd.pvi.ptid1\"), (572, 573)),(UniCase::ascii(\"vnd.quark.quarkxpress\"), (573, 578)),(UniCase::ascii(\"vnd.realvnc.bed\"), (578, 579)),(UniCase::ascii(\"vnd.recordare.musicxml\"), (579, 580)),(UniCase::ascii(\"vnd.recordare.musicxml+xml\"), (580, 581)),(UniCase::ascii(\"vnd.rig.cryptonote\"), (581, 582)),(UniCase::ascii(\"vnd.rn-realmedia\"), (582, 583)),(UniCase::ascii(\"vnd.rn-realmedia-vbr\"), (583, 584)),(UniCase::ascii(\"vnd.rn-rn_music_package\"), (584, 585)),(UniCase::ascii(\"vnd.route66.link66+xml\"), (585, 586)),(UniCase::ascii(\"vnd.sailingtracker.track\"), (586, 587)),(UniCase::ascii(\"vnd.seemail\"), (587, 588)),(UniCase::ascii(\"vnd.sema\"), (588, 589)),(UniCase::ascii(\"vnd.semd\"), (589, 590)),(UniCase::ascii(\"vnd.semf\"), (590, 591)),(UniCase::ascii(\"vnd.shana.informed.formdata\"), (591, 592)),(UniCase::ascii(\"vnd.shana.informed.formtemplate\"), (592, 593)),(UniCase::ascii(\"vnd.shana.informed.interchange\"), (593, 594)),(UniCase::ascii(\"vnd.shana.informed.package\"), (594, 595)),(UniCase::ascii(\"vnd.simtech-mindmapper\"), (595, 597)),(UniCase::ascii(\"vnd.smart.teacher\"), (597, 598)),(UniCase::ascii(\"vnd.solent.sdkm+xml\"), (598, 600)),(UniCase::ascii(\"vnd.spotfire.dxp\"), (600, 601)),(UniCase::ascii(\"vnd.spotfire.sfs\"), (601, 602)),(UniCase::ascii(\"vnd.stardivision.calc\"), (602, 603)),(UniCase::ascii(\"vnd.stardivision.draw\"), (603, 604)),(UniCase::ascii(\"vnd.stardivision.impress\"), (604, 605)),(UniCase::ascii(\"vnd.stardivision.math\"), (605, 606)),(UniCase::ascii(\"vnd.stardivision.writer\"), (606, 608)),(UniCase::ascii(\"vnd.stardivision.writer-global\"), (608, 609)),(UniCase::ascii(\"vnd.stepmania.package\"), (609, 610)),(UniCase::ascii(\"vnd.stepmania.stepchart\"), (610, 611)),(UniCase::ascii(\"vnd.sun.wadl+xml\"), (611, 612)),(UniCase::ascii(\"vnd.sun.xml.calc\"), (612, 613)),(UniCase::ascii(\"vnd.sun.xml.calc.template\"), (613, 614)),(UniCase::ascii(\"vnd.sun.xml.draw\"), (614, 615)),(UniCase::ascii(\"vnd.sun.xml.draw.template\"), (615, 616)),(UniCase::ascii(\"vnd.sun.xml.impress\"), (616, 617)),(UniCase::ascii(\"vnd.sun.xml.impress.template\"), (617, 618)),(UniCase::ascii(\"vnd.sun.xml.math\"), (618, 619)),(UniCase::ascii(\"vnd.sun.xml.writer\"), (619, 620)),(UniCase::ascii(\"vnd.sun.xml.writer.global\"), (620, 621)),(UniCase::ascii(\"vnd.sun.xml.writer.template\"), (621, 622)),(UniCase::ascii(\"vnd.sus-calendar\"), (622, 624)),(UniCase::ascii(\"vnd.svd\"), (624, 625)),(UniCase::ascii(\"vnd.symbian.install\"), (625, 627)),(UniCase::ascii(\"vnd.syncml+xml\"), (627, 628)),(UniCase::ascii(\"vnd.syncml.dm+wbxml\"), (628, 629)),(UniCase::ascii(\"vnd.syncml.dm+xml\"), (629, 630)),(UniCase::ascii(\"vnd.tao.intent-module-archive\"), (630, 631)),(UniCase::ascii(\"vnd.tcpdump.pcap\"), (631, 634)),(UniCase::ascii(\"vnd.tmobile-livetv\"), (634, 635)),(UniCase::ascii(\"vnd.trid.tpt\"), (635, 636)),(UniCase::ascii(\"vnd.triscape.mxs\"), (636, 637)),(UniCase::ascii(\"vnd.trueapp\"), (637, 638)),(UniCase::ascii(\"vnd.ufdl\"), (638, 640)),(UniCase::ascii(\"vnd.uiq.theme\"), (640, 641)),(UniCase::ascii(\"vnd.umajin\"), (641, 642)),(UniCase::ascii(\"vnd.unity\"), (642, 643)),(UniCase::ascii(\"vnd.uoml+xml\"), (643, 644)),(UniCase::ascii(\"vnd.vcx\"), (644, 645)),(UniCase::ascii(\"vnd.visio\"), (645, 651)),(UniCase::ascii(\"vnd.visionary\"), (651, 652)),(UniCase::ascii(\"vnd.vsf\"), (652, 653)),(UniCase::ascii(\"vnd.wap.wbxml\"), (653, 654)),(UniCase::ascii(\"vnd.wap.wmlc\"), (654, 655)),(UniCase::ascii(\"vnd.wap.wmlscriptc\"), (655, 656)),(UniCase::ascii(\"vnd.webturbo\"), (656, 657)),(UniCase::ascii(\"vnd.wolfram.player\"), (657, 658)),(UniCase::ascii(\"vnd.wordperfect\"), (658, 659)),(UniCase::ascii(\"vnd.wqd\"), (659, 660)),(UniCase::ascii(\"vnd.wt.stf\"), (660, 661)),(UniCase::ascii(\"vnd.xara\"), (661, 662)),(UniCase::ascii(\"vnd.xfdl\"), (662, 663)),(UniCase::ascii(\"vnd.yamaha.hv-dic\"), (663, 664)),(UniCase::ascii(\"vnd.yamaha.hv-script\"), (664, 665)),(UniCase::ascii(\"vnd.yamaha.hv-voice\"), (665, 666)),(UniCase::ascii(\"vnd.yamaha.openscoreformat\"), (666, 667)),(UniCase::ascii(\"vnd.yamaha.openscoreformat.osfpvg+xml\"), (667, 668)),(UniCase::ascii(\"vnd.yamaha.smaf-audio\"), (668, 669)),(UniCase::ascii(\"vnd.yamaha.smaf-phrase\"), (669, 670)),(UniCase::ascii(\"vnd.yellowriver-custom-menu\"), (670, 671)),(UniCase::ascii(\"vnd.zul\"), (671, 673)),(UniCase::ascii(\"vnd.zzazz.deck+xml\"), (673, 674)),(UniCase::ascii(\"voicexml+xml\"), (674, 675)),(UniCase::ascii(\"vsix\"), (675, 676)),(UniCase::ascii(\"wasm\"), (676, 677)),(UniCase::ascii(\"widget\"), (677, 678)),(UniCase::ascii(\"windows-library+xml\"), (678, 679)),(UniCase::ascii(\"windows-search-connector+xml\"), (679, 680)),(UniCase::ascii(\"winhlp\"), (680, 681)),(UniCase::ascii(\"wlmoviemaker\"), (681, 682)),(UniCase::ascii(\"wspolicy+xml\"), (682, 683)),(UniCase::ascii(\"x-7z-compressed\"), (683, 684)),(UniCase::ascii(\"x-abiword\"), (684, 685)),(UniCase::ascii(\"x-ace-compressed\"), (685, 686)),(UniCase::ascii(\"x-arj\"), (686, 687)),(UniCase::ascii(\"x-authorware-bin\"), (687, 690)),(UniCase::ascii(\"x-authorware-map\"), (690, 691)),(UniCase::ascii(\"x-authorware-seg\"), (691, 692)),(UniCase::ascii(\"x-bcpio\"), (692, 693)),(UniCase::ascii(\"x-bittorrent\"), (693, 694)),(UniCase::ascii(\"x-blorb\"), (694, 696)),(UniCase::ascii(\"x-bridge-url\"), (696, 697)),(UniCase::ascii(\"x-bzip\"), (697, 698)),(UniCase::ascii(\"x-bzip2\"), (698, 700)),(UniCase::ascii(\"x-cbr\"), (700, 705)),(UniCase::ascii(\"x-cdf\"), (705, 706)),(UniCase::ascii(\"x-cdlink\"), (706, 707)),(UniCase::ascii(\"x-cfs-compressed\"), (707, 708)),(UniCase::ascii(\"x-chat\"), (708, 709)),(UniCase::ascii(\"x-chess-pgn\"), (709, 710)),(UniCase::ascii(\"x-chrome-extension\"), (710, 711)),(UniCase::ascii(\"x-cocoa\"), (711, 712)),(UniCase::ascii(\"x-compress\"), (712, 713)),(UniCase::ascii(\"x-compressed\"), (713, 714)),(UniCase::ascii(\"x-cpio\"), (714, 715)),(UniCase::ascii(\"x-csh\"), (715, 716)),(UniCase::ascii(\"x-debian-package\"), (716, 717)),(UniCase::ascii(\"x-dgc-compressed\"), (717, 718)),(UniCase::ascii(\"x-director\"), (718, 727)),(UniCase::ascii(\"x-doom\"), (727, 728)),(UniCase::ascii(\"x-dtbncx+xml\"), (728, 729)),(UniCase::ascii(\"x-dtbook+xml\"), (729, 730)),(UniCase::ascii(\"x-dtbresource+xml\"), (730, 731)),(UniCase::ascii(\"x-dvi\"), (731, 732)),(UniCase::ascii(\"x-dxf\"), (732, 733)),(UniCase::ascii(\"x-endace-erf\"), (733, 734)),(UniCase::ascii(\"x-eva\"), (734, 735)),(UniCase::ascii(\"x-font-bdf\"), (735, 736)),(UniCase::ascii(\"x-font-ghostscript\"), (736, 737)),(UniCase::ascii(\"x-font-linux-psf\"), (737, 738)),(UniCase::ascii(\"x-font-pcf\"), (738, 739)),(UniCase::ascii(\"x-font-snf\"), (739, 740)),(UniCase::ascii(\"x-font-ttf\"), (740, 741)),(UniCase::ascii(\"x-font-type1\"), (741, 742)),(UniCase::ascii(\"x-freearc\"), (742, 743)),(UniCase::ascii(\"x-gca-compressed\"), (743, 744)),(UniCase::ascii(\"x-glulx\"), (744, 745)),(UniCase::ascii(\"x-gnumeric\"), (745, 746)),(UniCase::ascii(\"x-gramps-xml\"), (746, 747)),(UniCase::ascii(\"x-gtar\"), (747, 748)),(UniCase::ascii(\"x-gzip\"), (748, 749)),(UniCase::ascii(\"x-hdf\"), (749, 750)),(UniCase::ascii(\"x-httpd-php\"), (750, 751)),(UniCase::ascii(\"x-install-instructions\"), (751, 752)),(UniCase::ascii(\"x-internet-signup\"), (752, 754)),(UniCase::ascii(\"x-iphone\"), (754, 755)),(UniCase::ascii(\"x-itunes-ipa\"), (755, 756)),(UniCase::ascii(\"x-itunes-ipg\"), (756, 757)),(UniCase::ascii(\"x-itunes-ipsw\"), (757, 758)),(UniCase::ascii(\"x-itunes-ite\"), (758, 759)),(UniCase::ascii(\"x-itunes-itlp\"), (759, 760)),(UniCase::ascii(\"x-itunes-itms\"), (760, 761)),(UniCase::ascii(\"x-itunes-itpc\"), (761, 762)),(UniCase::ascii(\"x-java-applet\"), (762, 763)),(UniCase::ascii(\"x-java-archive-diff\"), (763, 764)),(UniCase::ascii(\"x-java-jnlp-file\"), (764, 765)),(UniCase::ascii(\"x-koan\"), (765, 766)),(UniCase::ascii(\"x-latex\"), (766, 767)),(UniCase::ascii(\"x-lua-bytecode\"), (767, 768)),(UniCase::ascii(\"x-lzh-compressed\"), (768, 769)),(UniCase::ascii(\"x-makeself\"), (769, 770)),(UniCase::ascii(\"x-mie\"), (770, 771)),(UniCase::ascii(\"x-miva-compiled\"), (771, 772)),(UniCase::ascii(\"x-mmxp\"), (772, 773)),(UniCase::ascii(\"x-mobipocket-ebook\"), (773, 775)),(UniCase::ascii(\"x-ms-application\"), (775, 776)),(UniCase::ascii(\"x-ms-license\"), (776, 777)),(UniCase::ascii(\"x-ms-manifest\"), (777, 778)),(UniCase::ascii(\"x-ms-reader\"), (778, 779)),(UniCase::ascii(\"x-ms-shortcut\"), (779, 780)),(UniCase::ascii(\"x-ms-vsto\"), (780, 781)),(UniCase::ascii(\"x-ms-wmd\"), (781, 782)),(UniCase::ascii(\"x-ms-wmz\"), (782, 783)),(UniCase::ascii(\"x-ms-xbap\"), (783, 784)),(UniCase::ascii(\"x-msaccess\"), (784, 785)),(UniCase::ascii(\"x-msbinder\"), (785, 786)),(UniCase::ascii(\"x-mscardfile\"), (786, 787)),(UniCase::ascii(\"x-msclip\"), (787, 788)),(UniCase::ascii(\"x-msdownload\"), (788, 791)),(UniCase::ascii(\"x-msmediaview\"), (791, 794)),(UniCase::ascii(\"x-msmetafile\"), (794, 796)),(UniCase::ascii(\"x-msmoney\"), (796, 797)),(UniCase::ascii(\"x-mspublisher\"), (797, 798)),(UniCase::ascii(\"x-msschedule\"), (798, 799)),(UniCase::ascii(\"x-msterminal\"), (799, 800)),(UniCase::ascii(\"x-mswrite\"), (800, 801)),(UniCase::ascii(\"x-netcdf\"), (801, 802)),(UniCase::ascii(\"x-ns-proxy-autoconfig\"), (802, 803)),(UniCase::ascii(\"x-nzb\"), (803, 804)),(UniCase::ascii(\"x-oleobject\"), (804, 805)),(UniCase::ascii(\"x-parquet\"), (805, 806)),(UniCase::ascii(\"x-perfmon\"), (806, 811)),(UniCase::ascii(\"x-perl\"), (811, 813)),(UniCase::ascii(\"x-pkcs12\"), (813, 815)),(UniCase::ascii(\"x-pkcs7-certificates\"), (815, 817)),(UniCase::ascii(\"x-pkcs7-certreqresp\"), (817, 818)),(UniCase::ascii(\"x-podcast\"), (818, 819)),(UniCase::ascii(\"x-quicktimeplayer\"), (819, 820)),(UniCase::ascii(\"x-rar-compressed\"), (820, 821)),(UniCase::ascii(\"x-research-info-systems\"), (821, 822)),(UniCase::ascii(\"x-safari-safariextz\"), (822, 823)),(UniCase::ascii(\"x-safari-webarchive\"), (823, 824)),(UniCase::ascii(\"x-sgimb\"), (824, 825)),(UniCase::ascii(\"x-sh\"), (825, 826)),(UniCase::ascii(\"x-shar\"), (826, 827)),(UniCase::ascii(\"x-shockwave-flash\"), (827, 829)),(UniCase::ascii(\"x-silverlight-app\"), (829, 830)),(UniCase::ascii(\"x-smaf\"), (830, 831)),(UniCase::ascii(\"x-sql\"), (831, 832)),(UniCase::ascii(\"x-stuffit\"), (832, 833)),(UniCase::ascii(\"x-stuffitx\"), (833, 834)),(UniCase::ascii(\"x-subrip\"), (834, 835)),(UniCase::ascii(\"x-sv4cpio\"), (835, 836)),(UniCase::ascii(\"x-sv4crc\"), (836, 837)),(UniCase::ascii(\"x-t3vm-image\"), (837, 838)),(UniCase::ascii(\"x-tads\"), (838, 839)),(UniCase::ascii(\"x-tar\"), (839, 840)),(UniCase::ascii(\"x-tcl\"), (840, 842)),(UniCase::ascii(\"x-tex\"), (842, 843)),(UniCase::ascii(\"x-tex-tfm\"), (843, 844)),(UniCase::ascii(\"x-texinfo\"), (844, 846)),(UniCase::ascii(\"x-tgif\"), (846, 847)),(UniCase::ascii(\"x-troff\"), (847, 850)),(UniCase::ascii(\"x-troff-man\"), (850, 851)),(UniCase::ascii(\"x-troff-me\"), (851, 852)),(UniCase::ascii(\"x-troff-ms\"), (852, 853)),(UniCase::ascii(\"x-ustar\"), (853, 854)),(UniCase::ascii(\"x-virtualbox-hdd\"), (854, 855)),(UniCase::ascii(\"x-virtualbox-ova\"), (855, 856)),(UniCase::ascii(\"x-virtualbox-ovf\"), (856, 857)),(UniCase::ascii(\"x-virtualbox-vbox\"), (857, 858)),(UniCase::ascii(\"x-virtualbox-vbox-extpack\"), (858, 859)),(UniCase::ascii(\"x-virtualbox-vdi\"), (859, 860)),(UniCase::ascii(\"x-virtualbox-vhd\"), (860, 861)),(UniCase::ascii(\"x-virtualbox-vmdk\"), (861, 862)),(UniCase::ascii(\"x-wais-source\"), (862, 863)),(UniCase::ascii(\"x-web-app-manifest+json\"), (863, 864)),(UniCase::ascii(\"x-wlpg-detect\"), (864, 865)),(UniCase::ascii(\"x-wlpg3-detect\"), (865, 866)),(UniCase::ascii(\"x-x509-ca-cert\"), (866, 870)),(UniCase::ascii(\"x-xfig\"), (870, 871)),(UniCase::ascii(\"x-xliff+xml\"), (871, 872)),(UniCase::ascii(\"x-xpinstall\"), (872, 873)),(UniCase::ascii(\"x-xz\"), (873, 874)),(UniCase::ascii(\"x-zmachine\"), (874, 882)),(UniCase::ascii(\"xaml+xml\"), (882, 883)),(UniCase::ascii(\"xcap-diff+xml\"), (883, 884)),(UniCase::ascii(\"xenc+xml\"), (884, 885)),(UniCase::ascii(\"xhtml+xml\"), (885, 887)),(UniCase::ascii(\"xml\"), (887, 931)),(UniCase::ascii(\"xop+xml\"), (931, 932)),(UniCase::ascii(\"xproc+xml\"), (932, 933)),(UniCase::ascii(\"xspf+xml\"), (933, 934)),(UniCase::ascii(\"xv+xml\"), (934, 938)),(UniCase::ascii(\"yang\"), (938, 939)),(UniCase::ascii(\"yin+xml\"), (939, 940)),(UniCase::ascii(\"zip\"), (940, 941)),] }),(UniCase::ascii(\"audio\"), TopLevelExts { start: 941, end: 1007, subs: &[(UniCase::ascii(\"aac\"), (941, 943)),(UniCase::ascii(\"ac3\"), (943, 944)),(UniCase::ascii(\"aiff\"), (944, 948)),(UniCase::ascii(\"annodex\"), (948, 949)),(UniCase::ascii(\"audible\"), (949, 950)),(UniCase::ascii(\"basic\"), (950, 952)),(UniCase::ascii(\"flac\"), (952, 953)),(UniCase::ascii(\"m4a\"), (953, 954)),(UniCase::ascii(\"m4b\"), (954, 955)),(UniCase::ascii(\"m4p\"), (955, 956)),(UniCase::ascii(\"mid\"), (956, 959)),(UniCase::ascii(\"midi\"), (959, 960)),(UniCase::ascii(\"mp4\"), (960, 961)),(UniCase::ascii(\"mpeg\"), (961, 967)),(UniCase::ascii(\"ogg\"), (967, 971)),(UniCase::ascii(\"s3m\"), (971, 972)),(UniCase::ascii(\"scpls\"), (972, 973)),(UniCase::ascii(\"silk\"), (973, 974)),(UniCase::ascii(\"vnd.audible.aax\"), (974, 975)),(UniCase::ascii(\"vnd.dece.audio\"), (975, 977)),(UniCase::ascii(\"vnd.digital-winds\"), (977, 978)),(UniCase::ascii(\"vnd.dlna.adts\"), (978, 979)),(UniCase::ascii(\"vnd.dra\"), (979, 980)),(UniCase::ascii(\"vnd.dts\"), (980, 981)),(UniCase::ascii(\"vnd.dts.hd\"), (981, 982)),(UniCase::ascii(\"vnd.lucent.voice\"), (982, 983)),(UniCase::ascii(\"vnd.ms-playready.media.pya\"), (983, 984)),(UniCase::ascii(\"vnd.nuera.ecelp4800\"), (984, 985)),(UniCase::ascii(\"vnd.nuera.ecelp7470\"), (985, 986)),(UniCase::ascii(\"vnd.nuera.ecelp9600\"), (986, 987)),(UniCase::ascii(\"vnd.rip\"), (987, 988)),(UniCase::ascii(\"wav\"), (988, 990)),(UniCase::ascii(\"webm\"), (990, 991)),(UniCase::ascii(\"x-caf\"), (991, 992)),(UniCase::ascii(\"x-gsm\"), (992, 993)),(UniCase::ascii(\"x-m4r\"), (993, 994)),(UniCase::ascii(\"x-matroska\"), (994, 995)),(UniCase::ascii(\"x-mpegurl\"), (995, 997)),(UniCase::ascii(\"x-ms-wax\"), (997, 998)),(UniCase::ascii(\"x-ms-wma\"), (998, 999)),(UniCase::ascii(\"x-pn-realaudio\"), (999, 1001)),(UniCase::ascii(\"x-pn-realaudio-plugin\"), (1001, 1002)),(UniCase::ascii(\"x-sd2\"), (1002, 1003)),(UniCase::ascii(\"x-smd\"), (1003, 1006)),(UniCase::ascii(\"xm\"), (1006, 1007)),] }),(UniCase::ascii(\"chemical\"), TopLevelExts { start: 1007, end: 1013, subs: &[(UniCase::ascii(\"x-cdx\"), (1007, 1008)),(UniCase::ascii(\"x-cif\"), (1008, 1009)),(UniCase::ascii(\"x-cmdf\"), (1009, 1010)),(UniCase::ascii(\"x-cml\"), (1010, 1011)),(UniCase::ascii(\"x-csml\"), (1011, 1012)),(UniCase::ascii(\"x-xyz\"), (1012, 1013)),] }),(UniCase::ascii(\"drawing\"), TopLevelExts { start: 1013, end: 1014, subs: &[(UniCase::ascii(\"x-dwf\"), (1013, 1014)),] }),(UniCase::ascii(\"font\"), TopLevelExts { start: 1014, end: 1017, subs: &[(UniCase::ascii(\"collection\"), (1014, 1015)),(UniCase::ascii(\"ttf\"), (1015, 1016)),(UniCase::ascii(\"woff2\"), (1016, 1017)),] }),(UniCase::ascii(\"image\"), TopLevelExts { start: 1017, end: 1119, subs: &[(UniCase::ascii(\"apng\"), (1017, 1018)),(UniCase::ascii(\"avif\"), (1018, 1019)),(UniCase::ascii(\"avif-sequence\"), (1019, 1020)),(UniCase::ascii(\"bmp\"), (1020, 1022)),(UniCase::ascii(\"cgm\"), (1022, 1023)),(UniCase::ascii(\"cis-cod\"), (1023, 1024)),(UniCase::ascii(\"g3fax\"), (1024, 1025)),(UniCase::ascii(\"gif\"), (1025, 1026)),(UniCase::ascii(\"heic\"), (1026, 1027)),(UniCase::ascii(\"heic-sequence\"), (1027, 1028)),(UniCase::ascii(\"heif\"), (1028, 1029)),(UniCase::ascii(\"heif-sequence\"), (1029, 1030)),(UniCase::ascii(\"ief\"), (1030, 1031)),(UniCase::ascii(\"jp2\"), (1031, 1033)),(UniCase::ascii(\"jpeg\"), (1033, 1037)),(UniCase::ascii(\"jpm\"), (1037, 1038)),(UniCase::ascii(\"jpx\"), (1038, 1040)),(UniCase::ascii(\"jxl\"), (1040, 1041)),(UniCase::ascii(\"ktx\"), (1041, 1042)),(UniCase::ascii(\"pict\"), (1042, 1045)),(UniCase::ascii(\"png\"), (1045, 1047)),(UniCase::ascii(\"prs.btif\"), (1047, 1048)),(UniCase::ascii(\"sgi\"), (1048, 1049)),(UniCase::ascii(\"svg+xml\"), (1049, 1051)),(UniCase::ascii(\"tiff\"), (1051, 1053)),(UniCase::ascii(\"vnd.dece.graphic\"), (1053, 1057)),(UniCase::ascii(\"vnd.djvu\"), (1057, 1059)),(UniCase::ascii(\"vnd.fastbidsheet\"), (1059, 1060)),(UniCase::ascii(\"vnd.fpx\"), (1060, 1061)),(UniCase::ascii(\"vnd.fst\"), (1061, 1062)),(UniCase::ascii(\"vnd.fujixerox.edmics-mmr\"), (1062, 1063)),(UniCase::ascii(\"vnd.fujixerox.edmics-rlc\"), (1063, 1064)),(UniCase::ascii(\"vnd.ms-modi\"), (1064, 1065)),(UniCase::ascii(\"vnd.ms-photo\"), (1065, 1066)),(UniCase::ascii(\"vnd.net-fpx\"), (1066, 1067)),(UniCase::ascii(\"vnd.radiance\"), (1067, 1068)),(UniCase::ascii(\"vnd.rn-realflash\"), (1068, 1069)),(UniCase::ascii(\"vnd.wap.wbmp\"), (1069, 1070)),(UniCase::ascii(\"vnd.xiff\"), (1070, 1071)),(UniCase::ascii(\"webp\"), (1071, 1072)),(UniCase::ascii(\"x-3ds\"), (1072, 1073)),(UniCase::ascii(\"x-adobe-dng\"), (1073, 1074)),(UniCase::ascii(\"x-canon-cr2\"), (1074, 1075)),(UniCase::ascii(\"x-canon-cr3\"), (1075, 1076)),(UniCase::ascii(\"x-canon-crw\"), (1076, 1077)),(UniCase::ascii(\"x-cmu-raster\"), (1077, 1078)),(UniCase::ascii(\"x-cmx\"), (1078, 1079)),(UniCase::ascii(\"x-epson-erf\"), (1079, 1080)),(UniCase::ascii(\"x-freehand\"), (1080, 1085)),(UniCase::ascii(\"x-fuji-raf\"), (1085, 1086)),(UniCase::ascii(\"x-icon\"), (1086, 1087)),(UniCase::ascii(\"x-jg\"), (1087, 1088)),(UniCase::ascii(\"x-jng\"), (1088, 1089)),(UniCase::ascii(\"x-kodak-dcr\"), (1089, 1090)),(UniCase::ascii(\"x-kodak-k25\"), (1090, 1091)),(UniCase::ascii(\"x-kodak-kdc\"), (1091, 1092)),(UniCase::ascii(\"x-macpaint\"), (1092, 1095)),(UniCase::ascii(\"x-minolta-mrw\"), (1095, 1096)),(UniCase::ascii(\"x-mrsid-image\"), (1096, 1097)),(UniCase::ascii(\"x-nikon-nef\"), (1097, 1098)),(UniCase::ascii(\"x-nikon-nrw\"), (1098, 1099)),(UniCase::ascii(\"x-olympus-orf\"), (1099, 1100)),(UniCase::ascii(\"x-panasonic-rw\"), (1100, 1101)),(UniCase::ascii(\"x-panasonic-rw2\"), (1101, 1103)),(UniCase::ascii(\"x-pentax-pef\"), (1103, 1104)),(UniCase::ascii(\"x-portable-anymap\"), (1104, 1105)),(UniCase::ascii(\"x-portable-bitmap\"), (1105, 1106)),(UniCase::ascii(\"x-portable-graymap\"), (1106, 1107)),(UniCase::ascii(\"x-portable-pixmap\"), (1107, 1108)),(UniCase::ascii(\"x-quicktime\"), (1108, 1110)),(UniCase::ascii(\"x-rgb\"), (1110, 1111)),(UniCase::ascii(\"x-sigma-x3f\"), (1111, 1112)),(UniCase::ascii(\"x-sony-arw\"), (1112, 1113)),(UniCase::ascii(\"x-sony-sr2\"), (1113, 1114)),(UniCase::ascii(\"x-sony-srf\"), (1114, 1115)),(UniCase::ascii(\"x-tga\"), (1115, 1116)),(UniCase::ascii(\"x-xbitmap\"), (1116, 1117)),(UniCase::ascii(\"x-xpixmap\"), (1117, 1118)),(UniCase::ascii(\"x-xwindowdump\"), (1118, 1119)),] }),(UniCase::ascii(\"message\"), TopLevelExts { start: 1119, end: 1129, subs: &[(UniCase::ascii(\"disposition-notification\"), (1119, 1120)),(UniCase::ascii(\"global\"), (1120, 1121)),(UniCase::ascii(\"global-delivery-status\"), (1121, 1122)),(UniCase::ascii(\"global-disposition-notification\"), (1122, 1123)),(UniCase::ascii(\"global-headers\"), (1123, 1124)),(UniCase::ascii(\"rfc822\"), (1124, 1129)),] }),(UniCase::ascii(\"model\"), TopLevelExts { start: 1129, end: 1147, subs: &[(UniCase::ascii(\"gltf+json\"), (1129, 1130)),(UniCase::ascii(\"gltf-binary\"), (1130, 1131)),(UniCase::ascii(\"iges\"), (1131, 1133)),(UniCase::ascii(\"mesh\"), (1133, 1136)),(UniCase::ascii(\"vnd.collada+xml\"), (1136, 1137)),(UniCase::ascii(\"vnd.gdl\"), (1137, 1138)),(UniCase::ascii(\"vnd.gtw\"), (1138, 1139)),(UniCase::ascii(\"vnd.vtu\"), (1139, 1140)),(UniCase::ascii(\"vrml\"), (1140, 1141)),(UniCase::ascii(\"x3d+binary\"), (1141, 1143)),(UniCase::ascii(\"x3d+vrml\"), (1143, 1145)),(UniCase::ascii(\"x3d+xml\"), (1145, 1147)),] }),(UniCase::ascii(\"text\"), TopLevelExts { start: 1147, end: 1330, subs: &[(UniCase::ascii(\"cache-manifest\"), (1147, 1148)),(UniCase::ascii(\"calendar\"), (1148, 1150)),(UniCase::ascii(\"coffeescript\"), (1150, 1152)),(UniCase::ascii(\"css\"), (1152, 1153)),(UniCase::ascii(\"csv\"), (1153, 1154)),(UniCase::ascii(\"dlm\"), (1154, 1155)),(UniCase::ascii(\"gemini\"), (1155, 1157)),(UniCase::ascii(\"h323\"), (1157, 1158)),(UniCase::ascii(\"html\"), (1158, 1162)),(UniCase::ascii(\"iuls\"), (1162, 1163)),(UniCase::ascii(\"jade\"), (1163, 1164)),(UniCase::ascii(\"javascript\"), (1164, 1169)),(UniCase::ascii(\"less\"), (1169, 1170)),(UniCase::ascii(\"markdown\"), (1170, 1172)),(UniCase::ascii(\"mathml\"), (1172, 1173)),(UniCase::ascii(\"n3\"), (1173, 1174)),(UniCase::ascii(\"plain\"), (1174, 1242)),(UniCase::ascii(\"prs.lines.tag\"), (1242, 1243)),(UniCase::ascii(\"richtext\"), (1243, 1244)),(UniCase::ascii(\"scriptlet\"), (1244, 1246)),(UniCase::ascii(\"sgml\"), (1246, 1248)),(UniCase::ascii(\"shex\"), (1248, 1249)),(UniCase::ascii(\"slim\"), (1249, 1251)),(UniCase::ascii(\"stylus\"), (1251, 1253)),(UniCase::ascii(\"tab-separated-values\"), (1253, 1254)),(UniCase::ascii(\"turtle\"), (1254, 1255)),(UniCase::ascii(\"uri-list\"), (1255, 1258)),(UniCase::ascii(\"vbscript\"), (1258, 1259)),(UniCase::ascii(\"vcard\"), (1259, 1260)),(UniCase::ascii(\"vnd.curl\"), (1260, 1261)),(UniCase::ascii(\"vnd.curl.dcurl\"), (1261, 1262)),(UniCase::ascii(\"vnd.curl.mcurl\"), (1262, 1263)),(UniCase::ascii(\"vnd.curl.scurl\"), (1263, 1264)),(UniCase::ascii(\"vnd.dvb.subtitle\"), (1264, 1265)),(UniCase::ascii(\"vnd.fly\"), (1265, 1266)),(UniCase::ascii(\"vnd.fmi.flexstor\"), (1266, 1267)),(UniCase::ascii(\"vnd.graphviz\"), (1267, 1268)),(UniCase::ascii(\"vnd.in3d.3dml\"), (1268, 1269)),(UniCase::ascii(\"vnd.in3d.spot\"), (1269, 1270)),(UniCase::ascii(\"vnd.sun.j2me.app-descriptor\"), (1270, 1271)),(UniCase::ascii(\"vnd.wap.wml\"), (1271, 1272)),(UniCase::ascii(\"vnd.wap.wmlscript\"), (1272, 1273)),(UniCase::ascii(\"vtt\"), (1273, 1274)),(UniCase::ascii(\"webviewhtml\"), (1274, 1275)),(UniCase::ascii(\"x-c\"), (1275, 1276)),(UniCase::ascii(\"x-component\"), (1276, 1277)),(UniCase::ascii(\"x-fortran\"), (1277, 1281)),(UniCase::ascii(\"x-gherkin\"), (1281, 1282)),(UniCase::ascii(\"x-handlebars-template\"), (1282, 1283)),(UniCase::ascii(\"x-hdml\"), (1283, 1284)),(UniCase::ascii(\"x-html-insertion\"), (1284, 1286)),(UniCase::ascii(\"x-lua\"), (1286, 1287)),(UniCase::ascii(\"x-markdown\"), (1287, 1289)),(UniCase::ascii(\"x-ms-contact\"), (1289, 1290)),(UniCase::ascii(\"x-ms-group\"), (1290, 1291)),(UniCase::ascii(\"x-ms-iqy\"), (1291, 1292)),(UniCase::ascii(\"x-ms-rqy\"), (1292, 1293)),(UniCase::ascii(\"x-nfo\"), (1293, 1294)),(UniCase::ascii(\"x-opml\"), (1294, 1295)),(UniCase::ascii(\"x-pascal\"), (1295, 1297)),(UniCase::ascii(\"x-processing\"), (1297, 1298)),(UniCase::ascii(\"x-rust\"), (1298, 1299)),(UniCase::ascii(\"x-sass\"), (1299, 1300)),(UniCase::ascii(\"x-scss\"), (1300, 1301)),(UniCase::ascii(\"x-setext\"), (1301, 1302)),(UniCase::ascii(\"x-sfv\"), (1302, 1303)),(UniCase::ascii(\"x-suse-ymp\"), (1303, 1304)),(UniCase::ascii(\"x-toml\"), (1304, 1305)),(UniCase::ascii(\"x-uuencode\"), (1305, 1306)),(UniCase::ascii(\"x-vcard\"), (1306, 1307)),(UniCase::ascii(\"x-yaml\"), (1307, 1309)),(UniCase::ascii(\"xml\"), (1309, 1330)),] }),(UniCase::ascii(\"video\"), TopLevelExts { start: 1330, end: 1411, subs: &[(UniCase::ascii(\"3gpp\"), (1330, 1332)),(UniCase::ascii(\"3gpp2\"), (1332, 1334)),(UniCase::ascii(\"annodex\"), (1334, 1335)),(UniCase::ascii(\"divx\"), (1335, 1336)),(UniCase::ascii(\"h261\"), (1336, 1337)),(UniCase::ascii(\"h263\"), (1337, 1338)),(UniCase::ascii(\"h264\"), (1338, 1339)),(UniCase::ascii(\"jpeg\"), (1339, 1340)),(UniCase::ascii(\"jpm\"), (1340, 1341)),(UniCase::ascii(\"mj2\"), (1341, 1343)),(UniCase::ascii(\"mp4\"), (1343, 1346)),(UniCase::ascii(\"mpeg\"), (1346, 1357)),(UniCase::ascii(\"ogg\"), (1357, 1358)),(UniCase::ascii(\"quicktime\"), (1358, 1361)),(UniCase::ascii(\"vnd.dece.hd\"), (1361, 1363)),(UniCase::ascii(\"vnd.dece.mobile\"), (1363, 1365)),(UniCase::ascii(\"vnd.dece.pd\"), (1365, 1367)),(UniCase::ascii(\"vnd.dece.sd\"), (1367, 1369)),(UniCase::ascii(\"vnd.dece.video\"), (1369, 1371)),(UniCase::ascii(\"vnd.dlna.mpeg-tts\"), (1371, 1376)),(UniCase::ascii(\"vnd.dvb.file\"), (1376, 1377)),(UniCase::ascii(\"vnd.fvt\"), (1377, 1378)),(UniCase::ascii(\"vnd.mpegurl\"), (1378, 1380)),(UniCase::ascii(\"vnd.ms-playready.media.pyv\"), (1380, 1381)),(UniCase::ascii(\"vnd.uvvu.mp4\"), (1381, 1383)),(UniCase::ascii(\"vnd.vivo\"), (1383, 1384)),(UniCase::ascii(\"webm\"), (1384, 1385)),(UniCase::ascii(\"x-dv\"), (1385, 1387)),(UniCase::ascii(\"x-f4v\"), (1387, 1388)),(UniCase::ascii(\"x-fli\"), (1388, 1389)),(UniCase::ascii(\"x-flv\"), (1389, 1390)),(UniCase::ascii(\"x-ivf\"), (1390, 1391)),(UniCase::ascii(\"x-la-asf\"), (1391, 1393)),(UniCase::ascii(\"x-m4v\"), (1393, 1394)),(UniCase::ascii(\"x-matroska\"), (1394, 1397)),(UniCase::ascii(\"x-mng\"), (1397, 1398)),(UniCase::ascii(\"x-ms-asf\"), (1398, 1402)),(UniCase::ascii(\"x-ms-vob\"), (1402, 1403)),(UniCase::ascii(\"x-ms-wm\"), (1403, 1404)),(UniCase::ascii(\"x-ms-wmp\"), (1404, 1405)),(UniCase::ascii(\"x-ms-wmv\"), (1405, 1406)),(UniCase::ascii(\"x-ms-wmx\"), (1406, 1407)),(UniCase::ascii(\"x-ms-wvx\"), (1407, 1408)),(UniCase::ascii(\"x-msvideo\"), (1408, 1409)),(UniCase::ascii(\"x-sgi-movie\"), (1409, 1410)),(UniCase::ascii(\"x-smv\"), (1410, 1411)),] }),(UniCase::ascii(\"x-conference\"), TopLevelExts { start: 1411, end: 1412, subs: &[(UniCase::ascii(\"x-cooltalk\"), (1411, 1412)),] }),(UniCase::ascii(\"x-world\"), TopLevelExts { start: 1412, end: 1417, subs: &[(UniCase::ascii(\"x-vrml\"), (1412, 1417)),] }),];\nconst EXTS: &'static [&'static str] = &[\"dwg\", \"ez\", \"anx\", \"aw\", \"atom\", \"atomcat\", \"atomsvc\", \"bdoc\", \"ccxml\", \"cdmia\", \"cdmic\", \"cdmid\", \"cdmio\", \"cdmiq\", \"cu\", \"mpd\", \"davmount\", \"x\", \"dbk\", \"dssc\", \"xdssc\", \"emma\", \"evy\", \"epub\", \"etl\", \"exi\", \"otf\", \"ttf\", \"pfr\", \"woff\", \"fif\", \"fsscript\", \"fsx\", \"spl\", \"geojson\", \"gml\", \"gpx\", \"gxf\", \"gz\", \"hjson\", \"hta\", \"stk\", \"ink\", \"inkml\", \"acx\", \"ipfix\", \"ear\", \"jar\", \"war\", \"ser\", \"mjs\", \"json\", \"json5\", \"jsonml\", \"jsonld\", \"jck\", \"jcz\", \"lostxml\", \"hqx\", \"cpt\", \"mads\", \"webmanifest\", \"mrc\", \"mrcx\", \"ma\", \"mb\", \"nb\", \"mathml\", \"mbox\", \"mscml\", \"metalink\", \"meta4\", \"mets\", \"mods\", \"m21\", \"mp21\", \"mp4s\", \"amc\", \"vsi\", \"accdb\", \"accde\", \"accdt\", \"ade\", \"adp\", \"mda\", \"mde\", \"accda\", \"accdc\", \"accft\", \"accdr\", \"accdw\", \"doc\", \"dot\", \"wbk\", \"wiz\", \"mxf\", \"nq\", \"nt\", \"aaf\", \"aca\", \"afm\", \"asd\", \"asi\", \"bin\", \"bpk\", \"buffer\", \"cab\", \"cur\", \"dat\", \"deb\", \"deploy\", \"dist\", \"distz\", \"dmg\", \"dms\", \"dsp\", \"dump\", \"dwp\", \"elc\", \"emz\", \"exe\", \"fla\", \"hhk\", \"hhp\", \"hxd\", \"hxh\", \"hxi\", \"hxq\", \"hxr\", \"hxs\", \"hxw\", \"img\", \"inf\", \"iso\", \"java\", \"jpb\", \"lpk\", \"lrf\", \"lzh\", \"mar\", \"mdp\", \"mix\", \"msi\", \"msm\", \"mso\", \"msp\", \"ocx\", \"pcx\", \"pcz\", \"pfb\", \"pfm\", \"pkg\", \"prm\", \"prx\", \"psd\", \"psm\", \"psp\", \"qxd\", \"rvt\", \"sea\", \"smi\", \"snp\", \"so\", \"thn\", \"toc\", \"u32\", \"xmp\", \"xsn\", \"xtp\", \"oda\", \"opf\", \"ogx\", \"axs\", \"omdoc\", \"one\", \"onea\", \"onepkg\", \"onetmp\", \"onetoc\", \"onetoc2\", \"osdx\", \"oxps\", \"xer\", \"pdf\", \"pgp\", \"asc\", \"sig\", \"prf\", \"p10\", \"p7c\", \"p7m\", \"p7s\", \"p8\", \"ac\", \"crl\", \"pkipath\", \"pki\", \"ai\", \"eps\", \"ps\", \"psc1\", \"cww\", \"pskcxml\", \"raml\", \"rat\", \"rdf\", \"rif\", \"rnc\", \"rl\", \"rld\", \"gbr\", \"mft\", \"roa\", \"rsd\", \"rss\", \"rtf\", \"sbml\", \"scq\", \"scs\", \"spq\", \"spp\", \"sdp\", \"setpay\", \"setreg\", \"shf\", \"smil\", \"rq\", \"srx\", \"gram\", \"grxml\", \"sru\", \"ssdl\", \"ssml\", \"step\", \"stp\", \"ssm\", \"tei\", \"teicorpus\", \"tfi\", \"tsd\", \"trig\", \"plb\", \"psb\", \"pvb\", \"tcap\", \"pwn\", \"aso\", \"imp\", \"acu\", \"acutc\", \"atc\", \"air\", \"fcdt\", \"fxp\", \"fxpl\", \"xdp\", \"xfdf\", \"ahead\", \"azf\", \"azs\", \"azw\", \"acc\", \"ami\", \"apk\", \"cii\", \"fti\", \"atx\", \"parquet\", \"mpkg\", \"pkpass\", \"swi\", \"iota\", \"aep\", \"mpm\", \"bmi\", \"rep\", \"cdxml\", \"mmd\", \"cdy\", \"csl\", \"cla\", \"rp9\", \"c4d\", \"c4f\", \"c4g\", \"c4p\", \"c4u\", \"c11amc\", \"c11amz\", \"csp\", \"cdbcmsg\", \"cmc\", \"clkx\", \"clkk\", \"clkp\", \"clkt\", \"clkw\", \"wbs\", \"ppd\", \"car\", \"pcurl\", \"dart\", \"rdz\", \"uvd\", \"uvf\", \"uvvd\", \"uvvf\", \"uvt\", \"uvvt\", \"uvvx\", \"uvx\", \"uvvz\", \"uvz\", \"fe_launch\", \"dna\", \"mlp\", \"dpg\", \"dfac\", \"kpxx\", \"ait\", \"geo\", \"mag\", \"nml\", \"esf\", \"msf\", \"qam\", \"slt\", \"ssf\", \"es3\", \"et3\", \"ez2\", \"ez3\", \"fdf\", \"mseed\", \"dataless\", \"seed\", \"gph\", \"ftc\", \"book\", \"fm\", \"frame\", \"maker\", \"fnc\", \"ltf\", \"fsc\", \"oas\", \"oa2\", \"oa3\", \"fg5\", \"bh2\", \"ddd\", \"xdw\", \"xbd\", \"fzs\", \"txd\", \"ggb\", \"ggt\", \"gex\", \"gre\", \"gxt\", \"g2w\", \"g3w\", \"gmx\", \"gdoc\", \"gslides\", \"gsheet\", \"kml\", \"kmz\", \"gqf\", \"gqs\", \"gac\", \"ghf\", \"gim\", \"grv\", \"gtm\", \"tpl\", \"vcg\", \"hal\", \"zmm\", \"hbci\", \"les\", \"hpgl\", \"hpid\", \"hps\", \"jlt\", \"pcl\", \"pclxl\", \"sfd-hdstx\", \"mpy\", \"afp\", \"list3820\", \"listafp\", \"irm\", \"sc\", \"icc\", \"icm\", \"igl\", \"ivp\", \"ivu\", \"igm\", \"xpw\", \"xpx\", \"i2g\", \"qbo\", \"qfx\", \"rcprofile\", \"irp\", \"xpr\", \"fcs\", \"jam\", \"rms\", \"jisp\", \"joda\", \"ktr\", \"ktz\", \"karbon\", \"chrt\", \"kfo\", \"flw\", \"kon\", \"kpr\", \"kpt\", \"ksp\", \"kwd\", \"kwt\", \"htke\", \"kia\", \"kne\", \"knp\", \"skd\", \"skm\", \"skt\", \"sse\", \"lasxml\", \"lbd\", \"lbe\", \"123\", \"apr\", \"pre\", \"nsf\", \"org\", \"scm\", \"lwp\", \"portpkg\", \"mcd\", \"mc1\", \"cdkey\", \"mwf\", \"mfm\", \"flo\", \"igx\", \"mif\", \"daf\", \"dis\", \"mbk\", \"mqy\", \"msl\", \"plc\", \"txf\", \"mpn\", \"mpc\", \"xul\", \"cil\", \"slk\", \"xla\", \"xlc\", \"xld\", \"xlk\", \"xll\", \"xlm\", \"xls\", \"xlt\", \"xlw\", \"xlam\", \"xlsb\", \"xlsm\", \"xltm\", \"eot\", \"chm\", \"ims\", \"lrm\", \"mpf\", \"calx\", \"thmx\", \"msg\", \"pst\", \"sst\", \"pko\", \"cat\", \"stl\", \"pot\", \"ppa\", \"pps\", \"ppt\", \"pwz\", \"ppam\", \"pptm\", \"sldm\", \"ppsm\", \"potm\", \"mpp\", \"mpt\", \"vdx\", \"docm\", \"dotm\", \"wcm\", \"wdb\", \"wks\", \"wps\", \"wpl\", \"xps\", \"mseq\", \"mus\", \"msty\", \"taglet\", \"nlu\", \"nitf\", \"ntf\", \"nnd\", \"nns\", \"nnw\", \"ngdat\", \"n-gage\", \"rpst\", \"rpss\", \"edm\", \"edx\", \"ext\", \"odc\", \"otc\", \"odb\", \"odf\", \"odft\", \"odg\", \"otg\", \"odi\", \"oti\", \"odp\", \"otp\", \"ods\", \"ots\", \"odt\", \"odm\", \"ott\", \"oth\", \"xo\", \"dd2\", \"oxt\", \"pptx\", \"sldx\", \"ppsx\", \"potx\", \"xlsx\", \"xltx\", \"docx\", \"dotx\", \"mgp\", \"dp\", \"esa\", \"oprc\", \"pdb\", \"pqa\", \"paw\", \"str\", \"ei6\", \"efif\", \"wg\", \"plf\", \"pbd\", \"box\", \"mgz\", \"qps\", \"ptid\", \"qwd\", \"qwt\", \"qxb\", \"qxl\", \"qxt\", \"bed\", \"mxl\", \"musicxml\", \"cryptonote\", \"rm\", \"rmvb\", \"rmp\", \"link66\", \"st\", \"see\", \"sema\", \"semd\", \"semf\", \"ifm\", \"itp\", \"iif\", \"ipk\", \"twd\", \"twds\", \"teacher\", \"sdkd\", \"sdkm\", \"dxp\", \"sfs\", \"sdc\", \"sda\", \"sdd\", \"smf\", \"sdw\", \"vor\", \"sgl\", \"smzip\", \"sm\", \"wadl\", \"sxc\", \"stc\", \"sxd\", \"std\", \"sxi\", \"sti\", \"sxm\", \"sxw\", \"sxg\", \"stw\", \"sus\", \"susp\", \"svd\", \"sis\", \"sisx\", \"xsm\", \"bdm\", \"xdm\", \"tao\", \"cap\", \"dmp\", \"pcap\", \"tmo\", \"tpt\", \"mxs\", \"tra\", \"ufd\", \"ufdl\", \"utz\", \"umj\", \"unityweb\", \"uoml\", \"vcx\", \"vsd\", \"vss\", \"vst\", \"vsw\", \"vsx\", \"vtx\", \"vis\", \"vsf\", \"wbxml\", \"wmlc\", \"wmlsc\", \"wtb\", \"nbp\", \"wpd\", \"wqd\", \"stf\", \"xar\", \"xfdl\", \"hvd\", \"hvs\", \"hvp\", \"osf\", \"osfpvg\", \"saf\", \"spf\", \"cmp\", \"zir\", \"zirz\", \"zaz\", \"vxml\", \"vsix\", \"wasm\", \"wgt\", \"library-ms\", \"searchconnector-ms\", \"hlp\", \"wlmp\", \"wspolicy\", \"7z\", \"abw\", \"ace\", \"arj\", \"aab\", \"vox\", \"x32\", \"aam\", \"aas\", \"bcpio\", \"torrent\", \"blb\", \"blorb\", \"adobebridge\", \"bz\", \"boz\", \"bz2\", \"cb7\", \"cba\", \"cbr\", \"cbt\", \"cbz\", \"cdf\", \"vcd\", \"cfs\", \"chat\", \"pgn\", \"crx\", \"cco\", \"z\", \"tgz\", \"cpio\", \"csh\", \"udeb\", \"dgc\", \"cct\", \"cst\", \"cxt\", \"dcr\", \"dir\", \"dxr\", \"fgd\", \"swa\", \"w3d\", \"wad\", \"ncx\", \"dtb\", \"res\", \"dvi\", \"dxf\", \"erf\", \"eva\", \"bdf\", \"gsf\", \"psf\", \"pcf\", \"snf\", \"ttf\", \"pfa\", \"arc\", \"gca\", \"ulx\", \"gnumeric\", \"gramps\", \"gtar\", \"gz\", \"hdf\", \"php\", \"install\", \"ins\", \"isp\", \"iii\", \"ipa\", \"ipg\", \"ipsw\", \"ite\", \"itlp\", \"itms\", \"itpc\", \"class\", \"jardiff\", \"jnlp\", \"skp\", \"latex\", \"luac\", \"lha\", \"run\", \"mie\", \"mvc\", \"mxp\", \"mobi\", \"prc\", \"application\", \"slupkg-ms\", \"manifest\", \"lit\", \"lnk\", \"vsto\", \"wmd\", \"wmz\", \"xbap\", \"mdb\", \"obd\", \"crd\", \"clp\", \"bat\", \"com\", \"dll\", \"m13\", \"m14\", \"mvb\", \"emf\", \"wmf\", \"mny\", \"pub\", \"scd\", \"trm\", \"wri\", \"nc\", \"pac\", \"nzb\", \"hhc\", \"parquet\", \"pma\", \"pmc\", \"pml\", \"pmr\", \"pmw\", \"pl\", \"pm\", \"p12\", \"pfx\", \"p7b\", \"spc\", \"p7r\", \"pcast\", \"qtl\", \"rar\", \"ris\", \"safariextz\", \"webarchive\", \"sgimb\", \"sh\", \"shar\", \"mfp\", \"swf\", \"xap\", \"mmf\", \"sql\", \"sit\", \"sitx\", \"srt\", \"sv4cpio\", \"sv4crc\", \"t3\", \"gam\", \"tar\", \"tcl\", \"tk\", \"tex\", \"tfm\", \"texi\", \"texinfo\", \"obj\", \"roff\", \"t\", \"tr\", \"man\", \"me\", \"ms\", \"ustar\", \"hdd\", \"ova\", \"ovf\", \"vbox\", \"vbox-extpack\", \"vdi\", \"vhd\", \"vmdk\", \"src\", \"webapp\", \"wlpginstall\", \"wlpginstall3\", \"cer\", \"crt\", \"der\", \"pem\", \"fig\", \"xlf\", \"xpi\", \"xz\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\", \"z8\", \"xaml\", \"xdf\", \"xenc\", \"xht\", \"xhtml\", \"asa\", \"asax\", \"ascx\", \"ashx\", \"asmx\", \"aspx\", \"config\", \"coverage\", \"datasource\", \"dgml\", \"filters\", \"generictest\", \"hxa\", \"hxc\", \"hxe\", \"hxf\", \"hxk\", \"hxv\", \"loadtest\", \"master\", \"mtx\", \"orderedtest\", \"psess\", \"rdlc\", \"resx\", \"rng\", \"ruleset\", \"settings\", \"sitemap\", \"skin\", \"snippet\", \"svc\", \"testrunconfig\", \"testsettings\", \"trx\", \"vcproj\", \"vcxproj\", \"vscontent\", \"vsmdi\", \"webtest\", \"wiq\", \"xmta\", \"xsc\", \"xss\", \"xop\", \"xpl\", \"xspf\", \"mxml\", \"xhvml\", \"xvm\", \"xvml\", \"yang\", \"yin\", \"zip\", \"aac\", \"adts\", \"ac3\", \"aif\", \"aifc\", \"aiff\", \"cdda\", \"axa\", \"aa\", \"au\", \"snd\", \"flac\", \"m4a\", \"m4b\", \"m4p\", \"mid\", \"midi\", \"rmi\", \"kar\", \"mp4a\", \"m2a\", \"m3a\", \"mp2\", \"mp2a\", \"mp3\", \"mpga\", \"oga\", \"ogg\", \"opus\", \"spx\", \"s3m\", \"pls\", \"sil\", \"aax\", \"uva\", \"uvva\", \"eol\", \"adt\", \"dra\", \"dts\", \"dtshd\", \"lvp\", \"pya\", \"ecelp4800\", \"ecelp7470\", \"ecelp9600\", \"rip\", \"wav\", \"wave\", \"weba\", \"caf\", \"gsm\", \"m4r\", \"mka\", \"m3u\", \"m3u8\", \"wax\", \"wma\", \"ra\", \"ram\", \"rpm\", \"sd2\", \"smd\", \"smx\", \"smz\", \"xm\", \"cdx\", \"cif\", \"cmdf\", \"cml\", \"csml\", \"xyz\", \"dwf\", \"ttc\", \"ttf\", \"woff2\", \"apng\", \"avif\", \"avifs\", \"bmp\", \"dib\", \"cgm\", \"cod\", \"g3\", \"gif\", \"heic\", \"heics\", \"heif\", \"heifs\", \"ief\", \"jp2\", \"jpg2\", \"jfif\", \"jpe\", \"jpeg\", \"jpg\", \"jpm\", \"jpf\", \"jpx\", \"jxl\", \"ktx\", \"pct\", \"pic\", \"pict\", \"png\", \"pnz\", \"btif\", \"sgi\", \"svg\", \"svgz\", \"tif\", \"tiff\", \"uvg\", \"uvi\", \"uvvg\", \"uvvi\", \"djv\", \"djvu\", \"fbs\", \"fpx\", \"fst\", \"mmr\", \"rlc\", \"mdi\", \"wdp\", \"npx\", \"hdr\", \"rf\", \"wbmp\", \"xif\", \"webp\", \"3ds\", \"dng\", \"cr2\", \"cr3\", \"crw\", \"ras\", \"cmx\", \"erf\", \"fh\", \"fh4\", \"fh5\", \"fh7\", \"fhc\", \"raf\", \"ico\", \"art\", \"jng\", \"dcr\", \"k25\", \"kdc\", \"mac\", \"pnt\", \"pntg\", \"mrw\", \"sid\", \"nef\", \"nrw\", \"orf\", \"raw\", \"rw2\", \"rwl\", \"pef\", \"pnm\", \"pbm\", \"pgm\", \"ppm\", \"qti\", \"qtif\", \"rgb\", \"x3f\", \"arw\", \"sr2\", \"srf\", \"tga\", \"xbm\", \"xpm\", \"xwd\", \"disposition-notification\", \"u8msg\", \"u8dsn\", \"u8mdn\", \"u8hdr\", \"eml\", \"mht\", \"mhtml\", \"mime\", \"nws\", \"gltf\", \"glb\", \"iges\", \"igs\", \"mesh\", \"msh\", \"silo\", \"dae\", \"gdl\", \"gtw\", \"vtu\", \"vrml\", \"x3db\", \"x3dbz\", \"x3dv\", \"x3dvz\", \"x3d\", \"x3dz\", \"appcache\", \"ics\", \"ifb\", \"coffee\", \"litcoffee\", \"css\", \"csv\", \"dlm\", \"gemini\", \"gmi\", \"323\", \"htm\", \"html\", \"hxt\", \"shtml\", \"uls\", \"jade\", \"ecma\", \"es\", \"js\", \"jsm\", \"jsx\", \"less\", \"markdown\", \"md\", \"mml\", \"n3\", \"asm\", \"bas\", \"c\", \"cc\", \"cd\", \"cfg\", \"cmd\", \"cnf\", \"conf\", \"cpp\", \"cs\", \"csdproj\", \"csproj\", \"cxx\", \"dbproj\", \"def\", \"dsw\", \"h\", \"hh\", \"hpp\", \"hxx\", \"i\", \"idl\", \"in\", \"inc\", \"ini\", \"inl\", \"ipproj\", \"jsxbin\", \"list\", \"log\", \"lst\", \"mak\", \"map\", \"mk\", \"odh\", \"odl\", \"pkgdef\", \"pkgundef\", \"py\", \"rc\", \"rc2\", \"rct\", \"reg\", \"rgs\", \"s\", \"scr\", \"sln\", \"sol\", \"sor\", \"srf\", \"text\", \"tlh\", \"tli\", \"txt\", \"user\", \"vb\", \"vbdproj\", \"vbproj\", \"vcs\", \"vddproj\", \"vdp\", \"vdproj\", \"vspscc\", \"vsscc\", \"vssscc\", \"xdr\", \"xoml\", \"dsc\", \"rtx\", \"sct\", \"wsc\", \"sgm\", \"sgml\", \"shex\", \"slim\", \"slm\", \"styl\", \"stylus\", \"tsv\", \"ttl\", \"uri\", \"uris\", \"urls\", \"vbs\", \"vcard\", \"curl\", \"dcurl\", \"mcurl\", \"scurl\", \"sub\", \"fly\", \"flx\", \"gv\", \"3dml\", \"spot\", \"jad\", \"wml\", \"wmls\", \"vtt\", \"htt\", \"dic\", \"htc\", \"f\", \"f77\", \"f90\", \"for\", \"feature\", \"hbs\", \"hdml\", \"qht\", \"qhtm\", \"lua\", \"md\", \"mkd\", \"contact\", \"group\", \"iqy\", \"rqy\", \"nfo\", \"opml\", \"p\", \"pas\", \"pde\", \"rs\", \"sass\", \"scss\", \"etx\", \"sfv\", \"ymp\", \"toml\", \"uu\", \"vcf\", \"yaml\", \"yml\", \"addin\", \"disco\", \"dll.config\", \"dtd\", \"dtsconfig\", \"exe.config\", \"mno\", \"ssisdeploymentmanifest\", \"vml\", \"vsct\", \"vsixlangpack\", \"vsixmanifest\", \"vssettings\", \"vstemplate\", \"wsdl\", \"xml\", \"xrm-ms\", \"xsd\", \"xsf\", \"xsl\", \"xslt\", \"3gp\", \"3gpp\", \"3g2\", \"3gp2\", \"axv\", \"divx\", \"h261\", \"h263\", \"h264\", \"jpgv\", \"jpgm\", \"mj2\", \"mjp2\", \"mp4\", \"mp4v\", \"mpg4\", \"m1v\", \"m2v\", \"mod\", \"mp2\", \"mp2v\", \"mpa\", \"mpe\", \"mpeg\", \"mpg\", \"mpv2\", \"vbk\", \"ogv\", \"mov\", \"mqv\", \"qt\", \"uvh\", \"uvvh\", \"uvm\", \"uvvm\", \"uvp\", \"uvvp\", \"uvs\", \"uvvs\", \"uvv\", \"uvvv\", \"m2t\", \"m2ts\", \"mts\", \"ts\", \"tts\", \"dvb\", \"fvt\", \"m4u\", \"mxu\", \"pyv\", \"uvu\", \"uvvu\", \"viv\", \"webm\", \"dif\", \"dv\", \"f4v\", \"fli\", \"flv\", \"ivf\", \"lsf\", \"lsx\", \"m4v\", \"mk3d\", \"mks\", \"mkv\", \"mng\", \"asf\", \"asr\", \"asx\", \"nsc\", \"vob\", \"wm\", \"wmp\", \"wmv\", \"wmx\", \"wvx\", \"avi\", \"movie\", \"smv\", \"ice\", \"flr\", \"wrl\", \"wrz\", \"xaf\", \"xof\"];\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","target","debug","build","selectors-3ba23bf78d2a15c4","out","ascii_case_insensitive_html_attributes.rs"],"content":"{ static SET: ::phf::Set<&'static str> = ::phf::Set { map: ::phf::Map {\n    key: 10121458955350035957,\n    disps: &[\n        (0, 2),\n        (8, 17),\n        (1, 5),\n        (0, 0),\n        (0, 20),\n        (0, 3),\n        (15, 2),\n        (17, 19),\n        (8, 9),\n        (0, 15),\n    ],\n    entries: &[\n        (\"dir\", ()),\n        (\"http-equiv\", ()),\n        (\"rel\", ()),\n        (\"enctype\", ()),\n        (\"align\", ()),\n        (\"accept\", ()),\n        (\"nohref\", ()),\n        (\"lang\", ()),\n        (\"bgcolor\", ()),\n        (\"direction\", ()),\n        (\"valign\", ()),\n        (\"checked\", ()),\n        (\"frame\", ()),\n        (\"link\", ()),\n        (\"accept-charset\", ()),\n        (\"hreflang\", ()),\n        (\"text\", ()),\n        (\"valuetype\", ()),\n        (\"language\", ()),\n        (\"nowrap\", ()),\n        (\"vlink\", ()),\n        (\"disabled\", ()),\n        (\"noshade\", ()),\n        (\"codetype\", ()),\n        (\"defer\", ()),\n        (\"noresize\", ()),\n        (\"target\", ()),\n        (\"scrolling\", ()),\n        (\"rules\", ()),\n        (\"scope\", ()),\n        (\"rev\", ()),\n        (\"media\", ()),\n        (\"method\", ()),\n        (\"charset\", ()),\n        (\"alink\", ()),\n        (\"selected\", ()),\n        (\"multiple\", ()),\n        (\"color\", ()),\n        (\"shape\", ()),\n        (\"type\", ()),\n        (\"clear\", ()),\n        (\"compact\", ()),\n        (\"face\", ()),\n        (\"declare\", ()),\n        (\"axis\", ()),\n        (\"readonly\", ()),\n    ],\n} }; &SET }","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","target","debug","build","serde-3740e996109640cc","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","target","debug","build","serde-e4c917075b3481f4","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","target","debug","build","serde_core-60a026f1211c8681","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","target","debug","build","serde_core-cadfe6cc5a4041df","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","target","debug","build","thiserror-137405de7d0ab17e","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private17 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","target","debug","build","typenum-890f80986b7746c4","out","tests.rs"],"content":"\nuse typenum::*;\nuse core::ops::*;\nuse core::cmp::Ordering;\n\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU0 = <<A as BitOr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitOrU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU0 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitXorU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU0 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU0 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU0 = <<A as Add<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0AddU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU0 = <<A as Max<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MaxU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU0 = <<A as Gcd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0GcdU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Sub_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0SubU0 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0SubU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_0() {\n    type A = UTerm;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU0 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU1 = <<A as BitOr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0BitOrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU1 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0BitXorU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU1 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU1 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU1 = <<A as Add<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0AddU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU1 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU1 = <<A as Pow<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PowU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU1 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU1 = <<A as Max<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0MaxU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U0GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU1 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0DivU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PartialDivU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_1() {\n    type A = UTerm;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU2 = <<A as BitOr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U0BitOrU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU2 = <<A as BitXor<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U0BitXorU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU2 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU2 = <<A as Add<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U0AddU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU2 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU2 = <<A as Pow<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PowU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU2 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U0MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U0GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU2 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0DivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PartialDivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_2() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU3 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U0BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU3 = <<A as BitXor<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U0BitXorU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU3 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU3 = <<A as Add<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U0AddU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU3 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU3 = <<A as Pow<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PowU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU3 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U0MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU3 = <<A as Gcd<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U0GcdU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU3 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0RemU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU3 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PartialDivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_3() {\n    type A = UTerm;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU4 = <<A as BitOr<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U0BitOrU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU4 = <<A as BitXor<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U0BitXorU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU4 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU4 = <<A as Add<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U0AddU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU4 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU4 = <<A as Pow<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PowU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU4 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U0MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU4 = <<A as Gcd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U0GcdU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU4 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0RemU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU4 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PartialDivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_4() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU5 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0BitAndU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U0BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU5 = <<A as BitXor<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U0BitXorU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU5 = <<A as Shl<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShlU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU5 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U0AddU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU5 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MulU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU5 = <<A as Pow<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PowU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU5 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0MinU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U0MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU5 = <<A as Gcd<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U0GcdU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU5 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0RemU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU5 = <<A as PartialDiv<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U0PartialDivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_5() {\n    type A = UTerm;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U0CmpU5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU0 = <<A as BitOr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitOrU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU0 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitXorU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU0 = <<A as Shl<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1ShlU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU0 = <<A as Shr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1ShrU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU0 = <<A as Add<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1AddU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU0 = <<A as Max<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MaxU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU0 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU0 = <<A as Sub<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1SubU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_0() {\n    type A = UInt<UTerm, B1>;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU1 = <<A as BitOr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitOrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU1 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1BitXorU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU1 = <<A as Shl<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U1ShlU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU1 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1ShrU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU1 = <<A as Add<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U1AddU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU1 = <<A as Mul<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MulU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU1 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU1 = <<A as Max<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MaxU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU1 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1SubU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU1 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1DivU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_PartialDiv_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PartialDivU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_1() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU1 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU2 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1BitOrU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU2 = <<A as BitXor<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1BitXorU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU2 = <<A as Shl<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U1ShlU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU2 = <<A as Add<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1AddU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU2 = <<A as Mul<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U1MulU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU2 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU2 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MinU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U1MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU2 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1DivU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_2() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU3 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitAndU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU3 = <<A as BitXor<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U1BitXorU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU3 = <<A as Shl<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U1ShlU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU3 = <<A as Add<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U1AddU3 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU3 = <<A as Mul<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1MulU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU3 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU3 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MinU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U1MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU3 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1RemU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_3() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU4 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1BitOrU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU4 = <<A as BitXor<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1BitXorU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU4 = <<A as Shl<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U1ShlU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU4 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1AddU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU4 = <<A as Mul<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U1MulU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU4 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU4 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MinU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U1MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU4 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1RemU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_4() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU5 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1BitAndU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU5 = <<A as BitXor<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U1BitXorU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU5 = <<A as Shl<B>>::Output as Same<U32>>::Output;\n\n    assert_eq!(<U1ShlU5 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU5 = <<A as Add<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U1AddU5 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU5 = <<A as Mul<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1MulU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU5 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1PowU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU5 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1MinU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U1MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U1DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU5 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U1RemU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_5() {\n    type A = UInt<UTerm, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U1CmpU5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU0 = <<A as BitOr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2BitOrU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU0 = <<A as BitXor<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2BitXorU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU0 = <<A as Shl<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2ShlU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU0 = <<A as Shr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2ShrU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU0 = <<A as Add<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2AddU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU0 = <<A as Max<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MaxU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU0 = <<A as Gcd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2GcdU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU0 = <<A as Sub<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2SubU0 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_0() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU1 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U2BitOrU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU1 = <<A as BitXor<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U2BitXorU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU1 = <<A as Shl<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U2ShlU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU1 = <<A as Shr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2ShrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU1 = <<A as Add<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U2AddU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU1 = <<A as Mul<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MulU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU1 = <<A as Pow<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2PowU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU1 = <<A as Max<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MaxU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU1 = <<A as Sub<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2SubU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU1 = <<A as Div<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2DivU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2PartialDivU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_1() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU2 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2BitAndU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU2 = <<A as BitOr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2BitOrU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU2 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2BitXorU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU2 = <<A as Shl<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U2ShlU2 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU2 = <<A as Add<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U2AddU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU2 = <<A as Mul<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U2MulU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU2 = <<A as Pow<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U2PowU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU2 = <<A as Max<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MaxU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU2 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2SubU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU2 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2DivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2PartialDivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_2() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU2 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU3 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2BitAndU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U2BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU3 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2BitXorU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU3 = <<A as Shl<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U2ShlU3 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU3 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U2AddU3 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU3 = <<A as Mul<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U2MulU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU3 = <<A as Pow<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U2PowU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU3 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MinU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U2MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU3 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2DivU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU3 = <<A as Rem<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2RemU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_3() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU4 = <<A as BitOr<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U2BitOrU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU4 = <<A as BitXor<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U2BitXorU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU4 = <<A as Shl<B>>::Output as Same<U32>>::Output;\n\n    assert_eq!(<U2ShlU4 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU4 = <<A as Add<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U2AddU4 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU4 = <<A as Mul<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U2MulU4 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU4 = <<A as Pow<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U2PowU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU4 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MinU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U2MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU4 = <<A as Gcd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2GcdU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU4 = <<A as Rem<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2RemU4 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_4() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU5 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2BitAndU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU5 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U2BitOrU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU5 = <<A as BitXor<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U2BitXorU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU5 = <<A as Shl<B>>::Output as Same<U64>>::Output;\n\n    assert_eq!(<U2ShlU5 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU5 = <<A as Add<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U2AddU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU5 = <<A as Mul<B>>::Output as Same<U10>>::Output;\n\n    assert_eq!(<U2MulU5 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU5 = <<A as Pow<B>>::Output as Same<U32>>::Output;\n\n    assert_eq!(<U2PowU5 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU5 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2MinU5 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U2MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U2GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U2DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU5 = <<A as Rem<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U2RemU5 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_5() {\n    type A = UInt<UInt<UTerm, B1>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U2CmpU5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU0 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitOrU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU0 = <<A as BitXor<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitXorU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU0 = <<A as Shl<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3ShlU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU0 = <<A as Shr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3ShrU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU0 = <<A as Add<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3AddU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU0 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MaxU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU0 = <<A as Gcd<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3GcdU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU0 = <<A as Sub<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3SubU0 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_0() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU1 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitOrU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU1 = <<A as BitXor<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U3BitXorU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU1 = <<A as Shl<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U3ShlU1 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU1 = <<A as Shr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3ShrU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU1 = <<A as Add<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U3AddU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU1 = <<A as Mul<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MulU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU1 = <<A as Pow<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3PowU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU1 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MaxU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU1 = <<A as Sub<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U3SubU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU1 = <<A as Div<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3DivU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3PartialDivU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_1() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU2 = <<A as BitAnd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U3BitAndU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU2 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitOrU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU2 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3BitXorU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU2 = <<A as Shl<B>>::Output as Same<U12>>::Output;\n\n    assert_eq!(<U3ShlU2 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU2 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3ShrU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU2 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U3AddU2 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU2 = <<A as Mul<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U3MulU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU2 = <<A as Pow<B>>::Output as Same<U9>>::Output;\n\n    assert_eq!(<U3PowU2 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U3MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU2 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MaxU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU2 = <<A as Sub<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3SubU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU2 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3DivU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_2() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU3 = <<A as BitAnd<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitAndU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU3 = <<A as BitOr<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3BitOrU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU3 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3BitXorU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U24 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU3 = <<A as Shl<B>>::Output as Same<U24>>::Output;\n\n    assert_eq!(<U3ShlU3 as Unsigned>::to_u64(), <U24 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU3 = <<A as Add<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U3AddU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU3 = <<A as Mul<B>>::Output as Same<U9>>::Output;\n\n    assert_eq!(<U3MulU3 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U27 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU3 = <<A as Pow<B>>::Output as Same<U27>>::Output;\n\n    assert_eq!(<U3PowU3 as Unsigned>::to_u64(), <U27 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU3 = <<A as Max<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MaxU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU3 = <<A as Gcd<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3GcdU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU3 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3SubU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU3 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3RemU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU3 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3PartialDivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_3() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU3 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU4 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3BitAndU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU4 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U3BitOrU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU4 = <<A as BitXor<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U3BitXorU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U48 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU4 = <<A as Shl<B>>::Output as Same<U48>>::Output;\n\n    assert_eq!(<U3ShlU4 as Unsigned>::to_u64(), <U48 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU4 = <<A as Add<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U3AddU4 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU4 = <<A as Mul<B>>::Output as Same<U12>>::Output;\n\n    assert_eq!(<U3MulU4 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U81 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU4 = <<A as Pow<B>>::Output as Same<U81>>::Output;\n\n    assert_eq!(<U3PowU4 as Unsigned>::to_u64(), <U81 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU4 = <<A as Min<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MinU4 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U3MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU4 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3DivU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU4 = <<A as Rem<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3RemU4 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_4() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU5 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3BitAndU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU5 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U3BitOrU5 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU5 = <<A as BitXor<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U3BitXorU5 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U96 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU5 = <<A as Shl<B>>::Output as Same<U96>>::Output;\n\n    assert_eq!(<U3ShlU5 as Unsigned>::to_u64(), <U96 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU5 = <<A as Add<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U3AddU5 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U15 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU5 = <<A as Mul<B>>::Output as Same<U15>>::Output;\n\n    assert_eq!(<U3MulU5 as Unsigned>::to_u64(), <U15 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U243 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU5 = <<A as Pow<B>>::Output as Same<U243>>::Output;\n\n    assert_eq!(<U3PowU5 as Unsigned>::to_u64(), <U243 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU5 = <<A as Min<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3MinU5 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U3MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U3GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U3DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU5 = <<A as Rem<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U3RemU5 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_5() {\n    type A = UInt<UInt<UTerm, B1>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U3CmpU5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU0 = <<A as BitOr<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4BitOrU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU0 = <<A as BitXor<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4BitXorU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU0 = <<A as Shl<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4ShlU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU0 = <<A as Shr<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4ShrU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU0 = <<A as Add<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4AddU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU0 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MaxU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU0 = <<A as Gcd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4GcdU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU0 = <<A as Sub<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4SubU0 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU1 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4BitAndU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU1 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U4BitOrU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU1 = <<A as BitXor<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U4BitXorU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU1 = <<A as Shl<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U4ShlU1 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU1 = <<A as Shr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4ShrU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU1 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U4AddU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU1 = <<A as Mul<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MulU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU1 = <<A as Pow<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4PowU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU1 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MaxU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU1 = <<A as Sub<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U4SubU1 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU1 = <<A as Div<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4DivU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4PartialDivU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU2 = <<A as BitOr<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U4BitOrU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU2 = <<A as BitXor<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U4BitXorU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU2 = <<A as Shl<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U4ShlU2 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU2 = <<A as Shr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4ShrU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU2 = <<A as Add<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U4AddU2 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU2 = <<A as Mul<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U4MulU2 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU2 = <<A as Pow<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U4PowU2 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU2 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MaxU2 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU2 = <<A as Gcd<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4GcdU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU2 = <<A as Sub<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4SubU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU2 = <<A as Div<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4DivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU2 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4RemU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU2 = <<A as PartialDiv<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U4PartialDivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU3 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4BitAndU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU3 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U4BitOrU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU3 = <<A as BitXor<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U4BitXorU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U32 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU3 = <<A as Shl<B>>::Output as Same<U32>>::Output;\n\n    assert_eq!(<U4ShlU3 as Unsigned>::to_u64(), <U32 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU3 = <<A as Add<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U4AddU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U12 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU3 = <<A as Mul<B>>::Output as Same<U12>>::Output;\n\n    assert_eq!(<U4MulU3 as Unsigned>::to_u64(), <U12 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU3 = <<A as Pow<B>>::Output as Same<U64>>::Output;\n\n    assert_eq!(<U4PowU3 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U4MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU3 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MaxU3 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU3 = <<A as Sub<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4SubU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU3 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4RemU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU4 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4BitAndU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU4 = <<A as BitOr<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4BitOrU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU4 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4BitXorU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U64 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU4 = <<A as Shl<B>>::Output as Same<U64>>::Output;\n\n    assert_eq!(<U4ShlU4 as Unsigned>::to_u64(), <U64 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU4 = <<A as Add<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U4AddU4 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U16 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU4 = <<A as Mul<B>>::Output as Same<U16>>::Output;\n\n    assert_eq!(<U4MulU4 as Unsigned>::to_u64(), <U16 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U256 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU4 = <<A as Pow<B>>::Output as Same<U256>>::Output;\n\n    assert_eq!(<U4PowU4 as Unsigned>::to_u64(), <U256 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU4 = <<A as Min<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MinU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU4 = <<A as Max<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MaxU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU4 = <<A as Gcd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4GcdU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU4 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4SubU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU4 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4DivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU4 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4RemU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU4 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4PartialDivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU4 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU5 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4BitAndU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U4BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU5 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4BitXorU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U128 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU5 = <<A as Shl<B>>::Output as Same<U128>>::Output;\n\n    assert_eq!(<U4ShlU5 as Unsigned>::to_u64(), <U128 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU5 = <<A as Add<B>>::Output as Same<U9>>::Output;\n\n    assert_eq!(<U4AddU5 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU5 = <<A as Mul<B>>::Output as Same<U20>>::Output;\n\n    assert_eq!(<U4MulU5 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1024 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU5 = <<A as Pow<B>>::Output as Same<U1024>>::Output;\n\n    assert_eq!(<U4PowU5 as Unsigned>::to_u64(), <U1024 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU5 = <<A as Min<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4MinU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U4MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU5 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U4GcdU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU5 = <<A as Div<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U4DivU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU5 = <<A as Rem<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U4RemU5 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U4CmpU5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU0 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5BitAndU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU0 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitOrU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU0 = <<A as BitXor<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitXorU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU0 = <<A as Shl<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5ShlU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU0 = <<A as Shr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5ShrU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU0 = <<A as Add<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5AddU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU0 = <<A as Mul<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5MulU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU0 = <<A as Pow<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5PowU0 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU0 = <<A as Min<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5MinU0 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU0 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU0 = <<A as Gcd<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5GcdU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU0 = <<A as Sub<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5SubU0 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_0() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU0 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU1 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5BitAndU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU1 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitOrU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU1 = <<A as BitXor<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U5BitXorU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU1 = <<A as Shl<B>>::Output as Same<U10>>::Output;\n\n    assert_eq!(<U5ShlU1 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU1 = <<A as Shr<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U5ShrU1 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU1 = <<A as Add<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U5AddU1 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU1 = <<A as Mul<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MulU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU1 = <<A as Pow<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5PowU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU1 = <<A as Min<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5MinU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU1 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU1 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5GcdU1 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU1 = <<A as Sub<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U5SubU1 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU1 = <<A as Div<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5DivU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU1 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5RemU1 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU1 = <<A as PartialDiv<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5PartialDivU1 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_1() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU1 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU2 = <<A as BitAnd<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5BitAndU2 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU2 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U5BitOrU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU2 = <<A as BitXor<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U5BitXorU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU2 = <<A as Shl<B>>::Output as Same<U20>>::Output;\n\n    assert_eq!(<U5ShlU2 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU2 = <<A as Shr<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5ShrU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU2 = <<A as Add<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U5AddU2 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU2 = <<A as Mul<B>>::Output as Same<U10>>::Output;\n\n    assert_eq!(<U5MulU2 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U25 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU2 = <<A as Pow<B>>::Output as Same<U25>>::Output;\n\n    assert_eq!(<U5PowU2 as Unsigned>::to_u64(), <U25 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU2 = <<A as Min<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U5MinU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU2 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU2 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU2 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5GcdU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU2 = <<A as Sub<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U5SubU2 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU2 = <<A as Div<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U5DivU2 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU2 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5RemU2 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_2() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU2 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU3 = <<A as BitAnd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5BitAndU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U7 = UInt<UInt<UInt<UTerm, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU3 = <<A as BitOr<B>>::Output as Same<U7>>::Output;\n\n    assert_eq!(<U5BitOrU3 as Unsigned>::to_u64(), <U7 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU3 = <<A as BitXor<B>>::Output as Same<U6>>::Output;\n\n    assert_eq!(<U5BitXorU3 as Unsigned>::to_u64(), <U6 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U40 = UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU3 = <<A as Shl<B>>::Output as Same<U40>>::Output;\n\n    assert_eq!(<U5ShlU3 as Unsigned>::to_u64(), <U40 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU3 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5ShrU3 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U8 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU3 = <<A as Add<B>>::Output as Same<U8>>::Output;\n\n    assert_eq!(<U5AddU3 as Unsigned>::to_u64(), <U8 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U15 = UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU3 = <<A as Mul<B>>::Output as Same<U15>>::Output;\n\n    assert_eq!(<U5MulU3 as Unsigned>::to_u64(), <U15 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U125 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU3 = <<A as Pow<B>>::Output as Same<U125>>::Output;\n\n    assert_eq!(<U5PowU3 as Unsigned>::to_u64(), <U125 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U3 = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU3 = <<A as Min<B>>::Output as Same<U3>>::Output;\n\n    assert_eq!(<U5MinU3 as Unsigned>::to_u64(), <U3 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU3 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU3 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU3 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5GcdU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU3 = <<A as Sub<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U5SubU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU3 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5DivU3 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n    type U2 = UInt<UInt<UTerm, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU3 = <<A as Rem<B>>::Output as Same<U2>>::Output;\n\n    assert_eq!(<U5RemU3 as Unsigned>::to_u64(), <U2 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_3() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UTerm, B1>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU3 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU4 = <<A as BitAnd<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U5BitAndU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU4 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitOrU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU4 = <<A as BitXor<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5BitXorU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U80 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU4 = <<A as Shl<B>>::Output as Same<U80>>::Output;\n\n    assert_eq!(<U5ShlU4 as Unsigned>::to_u64(), <U80 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU4 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5ShrU4 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U9 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU4 = <<A as Add<B>>::Output as Same<U9>>::Output;\n\n    assert_eq!(<U5AddU4 as Unsigned>::to_u64(), <U9 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U20 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU4 = <<A as Mul<B>>::Output as Same<U20>>::Output;\n\n    assert_eq!(<U5MulU4 as Unsigned>::to_u64(), <U20 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U625 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU4 = <<A as Pow<B>>::Output as Same<U625>>::Output;\n\n    assert_eq!(<U5PowU4 as Unsigned>::to_u64(), <U625 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U4 = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU4 = <<A as Min<B>>::Output as Same<U4>>::Output;\n\n    assert_eq!(<U5MinU4 as Unsigned>::to_u64(), <U4 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU4 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU4 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU4 = <<A as Gcd<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5GcdU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU4 = <<A as Sub<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5SubU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU4 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5DivU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU4 = <<A as Rem<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5RemU4 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_4() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU4 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU5 = <<A as BitAnd<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitAndU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU5 = <<A as BitOr<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5BitOrU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU5 = <<A as BitXor<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5BitXorU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U160 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B0>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU5 = <<A as Shl<B>>::Output as Same<U160>>::Output;\n\n    assert_eq!(<U5ShlU5 as Unsigned>::to_u64(), <U160 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU5 = <<A as Shr<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5ShrU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U10 = UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU5 = <<A as Add<B>>::Output as Same<U10>>::Output;\n\n    assert_eq!(<U5AddU5 as Unsigned>::to_u64(), <U10 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U25 = UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU5 = <<A as Mul<B>>::Output as Same<U25>>::Output;\n\n    assert_eq!(<U5MulU5 as Unsigned>::to_u64(), <U25 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U3125 = UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU5 = <<A as Pow<B>>::Output as Same<U3125>>::Output;\n\n    assert_eq!(<U5PowU5 as Unsigned>::to_u64(), <U3125 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU5 = <<A as Min<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MinU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU5 = <<A as Max<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5MaxU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U5 = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU5 = <<A as Gcd<B>>::Output as Same<U5>>::Output;\n\n    assert_eq!(<U5GcdU5 as Unsigned>::to_u64(), <U5 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU5 = <<A as Sub<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5SubU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU5 = <<A as Div<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5DivU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU5 = <<A as Rem<B>>::Output as Same<U0>>::Output;\n\n    assert_eq!(<U5RemU5 as Unsigned>::to_u64(), <U0 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type U1 = UInt<UTerm, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU5 = <<A as PartialDiv<B>>::Output as Same<U1>>::Output;\n\n    assert_eq!(<U5PartialDivU5 as Unsigned>::to_u64(), <U1 as Unsigned>::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_5() {\n    type A = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n    type B = UInt<UInt<UInt<UTerm, B1>, B0>, B1>;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU5 = <A as Cmp<B>>::Output;\n    assert_eq!(<U5CmpU5 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN5 = <<A as Add<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<N5AddN5 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN5 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5SubN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN5 = <<A as Mul<B>>::Output as Same<P25>>::Output;\n\n    assert_eq!(<N5MulN5 as Integer>::to_i64(), <P25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN5 = <<A as Max<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MaxN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN5 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5DivN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5PartialDivN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpN5 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN4 = <<A as Add<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<N5AddN4 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN4 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5SubN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN4 = <<A as Mul<B>>::Output as Same<P20>>::Output;\n\n    assert_eq!(<N5MulN4 as Integer>::to_i64(), <P20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN4 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinN4 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN4 = <<A as Max<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N5MaxN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN4 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5DivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN4 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5RemN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpN4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN3 = <<A as Add<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N5AddN3 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN3 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5SubN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN3 = <<A as Mul<B>>::Output as Same<P15>>::Output;\n\n    assert_eq!(<N5MulN3 as Integer>::to_i64(), <P15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN3 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinN3 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N5MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN3 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5RemN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpN3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN2 = <<A as Add<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N5AddN2 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN2 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N5SubN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN2 = <<A as Mul<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<N5MulN2 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN2 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinN2 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN2 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N5DivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpN2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN1 = <<A as Add<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N5AddN1 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN1 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N5SubN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN1 = <<A as Mul<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5MulN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN1 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN1 = <<A as Div<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5DivN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5PartialDivN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpN1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5Add_0 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5Add_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5Sub_0 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5Sub_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5Min_0 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5Min_0 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5Gcd_0 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5Gcd_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5Cmp_0 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP1 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N5AddP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP1 = <<A as Sub<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N5SubP1 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP1 = <<A as Mul<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MulP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP1 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP1 = <<A as Div<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5DivP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5PartialDivP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP1 = <<A as Pow<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5PowP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP2 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N5AddP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP2 = <<A as Sub<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N5SubP2 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP2 = <<A as Mul<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<N5MulP2 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP2 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinP2 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N5MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP2 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5DivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP2 = <<A as Pow<B>>::Output as Same<P25>>::Output;\n\n    assert_eq!(<N5PowP2 as Integer>::to_i64(), <P25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP3 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5AddP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP3 = <<A as Sub<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N5SubP3 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP3 = <<A as Mul<B>>::Output as Same<N15>>::Output;\n\n    assert_eq!(<N5MulP3 as Integer>::to_i64(), <N15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP3 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinP3 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N5MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP3 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N5RemP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N125 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP3 = <<A as Pow<B>>::Output as Same<N125>>::Output;\n\n    assert_eq!(<N5PowP3 as Integer>::to_i64(), <N125 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP4 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5AddP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP4 = <<A as Sub<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<N5SubP4 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP4 = <<A as Mul<B>>::Output as Same<N20>>::Output;\n\n    assert_eq!(<N5MulP4 as Integer>::to_i64(), <N20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP4 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinP4 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N5MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N5GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP4 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5DivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP4 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5RemP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P625 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP4 = <<A as Pow<B>>::Output as Same<P625>>::Output;\n\n    assert_eq!(<N5PowP4 as Integer>::to_i64(), <P625 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP5 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5AddP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP5 = <<A as Sub<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<N5SubP5 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N25 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP5 = <<A as Mul<B>>::Output as Same<N25>>::Output;\n\n    assert_eq!(<N5MulP5 as Integer>::to_i64(), <N25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N5MinP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N5GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP5 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5DivP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N5RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N5PartialDivP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3125 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP5 = <<A as Pow<B>>::Output as Same<N3125>>::Output;\n\n    assert_eq!(<N5PowP5 as Integer>::to_i64(), <N3125 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N5CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN5 = <<A as Add<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<N4AddN5 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN5 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4SubN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN5 = <<A as Mul<B>>::Output as Same<P20>>::Output;\n\n    assert_eq!(<N4MulN5 as Integer>::to_i64(), <P20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N4MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN5 = <<A as Max<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MaxN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN5 = <<A as Rem<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4RemN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN4 = <<A as Add<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N4AddN4 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN4 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4SubN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN4 = <<A as Mul<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<N4MulN4 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN4 = <<A as Max<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MaxN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN4 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4DivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4PartialDivN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpN4 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN3 = <<A as Add<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N4AddN3 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN3 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4SubN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN3 = <<A as Mul<B>>::Output as Same<P12>>::Output;\n\n    assert_eq!(<N4MulN3 as Integer>::to_i64(), <P12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN3 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinN3 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N4MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN3 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4RemN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpN3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN2 = <<A as Add<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N4AddN2 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN2 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N4SubN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN2 = <<A as Mul<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<N4MulN2 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN2 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N4MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N4GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN2 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N4DivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N4PartialDivN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpN2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN1 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N4AddN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN1 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N4SubN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN1 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4MulN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN1 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN1 = <<A as Div<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4DivN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4PartialDivN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpN1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4Add_0 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4Add_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4Sub_0 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4Sub_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4Min_0 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4Min_0 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4Gcd_0 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4Gcd_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp__0() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4Cmp_0 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP1 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N4AddP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP1 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N4SubP1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP1 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MulP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP1 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP1 = <<A as Div<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4DivP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4PartialDivP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP1 = <<A as Pow<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4PowP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P1() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP2 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N4AddP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP2 = <<A as Sub<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N4SubP2 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP2 = <<A as Mul<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N4MulP2 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP2 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N4MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N4GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP2 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N4DivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N4PartialDivP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP2 = <<A as Pow<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<N4PowP2 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P2() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP3 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4AddP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP3 = <<A as Sub<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N4SubP3 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP3 = <<A as Mul<B>>::Output as Same<N12>>::Output;\n\n    assert_eq!(<N4MulP3 as Integer>::to_i64(), <N12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP3 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinP3 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N4MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP3 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4RemP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N64 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP3 = <<A as Pow<B>>::Output as Same<N64>>::Output;\n\n    assert_eq!(<N4PowP3 as Integer>::to_i64(), <N64 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P3() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP4 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4AddP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP4 = <<A as Sub<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N4SubP4 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N16 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP4 = <<A as Mul<B>>::Output as Same<N16>>::Output;\n\n    assert_eq!(<N4MulP4 as Integer>::to_i64(), <N16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N4GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP4 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4DivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N4PartialDivP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P256 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP4 = <<A as Pow<B>>::Output as Same<P256>>::Output;\n\n    assert_eq!(<N4PowP4 as Integer>::to_i64(), <P256 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P4() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP5 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4AddP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP5 = <<A as Sub<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<N4SubP5 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP5 = <<A as Mul<B>>::Output as Same<N20>>::Output;\n\n    assert_eq!(<N4MulP5 as Integer>::to_i64(), <N20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP5 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4MinP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N4MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N4GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N4DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP5 = <<A as Rem<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N4RemP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1024 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP5 = <<A as Pow<B>>::Output as Same<N1024>>::Output;\n\n    assert_eq!(<N4PowP5 as Integer>::to_i64(), <N1024 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P5() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N4CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN5 = <<A as Add<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N3AddN5 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN5 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N3SubN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN5 = <<A as Mul<B>>::Output as Same<P15>>::Output;\n\n    assert_eq!(<N3MulN5 as Integer>::to_i64(), <P15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N3MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN5 = <<A as Max<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MaxN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN5 = <<A as Rem<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3RemN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN4 = <<A as Add<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N3AddN4 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN4 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3SubN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN4 = <<A as Mul<B>>::Output as Same<P12>>::Output;\n\n    assert_eq!(<N3MulN4 as Integer>::to_i64(), <P12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N3MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN4 = <<A as Max<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MaxN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN4 = <<A as Rem<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3RemN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN3 = <<A as Add<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N3AddN3 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN3 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3SubN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN3 = <<A as Mul<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<N3MulN3 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN3 = <<A as Max<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MaxN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3DivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3PartialDivN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpN3 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN2 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N3AddN2 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN2 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3SubN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN2 = <<A as Mul<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<N3MulN2 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN2 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N3MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN2 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3DivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpN2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN1 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N3AddN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN1 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N3SubN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN1 = <<A as Mul<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3MulN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN1 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN1 = <<A as Div<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3DivN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3PartialDivN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpN1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3Add_0 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3Add_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3Sub_0 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3Sub_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3Min_0 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3Min_0 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3Gcd_0 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3Gcd_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3Cmp_0 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP1 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N3AddP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP1 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N3SubP1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP1 = <<A as Mul<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MulP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP1 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP1 = <<A as Div<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3DivP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3PartialDivP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP1 = <<A as Pow<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3PowP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP2 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3AddP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP2 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N3SubP2 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP2 = <<A as Mul<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N3MulP2 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP2 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N3MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP2 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3DivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP2 = <<A as Pow<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<N3PowP2 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP3 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3AddP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP3 = <<A as Sub<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N3SubP3 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP3 = <<A as Mul<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<N3MulP3 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N3GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3DivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N3PartialDivP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N27 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP3 = <<A as Pow<B>>::Output as Same<N27>>::Output;\n\n    assert_eq!(<N3PowP3 as Integer>::to_i64(), <N27 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP4 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3AddP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP4 = <<A as Sub<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N3SubP4 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP4 = <<A as Mul<B>>::Output as Same<N12>>::Output;\n\n    assert_eq!(<N3MulP4 as Integer>::to_i64(), <N12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP4 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N3MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP4 = <<A as Rem<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3RemP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P81 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP4 = <<A as Pow<B>>::Output as Same<P81>>::Output;\n\n    assert_eq!(<N3PowP4 as Integer>::to_i64(), <P81 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP5 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N3AddP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP5 = <<A as Sub<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N3SubP5 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP5 = <<A as Mul<B>>::Output as Same<N15>>::Output;\n\n    assert_eq!(<N3MulP5 as Integer>::to_i64(), <N15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP5 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3MinP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N3MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N3GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N3DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP5 = <<A as Rem<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N3RemP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N243 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP5 = <<A as Pow<B>>::Output as Same<N243>>::Output;\n\n    assert_eq!(<N3PowP5 as Integer>::to_i64(), <N243 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N3CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN5 = <<A as Add<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N2AddN5 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN5 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N2SubN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN5 = <<A as Mul<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<N2MulN5 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N2MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN5 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MaxN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN5 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN4 = <<A as Add<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N2AddN4 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN4 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2SubN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN4 = <<A as Mul<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<N2MulN4 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N2MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN4 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MaxN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2GcdN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN4 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN3 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N2AddN3 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN3 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2SubN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN3 = <<A as Mul<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<N2MulN3 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N2MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN3 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MaxN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN3 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN2 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N2AddN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN2 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2SubN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN2 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N2MulN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN2 = <<A as Max<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MaxN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN2 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2DivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2PartialDivN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpN2 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN1 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N2AddN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN1 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N2SubN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN1 = <<A as Mul<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2MulN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN1 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N2MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN1 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2DivN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2PartialDivN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpN1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2Add_0 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2Add_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2Sub_0 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2Sub_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2Min_0 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2Min_0 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2Gcd_0 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2Gcd_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp__0() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2Cmp_0 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP1 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N2AddP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP1 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N2SubP1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP1 = <<A as Mul<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MulP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP1 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP1 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2DivP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2PartialDivP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP1 = <<A as Pow<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2PowP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P1() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP2 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2AddP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP2 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N2SubP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP2 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N2MulP2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP2 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N2DivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N2PartialDivP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP2 = <<A as Pow<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N2PowP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P2() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP3 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2AddP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP3 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N2SubP3 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP3 = <<A as Mul<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N2MulP3 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP3 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N2MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP3 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP3 = <<A as Pow<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N2PowP3 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P3() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP4 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2AddP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP4 = <<A as Sub<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N2SubP4 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP4 = <<A as Mul<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<N2MulP4 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP4 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N2MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N2GcdP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP4 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP4 = <<A as Pow<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<N2PowP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P4() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP5 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N2AddP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N7 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP5 = <<A as Sub<B>>::Output as Same<N7>>::Output;\n\n    assert_eq!(<N2SubP5 as Integer>::to_i64(), <N7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP5 = <<A as Mul<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<N2MulP5 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP5 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2MinP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N2MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N2GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N2DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP5 = <<A as Rem<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N2RemP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N32 = NInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP5 = <<A as Pow<B>>::Output as Same<N32>>::Output;\n\n    assert_eq!(<N2PowP5 as Integer>::to_i64(), <N32 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P5() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N2CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN5 = <<A as Add<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N1AddN5 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN5 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N1SubN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN5 = <<A as Mul<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N1MulN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N1MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN5 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MaxN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN5 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN5 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN4 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N1AddN4 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN4 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N1SubN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN4 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N1MulN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N1MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN4 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MaxN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN4 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN4 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1PowN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN3 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N1AddN3 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN3 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N1SubN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN3 = <<A as Mul<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N1MulN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N1MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN3 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MaxN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN3 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN3 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN2 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N1AddN2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN2 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1SubN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN2 = <<A as Mul<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N1MulN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N1MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN2 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MaxN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN2 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1PowN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN1 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N1AddN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN1 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1SubN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN1 = <<A as Mul<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1MulN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN1 = <<A as Max<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MaxN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN1 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1DivN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1PartialDivN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN1 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpN1 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1Add_0 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1Add_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1Sub_0 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1Sub_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1Min_0 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1Min_0 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1Gcd_0 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1Gcd_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp__0() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1Cmp_0 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP1 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1AddP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP1 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N1SubP1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP1 = <<A as Mul<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MulP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP1 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1DivP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PartialDivP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP1 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P1() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP2 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1AddP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP2 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N1SubP2 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP2 = <<A as Mul<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<N1MulP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP2 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N1MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP2 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP2 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1PowP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P2() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP3 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<N1AddP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP3 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N1SubP3 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP3 = <<A as Mul<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<N1MulP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP3 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N1MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP3 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP3 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P3() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP4 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<N1AddP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP4 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N1SubP4 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP4 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<N1MulP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP4 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N1MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP4 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP4 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1PowP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P4() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP5 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<N1AddP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP5 = <<A as Sub<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<N1SubP5 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP5 = <<A as Mul<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<N1MulP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP5 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1MinP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<N1MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<N1GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<N1DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP5 = <<A as Rem<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1RemP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP5 = <<A as Pow<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<N1PowP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P5() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<N1CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN5 = <<A as Add<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<_0AddN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN5 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<_0SubN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN5 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<_0MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN5 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MaxN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<_0GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N5() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN4 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<_0AddN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN4 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<_0SubN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN4 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<_0MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN4 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MaxN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<_0GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N4() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN3 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<_0AddN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN3 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<_0SubN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN3 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<_0MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN3 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MaxN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<_0GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N3() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN2 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<_0AddN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN2 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<_0SubN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN2 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<_0MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN2 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MaxN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<_0GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N2() {\n    type A = Z0;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN1 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<_0AddN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN1 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0SubN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN1 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<_0MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN1 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MaxN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN1 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N1() {\n    type A = Z0;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Add_0 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Add_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Sub_0 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Sub_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Max_0 = <<A as Max<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Max_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Gcd_0 = <<A as Gcd<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0Gcd_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow__0() {\n    type A = Z0;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp__0() {\n    type A = Z0;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0Cmp_0 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP1 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0AddP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP1 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<_0SubP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP1 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP1 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MinP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<_0GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP1 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP1 = <<A as Pow<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PowP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P1() {\n    type A = Z0;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpP1 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP2 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<_0AddP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP2 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<_0SubP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP2 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP2 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MinP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<_0MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<_0GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP2 = <<A as Pow<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PowP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P2() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP3 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<_0AddP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP3 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<_0SubP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP3 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP3 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MinP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<_0MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<_0GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP3 = <<A as Pow<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PowP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P3() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP4 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<_0AddP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP4 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<_0SubP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP4 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP4 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MinP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<_0MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<_0GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP4 = <<A as Pow<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PowP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P4() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP5 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<_0AddP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP5 = <<A as Sub<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<_0SubP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP5 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MulP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP5 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0MinP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<_0MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<_0GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PartialDivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP5 = <<A as Pow<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<_0PowP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P5() {\n    type A = Z0;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<_0CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN5 = <<A as Add<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P1AddN5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN5 = <<A as Sub<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P1SubN5 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN5 = <<A as Mul<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P1MulN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P1MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN5 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN5 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN5 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN4 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P1AddN4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN4 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P1SubN4 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN4 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P1MulN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P1MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN4 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN4 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN4 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN3 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P1AddN3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN3 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P1SubN3 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN3 = <<A as Mul<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P1MulN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P1MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN3 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN3 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN3 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN2 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1AddN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN2 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P1SubN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN2 = <<A as Mul<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P1MulN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P1MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN2 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN2 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN1 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1AddN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN1 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P1SubN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN1 = <<A as Mul<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1MulN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN1 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1DivN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1PartialDivN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN1 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1Add_0 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1Add_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1Sub_0 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1Sub_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1Max_0 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1Max_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1Gcd_0 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1Gcd_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp__0() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1Cmp_0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP1 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P1AddP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP1 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1SubP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP1 = <<A as Mul<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MulP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP1 = <<A as Max<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MaxP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP1 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1DivP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PartialDivP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP1 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P1() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpP1 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP2 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P1AddP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP2 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P1SubP2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP2 = <<A as Mul<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P1MulP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP2 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MinP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P1MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP2 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP2 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P2() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpP2 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP3 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P1AddP3 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP3 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P1SubP3 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP3 = <<A as Mul<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P1MulP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP3 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MinP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P1MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP3 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP3 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P3() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP4 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P1AddP4 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP4 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P1SubP4 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP4 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P1MulP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP4 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MinP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P1MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP4 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP4 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P4() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP5 = <<A as Add<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P1AddP5 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP5 = <<A as Sub<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P1SubP5 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP5 = <<A as Mul<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P1MulP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP5 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1MinP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P1MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P1DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP5 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1RemP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP5 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P1PowP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P5() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P1CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN5 = <<A as Add<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P2AddN5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN5 = <<A as Sub<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P2SubN5 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN5 = <<A as Mul<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<P2MulN5 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P2MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN5 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN5 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemN5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN4 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2AddN4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN4 = <<A as Sub<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P2SubN4 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN4 = <<A as Mul<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<P2MulN4 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P2MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN4 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2GcdN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN4 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemN4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN3 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P2AddN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN3 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P2SubN3 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN3 = <<A as Mul<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<P2MulN3 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P2MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN3 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN3 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN2 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2AddN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN2 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P2SubN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN2 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P2MulN2 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN2 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P2DivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P2PartialDivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN1 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2AddN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN1 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P2SubN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN1 = <<A as Mul<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2MulN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P2MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN1 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN1 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2DivN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2PartialDivN1 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2Add_0 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2Add_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2Sub_0 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2Sub_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2Max_0 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2Max_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2Gcd_0 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2Gcd_0 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2Cmp_0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP1 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P2AddP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP1 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2SubP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP1 = <<A as Mul<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MulP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP1 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP1 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2DivP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2PartialDivP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP1 = <<A as Pow<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2PowP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpP1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP2 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P2AddP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP2 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2SubP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP2 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P2MulP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP2 = <<A as Max<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MaxP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP2 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2DivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2PartialDivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP2 = <<A as Pow<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P2PowP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpP2 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP3 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P2AddP3 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP3 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P2SubP3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP3 = <<A as Mul<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P2MulP3 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP3 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MinP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P2MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP3 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP3 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP3 = <<A as Pow<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P2PowP3 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpP3 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP4 = <<A as Add<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P2AddP4 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP4 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P2SubP4 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP4 = <<A as Mul<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P2MulP4 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP4 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MinP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P2MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP4 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2GcdP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP4 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemP4 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP4 = <<A as Pow<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<P2PowP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP5 = <<A as Add<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P2AddP5 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP5 = <<A as Sub<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P2SubP5 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP5 = <<A as Mul<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<P2MulP5 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP5 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2MinP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P2MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P2GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P2DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP5 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P2RemP5 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P32 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP5 = <<A as Pow<B>>::Output as Same<P32>>::Output;\n\n    assert_eq!(<P2PowP5 as Integer>::to_i64(), <P32 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P2CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN5 = <<A as Add<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P3AddN5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN5 = <<A as Sub<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P3SubN5 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN5 = <<A as Mul<B>>::Output as Same<N15>>::Output;\n\n    assert_eq!(<P3MulN5 as Integer>::to_i64(), <N15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P3MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN5 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN5 = <<A as Rem<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3RemN5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN4 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3AddN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN4 = <<A as Sub<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P3SubN4 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN4 = <<A as Mul<B>>::Output as Same<N12>>::Output;\n\n    assert_eq!(<P3MulN4 as Integer>::to_i64(), <N12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P3MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN4 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3DivN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN4 = <<A as Rem<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3RemN4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN3 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3AddN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN3 = <<A as Sub<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P3SubN3 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N9 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN3 = <<A as Mul<B>>::Output as Same<N9>>::Output;\n\n    assert_eq!(<P3MulN3 as Integer>::to_i64(), <N9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P3MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3GcdN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3RemN3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN3 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3PartialDivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN2 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3AddN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN2 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P3SubN2 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN2 = <<A as Mul<B>>::Output as Same<N6>>::Output;\n\n    assert_eq!(<P3MulN2 as Integer>::to_i64(), <N6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P3MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN2 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN2 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3DivN2 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN1 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P3AddN1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN1 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P3SubN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN1 = <<A as Mul<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P3MulN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN1 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN1 = <<A as Div<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P3DivN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P3PartialDivN1 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3Add_0 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3Add_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3Sub_0 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3Sub_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3Max_0 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3Max_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3Gcd_0 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3Gcd_0 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp__0() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3Cmp_0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP1 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P3AddP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP1 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P3SubP1 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP1 = <<A as Mul<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MulP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP1 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP1 = <<A as Div<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3DivP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3PartialDivP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP1 = <<A as Pow<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3PowP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P1() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpP1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP2 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P3AddP2 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP2 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3SubP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP2 = <<A as Mul<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P3MulP2 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P3MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP2 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP2 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3DivP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP2 = <<A as Pow<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P3PowP2 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P2() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpP2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP3 = <<A as Add<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P3AddP3 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP3 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3SubP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP3 = <<A as Mul<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P3MulP3 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP3 = <<A as Max<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MaxP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP3 = <<A as Gcd<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3GcdP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP3 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3RemP3 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP3 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3PartialDivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P27 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP3 = <<A as Pow<B>>::Output as Same<P27>>::Output;\n\n    assert_eq!(<P3PowP3 as Integer>::to_i64(), <P27 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P3() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpP3 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP4 = <<A as Add<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P3AddP4 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP4 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P3SubP4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP4 = <<A as Mul<B>>::Output as Same<P12>>::Output;\n\n    assert_eq!(<P3MulP4 as Integer>::to_i64(), <P12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP4 = <<A as Min<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MinP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P3MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP4 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3DivP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP4 = <<A as Rem<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3RemP4 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P81 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP4 = <<A as Pow<B>>::Output as Same<P81>>::Output;\n\n    assert_eq!(<P3PowP4 as Integer>::to_i64(), <P81 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P4() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpP4 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP5 = <<A as Add<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P3AddP5 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP5 = <<A as Sub<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P3SubP5 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP5 = <<A as Mul<B>>::Output as Same<P15>>::Output;\n\n    assert_eq!(<P3MulP5 as Integer>::to_i64(), <P15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP5 = <<A as Min<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3MinP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P3MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P3GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P3DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP5 = <<A as Rem<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P3RemP5 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P243 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B0>, B0>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP5 = <<A as Pow<B>>::Output as Same<P243>>::Output;\n\n    assert_eq!(<P3PowP5 as Integer>::to_i64(), <P243 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P5() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P3CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN5 = <<A as Add<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4AddN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN5 = <<A as Sub<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P4SubN5 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN5 = <<A as Mul<B>>::Output as Same<N20>>::Output;\n\n    assert_eq!(<P4MulN5 as Integer>::to_i64(), <N20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P4MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN5 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdN5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4DivN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN5 = <<A as Rem<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4RemN5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN4 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4AddN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN4 = <<A as Sub<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P4SubN4 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N16 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN4 = <<A as Mul<B>>::Output as Same<N16>>::Output;\n\n    assert_eq!(<P4MulN4 as Integer>::to_i64(), <N16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P4MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4GcdN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN4 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4DivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemN4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN4 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4PartialDivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN3 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4AddN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN3 = <<A as Sub<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P4SubN3 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N12 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN3 = <<A as Mul<B>>::Output as Same<N12>>::Output;\n\n    assert_eq!(<P4MulN3 as Integer>::to_i64(), <N12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P4MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN3 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxN3 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN3 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4RemN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN2 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4AddN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN2 = <<A as Sub<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P4SubN2 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N8 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN2 = <<A as Mul<B>>::Output as Same<N8>>::Output;\n\n    assert_eq!(<P4MulN2 as Integer>::to_i64(), <N8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P4MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN2 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxN2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4GcdN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN2 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P4DivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemN2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN2 = <<A as PartialDiv<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P4PartialDivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN1 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P4AddN1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN1 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P4SubN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN1 = <<A as Mul<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P4MulN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN1 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN1 = <<A as Div<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P4DivN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P4PartialDivN1 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4Add_0 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4Add_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4Sub_0 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4Sub_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4Max_0 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4Max_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4Gcd_0 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4Gcd_0 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4Cmp_0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP1 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P4AddP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP1 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P4SubP1 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP1 = <<A as Mul<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MulP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP1 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP1 = <<A as Div<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4DivP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4PartialDivP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP1 = <<A as Pow<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4PowP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpP1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP2 = <<A as Add<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P4AddP2 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP2 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4SubP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP2 = <<A as Mul<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P4MulP2 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP2 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxP2 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP2 = <<A as Gcd<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4GcdP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP2 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4DivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP2 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemP2 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP2 = <<A as PartialDiv<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P4PartialDivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP2 = <<A as Pow<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<P4PowP2 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpP2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP3 = <<A as Add<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P4AddP3 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP3 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4SubP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P12 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP3 = <<A as Mul<B>>::Output as Same<P12>>::Output;\n\n    assert_eq!(<P4MulP3 as Integer>::to_i64(), <P12 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P4MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP3 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxP3 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP3 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4RemP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P64 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP3 = <<A as Pow<B>>::Output as Same<P64>>::Output;\n\n    assert_eq!(<P4PowP3 as Integer>::to_i64(), <P64 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpP3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP4 = <<A as Add<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P4AddP4 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP4 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4SubP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P16 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP4 = <<A as Mul<B>>::Output as Same<P16>>::Output;\n\n    assert_eq!(<P4MulP4 as Integer>::to_i64(), <P16 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP4 = <<A as Min<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MinP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP4 = <<A as Max<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MaxP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP4 = <<A as Gcd<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4GcdP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP4 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4DivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP4 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4RemP4 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP4 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4PartialDivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P256 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP4 = <<A as Pow<B>>::Output as Same<P256>>::Output;\n\n    assert_eq!(<P4PowP4 as Integer>::to_i64(), <P256 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpP4 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP5 = <<A as Add<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P4AddP5 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP5 = <<A as Sub<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P4SubP5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP5 = <<A as Mul<B>>::Output as Same<P20>>::Output;\n\n    assert_eq!(<P4MulP5 as Integer>::to_i64(), <P20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP5 = <<A as Min<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4MinP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P4MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP5 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P4GcdP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP5 = <<A as Div<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P4DivP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP5 = <<A as Rem<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P4RemP5 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1024 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP5 = <<A as Pow<B>>::Output as Same<P1024>>::Output;\n\n    assert_eq!(<P4PowP5 as Integer>::to_i64(), <P1024 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P4CmpP5 as Ord>::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN5 = <<A as Add<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5AddN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN5 = <<A as Sub<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<P5SubN5 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N25 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN5 = <<A as Mul<B>>::Output as Same<N25>>::Output;\n\n    assert_eq!(<P5MulN5 as Integer>::to_i64(), <N25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN5 = <<A as Min<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P5MinN5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5GcdN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN5 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P5DivN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5RemN5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN5 = <<A as PartialDiv<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P5PartialDivN5 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpN5 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN4 = <<A as Add<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5AddN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN4 = <<A as Sub<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P5SubN4 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N20 = NInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN4 = <<A as Mul<B>>::Output as Same<N20>>::Output;\n\n    assert_eq!(<P5MulN4 as Integer>::to_i64(), <N20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN4 = <<A as Min<B>>::Output as Same<N4>>::Output;\n\n    assert_eq!(<P5MinN4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN4 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxN4 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN4 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P5DivN4 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN4 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5RemN4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpN4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN3 = <<A as Add<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5AddN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN3 = <<A as Sub<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P5SubN3 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N15 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN3 = <<A as Mul<B>>::Output as Same<N15>>::Output;\n\n    assert_eq!(<P5MulN3 as Integer>::to_i64(), <N15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN3 = <<A as Min<B>>::Output as Same<N3>>::Output;\n\n    assert_eq!(<P5MinN3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN3 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxN3 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdN3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN3 = <<A as Div<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P5DivN3 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN3 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5RemN3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpN3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN2 = <<A as Add<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P5AddN2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN2 = <<A as Sub<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P5SubN2 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N10 = NInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN2 = <<A as Mul<B>>::Output as Same<N10>>::Output;\n\n    assert_eq!(<P5MulN2 as Integer>::to_i64(), <N10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN2 = <<A as Min<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P5MinN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN2 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxN2 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN2 = <<A as Div<B>>::Output as Same<N2>>::Output;\n\n    assert_eq!(<P5DivN2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5RemN2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpN2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN1 = <<A as Add<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P5AddN1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN1 = <<A as Sub<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P5SubN1 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN1 = <<A as Mul<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P5MulN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN1 = <<A as Min<B>>::Output as Same<N1>>::Output;\n\n    assert_eq!(<P5MinN1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN1 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxN1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN1 = <<A as Div<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P5DivN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5RemN1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN1 = <<A as PartialDiv<B>>::Output as Same<N5>>::Output;\n\n    assert_eq!(<P5PartialDivN1 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpN1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5Add_0 = <<A as Add<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5Add_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5Sub_0 = <<A as Sub<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5Sub_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Mul_0 = <<A as Mul<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5Mul_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Min_0 = <<A as Min<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5Min_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5Max_0 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5Max_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5Gcd_0 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5Gcd_0 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5Pow_0 = <<A as Pow<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5Pow_0 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp__0() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Cmp_0 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5Cmp_0 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP1 = <<A as Add<B>>::Output as Same<P6>>::Output;\n\n    assert_eq!(<P5AddP1 as Integer>::to_i64(), <P6 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP1 = <<A as Sub<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P5SubP1 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP1 = <<A as Mul<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MulP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP1 = <<A as Min<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5MinP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP1 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP1 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP1 = <<A as Div<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5DivP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP1 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5RemP1 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP1 = <<A as PartialDiv<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5PartialDivP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP1 = <<A as Pow<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5PowP1 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P1() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP1 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpP1 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P7 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP2 = <<A as Add<B>>::Output as Same<P7>>::Output;\n\n    assert_eq!(<P5AddP2 as Integer>::to_i64(), <P7 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP2 = <<A as Sub<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P5SubP2 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP2 = <<A as Mul<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<P5MulP2 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP2 = <<A as Min<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5MinP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP2 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxP2 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP2 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP2 = <<A as Div<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5DivP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP2 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5RemP2 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP2 = <<A as Pow<B>>::Output as Same<P25>>::Output;\n\n    assert_eq!(<P5PowP2 as Integer>::to_i64(), <P25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P2() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP2 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpP2 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P8 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP3 = <<A as Add<B>>::Output as Same<P8>>::Output;\n\n    assert_eq!(<P5AddP3 as Integer>::to_i64(), <P8 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP3 = <<A as Sub<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5SubP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P15 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP3 = <<A as Mul<B>>::Output as Same<P15>>::Output;\n\n    assert_eq!(<P5MulP3 as Integer>::to_i64(), <P15 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP3 = <<A as Min<B>>::Output as Same<P3>>::Output;\n\n    assert_eq!(<P5MinP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP3 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxP3 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP3 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP3 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5DivP3 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP3 = <<A as Rem<B>>::Output as Same<P2>>::Output;\n\n    assert_eq!(<P5RemP3 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P125 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B1>, B1>, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP3 = <<A as Pow<B>>::Output as Same<P125>>::Output;\n\n    assert_eq!(<P5PowP3 as Integer>::to_i64(), <P125 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P3() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP3 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpP3 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P9 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP4 = <<A as Add<B>>::Output as Same<P9>>::Output;\n\n    assert_eq!(<P5AddP4 as Integer>::to_i64(), <P9 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP4 = <<A as Sub<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5SubP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P20 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP4 = <<A as Mul<B>>::Output as Same<P20>>::Output;\n\n    assert_eq!(<P5MulP4 as Integer>::to_i64(), <P20 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP4 = <<A as Min<B>>::Output as Same<P4>>::Output;\n\n    assert_eq!(<P5MinP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP4 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxP4 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP4 = <<A as Gcd<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5GcdP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP4 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5DivP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP4 = <<A as Rem<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5RemP4 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P625 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B1>, B1>, B1>, B0>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP4 = <<A as Pow<B>>::Output as Same<P625>>::Output;\n\n    assert_eq!(<P5PowP4 as Integer>::to_i64(), <P625 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P4() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP4 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpP4 as Ord>::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P10 = PInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP5 = <<A as Add<B>>::Output as Same<P10>>::Output;\n\n    assert_eq!(<P5AddP5 as Integer>::to_i64(), <P10 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP5 = <<A as Sub<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5SubP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P25 = PInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP5 = <<A as Mul<B>>::Output as Same<P25>>::Output;\n\n    assert_eq!(<P5MulP5 as Integer>::to_i64(), <P25 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP5 = <<A as Min<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MinP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP5 = <<A as Max<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5MaxP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP5 = <<A as Gcd<B>>::Output as Same<P5>>::Output;\n\n    assert_eq!(<P5GcdP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP5 = <<A as Div<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5DivP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP5 = <<A as Rem<B>>::Output as Same<_0>>::Output;\n\n    assert_eq!(<P5RemP5 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP5 = <<A as PartialDiv<B>>::Output as Same<P1>>::Output;\n\n    assert_eq!(<P5PartialDivP5 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P3125 = PInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, B1>, B1>, B0>, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP5 = <<A as Pow<B>>::Output as Same<P3125>>::Output;\n\n    assert_eq!(<P5PowP5 as Integer>::to_i64(), <P3125 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P5() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type B = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP5 = <A as Cmp<B>>::Output;\n    assert_eq!(<P5CmpP5 as Ord>::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Neg() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegN5 = <<A as Neg>::Output as Same<P5>>::Output;\n    assert_eq!(<NegN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Abs() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsN5 = <<A as Abs>::Output as Same<P5>>::Output;\n    assert_eq!(<AbsN5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Neg() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type NegN4 = <<A as Neg>::Output as Same<P4>>::Output;\n    assert_eq!(<NegN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Abs() {\n    type A = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsN4 = <<A as Abs>::Output as Same<P4>>::Output;\n    assert_eq!(<AbsN4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Neg() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegN3 = <<A as Neg>::Output as Same<P3>>::Output;\n    assert_eq!(<NegN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Abs() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsN3 = <<A as Abs>::Output as Same<P3>>::Output;\n    assert_eq!(<AbsN3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Neg() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type NegN2 = <<A as Neg>::Output as Same<P2>>::Output;\n    assert_eq!(<NegN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Abs() {\n    type A = NInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsN2 = <<A as Abs>::Output as Same<P2>>::Output;\n    assert_eq!(<AbsN2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Neg() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegN1 = <<A as Neg>::Output as Same<P1>>::Output;\n    assert_eq!(<NegN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Abs() {\n    type A = NInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsN1 = <<A as Abs>::Output as Same<P1>>::Output;\n    assert_eq!(<AbsN1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Neg() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Neg_0 = <<A as Neg>::Output as Same<_0>>::Output;\n    assert_eq!(<Neg_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Abs() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Abs_0 = <<A as Abs>::Output as Same<_0>>::Output;\n    assert_eq!(<Abs_0 as Integer>::to_i64(), <_0 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Neg() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type N1 = NInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegP1 = <<A as Neg>::Output as Same<N1>>::Output;\n    assert_eq!(<NegP1 as Integer>::to_i64(), <N1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Abs() {\n    type A = PInt<UInt<UTerm, B1>>;\n    type P1 = PInt<UInt<UTerm, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsP1 = <<A as Abs>::Output as Same<P1>>::Output;\n    assert_eq!(<AbsP1 as Integer>::to_i64(), <P1 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Neg() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type N2 = NInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type NegP2 = <<A as Neg>::Output as Same<N2>>::Output;\n    assert_eq!(<NegP2 as Integer>::to_i64(), <N2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Abs() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B0>>;\n    type P2 = PInt<UInt<UInt<UTerm, B1>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsP2 = <<A as Abs>::Output as Same<P2>>::Output;\n    assert_eq!(<AbsP2 as Integer>::to_i64(), <P2 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Neg() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type N3 = NInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegP3 = <<A as Neg>::Output as Same<N3>>::Output;\n    assert_eq!(<NegP3 as Integer>::to_i64(), <N3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Abs() {\n    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;\n    type P3 = PInt<UInt<UInt<UTerm, B1>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsP3 = <<A as Abs>::Output as Same<P3>>::Output;\n    assert_eq!(<AbsP3 as Integer>::to_i64(), <P3 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Neg() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type N4 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type NegP4 = <<A as Neg>::Output as Same<N4>>::Output;\n    assert_eq!(<NegP4 as Integer>::to_i64(), <N4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Abs() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n    type P4 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsP4 = <<A as Abs>::Output as Same<P4>>::Output;\n    assert_eq!(<AbsP4 as Integer>::to_i64(), <P4 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Neg() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type N5 = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type NegP5 = <<A as Neg>::Output as Same<N5>>::Output;\n    assert_eq!(<NegP5 as Integer>::to_i64(), <N5 as Integer>::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Abs() {\n    type A = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n    type P5 = PInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;\n\n    #[allow(non_camel_case_types)]\n    type AbsP5 = <<A as Abs>::Output as Same<P5>>::Output;\n    assert_eq!(<AbsP5 as Integer>::to_i64(), <P5 as Integer>::to_i64());\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","target","debug","build","web_atoms-62bf835dc7c77f60","out","generated.rs"],"content":"pub type LocalName = :: string_cache :: Atom < LocalNameStaticSet > ;\n# [derive (PartialEq , Eq , PartialOrd , Ord)] pub struct LocalNameStaticSet ;\nimpl :: string_cache :: StaticAtomSet for LocalNameStaticSet { fn get () -> & 'static :: string_cache :: PhfStrSet { static SET : :: string_cache :: PhfStrSet = :: string_cache :: PhfStrSet { key : 12913932095322966823u64 , disps : & [(0u32 , 5u32) , (0u32 , 553u32) , (0u32 , 4u32) , (0u32 , 111u32) , (0u32 , 52u32) , (0u32 , 1u32) , (1u32 , 0u32) , (0u32 , 12u32) , (0u32 , 27u32) , (0u32 , 40u32) , (0u32 , 4u32) , (0u32 , 10u32) , (0u32 , 287u32) , (0u32 , 15u32) , (0u32 , 22u32) , (0u32 , 1u32) , (5u32 , 365u32) , (0u32 , 0u32) , (0u32 , 58u32) , (0u32 , 136u32) , (0u32 , 124u32) , (0u32 , 355u32) , (0u32 , 1u32) , (0u32 , 7u32) , (0u32 , 6u32) , (0u32 , 0u32) , (0u32 , 28u32) , (0u32 , 0u32) , (1u32 , 8u32) , (0u32 , 349u32) , (1u32 , 171u32) , (0u32 , 11u32) , (0u32 , 225u32) , (0u32 , 324u32) , (0u32 , 489u32) , (0u32 , 298u32) , (0u32 , 0u32) , (0u32 , 0u32) , (0u32 , 2u32) , (0u32 , 228u32) , (0u32 , 6u32) , (3u32 , 199u32) , (0u32 , 4u32) , (0u32 , 45u32) , (0u32 , 592u32) , (0u32 , 155u32) , (1u32 , 406u32) , (0u32 , 0u32) , (5u32 , 492u32) , (1u32 , 431u32) , (1u32 , 84u32) , (0u32 , 553u32) , (0u32 , 11u32) , (0u32 , 96u32) , (0u32 , 156u32) , (0u32 , 242u32) , (0u32 , 459u32) , (0u32 , 34u32) , (0u32 , 26u32) , (0u32 , 271u32) , (5u32 , 24u32) , (2u32 , 514u32) , (0u32 , 13u32) , (0u32 , 44u32) , (0u32 , 36u32) , (0u32 , 2u32) , (4u32 , 499u32) , (0u32 , 57u32) , (0u32 , 239u32) , (11u32 , 67u32) , (1u32 , 338u32) , (11u32 , 409u32) , (0u32 , 40u32) , (3u32 , 90u32) , (0u32 , 68u32) , (0u32 , 2u32) , (1u32 , 24u32) , (0u32 , 2u32) , (0u32 , 423u32) , (0u32 , 2u32) , (0u32 , 1u32) , (2u32 , 207u32) , (0u32 , 176u32) , (0u32 , 16u32) , (0u32 , 7u32) , (0u32 , 44u32) , (0u32 , 126u32) , (0u32 , 200u32) , (0u32 , 378u32) , (0u32 , 42u32) , (0u32 , 77u32) , (0u32 , 15u32) , (0u32 , 0u32) , (0u32 , 520u32) , (0u32 , 238u32) , (0u32 , 6u32) , (0u32 , 18u32) , (5u32 , 246u32) , (0u32 , 52u32) , (0u32 , 0u32) , (34u32 , 297u32) , (1u32 , 439u32) , (0u32 , 419u32) , (2u32 , 268u32) , (1u32 , 604u32) , (4u32 , 62u32) , (0u32 , 307u32) , (0u32 , 128u32) , (8u32 , 314u32) , (1u32 , 14u32) , (0u32 , 6u32) , (1u32 , 172u32) , (0u32 , 606u32) , (0u32 , 4u32) , (1u32 , 0u32) , (0u32 , 11u32) , (66u32 , 133u32) , (132u32 , 472u32) , (0u32 , 0u32) , (1u32 , 302u32) , (9u32 , 268u32) , (0u32 , 1u32) , (0u32 , 12u32)] , atoms : & [\"femorphology\",\n\"xml:space\",\n\"aria-orientation\",\n\"calcmode\",\n\"unicode-bidi\",\n\"altGlyphItem\",\n\"contentStyleType\",\n\"pointsAtX\",\n\"equalrows\",\n\"shadowrootclonable\",\n\"feDisplacementMap\",\n\"contentscripttype\",\n\"overline-thickness\",\n\"noresize\",\n\"ondragleave\",\n\"onmousewheel\",\n\"animatecolor\",\n\"writing-mode\",\n\"menuitem\",\n\"manifest\",\n\"contentstyletype\",\n\"flood-color\",\n\"accumulate\",\n\"equalcolumns\",\n\"repeatcount\",\n\"blockquote\",\n\"keysplines\",\n\"externalResourcesRequired\",\n\"v-ideographic\",\n\"xlink:title\",\n\"font-stretch\",\n\"aria-labelledby\",\n\"lighting-color\",\n\"codebase\",\n\"formnovalidate\",\n\"specularconstant\",\n\"aria-describedby\",\n\"maligngroup\",\n\"pathlength\",\n\"emptyset\",\n\"contextmenu\",\n\"text-anchor\",\n\"arabic-form\",\n\"onlosecapture\",\n\"onbeforeactivate\",\n\"aria-activedescendant\",\n\"conjugate\",\n\"aria-datatype\",\n\"aria-description\",\n\"baseline\",\n\"pointsatz\",\n\"mlabeledtr\",\n\"onsubmit\",\n\"aria-relevant\",\n\"aria-haspopup\",\n\"ondragover\",\n\"notation\",\n\"scrolldelay\",\n\"onbeforecut\",\n\"visibility\",\n\"fepointlight\",\n\"v-mathematical\",\n\"fill-rule\",\n\"aria-pressed\",\n\"rowalign\",\n\"onunload\",\n\"marker-start\",\n\"notprsubset\",\n\"selection\",\n\"stroke-width\",\n\"prefetch\",\n\"aria-posinset\",\n\"markerwidth\",\n\"onunhandledrejection\",\n\"femergenode\",\n\"partialdiff\",\n\"tabindex\",\n\"onmovestart\",\n\"fedistantlight\",\n\"aria-live\",\n\"longdesc\",\n\"vectorproduct\",\n\"baseProfile\",\n\"columnspan\",\n\"font-weight\",\n\"seamless\",\n\"aria-multiline\",\n\"stroke-linecap\",\n\"columnalign\",\n\"markerUnits\",\n\"ideographic\",\n\"onpagereveal\",\n\"contenteditable\",\n\"progress\",\n\"onkeypress\",\n\"actiontype\",\n\"scalarproduct\",\n\"plaintext\",\n\"aria-controls\",\n\"feConvolveMatrix\",\n\"zoomandpan\",\n\"clipPathUnits\",\n\"repeat-min\",\n\"zoomAndPan\",\n\"stop-color\",\n\"keyPoints\",\n\"spellcheck\",\n\"ononline\",\n\"onrejectionhandled\",\n\"feMorphology\",\n\"preserveAspectRatio\",\n\"textcontent\",\n\"elevation\",\n\"fecomposite\",\n\"pointer-events\",\n\"onbeforeupdate\",\n\"statechange\",\n\"fontweight\",\n\"rationals\",\n\"onfilterchange\",\n\"basefont\",\n\"maxlength\",\n\"property\",\n\"autoplay\",\n\"accent-height\",\n\"direction\",\n\"xml:base\",\n\"oninvalid\",\n\"exportparts\",\n\"stroke-dashoffset\",\n\"font-face-uri\",\n\"systemlanguage\",\n\"irrelevant\",\n\"veryverythickmathspace\",\n\"unselectable\",\n\"definition-src\",\n\"intersect\",\n\"aria-expanded\",\n\"eulergamma\",\n\"font-family\",\n\"lineargradient\",\n\"mphantom\",\n\"columnlines\",\n\"kernelunitlength\",\n\"matrixrow\",\n\"surfacescale\",\n\"aria-rowcount\",\n\"maskcontentunits\",\n\"font-face-src\",\n\"annotation-xml\",\n\"aria-roledescription\",\n\"textPath\",\n\"maskContentUnits\",\n\"keyTimes\",\n\"aria-colspan\",\n\"frameborder\",\n\"feSpecularLighting\",\n\"yChannelSelector\",\n\"translate\",\n\"occurrence\",\n\"mmultiscripts\",\n\"linearGradient\",\n\"foreignObject\",\n\"font-face\",\n\"marginheight\",\n\"markerunits\",\n\"attributeType\",\n\"dataformatas\",\n\"baseprofile\",\n\"naturalnumbers\",\n\"aria-rowspan\",\n\"ondatasetchanged\",\n\"readonly\",\n\"verythickmathspace\",\n\"background\",\n\"strikethrough-thickness\",\n\"accept-charset\",\n\"datetime\",\n\"strikethrough-position\",\n\"exponentiale\",\n\"spreadMethod\",\n\"kernelMatrix\",\n\"fecolormatrix\",\n\"onselectstart\",\n\"xlink:arcrole\",\n\"onfocusout\",\n\"animateMotion\",\n\"onrowenter\",\n\"units-per-em\",\n\"stdDeviation\",\n\"startoffset\",\n\"ondatasetcomplete\",\n\"fontsize\",\n\"feColorMatrix\",\n\"textarea\",\n\"filterUnits\",\n\"aria-modal\",\n\"aria-valuetext\",\n\"itemscope\",\n\"scriptsizemultiplier\",\n\"formmethod\",\n\"accentunder\",\n\"accesskey\",\n\"limitingConeAngle\",\n\"textContent\",\n\"inputmode\",\n\"onafterprint\",\n\"contentScriptType\",\n\"rowlines\",\n\"fontstyle\",\n\"displaystyle\",\n\"onmouseleave\",\n\"allowfullscreen\",\n\"symmetric\",\n\"notanumber\",\n\"lengthadjust\",\n\"startOffset\",\n\"cellspacing\",\n\"onformchange\",\n\"mprescripts\",\n\"fedropshadow\",\n\"aria-braillelabel\",\n\"alignmentscope\",\n\"maskunits\",\n\"viewTarget\",\n\"aria-valuemax\",\n\"kernelUnitLength\",\n\"fespotlight\",\n\"variance\",\n\"quotient\",\n\"momentabout\",\n\"pathLength\",\n\"marginwidth\",\n\"markerHeight\",\n\"aria-rowindex\",\n\"aria-grab\",\n\"clippathunits\",\n\"glyphref\",\n\"minlength\",\n\"v-alphabetic\",\n\"aria-autocomplete\",\n\"verythinmathspace\",\n\"edgemode\",\n\"radialgradient\",\n\"onmouseover\",\n\"feComposite\",\n\"scriptminsize\",\n\"aria-required\",\n\"vert-origin-y\",\n\"columnspacing\",\n\"domainofapplication\",\n\"ychannelselector\",\n\"shadowrootmode\",\n\"scriptlevel\",\n\"keytimes\",\n\"ondragenter\",\n\"shadowrootdelegatesfocus\",\n\"http-equiv\",\n\"patternContentUnits\",\n\"calcMode\",\n\"aria-flowto\",\n\"mathvariant\",\n\"multiple\",\n\"lowlimit\",\n\"itemprop\",\n\"diffuseConstant\",\n\"patternTransform\",\n\"onoffline\",\n\"clipPath\",\n\"attributename\",\n\"aria-errormessage\",\n\"requiredFeatures\",\n\"interval\",\n\"metadata\",\n\"feMergeNode\",\n\"polyline\",\n\"v-hanging\",\n\"filterRes\",\n\"groupalign\",\n\"fediffuselighting\",\n\"filterres\",\n\"onrowsinserted\",\n\"imaginaryi\",\n\"onmouseenter\",\n\"onpageshow\",\n\"feOffset\",\n\"superscriptshift\",\n\"requiredfeatures\",\n\"nomodule\",\n\"missing-glyph\",\n\"factorof\",\n\"multicol\",\n\"fill-opacity\",\n\"ondblclick\",\n\"basefrequency\",\n\"onscroll\",\n\"onerrorupdate\",\n\"aria-channel\",\n\"aria-brailleroledescription\",\n\"keySplines\",\n\"onmouseout\",\n\"separators\",\n\"rowspacing\",\n\"fePointLight\",\n\"requiredExtensions\",\n\"aria-multiselectable\",\n\"onpagehide\",\n\"viewtarget\",\n\"onchange\",\n\"pointsAtY\",\n\"mathsize\",\n\"baseFrequency\",\n\"itemtype\",\n\"factorial\",\n\"externalresourcesrequired\",\n\"textlength\",\n\"selector\",\n\"animatemotion\",\n\"onmoveend\",\n\"enable-background\",\n\"onforminput\",\n\"intercept\",\n\"feoffset\",\n\"exponent\",\n\"selected\",\n\"formenctype\",\n\"panose-1\",\n\"altglyph\",\n\"pointsaty\",\n\"xlink:href\",\n\"onbefordeactivate\",\n\"font-face-format\",\n\"dominant-baseline\",\n\"integrity\",\n\"autofocus\",\n\"text-decoration\",\n\"feDistantLight\",\n\"aria-invalid\",\n\"ondragstart\",\n\"repeat-max\",\n\"operator\",\n\"specularExponent\",\n\"aria-templateid\",\n\"menclose\",\n\"aria-details\",\n\"mathcolor\",\n\"animation\",\n\"fespecularlighting\",\n\"cellpadding\",\n\"mathematical\",\n\"stitchtiles\",\n\"crossorigin\",\n\"textpath\",\n\"xlink:role\",\n\"outerproduct\",\n\"hreflang\",\n\"annotation\",\n\"onmousemove\",\n\"stroke-linejoin\",\n\"patternunits\",\n\"ondataavailable\",\n\"codetype\",\n\"animatetransform\",\n\"onreadystatechange\",\n\"infinity\",\n\"surfaceScale\",\n\"onselect\",\n\"line-height\",\n\"onmessage\",\n\"aria-colindextext\",\n\"\",\n\"separator\",\n\"altglyphitem\",\n\"horiz-origin-y\",\n\"determinant\",\n\"condition\",\n\"xchannelselector\",\n\"repeatdur\",\n\"datalist\",\n\"cap-height\",\n\"equivalent\",\n\"fieldset\",\n\"linebreak\",\n\"gradienttransform\",\n\"amplitude\",\n\"aria-readonly\",\n\"feSpotLight\",\n\"bevelled\",\n\"fedisplacementmap\",\n\"animateColor\",\n\"aria-selected\",\n\"onmessageerror\",\n\"foreignobject\",\n\"attributetype\",\n\"prsubset\",\n\"radiogroup\",\n\"requiredextensions\",\n\"definitionURL\",\n\"listener\",\n\"colgroup\",\n\"diffuseconstant\",\n\"draggable\",\n\"columnwidth\",\n\"markerheight\",\n\"ondragend\",\n\"altGlyphDef\",\n\"xlink:show\",\n\"pointsatx\",\n\"ondragdrop\",\n\"feGaussianBlur\",\n\"unicode-range\",\n\"onbounce\",\n\"aria-valuemin\",\n\"glyph-orientation-vertical\",\n\"altGlyph\",\n\"thickmathspace\",\n\"formaction\",\n\"aria-owns\",\n\"onbeforeeditfocus\",\n\"autocomplete\",\n\"aria-placeholder\",\n\"filterunits\",\n\"noscript\",\n\"onrowexit\",\n\"mozbrowser\",\n\"onfocusin\",\n\"onhashchange\",\n\"fontfamily\",\n\"aria-keyshortcuts\",\n\"mediummathspace\",\n\"stroke-miterlimit\",\n\"valuetype\",\n\"clippath\",\n\"definitionurl\",\n\"datatemplate\",\n\"spreadmethod\",\n\"munderover\",\n\"language\",\n\"font-style\",\n\"glyphRef\",\n\"marker-end\",\n\"piecewise\",\n\"numOctaves\",\n\"placeholder\",\n\"frameset\",\n\"innertext\",\n\"onkeydown\",\n\"download\",\n\"onpropertychange\",\n\"shadowrootserializable\",\n\"onpopstate\",\n\"animateTransform\",\n\"repeat-template\",\n\"color-profile\",\n\"kernelmatrix\",\n\"xChannelSelector\",\n\"solidcolor\",\n\"gradientUnits\",\n\"horiz-origin-x\",\n\"template\",\n\"mathbackground\",\n\"codomain\",\n\"semantics\",\n\"preserveAlpha\",\n\"stddeviation\",\n\"fecomponenttransfer\",\n\"patterncontentunits\",\n\"glyph-name\",\n\"subscriptshift\",\n\"aria-current\",\n\"vert-adv-y\",\n\"word-spacing\",\n\"alignment-baseline\",\n\"aria-busy\",\n\"baseline-shift\",\n\"edgeMode\",\n\"controls\",\n\"onbeforecopy\",\n\"feDropShadow\",\n\"altglyphdef\",\n\"letter-spacing\",\n\"aria-level\",\n\"onlanguagechange\",\n\"xlink:type\",\n\"stitchTiles\",\n\"movablelimits\",\n\"feconvolvematrix\",\n\"xml:lang\",\n\"onrowsdelete\",\n\"vert-origin-x\",\n\"overflow\",\n\"novalidate\",\n\"feComponentTransfer\",\n\"preserveaspectratio\",\n\"specularexponent\",\n\"stroke-opacity\",\n\"aria-setsize\",\n\"image-rendering\",\n\"primitiveunits\",\n\"font-variant\",\n\"repeatDur\",\n\"ondeactivate\",\n\"malignmark\",\n\"formtarget\",\n\"limitingconeangle\",\n\"text-rendering\",\n\"innerText\",\n\"feturbulence\",\n\"fegaussianblur\",\n\"onstorage\",\n\"imaginary\",\n\"onmouseup\",\n\"onafterupdate\",\n\"attributeName\",\n\"flood-opacity\",\n\"reversed\",\n\"color-rendering\",\n\"required\",\n\"pointsAtZ\",\n\"tableValues\",\n\"aria-colindex\",\n\"aria-checked\",\n\"cartesianproduct\",\n\"complexes\",\n\"transform\",\n\"aria-sort\",\n\"tablevalues\",\n\"onresize\",\n\"oncontextmenu\",\n\"font-size\",\n\"aria-dropeffect\",\n\"linethickness\",\n\"integers\",\n\"font-face-name\",\n\"divergence\",\n\"figcaption\",\n\"notsubset\",\n\"color-interpolation\",\n\"gradientunits\",\n\"horiz-adv-x\",\n\"onpageswap\",\n\"font-size-adjust\",\n\"onrepeat\",\n\"specularConstant\",\n\"stretchy\",\n\"encoding\",\n\"stroke-dasharray\",\n\"thinmathspace\",\n\"aria-rowindextext\",\n\"shape-rendering\",\n\"aria-hidden\",\n\"clip-rule\",\n\"decoding\",\n\"systemLanguage\",\n\"feDiffuseLighting\",\n\"feTurbulence\",\n\"marker-mid\",\n\"underline-position\",\n\"numoctaves\",\n\"autosubmit\",\n\"underline-thickness\",\n\"additive\",\n\"aria-label\",\n\"xlink:actuate\",\n\"onbeforeprint\",\n\"alphabetic\",\n\"preservealpha\",\n\"markerWidth\",\n\"oncellchange\",\n\"gradientTransform\",\n\"noframes\",\n\"rendering-intent\",\n\"aria-valuenow\",\n\"onbeforepaste\",\n\"framespacing\",\n\"aria-colcount\",\n\"repeatCount\",\n\"clip-path\",\n\"patterntransform\",\n\"xmlns:xlink\",\n\"otherwise\",\n\"radialGradient\",\n\"onactivate\",\n\"lengthAdjust\",\n\"aria-atomic\",\n\"stop-opacity\",\n\"keypoints\",\n\"disabled\",\n\"maskUnits\",\n\"textLength\",\n\"repeat-start\",\n\"overline-position\",\n\"onbeforeunload\",\n\"primitiveUnits\",\n\"controllerchange\",\n\"x-height\",\n\"onfinish\",\n\"scrolling\",\n\"hidefocus\",\n\"onmousedown\",\n\"referrerpolicy\",\n\"specification\",\n\"color-interpolation-filters\",\n\"glyph-orientation-horizontal\",\n\"aria-disabled\",\n\"oncontrolselect\",\n\"veryverythinmathspace\",\n\"optgroup\",\n\"fetchpriority\",\n\"aria-secret\",\n\"orientation\",\n\"patternUnits\",\n\"laplacian\",\n\"transpose\"] , hashes : & [1031924441u32 , 544785510u32 , 1855625123u32 , 1924991364u32 , 4260186941u32 , 1660726878u32 , 1496007974u32 , 1713409972u32 , 610893786u32 , 2383700325u32 , 2091062413u32 , 4018656289u32 , 1764594812u32 , 3709793219u32 , 1356155463u32 , 825000363u32 , 3862168567u32 , 3812424145u32 , 3273539984u32 , 2927217335u32 , 787973706u32 , 2068298677u32 , 3278498399u32 , 3371793166u32 , 4144887102u32 , 1289880550u32 , 1980252733u32 , 4114207458u32 , 143478574u32 , 115637463u32 , 1060911337u32 , 1696233065u32 , 3799256240u32 , 1918948260u32 , 3572217425u32 , 4048787516u32 , 2730644329u32 , 4287406983u32 , 3041455211u32 , 3608092222u32 , 2389793136u32 , 1747256964u32 , 3199297686u32 , 3937191824u32 , 1833541319u32 , 3356497412u32 , 357019207u32 , 3084283302u32 , 2550357363u32 , 2047753258u32 , 2980412961u32 , 167340041u32 , 2591735095u32 , 3895686923u32 , 2893479988u32 , 2620153124u32 , 1196494198u32 , 3588373335u32 , 2363338602u32 , 680267915u32 , 3031015162u32 , 4032437431u32 , 183626286u32 , 962337312u32 , 11175636u32 , 1270941540u32 , 1704381425u32 , 3646787135u32 , 1529410224u32 , 2961964106u32 , 2884343567u32 , 1086403303u32 , 1961077096u32 , 486057470u32 , 2229477384u32 , 3140418151u32 , 441619653u32 , 1271998022u32 , 597485693u32 , 26369323u32 , 3838527384u32 , 2271863710u32 , 268294220u32 , 1113648994u32 , 2754786514u32 , 1967061597u32 , 688563368u32 , 859546789u32 , 95564789u32 , 3390498297u32 , 3468989663u32 , 3856221452u32 , 1026931307u32 , 3164895664u32 , 491646294u32 , 3674106722u32 , 742853127u32 , 498024801u32 , 269731020u32 , 3296146244u32 , 3653391143u32 , 193163341u32 , 3231125223u32 , 251844155u32 , 1531081973u32 , 3937177209u32 , 3345816294u32 , 1545307082u32 , 3798210249u32 , 1969026116u32 , 4080036470u32 , 2233655342u32 , 3074935477u32 , 2660037162u32 , 570359024u32 , 1064789251u32 , 2075053822u32 , 1436742140u32 , 1659529969u32 , 990264918u32 , 3805722218u32 , 4155473355u32 , 551601771u32 , 2113798551u32 , 2749033157u32 , 316404133u32 , 3107512368u32 , 849353939u32 , 3711226859u32 , 1493588833u32 , 3038336232u32 , 6175338u32 , 2998850704u32 , 1964478094u32 , 1459652027u32 , 1425318046u32 , 1270424231u32 , 2813597207u32 , 2798901808u32 , 4121432320u32 , 797499465u32 , 2213967518u32 , 3139000449u32 , 3434111473u32 , 1980444132u32 , 4193230156u32 , 1025361169u32 , 3648607726u32 , 3569972244u32 , 1040004347u32 , 1070642373u32 , 2005060454u32 , 2761967137u32 , 1135843586u32 , 3483791417u32 , 1670804630u32 , 2875176293u32 , 898289440u32 , 1647114263u32 , 4123782853u32 , 3595420161u32 , 1956396338u32 , 917510687u32 , 59658625u32 , 1341662051u32 , 3173477931u32 , 4001891308u32 , 3538034810u32 , 2146706716u32 , 3315223323u32 , 4118614427u32 , 4067843623u32 , 290068694u32 , 4274065971u32 , 540984354u32 , 3978549325u32 , 3668239605u32 , 2832170387u32 , 2055579803u32 , 527925402u32 , 150393700u32 , 1727774507u32 , 2627228424u32 , 3044528111u32 , 1674115585u32 , 4266430317u32 , 3708044859u32 , 1285071230u32 , 2673802232u32 , 577943792u32 , 3023844475u32 , 297387744u32 , 2140727092u32 , 3819629636u32 , 471362903u32 , 717168679u32 , 413668059u32 , 3336988988u32 , 1437637129u32 , 1106010321u32 , 2901051737u32 , 1039356818u32 , 1340705914u32 , 175932733u32 , 4207482022u32 , 1634030783u32 , 3088760233u32 , 4019313672u32 , 1943821868u32 , 89533980u32 , 1693167880u32 , 1746599759u32 , 3553740950u32 , 3391938715u32 , 3471797576u32 , 322837783u32 , 33840900u32 , 3087731897u32 , 2407704912u32 , 4279947214u32 , 1776997671u32 , 3099170635u32 , 428550904u32 , 1008080924u32 , 3081310440u32 , 2627759492u32 , 3394829011u32 , 1469020628u32 , 540156035u32 , 890471348u32 , 3467076559u32 , 2152634883u32 , 517970045u32 , 3420533286u32 , 998270762u32 , 1733779952u32 , 2648768565u32 , 53892155u32 , 1114315443u32 , 2192643058u32 , 1695163510u32 , 868058960u32 , 3522778558u32 , 2038498193u32 , 2062376914u32 , 149474300u32 , 776053845u32 , 303986147u32 , 1137297938u32 , 3072954000u32 , 1000927536u32 , 1079146945u32 , 123115520u32 , 261387879u32 , 1343823872u32 , 1346406727u32 , 1934553247u32 , 1465547969u32 , 624093324u32 , 1713731671u32 , 1462083347u32 , 1585700207u32 , 2907088801u32 , 2766318564u32 , 3364582022u32 , 898067958u32 , 2555432291u32 , 496466373u32 , 4110733451u32 , 3359083184u32 , 516688877u32 , 1784113404u32 , 3813953811u32 , 1638551108u32 , 11851321u32 , 2537656704u32 , 3574495545u32 , 23332298u32 , 3978774502u32 , 582074557u32 , 314533796u32 , 697370994u32 , 3225919750u32 , 745064063u32 , 1784393862u32 , 1406178112u32 , 4197022858u32 , 3368766693u32 , 2731266052u32 , 4214847380u32 , 340120193u32 , 284653812u32 , 2519983718u32 , 3318082606u32 , 4219469015u32 , 3263344947u32 , 2176790048u32 , 4257931290u32 , 832628307u32 , 2607187618u32 , 1563912927u32 , 2509936390u32 , 1152797465u32 , 2112894915u32 , 297767543u32 , 882636649u32 , 3730423347u32 , 1754753923u32 , 671909442u32 , 3717621328u32 , 191876287u32 , 214212608u32 , 876893636u32 , 3182531199u32 , 1068196084u32 , 1704100245u32 , 1151125310u32 , 1846373592u32 , 722849851u32 , 839481326u32 , 872051764u32 , 2250640510u32 , 1281759160u32 , 1700718142u32 , 1326112048u32 , 510569370u32 , 798432117u32 , 3473820876u32 , 2145215358u32 , 2985998690u32 , 3022377460u32 , 2351838155u32 , 3173400481u32 , 3290302249u32 , 2488083091u32 , 857129565u32 , 3022346510u32 , 3472575083u32 , 2331857769u32 , 742460070u32 , 671572742u32 , 3353385752u32 , 2869380463u32 , 2825708013u32 , 4213661298u32 , 1159398089u32 , 1344436999u32 , 968834697u32 , 3303937590u32 , 631162154u32 , 1578024761u32 , 1099196523u32 , 1290517656u32 , 2705478669u32 , 4151148662u32 , 2619524090u32 , 1960989138u32 , 3598404451u32 , 388019751u32 , 3221036252u32 , 2986159298u32 , 1715378710u32 , 4088548386u32 , 1081225797u32 , 3064390904u32 , 3311581079u32 , 1904259492u32 , 1029483847u32 , 2526332624u32 , 1721701609u32 , 4082073077u32 , 259654618u32 , 1160497299u32 , 1582153498u32 , 4114830095u32 , 1492357159u32 , 4064199297u32 , 3173625849u32 , 2481108222u32 , 1209573904u32 , 487396000u32 , 167018041u32 , 1751032114u32 , 2468381339u32 , 1004995609u32 , 2753608321u32 , 2701977759u32 , 42180808u32 , 2324745345u32 , 2274933261u32 , 940673285u32 , 1063313316u32 , 904157188u32 , 3447324541u32 , 1932517039u32 , 906623274u32 , 2117758015u32 , 1411183032u32 , 1289272887u32 , 482099679u32 , 2909783456u32 , 1213081654u32 , 3931194778u32 , 3367662520u32 , 4019205149u32 , 631093780u32 , 731340681u32 , 2196595662u32 , 4174481087u32 , 127349794u32 , 3054316836u32 , 236464811u32 , 1737183206u32 , 3720179864u32 , 3482160649u32 , 2488889144u32 , 3859396703u32 , 1528320406u32 , 977519882u32 , 139625561u32 , 369465691u32 , 3520680811u32 , 3496513502u32 , 130627326u32 , 2352150961u32 , 3349181976u32 , 3316294029u32 , 4133853804u32 , 431655942u32 , 1867791235u32 , 1597870884u32 , 3006277213u32 , 1365633322u32 , 790236809u32 , 1013909549u32 , 2338483475u32 , 1108361085u32 , 3213189697u32 , 1109713652u32 , 3756296120u32 , 1639866691u32 , 1340310784u32 , 2190494129u32 , 4227008938u32 , 2822081788u32 , 1829179432u32 , 3792741489u32 , 3224307212u32 , 1268358839u32 , 13535145u32 , 507264248u32 , 1122986055u32 , 1363498200u32 , 3123322936u32 , 1511898050u32 , 738404731u32 , 3200099719u32 , 1089255496u32 , 960352296u32 , 3192182081u32 , 41264406u32 , 3848540887u32 , 189988860u32 , 1054325476u32 , 2791371120u32 , 1390052554u32 , 2965230298u32 , 3953335784u32 , 1324932700u32 , 121548787u32 , 3857554377u32 , 225950890u32 , 3727352922u32 , 1443202521u32 , 1372447217u32 , 427162403u32 , 623782337u32 , 3855161187u32 , 3543883658u32 , 2282081120u32 , 4104071589u32 , 948133874u32 , 625288246u32 , 3629415669u32 , 1906307066u32 , 1490652026u32 , 1038372645u32 , 2577707114u32 , 3436454788u32 , 2286720981u32 , 4010765371u32 , 1694998203u32 , 1003700867u32 , 13967138u32 , 2458868732u32 , 2007550408u32 , 2440702496u32 , 3725445512u32 , 660920321u32 , 3735993810u32 , 642136761u32 , 1622957280u32 , 4197990453u32 , 1265818470u32 , 4086049772u32 , 1466152561u32 , 1756051603u32 , 2817038524u32 , 2606928828u32 , 1081021937u32 , 155801033u32 , 3337178u32 , 1463711312u32 , 3148690945u32 , 1048020461u32 , 3776643770u32 , 3517724257u32 , 1014874794u32 , 2162760400u32 , 836037603u32 , 699250933u32 , 2710653095u32 , 3650491062u32 , 3761485389u32 , 2990288183u32 , 2172529172u32 , 2974337319u32 , 1397943031u32 , 1031843807u32 , 938548574u32 , 1402964693u32 , 611308476u32 , 1359418558u32 , 951933631u32 , 3590479039u32 , 2771320901u32 , 1123905875u32 , 2938551886u32 , 2770211272u32 , 3480491085u32 , 1712566118u32 , 909579565u32 , 1328456326u32 , 1503507106u32 , 4157184116u32 , 1857928766u32 , 2806594463u32 , 3172500845u32 , 844290399u32 , 207807063u32 , 4016453314u32 , 4179141959u32 , 4208387215u32 , 2994067376u32 , 3017840974u32 , 2410855252u32 , 3503166008u32 , 3161172129u32 , 3505831613u32 , 3174660173u32 , 657335448u32 , 2271299428u32 , 581625092u32 , 497920229u32 , 1853897548u32 , 635163395u32 , 328232673u32 , 3535003966u32 , 3561280171u32 , 1313537745u32 , 1622799733u32 , 986461641u32 , 3377397637u32 , 835417400u32 , 2384049441u32 , 2762337148u32 , 4004244404u32 , 3745411061u32 , 3469436088u32 , 3949169397u32 , 909665113u32 , 1642132156u32 , 2720850668u32 , 3766194097u32 , 3441525639u32 , 2377326793u32 , 1882820659u32 , 2253042667u32 , 585557574u32 , 3015830598u32 , 3247137570u32 , 24676607u32 , 1327970202u32 , 235814134u32 , 3888122413u32 , 67060975u32 , 1500515759u32 , 372536167u32 , 1421968030u32 , 1494292933u32 , 326494834u32 , 2052860768u32 , 840604679u32 , 2143535654u32 , 520649620u32 , 1085252765u32 , 4125580644u32 , 3251283326u32 , 3637562920u32 , 3391050331u32 , 1545869555u32 , 718491279u32 , 3564373280u32 , 2231254690u32] } ;\n& SET } fn empty_string_index () -> u32 { 370u32 } } pub const ATOM_LOCALNAME__66_65_6D_6F_72_70_68_6F_6C_6F_67_79 : LocalName = LocalName :: pack_static (0u32) ;\npub const ATOM_LOCALNAME__78_6D_6C_3A_73_70_61_63_65 : LocalName = LocalName :: pack_static (1u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6F_72_69_65_6E_74_61_74_69_6F_6E : LocalName = LocalName :: pack_static (2u32) ;\npub const ATOM_LOCALNAME__63_61_6C_63_6D_6F_64_65 : LocalName = LocalName :: pack_static (3u32) ;\npub const ATOM_LOCALNAME__75_6E_69_63_6F_64_65_2D_62_69_64_69 : LocalName = LocalName :: pack_static (4u32) ;\npub const ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68_49_74_65_6D : LocalName = LocalName :: pack_static (5u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_53_74_79_6C_65_54_79_70_65 : LocalName = LocalName :: pack_static (6u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_58 : LocalName = LocalName :: pack_static (7u32) ;\npub const ATOM_LOCALNAME__65_71_75_61_6C_72_6F_77_73 : LocalName = LocalName :: pack_static (8u32) ;\npub const ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_63_6C_6F_6E_61_62_6C_65 : LocalName = LocalName :: pack_static (9u32) ;\npub const ATOM_LOCALNAME__66_65_44_69_73_70_6C_61_63_65_6D_65_6E_74_4D_61_70 : LocalName = LocalName :: pack_static (10u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_73_63_72_69_70_74_74_79_70_65 : LocalName = LocalName :: pack_static (11u32) ;\npub const ATOM_LOCALNAME__6F_76_65_72_6C_69_6E_65_2D_74_68_69_63_6B_6E_65_73_73 : LocalName = LocalName :: pack_static (12u32) ;\npub const ATOM_LOCALNAME__6E_6F_72_65_73_69_7A_65 : LocalName = LocalName :: pack_static (13u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_6C_65_61_76_65 : LocalName = LocalName :: pack_static (14u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_77_68_65_65_6C : LocalName = LocalName :: pack_static (15u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (16u32) ;\npub const ATOM_LOCALNAME__77_72_69_74_69_6E_67_2D_6D_6F_64_65 : LocalName = LocalName :: pack_static (17u32) ;\npub const ATOM_LOCALNAME__6D_65_6E_75_69_74_65_6D : LocalName = LocalName :: pack_static (18u32) ;\npub const ATOM_LOCALNAME__6D_61_6E_69_66_65_73_74 : LocalName = LocalName :: pack_static (19u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_73_74_79_6C_65_74_79_70_65 : LocalName = LocalName :: pack_static (20u32) ;\npub const ATOM_LOCALNAME__66_6C_6F_6F_64_2D_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (21u32) ;\npub const ATOM_LOCALNAME__61_63_63_75_6D_75_6C_61_74_65 : LocalName = LocalName :: pack_static (22u32) ;\npub const ATOM_LOCALNAME__65_71_75_61_6C_63_6F_6C_75_6D_6E_73 : LocalName = LocalName :: pack_static (23u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_63_6F_75_6E_74 : LocalName = LocalName :: pack_static (24u32) ;\npub const ATOM_LOCALNAME__62_6C_6F_63_6B_71_75_6F_74_65 : LocalName = LocalName :: pack_static (25u32) ;\npub const ATOM_LOCALNAME__6B_65_79_73_70_6C_69_6E_65_73 : LocalName = LocalName :: pack_static (26u32) ;\npub const ATOM_LOCALNAME__65_78_74_65_72_6E_61_6C_52_65_73_6F_75_72_63_65_73_52_65_71_75_69_72_65_64 : LocalName = LocalName :: pack_static (27u32) ;\npub const ATOM_LOCALNAME__76_2D_69_64_65_6F_67_72_61_70_68_69_63 : LocalName = LocalName :: pack_static (28u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_74_69_74_6C_65 : LocalName = LocalName :: pack_static (29u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_73_74_72_65_74_63_68 : LocalName = LocalName :: pack_static (30u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6C_61_62_65_6C_6C_65_64_62_79 : LocalName = LocalName :: pack_static (31u32) ;\npub const ATOM_LOCALNAME__6C_69_67_68_74_69_6E_67_2D_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (32u32) ;\npub const ATOM_LOCALNAME__63_6F_64_65_62_61_73_65 : LocalName = LocalName :: pack_static (33u32) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_6E_6F_76_61_6C_69_64_61_74_65 : LocalName = LocalName :: pack_static (34u32) ;\npub const ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_63_6F_6E_73_74_61_6E_74 : LocalName = LocalName :: pack_static (35u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_65_73_63_72_69_62_65_64_62_79 : LocalName = LocalName :: pack_static (36u32) ;\npub const ATOM_LOCALNAME__6D_61_6C_69_67_6E_67_72_6F_75_70 : LocalName = LocalName :: pack_static (37u32) ;\npub const ATOM_LOCALNAME__70_61_74_68_6C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (38u32) ;\npub const ATOM_LOCALNAME__65_6D_70_74_79_73_65_74 : LocalName = LocalName :: pack_static (39u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_78_74_6D_65_6E_75 : LocalName = LocalName :: pack_static (40u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_2D_61_6E_63_68_6F_72 : LocalName = LocalName :: pack_static (41u32) ;\npub const ATOM_LOCALNAME__61_72_61_62_69_63_2D_66_6F_72_6D : LocalName = LocalName :: pack_static (42u32) ;\npub const ATOM_LOCALNAME__6F_6E_6C_6F_73_65_63_61_70_74_75_72_65 : LocalName = LocalName :: pack_static (43u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_61_63_74_69_76_61_74_65 : LocalName = LocalName :: pack_static (44u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_61_63_74_69_76_65_64_65_73_63_65_6E_64_61_6E_74 : LocalName = LocalName :: pack_static (45u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_6A_75_67_61_74_65 : LocalName = LocalName :: pack_static (46u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_61_74_61_74_79_70_65 : LocalName = LocalName :: pack_static (47u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_65_73_63_72_69_70_74_69_6F_6E : LocalName = LocalName :: pack_static (48u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_6C_69_6E_65 : LocalName = LocalName :: pack_static (49u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_7A : LocalName = LocalName :: pack_static (50u32) ;\npub const ATOM_LOCALNAME__6D_6C_61_62_65_6C_65_64_74_72 : LocalName = LocalName :: pack_static (51u32) ;\npub const ATOM_LOCALNAME__6F_6E_73_75_62_6D_69_74 : LocalName = LocalName :: pack_static (52u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_65_6C_65_76_61_6E_74 : LocalName = LocalName :: pack_static (53u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_68_61_73_70_6F_70_75_70 : LocalName = LocalName :: pack_static (54u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_6F_76_65_72 : LocalName = LocalName :: pack_static (55u32) ;\npub const ATOM_LOCALNAME__6E_6F_74_61_74_69_6F_6E : LocalName = LocalName :: pack_static (56u32) ;\npub const ATOM_LOCALNAME__73_63_72_6F_6C_6C_64_65_6C_61_79 : LocalName = LocalName :: pack_static (57u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_63_75_74 : LocalName = LocalName :: pack_static (58u32) ;\npub const ATOM_LOCALNAME__76_69_73_69_62_69_6C_69_74_79 : LocalName = LocalName :: pack_static (59u32) ;\npub const ATOM_LOCALNAME__66_65_70_6F_69_6E_74_6C_69_67_68_74 : LocalName = LocalName :: pack_static (60u32) ;\npub const ATOM_LOCALNAME__76_2D_6D_61_74_68_65_6D_61_74_69_63_61_6C : LocalName = LocalName :: pack_static (61u32) ;\npub const ATOM_LOCALNAME__66_69_6C_6C_2D_72_75_6C_65 : LocalName = LocalName :: pack_static (62u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_70_72_65_73_73_65_64 : LocalName = LocalName :: pack_static (63u32) ;\npub const ATOM_LOCALNAME__72_6F_77_61_6C_69_67_6E : LocalName = LocalName :: pack_static (64u32) ;\npub const ATOM_LOCALNAME__6F_6E_75_6E_6C_6F_61_64 : LocalName = LocalName :: pack_static (65u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_73_74_61_72_74 : LocalName = LocalName :: pack_static (66u32) ;\npub const ATOM_LOCALNAME__6E_6F_74_70_72_73_75_62_73_65_74 : LocalName = LocalName :: pack_static (67u32) ;\npub const ATOM_LOCALNAME__73_65_6C_65_63_74_69_6F_6E : LocalName = LocalName :: pack_static (68u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_77_69_64_74_68 : LocalName = LocalName :: pack_static (69u32) ;\npub const ATOM_LOCALNAME__70_72_65_66_65_74_63_68 : LocalName = LocalName :: pack_static (70u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_70_6F_73_69_6E_73_65_74 : LocalName = LocalName :: pack_static (71u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_77_69_64_74_68 : LocalName = LocalName :: pack_static (72u32) ;\npub const ATOM_LOCALNAME__6F_6E_75_6E_68_61_6E_64_6C_65_64_72_65_6A_65_63_74_69_6F_6E : LocalName = LocalName :: pack_static (73u32) ;\npub const ATOM_LOCALNAME__66_65_6D_65_72_67_65_6E_6F_64_65 : LocalName = LocalName :: pack_static (74u32) ;\npub const ATOM_LOCALNAME__70_61_72_74_69_61_6C_64_69_66_66 : LocalName = LocalName :: pack_static (75u32) ;\npub const ATOM_LOCALNAME__74_61_62_69_6E_64_65_78 : LocalName = LocalName :: pack_static (76u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_76_65_73_74_61_72_74 : LocalName = LocalName :: pack_static (77u32) ;\npub const ATOM_LOCALNAME__66_65_64_69_73_74_61_6E_74_6C_69_67_68_74 : LocalName = LocalName :: pack_static (78u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6C_69_76_65 : LocalName = LocalName :: pack_static (79u32) ;\npub const ATOM_LOCALNAME__6C_6F_6E_67_64_65_73_63 : LocalName = LocalName :: pack_static (80u32) ;\npub const ATOM_LOCALNAME__76_65_63_74_6F_72_70_72_6F_64_75_63_74 : LocalName = LocalName :: pack_static (81u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_50_72_6F_66_69_6C_65 : LocalName = LocalName :: pack_static (82u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_75_6D_6E_73_70_61_6E : LocalName = LocalName :: pack_static (83u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_77_65_69_67_68_74 : LocalName = LocalName :: pack_static (84u32) ;\npub const ATOM_LOCALNAME__73_65_61_6D_6C_65_73_73 : LocalName = LocalName :: pack_static (85u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6D_75_6C_74_69_6C_69_6E_65 : LocalName = LocalName :: pack_static (86u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6C_69_6E_65_63_61_70 : LocalName = LocalName :: pack_static (87u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_75_6D_6E_61_6C_69_67_6E : LocalName = LocalName :: pack_static (88u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_55_6E_69_74_73 : LocalName = LocalName :: pack_static (89u32) ;\npub const ATOM_LOCALNAME__69_64_65_6F_67_72_61_70_68_69_63 : LocalName = LocalName :: pack_static (90u32) ;\npub const ATOM_LOCALNAME__6F_6E_70_61_67_65_72_65_76_65_61_6C : LocalName = LocalName :: pack_static (91u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_65_64_69_74_61_62_6C_65 : LocalName = LocalName :: pack_static (92u32) ;\npub const ATOM_LOCALNAME__70_72_6F_67_72_65_73_73 : LocalName = LocalName :: pack_static (93u32) ;\npub const ATOM_LOCALNAME__6F_6E_6B_65_79_70_72_65_73_73 : LocalName = LocalName :: pack_static (94u32) ;\npub const ATOM_LOCALNAME__61_63_74_69_6F_6E_74_79_70_65 : LocalName = LocalName :: pack_static (95u32) ;\npub const ATOM_LOCALNAME__73_63_61_6C_61_72_70_72_6F_64_75_63_74 : LocalName = LocalName :: pack_static (96u32) ;\npub const ATOM_LOCALNAME__70_6C_61_69_6E_74_65_78_74 : LocalName = LocalName :: pack_static (97u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6E_74_72_6F_6C_73 : LocalName = LocalName :: pack_static (98u32) ;\npub const ATOM_LOCALNAME__66_65_43_6F_6E_76_6F_6C_76_65_4D_61_74_72_69_78 : LocalName = LocalName :: pack_static (99u32) ;\npub const ATOM_LOCALNAME__7A_6F_6F_6D_61_6E_64_70_61_6E : LocalName = LocalName :: pack_static (100u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_50_61_74_68_55_6E_69_74_73 : LocalName = LocalName :: pack_static (101u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_2D_6D_69_6E : LocalName = LocalName :: pack_static (102u32) ;\npub const ATOM_LOCALNAME__7A_6F_6F_6D_41_6E_64_50_61_6E : LocalName = LocalName :: pack_static (103u32) ;\npub const ATOM_LOCALNAME__73_74_6F_70_2D_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (104u32) ;\npub const ATOM_LOCALNAME__6B_65_79_50_6F_69_6E_74_73 : LocalName = LocalName :: pack_static (105u32) ;\npub const ATOM_LOCALNAME__73_70_65_6C_6C_63_68_65_63_6B : LocalName = LocalName :: pack_static (106u32) ;\npub const ATOM_LOCALNAME__6F_6E_6F_6E_6C_69_6E_65 : LocalName = LocalName :: pack_static (107u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_65_6A_65_63_74_69_6F_6E_68_61_6E_64_6C_65_64 : LocalName = LocalName :: pack_static (108u32) ;\npub const ATOM_LOCALNAME__66_65_4D_6F_72_70_68_6F_6C_6F_67_79 : LocalName = LocalName :: pack_static (109u32) ;\npub const ATOM_LOCALNAME__70_72_65_73_65_72_76_65_41_73_70_65_63_74_52_61_74_69_6F : LocalName = LocalName :: pack_static (110u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_63_6F_6E_74_65_6E_74 : LocalName = LocalName :: pack_static (111u32) ;\npub const ATOM_LOCALNAME__65_6C_65_76_61_74_69_6F_6E : LocalName = LocalName :: pack_static (112u32) ;\npub const ATOM_LOCALNAME__66_65_63_6F_6D_70_6F_73_69_74_65 : LocalName = LocalName :: pack_static (113u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_65_72_2D_65_76_65_6E_74_73 : LocalName = LocalName :: pack_static (114u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_75_70_64_61_74_65 : LocalName = LocalName :: pack_static (115u32) ;\npub const ATOM_LOCALNAME__73_74_61_74_65_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (116u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_77_65_69_67_68_74 : LocalName = LocalName :: pack_static (117u32) ;\npub const ATOM_LOCALNAME__72_61_74_69_6F_6E_61_6C_73 : LocalName = LocalName :: pack_static (118u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_69_6C_74_65_72_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (119u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_66_6F_6E_74 : LocalName = LocalName :: pack_static (120u32) ;\npub const ATOM_LOCALNAME__6D_61_78_6C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (121u32) ;\npub const ATOM_LOCALNAME__70_72_6F_70_65_72_74_79 : LocalName = LocalName :: pack_static (122u32) ;\npub const ATOM_LOCALNAME__61_75_74_6F_70_6C_61_79 : LocalName = LocalName :: pack_static (123u32) ;\npub const ATOM_LOCALNAME__61_63_63_65_6E_74_2D_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (124u32) ;\npub const ATOM_LOCALNAME__64_69_72_65_63_74_69_6F_6E : LocalName = LocalName :: pack_static (125u32) ;\npub const ATOM_LOCALNAME__78_6D_6C_3A_62_61_73_65 : LocalName = LocalName :: pack_static (126u32) ;\npub const ATOM_LOCALNAME__6F_6E_69_6E_76_61_6C_69_64 : LocalName = LocalName :: pack_static (127u32) ;\npub const ATOM_LOCALNAME__65_78_70_6F_72_74_70_61_72_74_73 : LocalName = LocalName :: pack_static (128u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_64_61_73_68_6F_66_66_73_65_74 : LocalName = LocalName :: pack_static (129u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_75_72_69 : LocalName = LocalName :: pack_static (130u32) ;\npub const ATOM_LOCALNAME__73_79_73_74_65_6D_6C_61_6E_67_75_61_67_65 : LocalName = LocalName :: pack_static (131u32) ;\npub const ATOM_LOCALNAME__69_72_72_65_6C_65_76_61_6E_74 : LocalName = LocalName :: pack_static (132u32) ;\npub const ATOM_LOCALNAME__76_65_72_79_76_65_72_79_74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (133u32) ;\npub const ATOM_LOCALNAME__75_6E_73_65_6C_65_63_74_61_62_6C_65 : LocalName = LocalName :: pack_static (134u32) ;\npub const ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_2D_73_72_63 : LocalName = LocalName :: pack_static (135u32) ;\npub const ATOM_LOCALNAME__69_6E_74_65_72_73_65_63_74 : LocalName = LocalName :: pack_static (136u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_65_78_70_61_6E_64_65_64 : LocalName = LocalName :: pack_static (137u32) ;\npub const ATOM_LOCALNAME__65_75_6C_65_72_67_61_6D_6D_61 : LocalName = LocalName :: pack_static (138u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_6D_69_6C_79 : LocalName = LocalName :: pack_static (139u32) ;\npub const ATOM_LOCALNAME__6C_69_6E_65_61_72_67_72_61_64_69_65_6E_74 : LocalName = LocalName :: pack_static (140u32) ;\npub const ATOM_LOCALNAME__6D_70_68_61_6E_74_6F_6D : LocalName = LocalName :: pack_static (141u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_75_6D_6E_6C_69_6E_65_73 : LocalName = LocalName :: pack_static (142u32) ;\npub const ATOM_LOCALNAME__6B_65_72_6E_65_6C_75_6E_69_74_6C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (143u32) ;\npub const ATOM_LOCALNAME__6D_61_74_72_69_78_72_6F_77 : LocalName = LocalName :: pack_static (144u32) ;\npub const ATOM_LOCALNAME__73_75_72_66_61_63_65_73_63_61_6C_65 : LocalName = LocalName :: pack_static (145u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_63_6F_75_6E_74 : LocalName = LocalName :: pack_static (146u32) ;\npub const ATOM_LOCALNAME__6D_61_73_6B_63_6F_6E_74_65_6E_74_75_6E_69_74_73 : LocalName = LocalName :: pack_static (147u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_73_72_63 : LocalName = LocalName :: pack_static (148u32) ;\npub const ATOM_LOCALNAME__61_6E_6E_6F_74_61_74_69_6F_6E_2D_78_6D_6C : LocalName = LocalName :: pack_static (149u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_6F_6C_65_64_65_73_63_72_69_70_74_69_6F_6E : LocalName = LocalName :: pack_static (150u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_50_61_74_68 : LocalName = LocalName :: pack_static (151u32) ;\npub const ATOM_LOCALNAME__6D_61_73_6B_43_6F_6E_74_65_6E_74_55_6E_69_74_73 : LocalName = LocalName :: pack_static (152u32) ;\npub const ATOM_LOCALNAME__6B_65_79_54_69_6D_65_73 : LocalName = LocalName :: pack_static (153u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_73_70_61_6E : LocalName = LocalName :: pack_static (154u32) ;\npub const ATOM_LOCALNAME__66_72_61_6D_65_62_6F_72_64_65_72 : LocalName = LocalName :: pack_static (155u32) ;\npub const ATOM_LOCALNAME__66_65_53_70_65_63_75_6C_61_72_4C_69_67_68_74_69_6E_67 : LocalName = LocalName :: pack_static (156u32) ;\npub const ATOM_LOCALNAME__79_43_68_61_6E_6E_65_6C_53_65_6C_65_63_74_6F_72 : LocalName = LocalName :: pack_static (157u32) ;\npub const ATOM_LOCALNAME__74_72_61_6E_73_6C_61_74_65 : LocalName = LocalName :: pack_static (158u32) ;\npub const ATOM_LOCALNAME__6F_63_63_75_72_72_65_6E_63_65 : LocalName = LocalName :: pack_static (159u32) ;\npub const ATOM_LOCALNAME__6D_6D_75_6C_74_69_73_63_72_69_70_74_73 : LocalName = LocalName :: pack_static (160u32) ;\npub const ATOM_LOCALNAME__6C_69_6E_65_61_72_47_72_61_64_69_65_6E_74 : LocalName = LocalName :: pack_static (161u32) ;\npub const ATOM_LOCALNAME__66_6F_72_65_69_67_6E_4F_62_6A_65_63_74 : LocalName = LocalName :: pack_static (162u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65 : LocalName = LocalName :: pack_static (163u32) ;\npub const ATOM_LOCALNAME__6D_61_72_67_69_6E_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (164u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_75_6E_69_74_73 : LocalName = LocalName :: pack_static (165u32) ;\npub const ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_54_79_70_65 : LocalName = LocalName :: pack_static (166u32) ;\npub const ATOM_LOCALNAME__64_61_74_61_66_6F_72_6D_61_74_61_73 : LocalName = LocalName :: pack_static (167u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_70_72_6F_66_69_6C_65 : LocalName = LocalName :: pack_static (168u32) ;\npub const ATOM_LOCALNAME__6E_61_74_75_72_61_6C_6E_75_6D_62_65_72_73 : LocalName = LocalName :: pack_static (169u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_73_70_61_6E : LocalName = LocalName :: pack_static (170u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_61_74_61_73_65_74_63_68_61_6E_67_65_64 : LocalName = LocalName :: pack_static (171u32) ;\npub const ATOM_LOCALNAME__72_65_61_64_6F_6E_6C_79 : LocalName = LocalName :: pack_static (172u32) ;\npub const ATOM_LOCALNAME__76_65_72_79_74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (173u32) ;\npub const ATOM_LOCALNAME__62_61_63_6B_67_72_6F_75_6E_64 : LocalName = LocalName :: pack_static (174u32) ;\npub const ATOM_LOCALNAME__73_74_72_69_6B_65_74_68_72_6F_75_67_68_2D_74_68_69_63_6B_6E_65_73_73 : LocalName = LocalName :: pack_static (175u32) ;\npub const ATOM_LOCALNAME__61_63_63_65_70_74_2D_63_68_61_72_73_65_74 : LocalName = LocalName :: pack_static (176u32) ;\npub const ATOM_LOCALNAME__64_61_74_65_74_69_6D_65 : LocalName = LocalName :: pack_static (177u32) ;\npub const ATOM_LOCALNAME__73_74_72_69_6B_65_74_68_72_6F_75_67_68_2D_70_6F_73_69_74_69_6F_6E : LocalName = LocalName :: pack_static (178u32) ;\npub const ATOM_LOCALNAME__65_78_70_6F_6E_65_6E_74_69_61_6C_65 : LocalName = LocalName :: pack_static (179u32) ;\npub const ATOM_LOCALNAME__73_70_72_65_61_64_4D_65_74_68_6F_64 : LocalName = LocalName :: pack_static (180u32) ;\npub const ATOM_LOCALNAME__6B_65_72_6E_65_6C_4D_61_74_72_69_78 : LocalName = LocalName :: pack_static (181u32) ;\npub const ATOM_LOCALNAME__66_65_63_6F_6C_6F_72_6D_61_74_72_69_78 : LocalName = LocalName :: pack_static (182u32) ;\npub const ATOM_LOCALNAME__6F_6E_73_65_6C_65_63_74_73_74_61_72_74 : LocalName = LocalName :: pack_static (183u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_61_72_63_72_6F_6C_65 : LocalName = LocalName :: pack_static (184u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_6F_63_75_73_6F_75_74 : LocalName = LocalName :: pack_static (185u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_4D_6F_74_69_6F_6E : LocalName = LocalName :: pack_static (186u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_6F_77_65_6E_74_65_72 : LocalName = LocalName :: pack_static (187u32) ;\npub const ATOM_LOCALNAME__75_6E_69_74_73_2D_70_65_72_2D_65_6D : LocalName = LocalName :: pack_static (188u32) ;\npub const ATOM_LOCALNAME__73_74_64_44_65_76_69_61_74_69_6F_6E : LocalName = LocalName :: pack_static (189u32) ;\npub const ATOM_LOCALNAME__73_74_61_72_74_6F_66_66_73_65_74 : LocalName = LocalName :: pack_static (190u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_61_74_61_73_65_74_63_6F_6D_70_6C_65_74_65 : LocalName = LocalName :: pack_static (191u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_73_69_7A_65 : LocalName = LocalName :: pack_static (192u32) ;\npub const ATOM_LOCALNAME__66_65_43_6F_6C_6F_72_4D_61_74_72_69_78 : LocalName = LocalName :: pack_static (193u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_61_72_65_61 : LocalName = LocalName :: pack_static (194u32) ;\npub const ATOM_LOCALNAME__66_69_6C_74_65_72_55_6E_69_74_73 : LocalName = LocalName :: pack_static (195u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6D_6F_64_61_6C : LocalName = LocalName :: pack_static (196u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_74_65_78_74 : LocalName = LocalName :: pack_static (197u32) ;\npub const ATOM_LOCALNAME__69_74_65_6D_73_63_6F_70_65 : LocalName = LocalName :: pack_static (198u32) ;\npub const ATOM_LOCALNAME__73_63_72_69_70_74_73_69_7A_65_6D_75_6C_74_69_70_6C_69_65_72 : LocalName = LocalName :: pack_static (199u32) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_6D_65_74_68_6F_64 : LocalName = LocalName :: pack_static (200u32) ;\npub const ATOM_LOCALNAME__61_63_63_65_6E_74_75_6E_64_65_72 : LocalName = LocalName :: pack_static (201u32) ;\npub const ATOM_LOCALNAME__61_63_63_65_73_73_6B_65_79 : LocalName = LocalName :: pack_static (202u32) ;\npub const ATOM_LOCALNAME__6C_69_6D_69_74_69_6E_67_43_6F_6E_65_41_6E_67_6C_65 : LocalName = LocalName :: pack_static (203u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_43_6F_6E_74_65_6E_74 : LocalName = LocalName :: pack_static (204u32) ;\npub const ATOM_LOCALNAME__69_6E_70_75_74_6D_6F_64_65 : LocalName = LocalName :: pack_static (205u32) ;\npub const ATOM_LOCALNAME__6F_6E_61_66_74_65_72_70_72_69_6E_74 : LocalName = LocalName :: pack_static (206u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_53_63_72_69_70_74_54_79_70_65 : LocalName = LocalName :: pack_static (207u32) ;\npub const ATOM_LOCALNAME__72_6F_77_6C_69_6E_65_73 : LocalName = LocalName :: pack_static (208u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_73_74_79_6C_65 : LocalName = LocalName :: pack_static (209u32) ;\npub const ATOM_LOCALNAME__64_69_73_70_6C_61_79_73_74_79_6C_65 : LocalName = LocalName :: pack_static (210u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6C_65_61_76_65 : LocalName = LocalName :: pack_static (211u32) ;\npub const ATOM_LOCALNAME__61_6C_6C_6F_77_66_75_6C_6C_73_63_72_65_65_6E : LocalName = LocalName :: pack_static (212u32) ;\npub const ATOM_LOCALNAME__73_79_6D_6D_65_74_72_69_63 : LocalName = LocalName :: pack_static (213u32) ;\npub const ATOM_LOCALNAME__6E_6F_74_61_6E_75_6D_62_65_72 : LocalName = LocalName :: pack_static (214u32) ;\npub const ATOM_LOCALNAME__6C_65_6E_67_74_68_61_64_6A_75_73_74 : LocalName = LocalName :: pack_static (215u32) ;\npub const ATOM_LOCALNAME__73_74_61_72_74_4F_66_66_73_65_74 : LocalName = LocalName :: pack_static (216u32) ;\npub const ATOM_LOCALNAME__63_65_6C_6C_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (217u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_6F_72_6D_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (218u32) ;\npub const ATOM_LOCALNAME__6D_70_72_65_73_63_72_69_70_74_73 : LocalName = LocalName :: pack_static (219u32) ;\npub const ATOM_LOCALNAME__66_65_64_72_6F_70_73_68_61_64_6F_77 : LocalName = LocalName :: pack_static (220u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_62_72_61_69_6C_6C_65_6C_61_62_65_6C : LocalName = LocalName :: pack_static (221u32) ;\npub const ATOM_LOCALNAME__61_6C_69_67_6E_6D_65_6E_74_73_63_6F_70_65 : LocalName = LocalName :: pack_static (222u32) ;\npub const ATOM_LOCALNAME__6D_61_73_6B_75_6E_69_74_73 : LocalName = LocalName :: pack_static (223u32) ;\npub const ATOM_LOCALNAME__76_69_65_77_54_61_72_67_65_74 : LocalName = LocalName :: pack_static (224u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6D_61_78 : LocalName = LocalName :: pack_static (225u32) ;\npub const ATOM_LOCALNAME__6B_65_72_6E_65_6C_55_6E_69_74_4C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (226u32) ;\npub const ATOM_LOCALNAME__66_65_73_70_6F_74_6C_69_67_68_74 : LocalName = LocalName :: pack_static (227u32) ;\npub const ATOM_LOCALNAME__76_61_72_69_61_6E_63_65 : LocalName = LocalName :: pack_static (228u32) ;\npub const ATOM_LOCALNAME__71_75_6F_74_69_65_6E_74 : LocalName = LocalName :: pack_static (229u32) ;\npub const ATOM_LOCALNAME__6D_6F_6D_65_6E_74_61_62_6F_75_74 : LocalName = LocalName :: pack_static (230u32) ;\npub const ATOM_LOCALNAME__70_61_74_68_4C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (231u32) ;\npub const ATOM_LOCALNAME__6D_61_72_67_69_6E_77_69_64_74_68 : LocalName = LocalName :: pack_static (232u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_48_65_69_67_68_74 : LocalName = LocalName :: pack_static (233u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_69_6E_64_65_78 : LocalName = LocalName :: pack_static (234u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_67_72_61_62 : LocalName = LocalName :: pack_static (235u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_70_61_74_68_75_6E_69_74_73 : LocalName = LocalName :: pack_static (236u32) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68_72_65_66 : LocalName = LocalName :: pack_static (237u32) ;\npub const ATOM_LOCALNAME__6D_69_6E_6C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (238u32) ;\npub const ATOM_LOCALNAME__76_2D_61_6C_70_68_61_62_65_74_69_63 : LocalName = LocalName :: pack_static (239u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_61_75_74_6F_63_6F_6D_70_6C_65_74_65 : LocalName = LocalName :: pack_static (240u32) ;\npub const ATOM_LOCALNAME__76_65_72_79_74_68_69_6E_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (241u32) ;\npub const ATOM_LOCALNAME__65_64_67_65_6D_6F_64_65 : LocalName = LocalName :: pack_static (242u32) ;\npub const ATOM_LOCALNAME__72_61_64_69_61_6C_67_72_61_64_69_65_6E_74 : LocalName = LocalName :: pack_static (243u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6F_76_65_72 : LocalName = LocalName :: pack_static (244u32) ;\npub const ATOM_LOCALNAME__66_65_43_6F_6D_70_6F_73_69_74_65 : LocalName = LocalName :: pack_static (245u32) ;\npub const ATOM_LOCALNAME__73_63_72_69_70_74_6D_69_6E_73_69_7A_65 : LocalName = LocalName :: pack_static (246u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_65_71_75_69_72_65_64 : LocalName = LocalName :: pack_static (247u32) ;\npub const ATOM_LOCALNAME__76_65_72_74_2D_6F_72_69_67_69_6E_2D_79 : LocalName = LocalName :: pack_static (248u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_75_6D_6E_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (249u32) ;\npub const ATOM_LOCALNAME__64_6F_6D_61_69_6E_6F_66_61_70_70_6C_69_63_61_74_69_6F_6E : LocalName = LocalName :: pack_static (250u32) ;\npub const ATOM_LOCALNAME__79_63_68_61_6E_6E_65_6C_73_65_6C_65_63_74_6F_72 : LocalName = LocalName :: pack_static (251u32) ;\npub const ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_6D_6F_64_65 : LocalName = LocalName :: pack_static (252u32) ;\npub const ATOM_LOCALNAME__73_63_72_69_70_74_6C_65_76_65_6C : LocalName = LocalName :: pack_static (253u32) ;\npub const ATOM_LOCALNAME__6B_65_79_74_69_6D_65_73 : LocalName = LocalName :: pack_static (254u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_65_6E_74_65_72 : LocalName = LocalName :: pack_static (255u32) ;\npub const ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_64_65_6C_65_67_61_74_65_73_66_6F_63_75_73 : LocalName = LocalName :: pack_static (256u32) ;\npub const ATOM_LOCALNAME__68_74_74_70_2D_65_71_75_69_76 : LocalName = LocalName :: pack_static (257u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_43_6F_6E_74_65_6E_74_55_6E_69_74_73 : LocalName = LocalName :: pack_static (258u32) ;\npub const ATOM_LOCALNAME__63_61_6C_63_4D_6F_64_65 : LocalName = LocalName :: pack_static (259u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_66_6C_6F_77_74_6F : LocalName = LocalName :: pack_static (260u32) ;\npub const ATOM_LOCALNAME__6D_61_74_68_76_61_72_69_61_6E_74 : LocalName = LocalName :: pack_static (261u32) ;\npub const ATOM_LOCALNAME__6D_75_6C_74_69_70_6C_65 : LocalName = LocalName :: pack_static (262u32) ;\npub const ATOM_LOCALNAME__6C_6F_77_6C_69_6D_69_74 : LocalName = LocalName :: pack_static (263u32) ;\npub const ATOM_LOCALNAME__69_74_65_6D_70_72_6F_70 : LocalName = LocalName :: pack_static (264u32) ;\npub const ATOM_LOCALNAME__64_69_66_66_75_73_65_43_6F_6E_73_74_61_6E_74 : LocalName = LocalName :: pack_static (265u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_54_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (266u32) ;\npub const ATOM_LOCALNAME__6F_6E_6F_66_66_6C_69_6E_65 : LocalName = LocalName :: pack_static (267u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_50_61_74_68 : LocalName = LocalName :: pack_static (268u32) ;\npub const ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_6E_61_6D_65 : LocalName = LocalName :: pack_static (269u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_65_72_72_6F_72_6D_65_73_73_61_67_65 : LocalName = LocalName :: pack_static (270u32) ;\npub const ATOM_LOCALNAME__72_65_71_75_69_72_65_64_46_65_61_74_75_72_65_73 : LocalName = LocalName :: pack_static (271u32) ;\npub const ATOM_LOCALNAME__69_6E_74_65_72_76_61_6C : LocalName = LocalName :: pack_static (272u32) ;\npub const ATOM_LOCALNAME__6D_65_74_61_64_61_74_61 : LocalName = LocalName :: pack_static (273u32) ;\npub const ATOM_LOCALNAME__66_65_4D_65_72_67_65_4E_6F_64_65 : LocalName = LocalName :: pack_static (274u32) ;\npub const ATOM_LOCALNAME__70_6F_6C_79_6C_69_6E_65 : LocalName = LocalName :: pack_static (275u32) ;\npub const ATOM_LOCALNAME__76_2D_68_61_6E_67_69_6E_67 : LocalName = LocalName :: pack_static (276u32) ;\npub const ATOM_LOCALNAME__66_69_6C_74_65_72_52_65_73 : LocalName = LocalName :: pack_static (277u32) ;\npub const ATOM_LOCALNAME__67_72_6F_75_70_61_6C_69_67_6E : LocalName = LocalName :: pack_static (278u32) ;\npub const ATOM_LOCALNAME__66_65_64_69_66_66_75_73_65_6C_69_67_68_74_69_6E_67 : LocalName = LocalName :: pack_static (279u32) ;\npub const ATOM_LOCALNAME__66_69_6C_74_65_72_72_65_73 : LocalName = LocalName :: pack_static (280u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_6F_77_73_69_6E_73_65_72_74_65_64 : LocalName = LocalName :: pack_static (281u32) ;\npub const ATOM_LOCALNAME__69_6D_61_67_69_6E_61_72_79_69 : LocalName = LocalName :: pack_static (282u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_65_6E_74_65_72 : LocalName = LocalName :: pack_static (283u32) ;\npub const ATOM_LOCALNAME__6F_6E_70_61_67_65_73_68_6F_77 : LocalName = LocalName :: pack_static (284u32) ;\npub const ATOM_LOCALNAME__66_65_4F_66_66_73_65_74 : LocalName = LocalName :: pack_static (285u32) ;\npub const ATOM_LOCALNAME__73_75_70_65_72_73_63_72_69_70_74_73_68_69_66_74 : LocalName = LocalName :: pack_static (286u32) ;\npub const ATOM_LOCALNAME__72_65_71_75_69_72_65_64_66_65_61_74_75_72_65_73 : LocalName = LocalName :: pack_static (287u32) ;\npub const ATOM_LOCALNAME__6E_6F_6D_6F_64_75_6C_65 : LocalName = LocalName :: pack_static (288u32) ;\npub const ATOM_LOCALNAME__6D_69_73_73_69_6E_67_2D_67_6C_79_70_68 : LocalName = LocalName :: pack_static (289u32) ;\npub const ATOM_LOCALNAME__66_61_63_74_6F_72_6F_66 : LocalName = LocalName :: pack_static (290u32) ;\npub const ATOM_LOCALNAME__6D_75_6C_74_69_63_6F_6C : LocalName = LocalName :: pack_static (291u32) ;\npub const ATOM_LOCALNAME__66_69_6C_6C_2D_6F_70_61_63_69_74_79 : LocalName = LocalName :: pack_static (292u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_62_6C_63_6C_69_63_6B : LocalName = LocalName :: pack_static (293u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_66_72_65_71_75_65_6E_63_79 : LocalName = LocalName :: pack_static (294u32) ;\npub const ATOM_LOCALNAME__6F_6E_73_63_72_6F_6C_6C : LocalName = LocalName :: pack_static (295u32) ;\npub const ATOM_LOCALNAME__6F_6E_65_72_72_6F_72_75_70_64_61_74_65 : LocalName = LocalName :: pack_static (296u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_68_61_6E_6E_65_6C : LocalName = LocalName :: pack_static (297u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_62_72_61_69_6C_6C_65_72_6F_6C_65_64_65_73_63_72_69_70_74_69_6F_6E : LocalName = LocalName :: pack_static (298u32) ;\npub const ATOM_LOCALNAME__6B_65_79_53_70_6C_69_6E_65_73 : LocalName = LocalName :: pack_static (299u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6F_75_74 : LocalName = LocalName :: pack_static (300u32) ;\npub const ATOM_LOCALNAME__73_65_70_61_72_61_74_6F_72_73 : LocalName = LocalName :: pack_static (301u32) ;\npub const ATOM_LOCALNAME__72_6F_77_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (302u32) ;\npub const ATOM_LOCALNAME__66_65_50_6F_69_6E_74_4C_69_67_68_74 : LocalName = LocalName :: pack_static (303u32) ;\npub const ATOM_LOCALNAME__72_65_71_75_69_72_65_64_45_78_74_65_6E_73_69_6F_6E_73 : LocalName = LocalName :: pack_static (304u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6D_75_6C_74_69_73_65_6C_65_63_74_61_62_6C_65 : LocalName = LocalName :: pack_static (305u32) ;\npub const ATOM_LOCALNAME__6F_6E_70_61_67_65_68_69_64_65 : LocalName = LocalName :: pack_static (306u32) ;\npub const ATOM_LOCALNAME__76_69_65_77_74_61_72_67_65_74 : LocalName = LocalName :: pack_static (307u32) ;\npub const ATOM_LOCALNAME__6F_6E_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (308u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_59 : LocalName = LocalName :: pack_static (309u32) ;\npub const ATOM_LOCALNAME__6D_61_74_68_73_69_7A_65 : LocalName = LocalName :: pack_static (310u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_46_72_65_71_75_65_6E_63_79 : LocalName = LocalName :: pack_static (311u32) ;\npub const ATOM_LOCALNAME__69_74_65_6D_74_79_70_65 : LocalName = LocalName :: pack_static (312u32) ;\npub const ATOM_LOCALNAME__66_61_63_74_6F_72_69_61_6C : LocalName = LocalName :: pack_static (313u32) ;\npub const ATOM_LOCALNAME__65_78_74_65_72_6E_61_6C_72_65_73_6F_75_72_63_65_73_72_65_71_75_69_72_65_64 : LocalName = LocalName :: pack_static (314u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_6C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (315u32) ;\npub const ATOM_LOCALNAME__73_65_6C_65_63_74_6F_72 : LocalName = LocalName :: pack_static (316u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_6D_6F_74_69_6F_6E : LocalName = LocalName :: pack_static (317u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_76_65_65_6E_64 : LocalName = LocalName :: pack_static (318u32) ;\npub const ATOM_LOCALNAME__65_6E_61_62_6C_65_2D_62_61_63_6B_67_72_6F_75_6E_64 : LocalName = LocalName :: pack_static (319u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_6F_72_6D_69_6E_70_75_74 : LocalName = LocalName :: pack_static (320u32) ;\npub const ATOM_LOCALNAME__69_6E_74_65_72_63_65_70_74 : LocalName = LocalName :: pack_static (321u32) ;\npub const ATOM_LOCALNAME__66_65_6F_66_66_73_65_74 : LocalName = LocalName :: pack_static (322u32) ;\npub const ATOM_LOCALNAME__65_78_70_6F_6E_65_6E_74 : LocalName = LocalName :: pack_static (323u32) ;\npub const ATOM_LOCALNAME__73_65_6C_65_63_74_65_64 : LocalName = LocalName :: pack_static (324u32) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_65_6E_63_74_79_70_65 : LocalName = LocalName :: pack_static (325u32) ;\npub const ATOM_LOCALNAME__70_61_6E_6F_73_65_2D_31 : LocalName = LocalName :: pack_static (326u32) ;\npub const ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68 : LocalName = LocalName :: pack_static (327u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_79 : LocalName = LocalName :: pack_static (328u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_68_72_65_66 : LocalName = LocalName :: pack_static (329u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_64_65_61_63_74_69_76_61_74_65 : LocalName = LocalName :: pack_static (330u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_66_6F_72_6D_61_74 : LocalName = LocalName :: pack_static (331u32) ;\npub const ATOM_LOCALNAME__64_6F_6D_69_6E_61_6E_74_2D_62_61_73_65_6C_69_6E_65 : LocalName = LocalName :: pack_static (332u32) ;\npub const ATOM_LOCALNAME__69_6E_74_65_67_72_69_74_79 : LocalName = LocalName :: pack_static (333u32) ;\npub const ATOM_LOCALNAME__61_75_74_6F_66_6F_63_75_73 : LocalName = LocalName :: pack_static (334u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_2D_64_65_63_6F_72_61_74_69_6F_6E : LocalName = LocalName :: pack_static (335u32) ;\npub const ATOM_LOCALNAME__66_65_44_69_73_74_61_6E_74_4C_69_67_68_74 : LocalName = LocalName :: pack_static (336u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_69_6E_76_61_6C_69_64 : LocalName = LocalName :: pack_static (337u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_73_74_61_72_74 : LocalName = LocalName :: pack_static (338u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_2D_6D_61_78 : LocalName = LocalName :: pack_static (339u32) ;\npub const ATOM_LOCALNAME__6F_70_65_72_61_74_6F_72 : LocalName = LocalName :: pack_static (340u32) ;\npub const ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_45_78_70_6F_6E_65_6E_74 : LocalName = LocalName :: pack_static (341u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_74_65_6D_70_6C_61_74_65_69_64 : LocalName = LocalName :: pack_static (342u32) ;\npub const ATOM_LOCALNAME__6D_65_6E_63_6C_6F_73_65 : LocalName = LocalName :: pack_static (343u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_65_74_61_69_6C_73 : LocalName = LocalName :: pack_static (344u32) ;\npub const ATOM_LOCALNAME__6D_61_74_68_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (345u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_69_6F_6E : LocalName = LocalName :: pack_static (346u32) ;\npub const ATOM_LOCALNAME__66_65_73_70_65_63_75_6C_61_72_6C_69_67_68_74_69_6E_67 : LocalName = LocalName :: pack_static (347u32) ;\npub const ATOM_LOCALNAME__63_65_6C_6C_70_61_64_64_69_6E_67 : LocalName = LocalName :: pack_static (348u32) ;\npub const ATOM_LOCALNAME__6D_61_74_68_65_6D_61_74_69_63_61_6C : LocalName = LocalName :: pack_static (349u32) ;\npub const ATOM_LOCALNAME__73_74_69_74_63_68_74_69_6C_65_73 : LocalName = LocalName :: pack_static (350u32) ;\npub const ATOM_LOCALNAME__63_72_6F_73_73_6F_72_69_67_69_6E : LocalName = LocalName :: pack_static (351u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_70_61_74_68 : LocalName = LocalName :: pack_static (352u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_72_6F_6C_65 : LocalName = LocalName :: pack_static (353u32) ;\npub const ATOM_LOCALNAME__6F_75_74_65_72_70_72_6F_64_75_63_74 : LocalName = LocalName :: pack_static (354u32) ;\npub const ATOM_LOCALNAME__68_72_65_66_6C_61_6E_67 : LocalName = LocalName :: pack_static (355u32) ;\npub const ATOM_LOCALNAME__61_6E_6E_6F_74_61_74_69_6F_6E : LocalName = LocalName :: pack_static (356u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6D_6F_76_65 : LocalName = LocalName :: pack_static (357u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6C_69_6E_65_6A_6F_69_6E : LocalName = LocalName :: pack_static (358u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_75_6E_69_74_73 : LocalName = LocalName :: pack_static (359u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_61_74_61_61_76_61_69_6C_61_62_6C_65 : LocalName = LocalName :: pack_static (360u32) ;\npub const ATOM_LOCALNAME__63_6F_64_65_74_79_70_65 : LocalName = LocalName :: pack_static (361u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_74_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (362u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_65_61_64_79_73_74_61_74_65_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (363u32) ;\npub const ATOM_LOCALNAME__69_6E_66_69_6E_69_74_79 : LocalName = LocalName :: pack_static (364u32) ;\npub const ATOM_LOCALNAME__73_75_72_66_61_63_65_53_63_61_6C_65 : LocalName = LocalName :: pack_static (365u32) ;\npub const ATOM_LOCALNAME__6F_6E_73_65_6C_65_63_74 : LocalName = LocalName :: pack_static (366u32) ;\npub const ATOM_LOCALNAME__6C_69_6E_65_2D_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (367u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_65_73_73_61_67_65 : LocalName = LocalName :: pack_static (368u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_69_6E_64_65_78_74_65_78_74 : LocalName = LocalName :: pack_static (369u32) ;\npub const ATOM_LOCALNAME_ : LocalName = LocalName :: pack_static (370u32) ;\npub const ATOM_LOCALNAME__73_65_70_61_72_61_74_6F_72 : LocalName = LocalName :: pack_static (371u32) ;\npub const ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68_69_74_65_6D : LocalName = LocalName :: pack_static (372u32) ;\npub const ATOM_LOCALNAME__68_6F_72_69_7A_2D_6F_72_69_67_69_6E_2D_79 : LocalName = LocalName :: pack_static (373u32) ;\npub const ATOM_LOCALNAME__64_65_74_65_72_6D_69_6E_61_6E_74 : LocalName = LocalName :: pack_static (374u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_64_69_74_69_6F_6E : LocalName = LocalName :: pack_static (375u32) ;\npub const ATOM_LOCALNAME__78_63_68_61_6E_6E_65_6C_73_65_6C_65_63_74_6F_72 : LocalName = LocalName :: pack_static (376u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_64_75_72 : LocalName = LocalName :: pack_static (377u32) ;\npub const ATOM_LOCALNAME__64_61_74_61_6C_69_73_74 : LocalName = LocalName :: pack_static (378u32) ;\npub const ATOM_LOCALNAME__63_61_70_2D_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (379u32) ;\npub const ATOM_LOCALNAME__65_71_75_69_76_61_6C_65_6E_74 : LocalName = LocalName :: pack_static (380u32) ;\npub const ATOM_LOCALNAME__66_69_65_6C_64_73_65_74 : LocalName = LocalName :: pack_static (381u32) ;\npub const ATOM_LOCALNAME__6C_69_6E_65_62_72_65_61_6B : LocalName = LocalName :: pack_static (382u32) ;\npub const ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_74_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (383u32) ;\npub const ATOM_LOCALNAME__61_6D_70_6C_69_74_75_64_65 : LocalName = LocalName :: pack_static (384u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_65_61_64_6F_6E_6C_79 : LocalName = LocalName :: pack_static (385u32) ;\npub const ATOM_LOCALNAME__66_65_53_70_6F_74_4C_69_67_68_74 : LocalName = LocalName :: pack_static (386u32) ;\npub const ATOM_LOCALNAME__62_65_76_65_6C_6C_65_64 : LocalName = LocalName :: pack_static (387u32) ;\npub const ATOM_LOCALNAME__66_65_64_69_73_70_6C_61_63_65_6D_65_6E_74_6D_61_70 : LocalName = LocalName :: pack_static (388u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_43_6F_6C_6F_72 : LocalName = LocalName :: pack_static (389u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_73_65_6C_65_63_74_65_64 : LocalName = LocalName :: pack_static (390u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_65_73_73_61_67_65_65_72_72_6F_72 : LocalName = LocalName :: pack_static (391u32) ;\npub const ATOM_LOCALNAME__66_6F_72_65_69_67_6E_6F_62_6A_65_63_74 : LocalName = LocalName :: pack_static (392u32) ;\npub const ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_74_79_70_65 : LocalName = LocalName :: pack_static (393u32) ;\npub const ATOM_LOCALNAME__70_72_73_75_62_73_65_74 : LocalName = LocalName :: pack_static (394u32) ;\npub const ATOM_LOCALNAME__72_61_64_69_6F_67_72_6F_75_70 : LocalName = LocalName :: pack_static (395u32) ;\npub const ATOM_LOCALNAME__72_65_71_75_69_72_65_64_65_78_74_65_6E_73_69_6F_6E_73 : LocalName = LocalName :: pack_static (396u32) ;\npub const ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_55_52_4C : LocalName = LocalName :: pack_static (397u32) ;\npub const ATOM_LOCALNAME__6C_69_73_74_65_6E_65_72 : LocalName = LocalName :: pack_static (398u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_67_72_6F_75_70 : LocalName = LocalName :: pack_static (399u32) ;\npub const ATOM_LOCALNAME__64_69_66_66_75_73_65_63_6F_6E_73_74_61_6E_74 : LocalName = LocalName :: pack_static (400u32) ;\npub const ATOM_LOCALNAME__64_72_61_67_67_61_62_6C_65 : LocalName = LocalName :: pack_static (401u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_75_6D_6E_77_69_64_74_68 : LocalName = LocalName :: pack_static (402u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (403u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_65_6E_64 : LocalName = LocalName :: pack_static (404u32) ;\npub const ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68_44_65_66 : LocalName = LocalName :: pack_static (405u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_73_68_6F_77 : LocalName = LocalName :: pack_static (406u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_78 : LocalName = LocalName :: pack_static (407u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_64_72_6F_70 : LocalName = LocalName :: pack_static (408u32) ;\npub const ATOM_LOCALNAME__66_65_47_61_75_73_73_69_61_6E_42_6C_75_72 : LocalName = LocalName :: pack_static (409u32) ;\npub const ATOM_LOCALNAME__75_6E_69_63_6F_64_65_2D_72_61_6E_67_65 : LocalName = LocalName :: pack_static (410u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_6F_75_6E_63_65 : LocalName = LocalName :: pack_static (411u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6D_69_6E : LocalName = LocalName :: pack_static (412u32) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68_2D_6F_72_69_65_6E_74_61_74_69_6F_6E_2D_76_65_72_74_69_63_61_6C : LocalName = LocalName :: pack_static (413u32) ;\npub const ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68 : LocalName = LocalName :: pack_static (414u32) ;\npub const ATOM_LOCALNAME__74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (415u32) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_61_63_74_69_6F_6E : LocalName = LocalName :: pack_static (416u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6F_77_6E_73 : LocalName = LocalName :: pack_static (417u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_65_64_69_74_66_6F_63_75_73 : LocalName = LocalName :: pack_static (418u32) ;\npub const ATOM_LOCALNAME__61_75_74_6F_63_6F_6D_70_6C_65_74_65 : LocalName = LocalName :: pack_static (419u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_70_6C_61_63_65_68_6F_6C_64_65_72 : LocalName = LocalName :: pack_static (420u32) ;\npub const ATOM_LOCALNAME__66_69_6C_74_65_72_75_6E_69_74_73 : LocalName = LocalName :: pack_static (421u32) ;\npub const ATOM_LOCALNAME__6E_6F_73_63_72_69_70_74 : LocalName = LocalName :: pack_static (422u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_6F_77_65_78_69_74 : LocalName = LocalName :: pack_static (423u32) ;\npub const ATOM_LOCALNAME__6D_6F_7A_62_72_6F_77_73_65_72 : LocalName = LocalName :: pack_static (424u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_6F_63_75_73_69_6E : LocalName = LocalName :: pack_static (425u32) ;\npub const ATOM_LOCALNAME__6F_6E_68_61_73_68_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (426u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_66_61_6D_69_6C_79 : LocalName = LocalName :: pack_static (427u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6B_65_79_73_68_6F_72_74_63_75_74_73 : LocalName = LocalName :: pack_static (428u32) ;\npub const ATOM_LOCALNAME__6D_65_64_69_75_6D_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (429u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6D_69_74_65_72_6C_69_6D_69_74 : LocalName = LocalName :: pack_static (430u32) ;\npub const ATOM_LOCALNAME__76_61_6C_75_65_74_79_70_65 : LocalName = LocalName :: pack_static (431u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_70_61_74_68 : LocalName = LocalName :: pack_static (432u32) ;\npub const ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_75_72_6C : LocalName = LocalName :: pack_static (433u32) ;\npub const ATOM_LOCALNAME__64_61_74_61_74_65_6D_70_6C_61_74_65 : LocalName = LocalName :: pack_static (434u32) ;\npub const ATOM_LOCALNAME__73_70_72_65_61_64_6D_65_74_68_6F_64 : LocalName = LocalName :: pack_static (435u32) ;\npub const ATOM_LOCALNAME__6D_75_6E_64_65_72_6F_76_65_72 : LocalName = LocalName :: pack_static (436u32) ;\npub const ATOM_LOCALNAME__6C_61_6E_67_75_61_67_65 : LocalName = LocalName :: pack_static (437u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_73_74_79_6C_65 : LocalName = LocalName :: pack_static (438u32) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68_52_65_66 : LocalName = LocalName :: pack_static (439u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_65_6E_64 : LocalName = LocalName :: pack_static (440u32) ;\npub const ATOM_LOCALNAME__70_69_65_63_65_77_69_73_65 : LocalName = LocalName :: pack_static (441u32) ;\npub const ATOM_LOCALNAME__6E_75_6D_4F_63_74_61_76_65_73 : LocalName = LocalName :: pack_static (442u32) ;\npub const ATOM_LOCALNAME__70_6C_61_63_65_68_6F_6C_64_65_72 : LocalName = LocalName :: pack_static (443u32) ;\npub const ATOM_LOCALNAME__66_72_61_6D_65_73_65_74 : LocalName = LocalName :: pack_static (444u32) ;\npub const ATOM_LOCALNAME__69_6E_6E_65_72_74_65_78_74 : LocalName = LocalName :: pack_static (445u32) ;\npub const ATOM_LOCALNAME__6F_6E_6B_65_79_64_6F_77_6E : LocalName = LocalName :: pack_static (446u32) ;\npub const ATOM_LOCALNAME__64_6F_77_6E_6C_6F_61_64 : LocalName = LocalName :: pack_static (447u32) ;\npub const ATOM_LOCALNAME__6F_6E_70_72_6F_70_65_72_74_79_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (448u32) ;\npub const ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_73_65_72_69_61_6C_69_7A_61_62_6C_65 : LocalName = LocalName :: pack_static (449u32) ;\npub const ATOM_LOCALNAME__6F_6E_70_6F_70_73_74_61_74_65 : LocalName = LocalName :: pack_static (450u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_54_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (451u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_2D_74_65_6D_70_6C_61_74_65 : LocalName = LocalName :: pack_static (452u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_6F_72_2D_70_72_6F_66_69_6C_65 : LocalName = LocalName :: pack_static (453u32) ;\npub const ATOM_LOCALNAME__6B_65_72_6E_65_6C_6D_61_74_72_69_78 : LocalName = LocalName :: pack_static (454u32) ;\npub const ATOM_LOCALNAME__78_43_68_61_6E_6E_65_6C_53_65_6C_65_63_74_6F_72 : LocalName = LocalName :: pack_static (455u32) ;\npub const ATOM_LOCALNAME__73_6F_6C_69_64_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (456u32) ;\npub const ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_55_6E_69_74_73 : LocalName = LocalName :: pack_static (457u32) ;\npub const ATOM_LOCALNAME__68_6F_72_69_7A_2D_6F_72_69_67_69_6E_2D_78 : LocalName = LocalName :: pack_static (458u32) ;\npub const ATOM_LOCALNAME__74_65_6D_70_6C_61_74_65 : LocalName = LocalName :: pack_static (459u32) ;\npub const ATOM_LOCALNAME__6D_61_74_68_62_61_63_6B_67_72_6F_75_6E_64 : LocalName = LocalName :: pack_static (460u32) ;\npub const ATOM_LOCALNAME__63_6F_64_6F_6D_61_69_6E : LocalName = LocalName :: pack_static (461u32) ;\npub const ATOM_LOCALNAME__73_65_6D_61_6E_74_69_63_73 : LocalName = LocalName :: pack_static (462u32) ;\npub const ATOM_LOCALNAME__70_72_65_73_65_72_76_65_41_6C_70_68_61 : LocalName = LocalName :: pack_static (463u32) ;\npub const ATOM_LOCALNAME__73_74_64_64_65_76_69_61_74_69_6F_6E : LocalName = LocalName :: pack_static (464u32) ;\npub const ATOM_LOCALNAME__66_65_63_6F_6D_70_6F_6E_65_6E_74_74_72_61_6E_73_66_65_72 : LocalName = LocalName :: pack_static (465u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_63_6F_6E_74_65_6E_74_75_6E_69_74_73 : LocalName = LocalName :: pack_static (466u32) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68_2D_6E_61_6D_65 : LocalName = LocalName :: pack_static (467u32) ;\npub const ATOM_LOCALNAME__73_75_62_73_63_72_69_70_74_73_68_69_66_74 : LocalName = LocalName :: pack_static (468u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_75_72_72_65_6E_74 : LocalName = LocalName :: pack_static (469u32) ;\npub const ATOM_LOCALNAME__76_65_72_74_2D_61_64_76_2D_79 : LocalName = LocalName :: pack_static (470u32) ;\npub const ATOM_LOCALNAME__77_6F_72_64_2D_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (471u32) ;\npub const ATOM_LOCALNAME__61_6C_69_67_6E_6D_65_6E_74_2D_62_61_73_65_6C_69_6E_65 : LocalName = LocalName :: pack_static (472u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_62_75_73_79 : LocalName = LocalName :: pack_static (473u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_6C_69_6E_65_2D_73_68_69_66_74 : LocalName = LocalName :: pack_static (474u32) ;\npub const ATOM_LOCALNAME__65_64_67_65_4D_6F_64_65 : LocalName = LocalName :: pack_static (475u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_72_6F_6C_73 : LocalName = LocalName :: pack_static (476u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_63_6F_70_79 : LocalName = LocalName :: pack_static (477u32) ;\npub const ATOM_LOCALNAME__66_65_44_72_6F_70_53_68_61_64_6F_77 : LocalName = LocalName :: pack_static (478u32) ;\npub const ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68_64_65_66 : LocalName = LocalName :: pack_static (479u32) ;\npub const ATOM_LOCALNAME__6C_65_74_74_65_72_2D_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (480u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6C_65_76_65_6C : LocalName = LocalName :: pack_static (481u32) ;\npub const ATOM_LOCALNAME__6F_6E_6C_61_6E_67_75_61_67_65_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (482u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_74_79_70_65 : LocalName = LocalName :: pack_static (483u32) ;\npub const ATOM_LOCALNAME__73_74_69_74_63_68_54_69_6C_65_73 : LocalName = LocalName :: pack_static (484u32) ;\npub const ATOM_LOCALNAME__6D_6F_76_61_62_6C_65_6C_69_6D_69_74_73 : LocalName = LocalName :: pack_static (485u32) ;\npub const ATOM_LOCALNAME__66_65_63_6F_6E_76_6F_6C_76_65_6D_61_74_72_69_78 : LocalName = LocalName :: pack_static (486u32) ;\npub const ATOM_LOCALNAME__78_6D_6C_3A_6C_61_6E_67 : LocalName = LocalName :: pack_static (487u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_6F_77_73_64_65_6C_65_74_65 : LocalName = LocalName :: pack_static (488u32) ;\npub const ATOM_LOCALNAME__76_65_72_74_2D_6F_72_69_67_69_6E_2D_78 : LocalName = LocalName :: pack_static (489u32) ;\npub const ATOM_LOCALNAME__6F_76_65_72_66_6C_6F_77 : LocalName = LocalName :: pack_static (490u32) ;\npub const ATOM_LOCALNAME__6E_6F_76_61_6C_69_64_61_74_65 : LocalName = LocalName :: pack_static (491u32) ;\npub const ATOM_LOCALNAME__66_65_43_6F_6D_70_6F_6E_65_6E_74_54_72_61_6E_73_66_65_72 : LocalName = LocalName :: pack_static (492u32) ;\npub const ATOM_LOCALNAME__70_72_65_73_65_72_76_65_61_73_70_65_63_74_72_61_74_69_6F : LocalName = LocalName :: pack_static (493u32) ;\npub const ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_65_78_70_6F_6E_65_6E_74 : LocalName = LocalName :: pack_static (494u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6F_70_61_63_69_74_79 : LocalName = LocalName :: pack_static (495u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_73_65_74_73_69_7A_65 : LocalName = LocalName :: pack_static (496u32) ;\npub const ATOM_LOCALNAME__69_6D_61_67_65_2D_72_65_6E_64_65_72_69_6E_67 : LocalName = LocalName :: pack_static (497u32) ;\npub const ATOM_LOCALNAME__70_72_69_6D_69_74_69_76_65_75_6E_69_74_73 : LocalName = LocalName :: pack_static (498u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_76_61_72_69_61_6E_74 : LocalName = LocalName :: pack_static (499u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_44_75_72 : LocalName = LocalName :: pack_static (500u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_65_61_63_74_69_76_61_74_65 : LocalName = LocalName :: pack_static (501u32) ;\npub const ATOM_LOCALNAME__6D_61_6C_69_67_6E_6D_61_72_6B : LocalName = LocalName :: pack_static (502u32) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_74_61_72_67_65_74 : LocalName = LocalName :: pack_static (503u32) ;\npub const ATOM_LOCALNAME__6C_69_6D_69_74_69_6E_67_63_6F_6E_65_61_6E_67_6C_65 : LocalName = LocalName :: pack_static (504u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_2D_72_65_6E_64_65_72_69_6E_67 : LocalName = LocalName :: pack_static (505u32) ;\npub const ATOM_LOCALNAME__69_6E_6E_65_72_54_65_78_74 : LocalName = LocalName :: pack_static (506u32) ;\npub const ATOM_LOCALNAME__66_65_74_75_72_62_75_6C_65_6E_63_65 : LocalName = LocalName :: pack_static (507u32) ;\npub const ATOM_LOCALNAME__66_65_67_61_75_73_73_69_61_6E_62_6C_75_72 : LocalName = LocalName :: pack_static (508u32) ;\npub const ATOM_LOCALNAME__6F_6E_73_74_6F_72_61_67_65 : LocalName = LocalName :: pack_static (509u32) ;\npub const ATOM_LOCALNAME__69_6D_61_67_69_6E_61_72_79 : LocalName = LocalName :: pack_static (510u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_75_70 : LocalName = LocalName :: pack_static (511u32) ;\npub const ATOM_LOCALNAME__6F_6E_61_66_74_65_72_75_70_64_61_74_65 : LocalName = LocalName :: pack_static (512u32) ;\npub const ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_4E_61_6D_65 : LocalName = LocalName :: pack_static (513u32) ;\npub const ATOM_LOCALNAME__66_6C_6F_6F_64_2D_6F_70_61_63_69_74_79 : LocalName = LocalName :: pack_static (514u32) ;\npub const ATOM_LOCALNAME__72_65_76_65_72_73_65_64 : LocalName = LocalName :: pack_static (515u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_6F_72_2D_72_65_6E_64_65_72_69_6E_67 : LocalName = LocalName :: pack_static (516u32) ;\npub const ATOM_LOCALNAME__72_65_71_75_69_72_65_64 : LocalName = LocalName :: pack_static (517u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_5A : LocalName = LocalName :: pack_static (518u32) ;\npub const ATOM_LOCALNAME__74_61_62_6C_65_56_61_6C_75_65_73 : LocalName = LocalName :: pack_static (519u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_69_6E_64_65_78 : LocalName = LocalName :: pack_static (520u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_68_65_63_6B_65_64 : LocalName = LocalName :: pack_static (521u32) ;\npub const ATOM_LOCALNAME__63_61_72_74_65_73_69_61_6E_70_72_6F_64_75_63_74 : LocalName = LocalName :: pack_static (522u32) ;\npub const ATOM_LOCALNAME__63_6F_6D_70_6C_65_78_65_73 : LocalName = LocalName :: pack_static (523u32) ;\npub const ATOM_LOCALNAME__74_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (524u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_73_6F_72_74 : LocalName = LocalName :: pack_static (525u32) ;\npub const ATOM_LOCALNAME__74_61_62_6C_65_76_61_6C_75_65_73 : LocalName = LocalName :: pack_static (526u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_65_73_69_7A_65 : LocalName = LocalName :: pack_static (527u32) ;\npub const ATOM_LOCALNAME__6F_6E_63_6F_6E_74_65_78_74_6D_65_6E_75 : LocalName = LocalName :: pack_static (528u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_73_69_7A_65 : LocalName = LocalName :: pack_static (529u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_72_6F_70_65_66_66_65_63_74 : LocalName = LocalName :: pack_static (530u32) ;\npub const ATOM_LOCALNAME__6C_69_6E_65_74_68_69_63_6B_6E_65_73_73 : LocalName = LocalName :: pack_static (531u32) ;\npub const ATOM_LOCALNAME__69_6E_74_65_67_65_72_73 : LocalName = LocalName :: pack_static (532u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_6E_61_6D_65 : LocalName = LocalName :: pack_static (533u32) ;\npub const ATOM_LOCALNAME__64_69_76_65_72_67_65_6E_63_65 : LocalName = LocalName :: pack_static (534u32) ;\npub const ATOM_LOCALNAME__66_69_67_63_61_70_74_69_6F_6E : LocalName = LocalName :: pack_static (535u32) ;\npub const ATOM_LOCALNAME__6E_6F_74_73_75_62_73_65_74 : LocalName = LocalName :: pack_static (536u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_6F_72_2D_69_6E_74_65_72_70_6F_6C_61_74_69_6F_6E : LocalName = LocalName :: pack_static (537u32) ;\npub const ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_75_6E_69_74_73 : LocalName = LocalName :: pack_static (538u32) ;\npub const ATOM_LOCALNAME__68_6F_72_69_7A_2D_61_64_76_2D_78 : LocalName = LocalName :: pack_static (539u32) ;\npub const ATOM_LOCALNAME__6F_6E_70_61_67_65_73_77_61_70 : LocalName = LocalName :: pack_static (540u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_73_69_7A_65_2D_61_64_6A_75_73_74 : LocalName = LocalName :: pack_static (541u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_65_70_65_61_74 : LocalName = LocalName :: pack_static (542u32) ;\npub const ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_43_6F_6E_73_74_61_6E_74 : LocalName = LocalName :: pack_static (543u32) ;\npub const ATOM_LOCALNAME__73_74_72_65_74_63_68_79 : LocalName = LocalName :: pack_static (544u32) ;\npub const ATOM_LOCALNAME__65_6E_63_6F_64_69_6E_67 : LocalName = LocalName :: pack_static (545u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_64_61_73_68_61_72_72_61_79 : LocalName = LocalName :: pack_static (546u32) ;\npub const ATOM_LOCALNAME__74_68_69_6E_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (547u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_69_6E_64_65_78_74_65_78_74 : LocalName = LocalName :: pack_static (548u32) ;\npub const ATOM_LOCALNAME__73_68_61_70_65_2D_72_65_6E_64_65_72_69_6E_67 : LocalName = LocalName :: pack_static (549u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_68_69_64_64_65_6E : LocalName = LocalName :: pack_static (550u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_2D_72_75_6C_65 : LocalName = LocalName :: pack_static (551u32) ;\npub const ATOM_LOCALNAME__64_65_63_6F_64_69_6E_67 : LocalName = LocalName :: pack_static (552u32) ;\npub const ATOM_LOCALNAME__73_79_73_74_65_6D_4C_61_6E_67_75_61_67_65 : LocalName = LocalName :: pack_static (553u32) ;\npub const ATOM_LOCALNAME__66_65_44_69_66_66_75_73_65_4C_69_67_68_74_69_6E_67 : LocalName = LocalName :: pack_static (554u32) ;\npub const ATOM_LOCALNAME__66_65_54_75_72_62_75_6C_65_6E_63_65 : LocalName = LocalName :: pack_static (555u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_6D_69_64 : LocalName = LocalName :: pack_static (556u32) ;\npub const ATOM_LOCALNAME__75_6E_64_65_72_6C_69_6E_65_2D_70_6F_73_69_74_69_6F_6E : LocalName = LocalName :: pack_static (557u32) ;\npub const ATOM_LOCALNAME__6E_75_6D_6F_63_74_61_76_65_73 : LocalName = LocalName :: pack_static (558u32) ;\npub const ATOM_LOCALNAME__61_75_74_6F_73_75_62_6D_69_74 : LocalName = LocalName :: pack_static (559u32) ;\npub const ATOM_LOCALNAME__75_6E_64_65_72_6C_69_6E_65_2D_74_68_69_63_6B_6E_65_73_73 : LocalName = LocalName :: pack_static (560u32) ;\npub const ATOM_LOCALNAME__61_64_64_69_74_69_76_65 : LocalName = LocalName :: pack_static (561u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6C_61_62_65_6C : LocalName = LocalName :: pack_static (562u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_61_63_74_75_61_74_65 : LocalName = LocalName :: pack_static (563u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_70_72_69_6E_74 : LocalName = LocalName :: pack_static (564u32) ;\npub const ATOM_LOCALNAME__61_6C_70_68_61_62_65_74_69_63 : LocalName = LocalName :: pack_static (565u32) ;\npub const ATOM_LOCALNAME__70_72_65_73_65_72_76_65_61_6C_70_68_61 : LocalName = LocalName :: pack_static (566u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_57_69_64_74_68 : LocalName = LocalName :: pack_static (567u32) ;\npub const ATOM_LOCALNAME__6F_6E_63_65_6C_6C_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (568u32) ;\npub const ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_54_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (569u32) ;\npub const ATOM_LOCALNAME__6E_6F_66_72_61_6D_65_73 : LocalName = LocalName :: pack_static (570u32) ;\npub const ATOM_LOCALNAME__72_65_6E_64_65_72_69_6E_67_2D_69_6E_74_65_6E_74 : LocalName = LocalName :: pack_static (571u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6E_6F_77 : LocalName = LocalName :: pack_static (572u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_70_61_73_74_65 : LocalName = LocalName :: pack_static (573u32) ;\npub const ATOM_LOCALNAME__66_72_61_6D_65_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (574u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_63_6F_75_6E_74 : LocalName = LocalName :: pack_static (575u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_43_6F_75_6E_74 : LocalName = LocalName :: pack_static (576u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_2D_70_61_74_68 : LocalName = LocalName :: pack_static (577u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_74_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (578u32) ;\npub const ATOM_LOCALNAME__78_6D_6C_6E_73_3A_78_6C_69_6E_6B : LocalName = LocalName :: pack_static (579u32) ;\npub const ATOM_LOCALNAME__6F_74_68_65_72_77_69_73_65 : LocalName = LocalName :: pack_static (580u32) ;\npub const ATOM_LOCALNAME__72_61_64_69_61_6C_47_72_61_64_69_65_6E_74 : LocalName = LocalName :: pack_static (581u32) ;\npub const ATOM_LOCALNAME__6F_6E_61_63_74_69_76_61_74_65 : LocalName = LocalName :: pack_static (582u32) ;\npub const ATOM_LOCALNAME__6C_65_6E_67_74_68_41_64_6A_75_73_74 : LocalName = LocalName :: pack_static (583u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_61_74_6F_6D_69_63 : LocalName = LocalName :: pack_static (584u32) ;\npub const ATOM_LOCALNAME__73_74_6F_70_2D_6F_70_61_63_69_74_79 : LocalName = LocalName :: pack_static (585u32) ;\npub const ATOM_LOCALNAME__6B_65_79_70_6F_69_6E_74_73 : LocalName = LocalName :: pack_static (586u32) ;\npub const ATOM_LOCALNAME__64_69_73_61_62_6C_65_64 : LocalName = LocalName :: pack_static (587u32) ;\npub const ATOM_LOCALNAME__6D_61_73_6B_55_6E_69_74_73 : LocalName = LocalName :: pack_static (588u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_4C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (589u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_2D_73_74_61_72_74 : LocalName = LocalName :: pack_static (590u32) ;\npub const ATOM_LOCALNAME__6F_76_65_72_6C_69_6E_65_2D_70_6F_73_69_74_69_6F_6E : LocalName = LocalName :: pack_static (591u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_75_6E_6C_6F_61_64 : LocalName = LocalName :: pack_static (592u32) ;\npub const ATOM_LOCALNAME__70_72_69_6D_69_74_69_76_65_55_6E_69_74_73 : LocalName = LocalName :: pack_static (593u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_72_6F_6C_6C_65_72_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (594u32) ;\npub const ATOM_LOCALNAME__78_2D_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (595u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_69_6E_69_73_68 : LocalName = LocalName :: pack_static (596u32) ;\npub const ATOM_LOCALNAME__73_63_72_6F_6C_6C_69_6E_67 : LocalName = LocalName :: pack_static (597u32) ;\npub const ATOM_LOCALNAME__68_69_64_65_66_6F_63_75_73 : LocalName = LocalName :: pack_static (598u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_64_6F_77_6E : LocalName = LocalName :: pack_static (599u32) ;\npub const ATOM_LOCALNAME__72_65_66_65_72_72_65_72_70_6F_6C_69_63_79 : LocalName = LocalName :: pack_static (600u32) ;\npub const ATOM_LOCALNAME__73_70_65_63_69_66_69_63_61_74_69_6F_6E : LocalName = LocalName :: pack_static (601u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_6F_72_2D_69_6E_74_65_72_70_6F_6C_61_74_69_6F_6E_2D_66_69_6C_74_65_72_73 : LocalName = LocalName :: pack_static (602u32) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68_2D_6F_72_69_65_6E_74_61_74_69_6F_6E_2D_68_6F_72_69_7A_6F_6E_74_61_6C : LocalName = LocalName :: pack_static (603u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_69_73_61_62_6C_65_64 : LocalName = LocalName :: pack_static (604u32) ;\npub const ATOM_LOCALNAME__6F_6E_63_6F_6E_74_72_6F_6C_73_65_6C_65_63_74 : LocalName = LocalName :: pack_static (605u32) ;\npub const ATOM_LOCALNAME__76_65_72_79_76_65_72_79_74_68_69_6E_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (606u32) ;\npub const ATOM_LOCALNAME__6F_70_74_67_72_6F_75_70 : LocalName = LocalName :: pack_static (607u32) ;\npub const ATOM_LOCALNAME__66_65_74_63_68_70_72_69_6F_72_69_74_79 : LocalName = LocalName :: pack_static (608u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_73_65_63_72_65_74 : LocalName = LocalName :: pack_static (609u32) ;\npub const ATOM_LOCALNAME__6F_72_69_65_6E_74_61_74_69_6F_6E : LocalName = LocalName :: pack_static (610u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_55_6E_69_74_73 : LocalName = LocalName :: pack_static (611u32) ;\npub const ATOM_LOCALNAME__6C_61_70_6C_61_63_69_61_6E : LocalName = LocalName :: pack_static (612u32) ;\npub const ATOM_LOCALNAME__74_72_61_6E_73_70_6F_73_65 : LocalName = LocalName :: pack_static (613u32) ;\npub const ATOM_LOCALNAME__2A : LocalName = LocalName :: pack_inline (10752u64 , 1u8) ;\npub const ATOM_LOCALNAME__61 : LocalName = LocalName :: pack_inline (24832u64 , 1u8) ;\npub const ATOM_LOCALNAME__61_62_62_72 : LocalName = LocalName :: pack_inline (491276886272u64 , 4u8) ;\npub const ATOM_LOCALNAME__61_62_73 : LocalName = LocalName :: pack_inline (1935827200u64 , 3u8) ;\npub const ATOM_LOCALNAME__61_63_63_65_6E_74 : LocalName = LocalName :: pack_inline (32772479036645632u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_63_63_65_70_74 : LocalName = LocalName :: pack_inline (32774678059901184u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_63_72_6F_6E_79_6D : LocalName = LocalName :: pack_inline (7888457647255675136u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_63_74_69_6F_6E : LocalName = LocalName :: pack_inline (31084746153091328u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_63_74_69_76_65 : LocalName = LocalName :: pack_inline (28559167944089856u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_63_74_75_61_74_65 : LocalName = LocalName :: pack_inline (7310575252220895488u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_64_64_72_65_73_73 : LocalName = LocalName :: pack_inline (8319104478668415232u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_6C_69_67_6E : LocalName = LocalName :: pack_inline (121390429397248u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_6C_69_6E_6B : LocalName = LocalName :: pack_inline (118121959284992u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_6C_74 : LocalName = LocalName :: pack_inline (1953259776u64 , 3u8) ;\npub const ATOM_LOCALNAME__61_6C_74_69_6D_67 : LocalName = LocalName :: pack_inline (29112222293451008u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_6C_74_74_65_78_74 : LocalName = LocalName :: pack_inline (8392569456448790784u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_6E_64 : LocalName = LocalName :: pack_inline (1684955392u64 , 3u8) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65 : LocalName = LocalName :: pack_inline (7310575217677328640u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_70_70_6C_65_74 : LocalName = LocalName :: pack_inline (32762613715722496u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_70_70_6C_79 : LocalName = LocalName :: pack_inline (133506649841920u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_70_70_72_6F_78 : LocalName = LocalName :: pack_inline (33899534508646656u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_6F_73 : LocalName = LocalName :: pack_inline (32492094982611200u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_6F_73_68 : LocalName = LocalName :: pack_inline (7526481874927116544u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_6F_74 : LocalName = LocalName :: pack_inline (32773569959321856u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_6F_74_68 : LocalName = LocalName :: pack_inline (7526763349903827200u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_73_63 : LocalName = LocalName :: pack_inline (27992893401751808u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_73_63_68 : LocalName = LocalName :: pack_inline (7521982673346257152u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_68_69_76_65 : LocalName = LocalName :: pack_inline (7311146942148534528u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_72_6F_6C_65 : LocalName = LocalName :: pack_inline (7308338832400867584u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_73_65_63 : LocalName = LocalName :: pack_inline (27977568958439680u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_73_65_63_68 : LocalName = LocalName :: pack_inline (7521967348902945024u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_73_69_6E : LocalName = LocalName :: pack_inline (31078191748768000u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_73_69_6E_68 : LocalName = LocalName :: pack_inline (7525067971693273344u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_74_61_6E : LocalName = LocalName :: pack_inline (31069399950713088u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_74_61_6E_68 : LocalName = LocalName :: pack_inline (7525059179895218432u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_65_61 : LocalName = LocalName :: pack_inline (418313822464u64 , 4u8) ;\npub const ATOM_LOCALNAME__61_72_67 : LocalName = LocalName :: pack_inline (1735549184u64 , 3u8) ;\npub const ATOM_LOCALNAME__61_72_74_69_63_6C_65 : LocalName = LocalName :: pack_inline (7308325599891841280u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_73 : LocalName = LocalName :: pack_inline (7561472u64 , 2u8) ;\npub const ATOM_LOCALNAME__61_73_63_65_6E_74 : LocalName = LocalName :: pack_inline (32772479037694208u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_73_69_64_65 : LocalName = LocalName :: pack_inline (111481940304128u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_73_79_6E_63 : LocalName = LocalName :: pack_inline (109326135156992u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_75_64_69_6F : LocalName = LocalName :: pack_inline (122498447663360u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_78_69_73 : LocalName = LocalName :: pack_inline (495690735872u64 , 4u8) ;\npub const ATOM_LOCALNAME__61_7A_69_6D_75_74_68 : LocalName = LocalName :: pack_inline (7526769990024454400u64 , 7u8) ;\npub const ATOM_LOCALNAME__62 : LocalName = LocalName :: pack_inline (25088u64 , 1u8) ;\npub const ATOM_LOCALNAME__62_61_73_65 : LocalName = LocalName :: pack_inline (435727458816u64 , 4u8) ;\npub const ATOM_LOCALNAME__62_62_6F_78 : LocalName = LocalName :: pack_inline (517264794112u64 , 4u8) ;\npub const ATOM_LOCALNAME__62_64_69 : LocalName = LocalName :: pack_inline (1768186368u64 , 3u8) ;\npub const ATOM_LOCALNAME__62_64_6F : LocalName = LocalName :: pack_inline (1868849664u64 , 3u8) ;\npub const ATOM_LOCALNAME__62_65_67_69_6E : LocalName = LocalName :: pack_inline (121398985318912u64 , 5u8) ;\npub const ATOM_LOCALNAME__62_67_63_6F_6C_6F_72 : LocalName = LocalName :: pack_inline (8245928668403556864u64 , 7u8) ;\npub const ATOM_LOCALNAME__62_67_73_6F_75_6E_64 : LocalName = LocalName :: pack_inline (7236850772768940544u64 , 7u8) ;\npub const ATOM_LOCALNAME__62_69_61_73 : LocalName = LocalName :: pack_inline (495555535360u64 , 4u8) ;\npub const ATOM_LOCALNAME__62_69_67 : LocalName = LocalName :: pack_inline (1734959616u64 , 3u8) ;\npub const ATOM_LOCALNAME__62_6C_69_6E_6B : LocalName = LocalName :: pack_inline (118121959285248u64 , 5u8) ;\npub const ATOM_LOCALNAME__62_6F_64_79 : LocalName = LocalName :: pack_inline (521376064000u64 , 4u8) ;\npub const ATOM_LOCALNAME__62_6F_72_64_65_72 : LocalName = LocalName :: pack_inline (32199629436051968u64 , 6u8) ;\npub const ATOM_LOCALNAME__62_72 : LocalName = LocalName :: pack_inline (7496192u64 , 2u8) ;\npub const ATOM_LOCALNAME__62_75_74_74_6F_6E : LocalName = LocalName :: pack_inline (31084793398911488u64 , 6u8) ;\npub const ATOM_LOCALNAME__62_76_61_72 : LocalName = LocalName :: pack_inline (491261420032u64 , 4u8) ;\npub const ATOM_LOCALNAME__62_79 : LocalName = LocalName :: pack_inline (7954944u64 , 2u8) ;\npub const ATOM_LOCALNAME__63_61_6E_76_61_73 : LocalName = LocalName :: pack_inline (32476783607636736u64 , 6u8) ;\npub const ATOM_LOCALNAME__63_61_70_74_69_6F_6E : LocalName = LocalName :: pack_inline (7957695015409509120u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_61_72_64 : LocalName = LocalName :: pack_inline (431415714560u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_65_69_6C_69_6E_67 : LocalName = LocalName :: pack_inline (7453010347690386176u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_65_6E_74_65_72 : LocalName = LocalName :: pack_inline (32199698087764736u64 , 6u8) ;\npub const ATOM_LOCALNAME__63_68_61_72 : LocalName = LocalName :: pack_inline (491260502784u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_68_61_72_6F_66_66 : LocalName = LocalName :: pack_inline (7378707576544322304u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_68_61_72_73_65_74 : LocalName = LocalName :: pack_inline (8387236816145113856u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_68_65_63_6B_65_64 : LocalName = LocalName :: pack_inline (7234306451087844096u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_69 : LocalName = LocalName :: pack_inline (6906624u64 , 2u8) ;\npub const ATOM_LOCALNAME__63_69_72_63_6C_65 : LocalName = LocalName :: pack_inline (28548147024847616u64 , 6u8) ;\npub const ATOM_LOCALNAME__63_69_74_65 : LocalName = LocalName :: pack_inline (435744760576u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_6C_61_73_73 : LocalName = LocalName :: pack_inline (126939392926464u64 , 5u8) ;\npub const ATOM_LOCALNAME__63_6C_61_73_73_69_64 : LocalName = LocalName :: pack_inline (7235441215740338944u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6C_65_61_72 : LocalName = LocalName :: pack_inline (125762638996224u64 , 5u8) ;\npub const ATOM_LOCALNAME__63_6C_69_70 : LocalName = LocalName :: pack_inline (482805048064u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_6C_6F_73_65 : LocalName = LocalName :: pack_inline (111546465018624u64 , 5u8) ;\npub const ATOM_LOCALNAME__63_6C_6F_73_75_72_65 : LocalName = LocalName :: pack_inline (7310034283826799360u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6E : LocalName = LocalName :: pack_inline (7234304u64 , 2u8) ;\npub const ATOM_LOCALNAME__63_6F_64_65 : LocalName = LocalName :: pack_inline (435476718336u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_6F_6C : LocalName = LocalName :: pack_inline (1819239168u64 , 3u8) ;\npub const ATOM_LOCALNAME__63_6F_6C_6F_72 : LocalName = LocalName :: pack_inline (125822886175488u64 , 5u8) ;\npub const ATOM_LOCALNAME__63_6F_6C_73 : LocalName = LocalName :: pack_inline (495740478208u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_6F_6C_73_70_61_6E : LocalName = LocalName :: pack_inline (7953762057955795712u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6F_6D_70_61_63_74 : LocalName = LocalName :: pack_inline (8386654066594243328u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6F_6D_70_6F_73_65 : LocalName = LocalName :: pack_inline (7310309148815483648u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74 : LocalName = LocalName :: pack_inline (8389754706581218048u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6F_6F_72_64_73 : LocalName = LocalName :: pack_inline (32480064980345600u64 , 6u8) ;\npub const ATOM_LOCALNAME__63_6F_73 : LocalName = LocalName :: pack_inline (1936679680u64 , 3u8) ;\npub const ATOM_LOCALNAME__63_6F_73_68 : LocalName = LocalName :: pack_inline (448613278464u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_6F_74 : LocalName = LocalName :: pack_inline (1953456896u64 , 3u8) ;\npub const ATOM_LOCALNAME__63_6F_74_68 : LocalName = LocalName :: pack_inline (448630055680u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_73_63 : LocalName = LocalName :: pack_inline (1668506368u64 , 3u8) ;\npub const ATOM_LOCALNAME__63_73_63_68 : LocalName = LocalName :: pack_inline (448345105152u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_73_79_6D_62_6F_6C : LocalName = LocalName :: pack_inline (7813572100839662336u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_75_72_6C : LocalName = LocalName :: pack_inline (465776763648u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_75_72_73_6F_72 : LocalName = LocalName :: pack_inline (32210688977232640u64 , 6u8) ;\npub const ATOM_LOCALNAME__63_78 : LocalName = LocalName :: pack_inline (7889664u64 , 2u8) ;\npub const ATOM_LOCALNAME__63_79 : LocalName = LocalName :: pack_inline (7955200u64 , 2u8) ;\npub const ATOM_LOCALNAME__64 : LocalName = LocalName :: pack_inline (25600u64 , 1u8) ;\npub const ATOM_LOCALNAME__64_61_74_61 : LocalName = LocalName :: pack_inline (418564367360u64 , 4u8) ;\npub const ATOM_LOCALNAME__64_61_74_61_66_6C_64 : LocalName = LocalName :: pack_inline (7236271270027944960u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_61_74_61_73_72_63 : LocalName = LocalName :: pack_inline (7165916819501442048u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_64 : LocalName = LocalName :: pack_inline (6579200u64 , 2u8) ;\npub const ATOM_LOCALNAME__64_65_63_6C_61_72_65 : LocalName = LocalName :: pack_inline (7310012263327687680u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_65_66_61_75_6C_74 : LocalName = LocalName :: pack_inline (8389209267074589696u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_65_66_65_72 : LocalName = LocalName :: pack_inline (125779835184128u64 , 5u8) ;\npub const ATOM_LOCALNAME__64_65_66_73 : LocalName = LocalName :: pack_inline (495639159808u64 , 4u8) ;\npub const ATOM_LOCALNAME__64_65_67_72_65_65 : LocalName = LocalName :: pack_inline (28540514683151360u64 , 6u8) ;\npub const ATOM_LOCALNAME__64_65_6C : LocalName = LocalName :: pack_inline (1818584064u64 , 3u8) ;\npub const ATOM_LOCALNAME__64_65_70_74_68 : LocalName = LocalName :: pack_inline (114849311187968u64 , 5u8) ;\npub const ATOM_LOCALNAME__64_65_73_63 : LocalName = LocalName :: pack_inline (427137786880u64 , 4u8) ;\npub const ATOM_LOCALNAME__64_65_73_63_65_6E_74 : LocalName = LocalName :: pack_inline (8389754633650004992u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_65_74_61_69_6C_73 : LocalName = LocalName :: pack_inline (8317138479132009472u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_66_6E : LocalName = LocalName :: pack_inline (1852204032u64 , 3u8) ;\npub const ATOM_LOCALNAME__64_69_61_6C_6F_67 : LocalName = LocalName :: pack_inline (29114433882645504u64 , 6u8) ;\npub const ATOM_LOCALNAME__64_69_66_66 : LocalName = LocalName :: pack_inline (439804847104u64 , 4u8) ;\npub const ATOM_LOCALNAME__64_69_72 : LocalName = LocalName :: pack_inline (1919509504u64 , 3u8) ;\npub const ATOM_LOCALNAME__64_69_72_6E_61_6D_65 : LocalName = LocalName :: pack_inline (7308604897285989376u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_69_73_63_61_72_64 : LocalName = LocalName :: pack_inline (7237954630903751680u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_69_73_70_6C_61_79 : LocalName = LocalName :: pack_inline (8746391181558637568u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_69_76 : LocalName = LocalName :: pack_inline (1986618368u64 , 3u8) ;\npub const ATOM_LOCALNAME__64_69_76_69_64_65 : LocalName = LocalName :: pack_inline (28539376768738304u64 , 6u8) ;\npub const ATOM_LOCALNAME__64_69_76_69_73_6F_72 : LocalName = LocalName :: pack_inline (8245936339534046208u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_6C : LocalName = LocalName :: pack_inline (7103488u64 , 2u8) ;\npub const ATOM_LOCALNAME__64_6F_6D_61_69_6E : LocalName = LocalName :: pack_inline (31078114606932992u64 , 6u8) ;\npub const ATOM_LOCALNAME__64_74 : LocalName = LocalName :: pack_inline (7627776u64 , 2u8) ;\npub const ATOM_LOCALNAME__64_75_72 : LocalName = LocalName :: pack_inline (1920295936u64 , 3u8) ;\npub const ATOM_LOCALNAME__64_78 : LocalName = LocalName :: pack_inline (7889920u64 , 2u8) ;\npub const ATOM_LOCALNAME__64_79 : LocalName = LocalName :: pack_inline (7955456u64 , 2u8) ;\npub const ATOM_LOCALNAME__65_64_67_65 : LocalName = LocalName :: pack_inline (435526329600u64 , 4u8) ;\npub const ATOM_LOCALNAME__65_6C_6C_69_70_73_65 : LocalName = LocalName :: pack_inline (7310310218245367040u64 , 7u8) ;\npub const ATOM_LOCALNAME__65_6D : LocalName = LocalName :: pack_inline (7169280u64 , 2u8) ;\npub const ATOM_LOCALNAME__65_6D_62_65_64 : LocalName = LocalName :: pack_inline (110386605810944u64 , 5u8) ;\npub const ATOM_LOCALNAME__65_6E_63_74_79_70_65 : LocalName = LocalName :: pack_inline (7309475736013661440u64 , 7u8) ;\npub const ATOM_LOCALNAME__65_6E_64 : LocalName = LocalName :: pack_inline (1684956416u64 , 3u8) ;\npub const ATOM_LOCALNAME__65_71 : LocalName = LocalName :: pack_inline (7431424u64 , 2u8) ;\npub const ATOM_LOCALNAME__65_76_65_6E_74 : LocalName = LocalName :: pack_inline (128017497482496u64 , 5u8) ;\npub const ATOM_LOCALNAME__65_78_69_73_74_73 : LocalName = LocalName :: pack_inline (32497661361284352u64 , 6u8) ;\npub const ATOM_LOCALNAME__65_78_70 : LocalName = LocalName :: pack_inline (1886938368u64 , 3u8) ;\npub const ATOM_LOCALNAME__66_61_63_65 : LocalName = LocalName :: pack_inline (435459024384u64 , 4u8) ;\npub const ATOM_LOCALNAME__66_61_6C_73_65 : LocalName = LocalName :: pack_inline (111546413966848u64 , 5u8) ;\npub const ATOM_LOCALNAME__66_65_42_6C_65_6E_64 : LocalName = LocalName :: pack_inline (7236833166875780608u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_46_6C_6F_6F_64 : LocalName = LocalName :: pack_inline (7237125637035877888u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_46_75_6E_63_41 : LocalName = LocalName :: pack_inline (4711731085130950144u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_46_75_6E_63_42 : LocalName = LocalName :: pack_inline (4783788679168878080u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_46_75_6E_63_47 : LocalName = LocalName :: pack_inline (5144076649358517760u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_46_75_6E_63_52 : LocalName = LocalName :: pack_inline (5936710183775725056u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_49_6D_61_67_65 : LocalName = LocalName :: pack_inline (7306916042442630656u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_4D_65_72_67_65 : LocalName = LocalName :: pack_inline (7306934699847673344u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_54_69_6C_65 : LocalName = LocalName :: pack_inline (28548172291073536u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_65_62_6C_65_6E_64 : LocalName = LocalName :: pack_inline (7236833167412651520u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_66_6C_6F_6F_64 : LocalName = LocalName :: pack_inline (7237125637572748800u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_66_75_6E_63_61 : LocalName = LocalName :: pack_inline (7017574094881515008u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_66_75_6E_63_62 : LocalName = LocalName :: pack_inline (7089631688919442944u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_66_75_6E_63_67 : LocalName = LocalName :: pack_inline (7449919659109082624u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_66_75_6E_63_72 : LocalName = LocalName :: pack_inline (8242553193526289920u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_69_6D_61_67_65 : LocalName = LocalName :: pack_inline (7306916042979501568u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_6D_65_72_67_65 : LocalName = LocalName :: pack_inline (7306934700384544256u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_6E_63_65 : LocalName = LocalName :: pack_inline (111477728306688u64 , 5u8) ;\npub const ATOM_LOCALNAME__66_65_74_63_68 : LocalName = LocalName :: pack_inline (114776363853312u64 , 5u8) ;\npub const ATOM_LOCALNAME__66_65_74_69_6C_65 : LocalName = LocalName :: pack_inline (28548172827944448u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_69_67_75_72_65 : LocalName = LocalName :: pack_inline (28554821219476992u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_69_6C_6C : LocalName = LocalName :: pack_inline (465675314688u64 , 4u8) ;\npub const ATOM_LOCALNAME__66_69_6C_74_65_72 : LocalName = LocalName :: pack_inline (32199698054473216u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_6C_6F_6F_72 : LocalName = LocalName :: pack_inline (125822936311296u64 , 5u8) ;\npub const ATOM_LOCALNAME__66_6E : LocalName = LocalName :: pack_inline (7235072u64 , 2u8) ;\npub const ATOM_LOCALNAME__66_6F_6E_74 : LocalName = LocalName :: pack_inline (500069000704u64 , 4u8) ;\npub const ATOM_LOCALNAME__66_6F_6F_74_65_72 : LocalName = LocalName :: pack_inline (32199698105198080u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_6F_72 : LocalName = LocalName :: pack_inline (1919903232u64 , 3u8) ;\npub const ATOM_LOCALNAME__66_6F_72_61_6C_6C : LocalName = LocalName :: pack_inline (30518463272281600u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_6F_72_6D : LocalName = LocalName :: pack_inline (470071338496u64 , 4u8) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_61_74 : LocalName = LocalName :: pack_inline (32758219997668864u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_72_61_6D_65 : LocalName = LocalName :: pack_inline (111520460727808u64 , 5u8) ;\npub const ATOM_LOCALNAME__66_72_6F_6D : LocalName = LocalName :: pack_inline (470021203456u64 , 4u8) ;\npub const ATOM_LOCALNAME__66_78 : LocalName = LocalName :: pack_inline (7890432u64 , 2u8) ;\npub const ATOM_LOCALNAME__66_79 : LocalName = LocalName :: pack_inline (7955968u64 , 2u8) ;\npub const ATOM_LOCALNAME__67 : LocalName = LocalName :: pack_inline (26368u64 , 1u8) ;\npub const ATOM_LOCALNAME__67_31 : LocalName = LocalName :: pack_inline (3237632u64 , 2u8) ;\npub const ATOM_LOCALNAME__67_32 : LocalName = LocalName :: pack_inline (3303168u64 , 2u8) ;\npub const ATOM_LOCALNAME__67_63_64 : LocalName = LocalName :: pack_inline (1684236032u64 , 3u8) ;\npub const ATOM_LOCALNAME__67_65_71 : LocalName = LocalName :: pack_inline (1902470912u64 , 3u8) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68 : LocalName = LocalName :: pack_inline (114832282773248u64 , 5u8) ;\npub const ATOM_LOCALNAME__67_72_61_64 : LocalName = LocalName :: pack_inline (431131617024u64 , 4u8) ;\npub const ATOM_LOCALNAME__67_74 : LocalName = LocalName :: pack_inline (7628544u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_31 : LocalName = LocalName :: pack_inline (3237888u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_32 : LocalName = LocalName :: pack_inline (3303424u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_33 : LocalName = LocalName :: pack_inline (3368960u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_34 : LocalName = LocalName :: pack_inline (3434496u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_35 : LocalName = LocalName :: pack_inline (3500032u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_36 : LocalName = LocalName :: pack_inline (3565568u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_61_6E_64_6C_65_72 : LocalName = LocalName :: pack_inline (8243113871575967744u64 , 7u8) ;\npub const ATOM_LOCALNAME__68_61_6E_67_69_6E_67 : LocalName = LocalName :: pack_inline (7453010326299174912u64 , 7u8) ;\npub const ATOM_LOCALNAME__68_65_61_64 : LocalName = LocalName :: pack_inline (431130765312u64 , 4u8) ;\npub const ATOM_LOCALNAME__68_65_61_64_65_72 : LocalName = LocalName :: pack_inline (32199629150185472u64 , 6u8) ;\npub const ATOM_LOCALNAME__68_65_61_64_65_72_73 : LocalName = LocalName :: pack_inline (8318822943511898112u64 , 7u8) ;\npub const ATOM_LOCALNAME__68_65_69_67_68_74 : LocalName = LocalName :: pack_inline (32765890657609728u64 , 6u8) ;\npub const ATOM_LOCALNAME__68_67_72_6F_75_70 : LocalName = LocalName :: pack_inline (31654318912792576u64 , 6u8) ;\npub const ATOM_LOCALNAME__68_69_64_64_65_6E : LocalName = LocalName :: pack_inline (31073729293936640u64 , 6u8) ;\npub const ATOM_LOCALNAME__68_69_67_68 : LocalName = LocalName :: pack_inline (448411559936u64 , 4u8) ;\npub const ATOM_LOCALNAME__68_6B_65_72_6E : LocalName = LocalName :: pack_inline (121437606864896u64 , 5u8) ;\npub const ATOM_LOCALNAME__68_72 : LocalName = LocalName :: pack_inline (7497728u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_72_65_66 : LocalName = LocalName :: pack_inline (439788660736u64 , 4u8) ;\npub const ATOM_LOCALNAME__68_73_70_61_63_65 : LocalName = LocalName :: pack_inline (28538242797365248u64 , 6u8) ;\npub const ATOM_LOCALNAME__68_74_6D_6C : LocalName = LocalName :: pack_inline (465692813312u64 , 4u8) ;\npub const ATOM_LOCALNAME__69 : LocalName = LocalName :: pack_inline (26880u64 , 1u8) ;\npub const ATOM_LOCALNAME__69_63_6F_6E : LocalName = LocalName :: pack_inline (474315188480u64 , 4u8) ;\npub const ATOM_LOCALNAME__69_64 : LocalName = LocalName :: pack_inline (6580480u64 , 2u8) ;\npub const ATOM_LOCALNAME__69_64_65_6E_74 : LocalName = LocalName :: pack_inline (128017496303872u64 , 5u8) ;\npub const ATOM_LOCALNAME__69_66_72_61_6D_65 : LocalName = LocalName :: pack_inline (28549237946345728u64 , 6u8) ;\npub const ATOM_LOCALNAME__69_6D_61_67_65 : LocalName = LocalName :: pack_inline (111494690597120u64 , 5u8) ;\npub const ATOM_LOCALNAME__69_6D_67 : LocalName = LocalName :: pack_inline (1735223552u64 , 3u8) ;\npub const ATOM_LOCALNAME__69_6D_70_6C_69_65_73 : LocalName = LocalName :: pack_inline (8315168201473091840u64 , 7u8) ;\npub const ATOM_LOCALNAME__69_6E : LocalName = LocalName :: pack_inline (7235840u64 , 2u8) ;\npub const ATOM_LOCALNAME__69_6E_32 : LocalName = LocalName :: pack_inline (846096640u64 , 3u8) ;\npub const ATOM_LOCALNAME__69_6E_64_65_78 : LocalName = LocalName :: pack_inline (132376871987456u64 , 5u8) ;\npub const ATOM_LOCALNAME__69_6E_70_75_74 : LocalName = LocalName :: pack_inline (128047746279680u64 , 5u8) ;\npub const ATOM_LOCALNAME__69_6E_73 : LocalName = LocalName :: pack_inline (1936615680u64 , 3u8) ;\npub const ATOM_LOCALNAME__69_6E_74 : LocalName = LocalName :: pack_inline (1953392896u64 , 3u8) ;\npub const ATOM_LOCALNAME__69_6E_76_65_72_73_65 : LocalName = LocalName :: pack_inline (7310312400256657664u64 , 7u8) ;\npub const ATOM_LOCALNAME__69_73_69_6E_64_65_78 : LocalName = LocalName :: pack_inline (8675450682577479936u64 , 7u8) ;\npub const ATOM_LOCALNAME__69_73_6D_61_70 : LocalName = LocalName :: pack_inline (123563750418688u64 , 5u8) ;\npub const ATOM_LOCALNAME__69_74_65_6D_69_64 : LocalName = LocalName :: pack_inline (28263416245545216u64 , 6u8) ;\npub const ATOM_LOCALNAME__69_74_65_6D_72_65_66 : LocalName = LocalName :: pack_inline (7378429378695555328u64 , 7u8) ;\npub const ATOM_LOCALNAME__6B : LocalName = LocalName :: pack_inline (27392u64 , 1u8) ;\npub const ATOM_LOCALNAME__6B_31 : LocalName = LocalName :: pack_inline (3238656u64 , 2u8) ;\npub const ATOM_LOCALNAME__6B_32 : LocalName = LocalName :: pack_inline (3304192u64 , 2u8) ;\npub const ATOM_LOCALNAME__6B_33 : LocalName = LocalName :: pack_inline (3369728u64 , 2u8) ;\npub const ATOM_LOCALNAME__6B_34 : LocalName = LocalName :: pack_inline (3435264u64 , 2u8) ;\npub const ATOM_LOCALNAME__6B_62_64 : LocalName = LocalName :: pack_inline (1684171520u64 , 3u8) ;\npub const ATOM_LOCALNAME__6B_65_72_6E_69_6E_67 : LocalName = LocalName :: pack_inline (7453010356431317760u64 , 7u8) ;\npub const ATOM_LOCALNAME__6B_65_79_67_65_6E : LocalName = LocalName :: pack_inline (31073742530898688u64 , 6u8) ;\npub const ATOM_LOCALNAME__6B_69_6E_64 : LocalName = LocalName :: pack_inline (431349132032u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_61_62_65_6C : LocalName = LocalName :: pack_inline (119182698048512u64 , 5u8) ;\npub const ATOM_LOCALNAME__6C_61_6D_62_64_61 : LocalName = LocalName :: pack_inline (27413446645607424u64 , 6u8) ;\npub const ATOM_LOCALNAME__6C_61_6E_67 : LocalName = LocalName :: pack_inline (444233509888u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_61_72_67_65_6F_70 : LocalName = LocalName :: pack_inline (8101805749637835776u64 , 7u8) ;\npub const ATOM_LOCALNAME__6C_63_6D : LocalName = LocalName :: pack_inline (1835232256u64 , 3u8) ;\npub const ATOM_LOCALNAME__6C_65_67_65_6E_64 : LocalName = LocalName :: pack_inline (28268879476517888u64 , 6u8) ;\npub const ATOM_LOCALNAME__6C_65_71 : LocalName = LocalName :: pack_inline (1902472192u64 , 3u8) ;\npub const ATOM_LOCALNAME__6C_69 : LocalName = LocalName :: pack_inline (6908928u64 , 2u8) ;\npub const ATOM_LOCALNAME__6C_69_6D_69_74 : LocalName = LocalName :: pack_inline (127996156013568u64 , 5u8) ;\npub const ATOM_LOCALNAME__6C_69_6E_65 : LocalName = LocalName :: pack_inline (435644099584u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_69_6E_6B : LocalName = LocalName :: pack_inline (461413903360u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_69_73_74 : LocalName = LocalName :: pack_inline (500152495104u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_69_73_74_69_6E_67 : LocalName = LocalName :: pack_inline (7453010382218161152u64 , 7u8) ;\npub const ATOM_LOCALNAME__6C_6E : LocalName = LocalName :: pack_inline (7236608u64 , 2u8) ;\npub const ATOM_LOCALNAME__6C_6F_61_64_69_6E_67 : LocalName = LocalName :: pack_inline (7453010313197087744u64 , 7u8) ;\npub const ATOM_LOCALNAME__6C_6F_63_61_6C : LocalName = LocalName :: pack_inline (119165535874048u64 , 5u8) ;\npub const ATOM_LOCALNAME__6C_6F_67 : LocalName = LocalName :: pack_inline (1735355392u64 , 3u8) ;\npub const ATOM_LOCALNAME__6C_6F_67_62_61_73_65 : LocalName = LocalName :: pack_inline (7310293695422491648u64 , 7u8) ;\npub const ATOM_LOCALNAME__6C_6F_6F_70 : LocalName = LocalName :: pack_inline (482905910272u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_6F_77 : LocalName = LocalName :: pack_inline (2003790848u64 , 3u8) ;\npub const ATOM_LOCALNAME__6C_6F_77_73_72_63 : LocalName = LocalName :: pack_inline (27991862944951296u64 , 6u8) ;\npub const ATOM_LOCALNAME__6C_71_75_6F_74_65 : LocalName = LocalName :: pack_inline (28556994708335616u64 , 6u8) ;\npub const ATOM_LOCALNAME__6C_73_70_61_63_65 : LocalName = LocalName :: pack_inline (28538242797366272u64 , 6u8) ;\npub const ATOM_LOCALNAME__6C_74 : LocalName = LocalName :: pack_inline (7629824u64 , 2u8) ;\npub const ATOM_LOCALNAME__6D_61_63_72_6F_73 : LocalName = LocalName :: pack_inline (32492159406009600u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_61_63_74_69_6F_6E : LocalName = LocalName :: pack_inline (7957695015191407872u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_61_69_6E : LocalName = LocalName :: pack_inline (474214395136u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_61_70 : LocalName = LocalName :: pack_inline (1885433088u64 , 3u8) ;\npub const ATOM_LOCALNAME__6D_61_72_6B : LocalName = LocalName :: pack_inline (461480488192u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72 : LocalName = LocalName :: pack_inline (32199659499908352u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_61_72_71_75_65_65 : LocalName = LocalName :: pack_inline (7306375100589239552u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_61_73_6B : LocalName = LocalName :: pack_inline (461497265408u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_61_74_68 : LocalName = LocalName :: pack_inline (448629140736u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_61_74_72_69_78 : LocalName = LocalName :: pack_inline (33892937505008896u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_61_78 : LocalName = LocalName :: pack_inline (2019650816u64 , 3u8) ;\npub const ATOM_LOCALNAME__6D_61_78_73_69_7A_65 : LocalName = LocalName :: pack_inline (7312272889651227904u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_65_61_6E : LocalName = LocalName :: pack_inline (474080439552u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_65_64_69_61 : LocalName = LocalName :: pack_inline (107105283828992u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_65_64_69_61_6E : LocalName = LocalName :: pack_inline (31069352722001152u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_65_6E_75 : LocalName = LocalName :: pack_inline (504363314432u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_65_72_72_6F_72 : LocalName = LocalName :: pack_inline (32210684681219328u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_65_74_61 : LocalName = LocalName :: pack_inline (418564631808u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_65_74_65_72 : LocalName = LocalName :: pack_inline (125780070067456u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_65_74_68_6F_64 : LocalName = LocalName :: pack_inline (28269992091151616u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_66_65_6E_63_65_64 : LocalName = LocalName :: pack_inline (7234297702239333632u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_66_72_61_63 : LocalName = LocalName :: pack_inline (109270182292736u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_67_6C_79_70_68 : LocalName = LocalName :: pack_inline (29397064389979392u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_69 : LocalName = LocalName :: pack_inline (6909184u64 , 2u8) ;\npub const ATOM_LOCALNAME__6D_69_6E : LocalName = LocalName :: pack_inline (1852402944u64 , 3u8) ;\npub const ATOM_LOCALNAME__6D_69_6E_73_69_7A_65 : LocalName = LocalName :: pack_inline (7312272889483980032u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_69_6E_75_73 : LocalName = LocalName :: pack_inline (126948200770816u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_6E : LocalName = LocalName :: pack_inline (7236864u64 , 2u8) ;\npub const ATOM_LOCALNAME__6D_6F : LocalName = LocalName :: pack_inline (7302400u64 , 2u8) ;\npub const ATOM_LOCALNAME__6D_6F_64_65 : LocalName = LocalName :: pack_inline (435476720896u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_6F_6D_65_6E_74 : LocalName = LocalName :: pack_inline (32772479205207296u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_6F_76_65_72 : LocalName = LocalName :: pack_inline (125780104277248u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_70_61_64_64_65_64 : LocalName = LocalName :: pack_inline (7234298758734834944u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_70_61_74_68 : LocalName = LocalName :: pack_inline (114849060252928u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_72_6F_6F_74 : LocalName = LocalName :: pack_inline (128021959961856u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_72_6F_77 : LocalName = LocalName :: pack_inline (512970878208u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_73 : LocalName = LocalName :: pack_inline (7564544u64 , 2u8) ;\npub const ATOM_LOCALNAME__6D_73_70_61_63_65 : LocalName = LocalName :: pack_inline (28538242797366528u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_73_71_72_74 : LocalName = LocalName :: pack_inline (128034878483712u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_73_74_79_6C_65 : LocalName = LocalName :: pack_inline (28548241548340480u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_73_75_62 : LocalName = LocalName :: pack_inline (422877293824u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_73_75_62_73_75_70 : LocalName = LocalName :: pack_inline (8103509971237563648u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_73_75_70 : LocalName = LocalName :: pack_inline (483006835968u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_74_61_62_6C_65 : LocalName = LocalName :: pack_inline (28548142445391104u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_74_64 : LocalName = LocalName :: pack_inline (1685351680u64 , 3u8) ;\npub const ATOM_LOCALNAME__6D_74_65_78_74 : LocalName = LocalName :: pack_inline (128060447026432u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_74_72 : LocalName = LocalName :: pack_inline (1920232704u64 , 3u8) ;\npub const ATOM_LOCALNAME__6D_75_6E_64_65_72 : LocalName = LocalName :: pack_inline (32199629369339136u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_75_74_65_64 : LocalName = LocalName :: pack_inline (110386908327168u64 , 5u8) ;\npub const ATOM_LOCALNAME__6E_61_6D_65 : LocalName = LocalName :: pack_inline (435626798592u64 , 4u8) ;\npub const ATOM_LOCALNAME__6E_61_72_67_73 : LocalName = LocalName :: pack_inline (126888137813504u64 , 5u8) ;\npub const ATOM_LOCALNAME__6E_61_76 : LocalName = LocalName :: pack_inline (1986096640u64 , 3u8) ;\npub const ATOM_LOCALNAME__6E_65_71 : LocalName = LocalName :: pack_inline (1902472704u64 , 3u8) ;\npub const ATOM_LOCALNAME__6E_65_73_74 : LocalName = LocalName :: pack_inline (500152233472u64 , 4u8) ;\npub const ATOM_LOCALNAME__6E_65_78_74_69_64 : LocalName = LocalName :: pack_inline (28263446628101632u64 , 6u8) ;\npub const ATOM_LOCALNAME__6E_6F_62_72 : LocalName = LocalName :: pack_inline (491277741568u64 , 4u8) ;\npub const ATOM_LOCALNAME__6E_6F_65_6D_62_65_64 : LocalName = LocalName :: pack_inline (7234296598433328640u64 , 7u8) ;\npub const ATOM_LOCALNAME__6E_6F_68_72_65_66 : LocalName = LocalName :: pack_inline (28821989677297152u64 , 6u8) ;\npub const ATOM_LOCALNAME__6E_6F_6E_63_65 : LocalName = LocalName :: pack_inline (111477728964096u64 , 5u8) ;\npub const ATOM_LOCALNAME__6E_6F_6E_65 : LocalName = LocalName :: pack_inline (435644493312u64 , 4u8) ;\npub const ATOM_LOCALNAME__6E_6F_73_68_61_64_65 : LocalName = LocalName :: pack_inline (7306071596742962688u64 , 7u8) ;\npub const ATOM_LOCALNAME__6E_6F_74 : LocalName = LocalName :: pack_inline (1953459712u64 , 3u8) ;\npub const ATOM_LOCALNAME__6E_6F_74_69_6E : LocalName = LocalName :: pack_inline (121399204081152u64 , 5u8) ;\npub const ATOM_LOCALNAME__6E_6F_77_72_61_70 : LocalName = LocalName :: pack_inline (31632341649550848u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_62_6A_65_63_74 : LocalName = LocalName :: pack_inline (32760384526118656u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_66_66_73_65_74 : LocalName = LocalName :: pack_inline (32762643612069632u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6C : LocalName = LocalName :: pack_inline (7106304u64 , 2u8) ;\npub const ATOM_LOCALNAME__6F_6E_61_62_6F_72_74 : LocalName = LocalName :: pack_inline (8390891524076760832u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_67_69_6E : LocalName = LocalName :: pack_inline (7956003901867454208u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_62_6C_75_72 : LocalName = LocalName :: pack_inline (32217255713337088u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_63_6C_69_63_6B : LocalName = LocalName :: pack_inline (7738144498998210304u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_63_6F_70_79 : LocalName = LocalName :: pack_inline (34182095893851904u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_63_75_74 : LocalName = LocalName :: pack_inline (128047528177408u64 , 5u8) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67 : LocalName = LocalName :: pack_inline (29099066540322560u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_6F_70 : LocalName = LocalName :: pack_inline (31647734493507328u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_65_6E_64 : LocalName = LocalName :: pack_inline (110425310916352u64 , 5u8) ;\npub const ATOM_LOCALNAME__6F_6E_65_72_72_6F_72 : LocalName = LocalName :: pack_inline (8245935278392241920u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_66_6F_63_75_73 : LocalName = LocalName :: pack_inline (8319665216747892480u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_68_65_6C_70 : LocalName = LocalName :: pack_inline (31644380191158016u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_69_6E_70_75_74 : LocalName = LocalName :: pack_inline (8391737100192345856u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_6B_65_79_75_70 : LocalName = LocalName :: pack_inline (8103516581024132864u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_6C_6F_61_64 : LocalName = LocalName :: pack_inline (28254628859506432u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_76_65 : LocalName = LocalName :: pack_inline (28559193597177600u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_70_61_73_74_65 : LocalName = LocalName :: pack_inline (7310594957464465152u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_72_65_73_65_74 : LocalName = LocalName :: pack_inline (8387236760596147968u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_73_74_61_72_74 : LocalName = LocalName :: pack_inline (8390876208525373184u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_73_74_6F_70 : LocalName = LocalName :: pack_inline (31647743335100160u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_7A_6F_6F_6D : LocalName = LocalName :: pack_inline (30803297047572224u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_70_61_63_69_74_79 : LocalName = LocalName :: pack_inline (8751735851445153536u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_70_65_6E : LocalName = LocalName :: pack_inline (474148269824u64 , 4u8) ;\npub const ATOM_LOCALNAME__6F_70_74_69_6D_75_6D : LocalName = LocalName :: pack_inline (7887330622101810944u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_70_74_69_6F_6E : LocalName = LocalName :: pack_inline (31084746153946880u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_72 : LocalName = LocalName :: pack_inline (7499520u64 , 2u8) ;\npub const ATOM_LOCALNAME__6F_72_64_65_72 : LocalName = LocalName :: pack_inline (125779802484480u64 , 5u8) ;\npub const ATOM_LOCALNAME__6F_72_69_65_6E_74 : LocalName = LocalName :: pack_inline (32772479138295552u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_72_69_67_69_6E : LocalName = LocalName :: pack_inline (31078140309827328u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_74_68_65_72 : LocalName = LocalName :: pack_inline (125779869724416u64 , 5u8) ;\npub const ATOM_LOCALNAME__6F_75_74_70_75_74 : LocalName = LocalName :: pack_inline (32780223149076224u64 , 6u8) ;\npub const ATOM_LOCALNAME__70 : LocalName = LocalName :: pack_inline (28672u64 , 1u8) ;\npub const ATOM_LOCALNAME__70_61_72_61_6D : LocalName = LocalName :: pack_inline (120265298243584u64 , 5u8) ;\npub const ATOM_LOCALNAME__70_61_72_73_65 : LocalName = LocalName :: pack_inline (111546514632704u64 , 5u8) ;\npub const ATOM_LOCALNAME__70_61_72_74 : LocalName = LocalName :: pack_inline (500135194624u64 , 4u8) ;\npub const ATOM_LOCALNAME__70_61_74_68 : LocalName = LocalName :: pack_inline (448629141504u64 , 4u8) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E : LocalName = LocalName :: pack_inline (7958535042360242176u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_69 : LocalName = LocalName :: pack_inline (6909952u64 , 2u8) ;\npub const ATOM_LOCALNAME__70_69_63_74_75_72_65 : LocalName = LocalName :: pack_inline (7310034287920246784u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_69_65_63_65 : LocalName = LocalName :: pack_inline (111477577576448u64 , 5u8) ;\npub const ATOM_LOCALNAME__70_69_6E_67 : LocalName = LocalName :: pack_inline (444234035200u64 , 4u8) ;\npub const ATOM_LOCALNAME__70_6C_75_73 : LocalName = LocalName :: pack_inline (495891279872u64 , 4u8) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73 : LocalName = LocalName :: pack_inline (32497639885860864u64 , 6u8) ;\npub const ATOM_LOCALNAME__70_6F_6C_79_67_6F_6E : LocalName = LocalName :: pack_inline (7957692837794902016u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_6F_73_74_65_72 : LocalName = LocalName :: pack_inline (32199698172309504u64 , 6u8) ;\npub const ATOM_LOCALNAME__70_6F_77_65_72 : LocalName = LocalName :: pack_inline (125780121055232u64 , 5u8) ;\npub const ATOM_LOCALNAME__70_72_65 : LocalName = LocalName :: pack_inline (1701998592u64 , 3u8) ;\npub const ATOM_LOCALNAME__70_72_65_6C_6F_61_64 : LocalName = LocalName :: pack_inline (7233184987882876928u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_72_69_6D_65_73 : LocalName = LocalName :: pack_inline (32481142916673536u64 , 6u8) ;\npub const ATOM_LOCALNAME__70_72_6F_64_75_63_74 : LocalName = LocalName :: pack_inline (8386676005320945664u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_72_6F_66_69_6C_65 : LocalName = LocalName :: pack_inline (7308332183992823808u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_72_6F_6D_70_74 : LocalName = LocalName :: pack_inline (32774712621953024u64 , 6u8) ;\npub const ATOM_LOCALNAME__71 : LocalName = LocalName :: pack_inline (28928u64 , 1u8) ;\npub const ATOM_LOCALNAME__72 : LocalName = LocalName :: pack_inline (29184u64 , 1u8) ;\npub const ATOM_LOCALNAME__72_61_64_69_75_73 : LocalName = LocalName :: pack_inline (32498717837849088u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_62 : LocalName = LocalName :: pack_inline (6451712u64 , 2u8) ;\npub const ATOM_LOCALNAME__72_65_61_6C : LocalName = LocalName :: pack_inline (465490506240u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_61_6C_73 : LocalName = LocalName :: pack_inline (126909327700480u64 , 5u8) ;\npub const ATOM_LOCALNAME__72_65_63_74 : LocalName = LocalName :: pack_inline (499883799040u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_66_58 : LocalName = LocalName :: pack_inline (379675046400u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_66_59 : LocalName = LocalName :: pack_inline (383970013696u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_66_78 : LocalName = LocalName :: pack_inline (517113999872u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_66_79 : LocalName = LocalName :: pack_inline (521408967168u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_6C : LocalName = LocalName :: pack_inline (1818587648u64 , 3u8) ;\npub const ATOM_LOCALNAME__72_65_6C_6E : LocalName = LocalName :: pack_inline (474264990208u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_6D : LocalName = LocalName :: pack_inline (1835364864u64 , 3u8) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74 : LocalName = LocalName :: pack_inline (32758185603723776u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_65_70_6C_61_63_65 : LocalName = LocalName :: pack_inline (7305790138895135232u64 , 7u8) ;\npub const ATOM_LOCALNAME__72_65_73_74_61_72_74 : LocalName = LocalName :: pack_inline (8390876208524784128u64 , 7u8) ;\npub const ATOM_LOCALNAME__72_65_73_75_6C_74 : LocalName = LocalName :: pack_inline (32770349001437696u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_65_76 : LocalName = LocalName :: pack_inline (1986359808u64 , 3u8) ;\npub const ATOM_LOCALNAME__72_6F_6C_65 : LocalName = LocalName :: pack_inline (435610939904u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_6F_6F_74 : LocalName = LocalName :: pack_inline (500085780992u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_6F_74_61_74_65 : LocalName = LocalName :: pack_inline (28556934561886720u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_6F_77_73 : LocalName = LocalName :: pack_inline (495925031424u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_6F_77_73_70_61_6E : LocalName = LocalName :: pack_inline (7953762058140348928u64 , 7u8) ;\npub const ATOM_LOCALNAME__72_70 : LocalName = LocalName :: pack_inline (7369216u64 , 2u8) ;\npub const ATOM_LOCALNAME__72_71_75_6F_74_65 : LocalName = LocalName :: pack_inline (28556994708337152u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_73_70_61_63_65 : LocalName = LocalName :: pack_inline (28538242797367808u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_74 : LocalName = LocalName :: pack_inline (7631360u64 , 2u8) ;\npub const ATOM_LOCALNAME__72_74_63 : LocalName = LocalName :: pack_inline (1668575744u64 , 3u8) ;\npub const ATOM_LOCALNAME__72_75_62_79 : LocalName = LocalName :: pack_inline (521342906880u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_75_6C_65 : LocalName = LocalName :: pack_inline (435611333120u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_75_6C_65_73 : LocalName = LocalName :: pack_inline (126879448527360u64 , 5u8) ;\npub const ATOM_LOCALNAME__72_78 : LocalName = LocalName :: pack_inline (7893504u64 , 2u8) ;\npub const ATOM_LOCALNAME__72_79 : LocalName = LocalName :: pack_inline (7959040u64 , 2u8) ;\npub const ATOM_LOCALNAME__73 : LocalName = LocalName :: pack_inline (29440u64 , 1u8) ;\npub const ATOM_LOCALNAME__73_61_6D_70 : LocalName = LocalName :: pack_inline (482871440128u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_61_6E_64_62_6F_78 : LocalName = LocalName :: pack_inline (8678263190454366976u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_63_61_6C_65 : LocalName = LocalName :: pack_inline (111516164780800u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_63_68_65_6D_65 : LocalName = LocalName :: pack_inline (28549254958248704u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_63_6F_70_65 : LocalName = LocalName :: pack_inline (111533579531008u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_63_6F_70_65_64 : LocalName = LocalName :: pack_inline (28259031250596608u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_63_72_69_70_74 : LocalName = LocalName :: pack_inline (32774695491433216u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_64_65_76 : LocalName = LocalName :: pack_inline (508507222784u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_65_61_72_63_68 : LocalName = LocalName :: pack_inline (29382740489368320u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_65_63 : LocalName = LocalName :: pack_inline (1667592960u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_65_63_68 : LocalName = LocalName :: pack_inline (448344191744u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_65_63_74_69_6F_6E : LocalName = LocalName :: pack_inline (7957695015191671552u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_65_65_64 : LocalName = LocalName :: pack_inline (431197876992u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_65_6C_65_63_74 : LocalName = LocalName :: pack_inline (32760384559870720u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_65_70 : LocalName = LocalName :: pack_inline (1885696768u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_65_74 : LocalName = LocalName :: pack_inline (1952805632u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_65_74_64_69_66_66 : LocalName = LocalName :: pack_inline (7378700919663588096u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_68_61_70_65 : LocalName = LocalName :: pack_inline (111533344977664u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_68_6F_77 : LocalName = LocalName :: pack_inline (512970224384u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_69_6E : LocalName = LocalName :: pack_inline (1852404480u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_69_6E_68 : LocalName = LocalName :: pack_inline (448529003264u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_69_7A_65 : LocalName = LocalName :: pack_inline (435845427968u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_69_7A_65_73 : LocalName = LocalName :: pack_inline (126879682622208u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_6C_6F_70_65 : LocalName = LocalName :: pack_inline (111533580120832u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_6C_6F_74 : LocalName = LocalName :: pack_inline (500085584640u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_6D_61_6C_6C : LocalName = LocalName :: pack_inline (119212746830592u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_6F_75_72_63_65 : LocalName = LocalName :: pack_inline (28538315895436032u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_70_61_63_65 : LocalName = LocalName :: pack_inline (111477510927104u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_70_61_63_65_72 : LocalName = LocalName :: pack_inline (32199624855941888u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_inline (7453010308902187776u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_70_61_6E : LocalName = LocalName :: pack_inline (474081161984u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_70_65_65_64 : LocalName = LocalName :: pack_inline (110386656342784u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_72_63 : LocalName = LocalName :: pack_inline (1668444928u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_72_63_64_6F_63 : LocalName = LocalName :: pack_inline (27988499650212608u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_72_63_6C_61_6E_67 : LocalName = LocalName :: pack_inline (7453001551497556736u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_72_63_73_65_74 : LocalName = LocalName :: pack_inline (32762643562525440u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_74_61_6E_64_62_79 : LocalName = LocalName :: pack_inline (8746663851551126272u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_74_61_72_74 : LocalName = LocalName :: pack_inline (128034610115328u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_74_65_6D_68 : LocalName = LocalName :: pack_inline (114819062854400u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_74_65_6D_76 : LocalName = LocalName :: pack_inline (130212225643264u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_74_65_70 : LocalName = LocalName :: pack_inline (482738467584u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_74_6F_70 : LocalName = LocalName :: pack_inline (482906239744u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_74_72_69_6B_65 : LocalName = LocalName :: pack_inline (28547073283748608u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_74_72_69_6E_67 : LocalName = LocalName :: pack_inline (29113321772053248u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65 : LocalName = LocalName :: pack_inline (28547099053552384u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6E_67 : LocalName = LocalName :: pack_inline (29113347541857024u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_74_79_6C_65 : LocalName = LocalName :: pack_inline (111516568548096u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_75_62 : LocalName = LocalName :: pack_inline (1651864320u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_75_62_73_65_74 : LocalName = LocalName :: pack_inline (32762643545944832u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_75_6D : LocalName = LocalName :: pack_inline (1836413696u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_75_6D_6D_61_72_79 : LocalName = LocalName :: pack_inline (8751164148550038272u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_75_70 : LocalName = LocalName :: pack_inline (1886745344u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_76_67 : LocalName = LocalName :: pack_inline (1735815936u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_77_69_74_63_68 : LocalName = LocalName :: pack_inline (29382749214700288u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_79_6D_62_6F_6C : LocalName = LocalName :: pack_inline (30521766018904832u64 , 6u8) ;\npub const ATOM_LOCALNAME__74_61_62_6C_65 : LocalName = LocalName :: pack_inline (111516181427200u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_61_6E : LocalName = LocalName :: pack_inline (1851880448u64 , 3u8) ;\npub const ATOM_LOCALNAME__74_61_6E_68 : LocalName = LocalName :: pack_inline (448528479232u64 , 4u8) ;\npub const ATOM_LOCALNAME__74_61_72_67_65_74 : LocalName = LocalName :: pack_inline (32762592273462272u64 , 6u8) ;\npub const ATOM_LOCALNAME__74_61_72_67_65_74_58 : LocalName = LocalName :: pack_inline (6373830867611120640u64 , 7u8) ;\npub const ATOM_LOCALNAME__74_61_72_67_65_74_59 : LocalName = LocalName :: pack_inline (6445888461649048576u64 , 7u8) ;\npub const ATOM_LOCALNAME__74_61_72_67_65_74_78 : LocalName = LocalName :: pack_inline (8679673876824814592u64 , 7u8) ;\npub const ATOM_LOCALNAME__74_61_72_67_65_74_79 : LocalName = LocalName :: pack_inline (8751731470862742528u64 , 7u8) ;\npub const ATOM_LOCALNAME__74_62_6F_64_79 : LocalName = LocalName :: pack_inline (133472272413696u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_62_72_65_61_6B : LocalName = LocalName :: pack_inline (30224910846686208u64 , 6u8) ;\npub const ATOM_LOCALNAME__74_64 : LocalName = LocalName :: pack_inline (6583296u64 , 2u8) ;\npub const ATOM_LOCALNAME__74_65_6E_64_73_74_6F : LocalName = LocalName :: pack_inline (8031170910694503424u64 , 7u8) ;\npub const ATOM_LOCALNAME__74_65_78_74 : LocalName = LocalName :: pack_inline (500236121088u64 , 4u8) ;\npub const ATOM_LOCALNAME__74_66_6F_6F_74 : LocalName = LocalName :: pack_inline (128021959177216u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_68 : LocalName = LocalName :: pack_inline (6845440u64 , 2u8) ;\npub const ATOM_LOCALNAME__74_68_65_61_64 : LocalName = LocalName :: pack_inline (110369475949568u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_69_6D_65 : LocalName = LocalName :: pack_inline (435627324416u64 , 4u8) ;\npub const ATOM_LOCALNAME__74_69_6D_65_73 : LocalName = LocalName :: pack_inline (126879464518656u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_69_74_6C_65 : LocalName = LocalName :: pack_inline (111516483941376u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_6F : LocalName = LocalName :: pack_inline (7304192u64 , 2u8) ;\npub const ATOM_LOCALNAME__74_6F_67_67_6C_65 : LocalName = LocalName :: pack_inline (28548164020564992u64 , 6u8) ;\npub const ATOM_LOCALNAME__74_72 : LocalName = LocalName :: pack_inline (7500800u64 , 2u8) ;\npub const ATOM_LOCALNAME__74_72_61_63_6B : LocalName = LocalName :: pack_inline (118074580825088u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_72_65_66 : LocalName = LocalName :: pack_inline (439788663808u64 , 4u8) ;\npub const ATOM_LOCALNAME__74_72_75_65 : LocalName = LocalName :: pack_inline (435762131968u64 , 4u8) ;\npub const ATOM_LOCALNAME__74_73_70_61_6E : LocalName = LocalName :: pack_inline (121364777497600u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_74 : LocalName = LocalName :: pack_inline (7631872u64 , 2u8) ;\npub const ATOM_LOCALNAME__74_79_70_65 : LocalName = LocalName :: pack_inline (435678704640u64 , 4u8) ;\npub const ATOM_LOCALNAME__75 : LocalName = LocalName :: pack_inline (29952u64 , 1u8) ;\npub const ATOM_LOCALNAME__75_31 : LocalName = LocalName :: pack_inline (3241216u64 , 2u8) ;\npub const ATOM_LOCALNAME__75_32 : LocalName = LocalName :: pack_inline (3306752u64 , 2u8) ;\npub const ATOM_LOCALNAME__75_6C : LocalName = LocalName :: pack_inline (7107840u64 , 2u8) ;\npub const ATOM_LOCALNAME__75_6E_69_63_6F_64_65 : LocalName = LocalName :: pack_inline (7306086968263079168u64 , 7u8) ;\npub const ATOM_LOCALNAME__75_6E_69_6F_6E : LocalName = LocalName :: pack_inline (121424789271808u64 , 5u8) ;\npub const ATOM_LOCALNAME__75_70_6C_69_6D_69_74 : LocalName = LocalName :: pack_inline (8388356080512562432u64 , 7u8) ;\npub const ATOM_LOCALNAME__75_73_65 : LocalName = LocalName :: pack_inline (1702065408u64 , 3u8) ;\npub const ATOM_LOCALNAME__75_73_65_6D_61_70 : LocalName = LocalName :: pack_inline (31632319872988416u64 , 6u8) ;\npub const ATOM_LOCALNAME__76_61_6C_69_67_6E : LocalName = LocalName :: pack_inline (31075949925725696u64 , 6u8) ;\npub const ATOM_LOCALNAME__76_61_6C_75_65 : LocalName = LocalName :: pack_inline (111555003905536u64 , 5u8) ;\npub const ATOM_LOCALNAME__76_61_6C_75_65_73 : LocalName = LocalName :: pack_inline (32481177325630976u64 , 6u8) ;\npub const ATOM_LOCALNAME__76_61_72 : LocalName = LocalName :: pack_inline (1918989824u64 , 3u8) ;\npub const ATOM_LOCALNAME__76_65_63_74_6F_72 : LocalName = LocalName :: pack_inline (32210693019497984u64 , 6u8) ;\npub const ATOM_LOCALNAME__76_65_72_73_69_6F_6E : LocalName = LocalName :: pack_inline (7957695011148363264u64 , 7u8) ;\npub const ATOM_LOCALNAME__76_69_64_65_6F : LocalName = LocalName :: pack_inline (122481267013120u64 , 5u8) ;\npub const ATOM_LOCALNAME__76_69_65_77 : LocalName = LocalName :: pack_inline (512802518528u64 , 4u8) ;\npub const ATOM_LOCALNAME__76_69_65_77_42_6F_78 : LocalName = LocalName :: pack_inline (8678228087536186880u64 , 7u8) ;\npub const ATOM_LOCALNAME__76_69_65_77_62_6F_78 : LocalName = LocalName :: pack_inline (8678263271908275712u64 , 7u8) ;\npub const ATOM_LOCALNAME__76_6B_65_72_6E : LocalName = LocalName :: pack_inline (121437606868480u64 , 5u8) ;\npub const ATOM_LOCALNAME__76_6C_69_6E_6B : LocalName = LocalName :: pack_inline (118121959290368u64 , 5u8) ;\npub const ATOM_LOCALNAME__76_73_70_61_63_65 : LocalName = LocalName :: pack_inline (28538242797368832u64 , 6u8) ;\npub const ATOM_LOCALNAME__77_62_72 : LocalName = LocalName :: pack_inline (1919055616u64 , 3u8) ;\npub const ATOM_LOCALNAME__77_68_65_6E : LocalName = LocalName :: pack_inline (474147747584u64 , 4u8) ;\npub const ATOM_LOCALNAME__77_69_64_74_68 : LocalName = LocalName :: pack_inline (114849110128384u64 , 5u8) ;\npub const ATOM_LOCALNAME__77_69_64_74_68_73 : LocalName = LocalName :: pack_inline (32484471431853824u64 , 6u8) ;\npub const ATOM_LOCALNAME__77_72_61_70 : LocalName = LocalName :: pack_inline (482671228672u64 , 4u8) ;\npub const ATOM_LOCALNAME__78 : LocalName = LocalName :: pack_inline (30720u64 , 1u8) ;\npub const ATOM_LOCALNAME__78_31 : LocalName = LocalName :: pack_inline (3241984u64 , 2u8) ;\npub const ATOM_LOCALNAME__78_32 : LocalName = LocalName :: pack_inline (3307520u64 , 2u8) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B : LocalName = LocalName :: pack_inline (118121959290880u64 , 5u8) ;\npub const ATOM_LOCALNAME__78_6D_6C_6E_73 : LocalName = LocalName :: pack_inline (126918102710272u64 , 5u8) ;\npub const ATOM_LOCALNAME__78_6D_70 : LocalName = LocalName :: pack_inline (1886222336u64 , 3u8) ;\npub const ATOM_LOCALNAME__78_6F_72 : LocalName = LocalName :: pack_inline (1919907840u64 , 3u8) ;\npub const ATOM_LOCALNAME__78_72_65_66 : LocalName = LocalName :: pack_inline (439788664832u64 , 4u8) ;\npub const ATOM_LOCALNAME__79 : LocalName = LocalName :: pack_inline (30976u64 , 1u8) ;\npub const ATOM_LOCALNAME__79_31 : LocalName = LocalName :: pack_inline (3242240u64 , 2u8) ;\npub const ATOM_LOCALNAME__79_32 : LocalName = LocalName :: pack_inline (3307776u64 , 2u8) ;\npub const ATOM_LOCALNAME__7A : LocalName = LocalName :: pack_inline (31232u64 , 1u8) ;\n# [doc = \"Takes a local name as a string and returns its key in the string cache.\"] # [macro_export] macro_rules ! local_name { (\"femorphology\") => { $ crate :: ATOM_LOCALNAME__66_65_6D_6F_72_70_68_6F_6C_6F_67_79 } ;\n(\"xml:space\") => { $ crate :: ATOM_LOCALNAME__78_6D_6C_3A_73_70_61_63_65 } ;\n(\"aria-orientation\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6F_72_69_65_6E_74_61_74_69_6F_6E } ;\n(\"calcmode\") => { $ crate :: ATOM_LOCALNAME__63_61_6C_63_6D_6F_64_65 } ;\n(\"unicode-bidi\") => { $ crate :: ATOM_LOCALNAME__75_6E_69_63_6F_64_65_2D_62_69_64_69 } ;\n(\"altGlyphItem\") => { $ crate :: ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68_49_74_65_6D } ;\n(\"contentStyleType\") => { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_53_74_79_6C_65_54_79_70_65 } ;\n(\"pointsAtX\") => { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_58 } ;\n(\"equalrows\") => { $ crate :: ATOM_LOCALNAME__65_71_75_61_6C_72_6F_77_73 } ;\n(\"shadowrootclonable\") => { $ crate :: ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_63_6C_6F_6E_61_62_6C_65 } ;\n(\"feDisplacementMap\") => { $ crate :: ATOM_LOCALNAME__66_65_44_69_73_70_6C_61_63_65_6D_65_6E_74_4D_61_70 } ;\n(\"contentscripttype\") => { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_73_63_72_69_70_74_74_79_70_65 } ;\n(\"overline-thickness\") => { $ crate :: ATOM_LOCALNAME__6F_76_65_72_6C_69_6E_65_2D_74_68_69_63_6B_6E_65_73_73 } ;\n(\"noresize\") => { $ crate :: ATOM_LOCALNAME__6E_6F_72_65_73_69_7A_65 } ;\n(\"ondragleave\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_6C_65_61_76_65 } ;\n(\"onmousewheel\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_77_68_65_65_6C } ;\n(\"animatecolor\") => { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_63_6F_6C_6F_72 } ;\n(\"writing-mode\") => { $ crate :: ATOM_LOCALNAME__77_72_69_74_69_6E_67_2D_6D_6F_64_65 } ;\n(\"menuitem\") => { $ crate :: ATOM_LOCALNAME__6D_65_6E_75_69_74_65_6D } ;\n(\"manifest\") => { $ crate :: ATOM_LOCALNAME__6D_61_6E_69_66_65_73_74 } ;\n(\"contentstyletype\") => { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_73_74_79_6C_65_74_79_70_65 } ;\n(\"flood-color\") => { $ crate :: ATOM_LOCALNAME__66_6C_6F_6F_64_2D_63_6F_6C_6F_72 } ;\n(\"accumulate\") => { $ crate :: ATOM_LOCALNAME__61_63_63_75_6D_75_6C_61_74_65 } ;\n(\"equalcolumns\") => { $ crate :: ATOM_LOCALNAME__65_71_75_61_6C_63_6F_6C_75_6D_6E_73 } ;\n(\"repeatcount\") => { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_63_6F_75_6E_74 } ;\n(\"blockquote\") => { $ crate :: ATOM_LOCALNAME__62_6C_6F_63_6B_71_75_6F_74_65 } ;\n(\"keysplines\") => { $ crate :: ATOM_LOCALNAME__6B_65_79_73_70_6C_69_6E_65_73 } ;\n(\"externalResourcesRequired\") => { $ crate :: ATOM_LOCALNAME__65_78_74_65_72_6E_61_6C_52_65_73_6F_75_72_63_65_73_52_65_71_75_69_72_65_64 } ;\n(\"v-ideographic\") => { $ crate :: ATOM_LOCALNAME__76_2D_69_64_65_6F_67_72_61_70_68_69_63 } ;\n(\"xlink:title\") => { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_74_69_74_6C_65 } ;\n(\"font-stretch\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_73_74_72_65_74_63_68 } ;\n(\"aria-labelledby\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6C_61_62_65_6C_6C_65_64_62_79 } ;\n(\"lighting-color\") => { $ crate :: ATOM_LOCALNAME__6C_69_67_68_74_69_6E_67_2D_63_6F_6C_6F_72 } ;\n(\"codebase\") => { $ crate :: ATOM_LOCALNAME__63_6F_64_65_62_61_73_65 } ;\n(\"formnovalidate\") => { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_6E_6F_76_61_6C_69_64_61_74_65 } ;\n(\"specularconstant\") => { $ crate :: ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_63_6F_6E_73_74_61_6E_74 } ;\n(\"aria-describedby\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_65_73_63_72_69_62_65_64_62_79 } ;\n(\"maligngroup\") => { $ crate :: ATOM_LOCALNAME__6D_61_6C_69_67_6E_67_72_6F_75_70 } ;\n(\"pathlength\") => { $ crate :: ATOM_LOCALNAME__70_61_74_68_6C_65_6E_67_74_68 } ;\n(\"emptyset\") => { $ crate :: ATOM_LOCALNAME__65_6D_70_74_79_73_65_74 } ;\n(\"contextmenu\") => { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_78_74_6D_65_6E_75 } ;\n(\"text-anchor\") => { $ crate :: ATOM_LOCALNAME__74_65_78_74_2D_61_6E_63_68_6F_72 } ;\n(\"arabic-form\") => { $ crate :: ATOM_LOCALNAME__61_72_61_62_69_63_2D_66_6F_72_6D } ;\n(\"onlosecapture\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6C_6F_73_65_63_61_70_74_75_72_65 } ;\n(\"onbeforeactivate\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_61_63_74_69_76_61_74_65 } ;\n(\"aria-activedescendant\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_61_63_74_69_76_65_64_65_73_63_65_6E_64_61_6E_74 } ;\n(\"conjugate\") => { $ crate :: ATOM_LOCALNAME__63_6F_6E_6A_75_67_61_74_65 } ;\n(\"aria-datatype\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_61_74_61_74_79_70_65 } ;\n(\"aria-description\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_65_73_63_72_69_70_74_69_6F_6E } ;\n(\"baseline\") => { $ crate :: ATOM_LOCALNAME__62_61_73_65_6C_69_6E_65 } ;\n(\"pointsatz\") => { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_7A } ;\n(\"mlabeledtr\") => { $ crate :: ATOM_LOCALNAME__6D_6C_61_62_65_6C_65_64_74_72 } ;\n(\"onsubmit\") => { $ crate :: ATOM_LOCALNAME__6F_6E_73_75_62_6D_69_74 } ;\n(\"aria-relevant\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_65_6C_65_76_61_6E_74 } ;\n(\"aria-haspopup\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_68_61_73_70_6F_70_75_70 } ;\n(\"ondragover\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_6F_76_65_72 } ;\n(\"notation\") => { $ crate :: ATOM_LOCALNAME__6E_6F_74_61_74_69_6F_6E } ;\n(\"scrolldelay\") => { $ crate :: ATOM_LOCALNAME__73_63_72_6F_6C_6C_64_65_6C_61_79 } ;\n(\"onbeforecut\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_63_75_74 } ;\n(\"visibility\") => { $ crate :: ATOM_LOCALNAME__76_69_73_69_62_69_6C_69_74_79 } ;\n(\"fepointlight\") => { $ crate :: ATOM_LOCALNAME__66_65_70_6F_69_6E_74_6C_69_67_68_74 } ;\n(\"v-mathematical\") => { $ crate :: ATOM_LOCALNAME__76_2D_6D_61_74_68_65_6D_61_74_69_63_61_6C } ;\n(\"fill-rule\") => { $ crate :: ATOM_LOCALNAME__66_69_6C_6C_2D_72_75_6C_65 } ;\n(\"aria-pressed\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_70_72_65_73_73_65_64 } ;\n(\"rowalign\") => { $ crate :: ATOM_LOCALNAME__72_6F_77_61_6C_69_67_6E } ;\n(\"onunload\") => { $ crate :: ATOM_LOCALNAME__6F_6E_75_6E_6C_6F_61_64 } ;\n(\"marker-start\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_73_74_61_72_74 } ;\n(\"notprsubset\") => { $ crate :: ATOM_LOCALNAME__6E_6F_74_70_72_73_75_62_73_65_74 } ;\n(\"selection\") => { $ crate :: ATOM_LOCALNAME__73_65_6C_65_63_74_69_6F_6E } ;\n(\"stroke-width\") => { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_77_69_64_74_68 } ;\n(\"prefetch\") => { $ crate :: ATOM_LOCALNAME__70_72_65_66_65_74_63_68 } ;\n(\"aria-posinset\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_70_6F_73_69_6E_73_65_74 } ;\n(\"markerwidth\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_77_69_64_74_68 } ;\n(\"onunhandledrejection\") => { $ crate :: ATOM_LOCALNAME__6F_6E_75_6E_68_61_6E_64_6C_65_64_72_65_6A_65_63_74_69_6F_6E } ;\n(\"femergenode\") => { $ crate :: ATOM_LOCALNAME__66_65_6D_65_72_67_65_6E_6F_64_65 } ;\n(\"partialdiff\") => { $ crate :: ATOM_LOCALNAME__70_61_72_74_69_61_6C_64_69_66_66 } ;\n(\"tabindex\") => { $ crate :: ATOM_LOCALNAME__74_61_62_69_6E_64_65_78 } ;\n(\"onmovestart\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_76_65_73_74_61_72_74 } ;\n(\"fedistantlight\") => { $ crate :: ATOM_LOCALNAME__66_65_64_69_73_74_61_6E_74_6C_69_67_68_74 } ;\n(\"aria-live\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6C_69_76_65 } ;\n(\"longdesc\") => { $ crate :: ATOM_LOCALNAME__6C_6F_6E_67_64_65_73_63 } ;\n(\"vectorproduct\") => { $ crate :: ATOM_LOCALNAME__76_65_63_74_6F_72_70_72_6F_64_75_63_74 } ;\n(\"baseProfile\") => { $ crate :: ATOM_LOCALNAME__62_61_73_65_50_72_6F_66_69_6C_65 } ;\n(\"columnspan\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_75_6D_6E_73_70_61_6E } ;\n(\"font-weight\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_77_65_69_67_68_74 } ;\n(\"seamless\") => { $ crate :: ATOM_LOCALNAME__73_65_61_6D_6C_65_73_73 } ;\n(\"aria-multiline\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6D_75_6C_74_69_6C_69_6E_65 } ;\n(\"stroke-linecap\") => { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6C_69_6E_65_63_61_70 } ;\n(\"columnalign\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_75_6D_6E_61_6C_69_67_6E } ;\n(\"markerUnits\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_55_6E_69_74_73 } ;\n(\"ideographic\") => { $ crate :: ATOM_LOCALNAME__69_64_65_6F_67_72_61_70_68_69_63 } ;\n(\"onpagereveal\") => { $ crate :: ATOM_LOCALNAME__6F_6E_70_61_67_65_72_65_76_65_61_6C } ;\n(\"contenteditable\") => { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_65_64_69_74_61_62_6C_65 } ;\n(\"progress\") => { $ crate :: ATOM_LOCALNAME__70_72_6F_67_72_65_73_73 } ;\n(\"onkeypress\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6B_65_79_70_72_65_73_73 } ;\n(\"actiontype\") => { $ crate :: ATOM_LOCALNAME__61_63_74_69_6F_6E_74_79_70_65 } ;\n(\"scalarproduct\") => { $ crate :: ATOM_LOCALNAME__73_63_61_6C_61_72_70_72_6F_64_75_63_74 } ;\n(\"plaintext\") => { $ crate :: ATOM_LOCALNAME__70_6C_61_69_6E_74_65_78_74 } ;\n(\"aria-controls\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6E_74_72_6F_6C_73 } ;\n(\"feConvolveMatrix\") => { $ crate :: ATOM_LOCALNAME__66_65_43_6F_6E_76_6F_6C_76_65_4D_61_74_72_69_78 } ;\n(\"zoomandpan\") => { $ crate :: ATOM_LOCALNAME__7A_6F_6F_6D_61_6E_64_70_61_6E } ;\n(\"clipPathUnits\") => { $ crate :: ATOM_LOCALNAME__63_6C_69_70_50_61_74_68_55_6E_69_74_73 } ;\n(\"repeat-min\") => { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_2D_6D_69_6E } ;\n(\"zoomAndPan\") => { $ crate :: ATOM_LOCALNAME__7A_6F_6F_6D_41_6E_64_50_61_6E } ;\n(\"stop-color\") => { $ crate :: ATOM_LOCALNAME__73_74_6F_70_2D_63_6F_6C_6F_72 } ;\n(\"keyPoints\") => { $ crate :: ATOM_LOCALNAME__6B_65_79_50_6F_69_6E_74_73 } ;\n(\"spellcheck\") => { $ crate :: ATOM_LOCALNAME__73_70_65_6C_6C_63_68_65_63_6B } ;\n(\"ononline\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6F_6E_6C_69_6E_65 } ;\n(\"onrejectionhandled\") => { $ crate :: ATOM_LOCALNAME__6F_6E_72_65_6A_65_63_74_69_6F_6E_68_61_6E_64_6C_65_64 } ;\n(\"feMorphology\") => { $ crate :: ATOM_LOCALNAME__66_65_4D_6F_72_70_68_6F_6C_6F_67_79 } ;\n(\"preserveAspectRatio\") => { $ crate :: ATOM_LOCALNAME__70_72_65_73_65_72_76_65_41_73_70_65_63_74_52_61_74_69_6F } ;\n(\"textcontent\") => { $ crate :: ATOM_LOCALNAME__74_65_78_74_63_6F_6E_74_65_6E_74 } ;\n(\"elevation\") => { $ crate :: ATOM_LOCALNAME__65_6C_65_76_61_74_69_6F_6E } ;\n(\"fecomposite\") => { $ crate :: ATOM_LOCALNAME__66_65_63_6F_6D_70_6F_73_69_74_65 } ;\n(\"pointer-events\") => { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_65_72_2D_65_76_65_6E_74_73 } ;\n(\"onbeforeupdate\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_75_70_64_61_74_65 } ;\n(\"statechange\") => { $ crate :: ATOM_LOCALNAME__73_74_61_74_65_63_68_61_6E_67_65 } ;\n(\"fontweight\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_77_65_69_67_68_74 } ;\n(\"rationals\") => { $ crate :: ATOM_LOCALNAME__72_61_74_69_6F_6E_61_6C_73 } ;\n(\"onfilterchange\") => { $ crate :: ATOM_LOCALNAME__6F_6E_66_69_6C_74_65_72_63_68_61_6E_67_65 } ;\n(\"basefont\") => { $ crate :: ATOM_LOCALNAME__62_61_73_65_66_6F_6E_74 } ;\n(\"maxlength\") => { $ crate :: ATOM_LOCALNAME__6D_61_78_6C_65_6E_67_74_68 } ;\n(\"property\") => { $ crate :: ATOM_LOCALNAME__70_72_6F_70_65_72_74_79 } ;\n(\"autoplay\") => { $ crate :: ATOM_LOCALNAME__61_75_74_6F_70_6C_61_79 } ;\n(\"accent-height\") => { $ crate :: ATOM_LOCALNAME__61_63_63_65_6E_74_2D_68_65_69_67_68_74 } ;\n(\"direction\") => { $ crate :: ATOM_LOCALNAME__64_69_72_65_63_74_69_6F_6E } ;\n(\"xml:base\") => { $ crate :: ATOM_LOCALNAME__78_6D_6C_3A_62_61_73_65 } ;\n(\"oninvalid\") => { $ crate :: ATOM_LOCALNAME__6F_6E_69_6E_76_61_6C_69_64 } ;\n(\"exportparts\") => { $ crate :: ATOM_LOCALNAME__65_78_70_6F_72_74_70_61_72_74_73 } ;\n(\"stroke-dashoffset\") => { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_64_61_73_68_6F_66_66_73_65_74 } ;\n(\"font-face-uri\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_75_72_69 } ;\n(\"systemlanguage\") => { $ crate :: ATOM_LOCALNAME__73_79_73_74_65_6D_6C_61_6E_67_75_61_67_65 } ;\n(\"irrelevant\") => { $ crate :: ATOM_LOCALNAME__69_72_72_65_6C_65_76_61_6E_74 } ;\n(\"veryverythickmathspace\") => { $ crate :: ATOM_LOCALNAME__76_65_72_79_76_65_72_79_74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 } ;\n(\"unselectable\") => { $ crate :: ATOM_LOCALNAME__75_6E_73_65_6C_65_63_74_61_62_6C_65 } ;\n(\"definition-src\") => { $ crate :: ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_2D_73_72_63 } ;\n(\"intersect\") => { $ crate :: ATOM_LOCALNAME__69_6E_74_65_72_73_65_63_74 } ;\n(\"aria-expanded\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_65_78_70_61_6E_64_65_64 } ;\n(\"eulergamma\") => { $ crate :: ATOM_LOCALNAME__65_75_6C_65_72_67_61_6D_6D_61 } ;\n(\"font-family\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_6D_69_6C_79 } ;\n(\"lineargradient\") => { $ crate :: ATOM_LOCALNAME__6C_69_6E_65_61_72_67_72_61_64_69_65_6E_74 } ;\n(\"mphantom\") => { $ crate :: ATOM_LOCALNAME__6D_70_68_61_6E_74_6F_6D } ;\n(\"columnlines\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_75_6D_6E_6C_69_6E_65_73 } ;\n(\"kernelunitlength\") => { $ crate :: ATOM_LOCALNAME__6B_65_72_6E_65_6C_75_6E_69_74_6C_65_6E_67_74_68 } ;\n(\"matrixrow\") => { $ crate :: ATOM_LOCALNAME__6D_61_74_72_69_78_72_6F_77 } ;\n(\"surfacescale\") => { $ crate :: ATOM_LOCALNAME__73_75_72_66_61_63_65_73_63_61_6C_65 } ;\n(\"aria-rowcount\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_63_6F_75_6E_74 } ;\n(\"maskcontentunits\") => { $ crate :: ATOM_LOCALNAME__6D_61_73_6B_63_6F_6E_74_65_6E_74_75_6E_69_74_73 } ;\n(\"font-face-src\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_73_72_63 } ;\n(\"annotation-xml\") => { $ crate :: ATOM_LOCALNAME__61_6E_6E_6F_74_61_74_69_6F_6E_2D_78_6D_6C } ;\n(\"aria-roledescription\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_6F_6C_65_64_65_73_63_72_69_70_74_69_6F_6E } ;\n(\"textPath\") => { $ crate :: ATOM_LOCALNAME__74_65_78_74_50_61_74_68 } ;\n(\"maskContentUnits\") => { $ crate :: ATOM_LOCALNAME__6D_61_73_6B_43_6F_6E_74_65_6E_74_55_6E_69_74_73 } ;\n(\"keyTimes\") => { $ crate :: ATOM_LOCALNAME__6B_65_79_54_69_6D_65_73 } ;\n(\"aria-colspan\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_73_70_61_6E } ;\n(\"frameborder\") => { $ crate :: ATOM_LOCALNAME__66_72_61_6D_65_62_6F_72_64_65_72 } ;\n(\"feSpecularLighting\") => { $ crate :: ATOM_LOCALNAME__66_65_53_70_65_63_75_6C_61_72_4C_69_67_68_74_69_6E_67 } ;\n(\"yChannelSelector\") => { $ crate :: ATOM_LOCALNAME__79_43_68_61_6E_6E_65_6C_53_65_6C_65_63_74_6F_72 } ;\n(\"translate\") => { $ crate :: ATOM_LOCALNAME__74_72_61_6E_73_6C_61_74_65 } ;\n(\"occurrence\") => { $ crate :: ATOM_LOCALNAME__6F_63_63_75_72_72_65_6E_63_65 } ;\n(\"mmultiscripts\") => { $ crate :: ATOM_LOCALNAME__6D_6D_75_6C_74_69_73_63_72_69_70_74_73 } ;\n(\"linearGradient\") => { $ crate :: ATOM_LOCALNAME__6C_69_6E_65_61_72_47_72_61_64_69_65_6E_74 } ;\n(\"foreignObject\") => { $ crate :: ATOM_LOCALNAME__66_6F_72_65_69_67_6E_4F_62_6A_65_63_74 } ;\n(\"font-face\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65 } ;\n(\"marginheight\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_67_69_6E_68_65_69_67_68_74 } ;\n(\"markerunits\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_75_6E_69_74_73 } ;\n(\"attributeType\") => { $ crate :: ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_54_79_70_65 } ;\n(\"dataformatas\") => { $ crate :: ATOM_LOCALNAME__64_61_74_61_66_6F_72_6D_61_74_61_73 } ;\n(\"baseprofile\") => { $ crate :: ATOM_LOCALNAME__62_61_73_65_70_72_6F_66_69_6C_65 } ;\n(\"naturalnumbers\") => { $ crate :: ATOM_LOCALNAME__6E_61_74_75_72_61_6C_6E_75_6D_62_65_72_73 } ;\n(\"aria-rowspan\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_73_70_61_6E } ;\n(\"ondatasetchanged\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_61_74_61_73_65_74_63_68_61_6E_67_65_64 } ;\n(\"readonly\") => { $ crate :: ATOM_LOCALNAME__72_65_61_64_6F_6E_6C_79 } ;\n(\"verythickmathspace\") => { $ crate :: ATOM_LOCALNAME__76_65_72_79_74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 } ;\n(\"background\") => { $ crate :: ATOM_LOCALNAME__62_61_63_6B_67_72_6F_75_6E_64 } ;\n(\"strikethrough-thickness\") => { $ crate :: ATOM_LOCALNAME__73_74_72_69_6B_65_74_68_72_6F_75_67_68_2D_74_68_69_63_6B_6E_65_73_73 } ;\n(\"accept-charset\") => { $ crate :: ATOM_LOCALNAME__61_63_63_65_70_74_2D_63_68_61_72_73_65_74 } ;\n(\"datetime\") => { $ crate :: ATOM_LOCALNAME__64_61_74_65_74_69_6D_65 } ;\n(\"strikethrough-position\") => { $ crate :: ATOM_LOCALNAME__73_74_72_69_6B_65_74_68_72_6F_75_67_68_2D_70_6F_73_69_74_69_6F_6E } ;\n(\"exponentiale\") => { $ crate :: ATOM_LOCALNAME__65_78_70_6F_6E_65_6E_74_69_61_6C_65 } ;\n(\"spreadMethod\") => { $ crate :: ATOM_LOCALNAME__73_70_72_65_61_64_4D_65_74_68_6F_64 } ;\n(\"kernelMatrix\") => { $ crate :: ATOM_LOCALNAME__6B_65_72_6E_65_6C_4D_61_74_72_69_78 } ;\n(\"fecolormatrix\") => { $ crate :: ATOM_LOCALNAME__66_65_63_6F_6C_6F_72_6D_61_74_72_69_78 } ;\n(\"onselectstart\") => { $ crate :: ATOM_LOCALNAME__6F_6E_73_65_6C_65_63_74_73_74_61_72_74 } ;\n(\"xlink:arcrole\") => { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_61_72_63_72_6F_6C_65 } ;\n(\"onfocusout\") => { $ crate :: ATOM_LOCALNAME__6F_6E_66_6F_63_75_73_6F_75_74 } ;\n(\"animateMotion\") => { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_4D_6F_74_69_6F_6E } ;\n(\"onrowenter\") => { $ crate :: ATOM_LOCALNAME__6F_6E_72_6F_77_65_6E_74_65_72 } ;\n(\"units-per-em\") => { $ crate :: ATOM_LOCALNAME__75_6E_69_74_73_2D_70_65_72_2D_65_6D } ;\n(\"stdDeviation\") => { $ crate :: ATOM_LOCALNAME__73_74_64_44_65_76_69_61_74_69_6F_6E } ;\n(\"startoffset\") => { $ crate :: ATOM_LOCALNAME__73_74_61_72_74_6F_66_66_73_65_74 } ;\n(\"ondatasetcomplete\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_61_74_61_73_65_74_63_6F_6D_70_6C_65_74_65 } ;\n(\"fontsize\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_73_69_7A_65 } ;\n(\"feColorMatrix\") => { $ crate :: ATOM_LOCALNAME__66_65_43_6F_6C_6F_72_4D_61_74_72_69_78 } ;\n(\"textarea\") => { $ crate :: ATOM_LOCALNAME__74_65_78_74_61_72_65_61 } ;\n(\"filterUnits\") => { $ crate :: ATOM_LOCALNAME__66_69_6C_74_65_72_55_6E_69_74_73 } ;\n(\"aria-modal\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6D_6F_64_61_6C } ;\n(\"aria-valuetext\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_74_65_78_74 } ;\n(\"itemscope\") => { $ crate :: ATOM_LOCALNAME__69_74_65_6D_73_63_6F_70_65 } ;\n(\"scriptsizemultiplier\") => { $ crate :: ATOM_LOCALNAME__73_63_72_69_70_74_73_69_7A_65_6D_75_6C_74_69_70_6C_69_65_72 } ;\n(\"formmethod\") => { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_6D_65_74_68_6F_64 } ;\n(\"accentunder\") => { $ crate :: ATOM_LOCALNAME__61_63_63_65_6E_74_75_6E_64_65_72 } ;\n(\"accesskey\") => { $ crate :: ATOM_LOCALNAME__61_63_63_65_73_73_6B_65_79 } ;\n(\"limitingConeAngle\") => { $ crate :: ATOM_LOCALNAME__6C_69_6D_69_74_69_6E_67_43_6F_6E_65_41_6E_67_6C_65 } ;\n(\"textContent\") => { $ crate :: ATOM_LOCALNAME__74_65_78_74_43_6F_6E_74_65_6E_74 } ;\n(\"inputmode\") => { $ crate :: ATOM_LOCALNAME__69_6E_70_75_74_6D_6F_64_65 } ;\n(\"onafterprint\") => { $ crate :: ATOM_LOCALNAME__6F_6E_61_66_74_65_72_70_72_69_6E_74 } ;\n(\"contentScriptType\") => { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_53_63_72_69_70_74_54_79_70_65 } ;\n(\"rowlines\") => { $ crate :: ATOM_LOCALNAME__72_6F_77_6C_69_6E_65_73 } ;\n(\"fontstyle\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_73_74_79_6C_65 } ;\n(\"displaystyle\") => { $ crate :: ATOM_LOCALNAME__64_69_73_70_6C_61_79_73_74_79_6C_65 } ;\n(\"onmouseleave\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6C_65_61_76_65 } ;\n(\"allowfullscreen\") => { $ crate :: ATOM_LOCALNAME__61_6C_6C_6F_77_66_75_6C_6C_73_63_72_65_65_6E } ;\n(\"symmetric\") => { $ crate :: ATOM_LOCALNAME__73_79_6D_6D_65_74_72_69_63 } ;\n(\"notanumber\") => { $ crate :: ATOM_LOCALNAME__6E_6F_74_61_6E_75_6D_62_65_72 } ;\n(\"lengthadjust\") => { $ crate :: ATOM_LOCALNAME__6C_65_6E_67_74_68_61_64_6A_75_73_74 } ;\n(\"startOffset\") => { $ crate :: ATOM_LOCALNAME__73_74_61_72_74_4F_66_66_73_65_74 } ;\n(\"cellspacing\") => { $ crate :: ATOM_LOCALNAME__63_65_6C_6C_73_70_61_63_69_6E_67 } ;\n(\"onformchange\") => { $ crate :: ATOM_LOCALNAME__6F_6E_66_6F_72_6D_63_68_61_6E_67_65 } ;\n(\"mprescripts\") => { $ crate :: ATOM_LOCALNAME__6D_70_72_65_73_63_72_69_70_74_73 } ;\n(\"fedropshadow\") => { $ crate :: ATOM_LOCALNAME__66_65_64_72_6F_70_73_68_61_64_6F_77 } ;\n(\"aria-braillelabel\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_62_72_61_69_6C_6C_65_6C_61_62_65_6C } ;\n(\"alignmentscope\") => { $ crate :: ATOM_LOCALNAME__61_6C_69_67_6E_6D_65_6E_74_73_63_6F_70_65 } ;\n(\"maskunits\") => { $ crate :: ATOM_LOCALNAME__6D_61_73_6B_75_6E_69_74_73 } ;\n(\"viewTarget\") => { $ crate :: ATOM_LOCALNAME__76_69_65_77_54_61_72_67_65_74 } ;\n(\"aria-valuemax\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6D_61_78 } ;\n(\"kernelUnitLength\") => { $ crate :: ATOM_LOCALNAME__6B_65_72_6E_65_6C_55_6E_69_74_4C_65_6E_67_74_68 } ;\n(\"fespotlight\") => { $ crate :: ATOM_LOCALNAME__66_65_73_70_6F_74_6C_69_67_68_74 } ;\n(\"variance\") => { $ crate :: ATOM_LOCALNAME__76_61_72_69_61_6E_63_65 } ;\n(\"quotient\") => { $ crate :: ATOM_LOCALNAME__71_75_6F_74_69_65_6E_74 } ;\n(\"momentabout\") => { $ crate :: ATOM_LOCALNAME__6D_6F_6D_65_6E_74_61_62_6F_75_74 } ;\n(\"pathLength\") => { $ crate :: ATOM_LOCALNAME__70_61_74_68_4C_65_6E_67_74_68 } ;\n(\"marginwidth\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_67_69_6E_77_69_64_74_68 } ;\n(\"markerHeight\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_48_65_69_67_68_74 } ;\n(\"aria-rowindex\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_69_6E_64_65_78 } ;\n(\"aria-grab\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_67_72_61_62 } ;\n(\"clippathunits\") => { $ crate :: ATOM_LOCALNAME__63_6C_69_70_70_61_74_68_75_6E_69_74_73 } ;\n(\"glyphref\") => { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68_72_65_66 } ;\n(\"minlength\") => { $ crate :: ATOM_LOCALNAME__6D_69_6E_6C_65_6E_67_74_68 } ;\n(\"v-alphabetic\") => { $ crate :: ATOM_LOCALNAME__76_2D_61_6C_70_68_61_62_65_74_69_63 } ;\n(\"aria-autocomplete\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_61_75_74_6F_63_6F_6D_70_6C_65_74_65 } ;\n(\"verythinmathspace\") => { $ crate :: ATOM_LOCALNAME__76_65_72_79_74_68_69_6E_6D_61_74_68_73_70_61_63_65 } ;\n(\"edgemode\") => { $ crate :: ATOM_LOCALNAME__65_64_67_65_6D_6F_64_65 } ;\n(\"radialgradient\") => { $ crate :: ATOM_LOCALNAME__72_61_64_69_61_6C_67_72_61_64_69_65_6E_74 } ;\n(\"onmouseover\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6F_76_65_72 } ;\n(\"feComposite\") => { $ crate :: ATOM_LOCALNAME__66_65_43_6F_6D_70_6F_73_69_74_65 } ;\n(\"scriptminsize\") => { $ crate :: ATOM_LOCALNAME__73_63_72_69_70_74_6D_69_6E_73_69_7A_65 } ;\n(\"aria-required\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_65_71_75_69_72_65_64 } ;\n(\"vert-origin-y\") => { $ crate :: ATOM_LOCALNAME__76_65_72_74_2D_6F_72_69_67_69_6E_2D_79 } ;\n(\"columnspacing\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_75_6D_6E_73_70_61_63_69_6E_67 } ;\n(\"domainofapplication\") => { $ crate :: ATOM_LOCALNAME__64_6F_6D_61_69_6E_6F_66_61_70_70_6C_69_63_61_74_69_6F_6E } ;\n(\"ychannelselector\") => { $ crate :: ATOM_LOCALNAME__79_63_68_61_6E_6E_65_6C_73_65_6C_65_63_74_6F_72 } ;\n(\"shadowrootmode\") => { $ crate :: ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_6D_6F_64_65 } ;\n(\"scriptlevel\") => { $ crate :: ATOM_LOCALNAME__73_63_72_69_70_74_6C_65_76_65_6C } ;\n(\"keytimes\") => { $ crate :: ATOM_LOCALNAME__6B_65_79_74_69_6D_65_73 } ;\n(\"ondragenter\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_65_6E_74_65_72 } ;\n(\"shadowrootdelegatesfocus\") => { $ crate :: ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_64_65_6C_65_67_61_74_65_73_66_6F_63_75_73 } ;\n(\"http-equiv\") => { $ crate :: ATOM_LOCALNAME__68_74_74_70_2D_65_71_75_69_76 } ;\n(\"patternContentUnits\") => { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_43_6F_6E_74_65_6E_74_55_6E_69_74_73 } ;\n(\"calcMode\") => { $ crate :: ATOM_LOCALNAME__63_61_6C_63_4D_6F_64_65 } ;\n(\"aria-flowto\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_66_6C_6F_77_74_6F } ;\n(\"mathvariant\") => { $ crate :: ATOM_LOCALNAME__6D_61_74_68_76_61_72_69_61_6E_74 } ;\n(\"multiple\") => { $ crate :: ATOM_LOCALNAME__6D_75_6C_74_69_70_6C_65 } ;\n(\"lowlimit\") => { $ crate :: ATOM_LOCALNAME__6C_6F_77_6C_69_6D_69_74 } ;\n(\"itemprop\") => { $ crate :: ATOM_LOCALNAME__69_74_65_6D_70_72_6F_70 } ;\n(\"diffuseConstant\") => { $ crate :: ATOM_LOCALNAME__64_69_66_66_75_73_65_43_6F_6E_73_74_61_6E_74 } ;\n(\"patternTransform\") => { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_54_72_61_6E_73_66_6F_72_6D } ;\n(\"onoffline\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6F_66_66_6C_69_6E_65 } ;\n(\"clipPath\") => { $ crate :: ATOM_LOCALNAME__63_6C_69_70_50_61_74_68 } ;\n(\"attributename\") => { $ crate :: ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_6E_61_6D_65 } ;\n(\"aria-errormessage\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_65_72_72_6F_72_6D_65_73_73_61_67_65 } ;\n(\"requiredFeatures\") => { $ crate :: ATOM_LOCALNAME__72_65_71_75_69_72_65_64_46_65_61_74_75_72_65_73 } ;\n(\"interval\") => { $ crate :: ATOM_LOCALNAME__69_6E_74_65_72_76_61_6C } ;\n(\"metadata\") => { $ crate :: ATOM_LOCALNAME__6D_65_74_61_64_61_74_61 } ;\n(\"feMergeNode\") => { $ crate :: ATOM_LOCALNAME__66_65_4D_65_72_67_65_4E_6F_64_65 } ;\n(\"polyline\") => { $ crate :: ATOM_LOCALNAME__70_6F_6C_79_6C_69_6E_65 } ;\n(\"v-hanging\") => { $ crate :: ATOM_LOCALNAME__76_2D_68_61_6E_67_69_6E_67 } ;\n(\"filterRes\") => { $ crate :: ATOM_LOCALNAME__66_69_6C_74_65_72_52_65_73 } ;\n(\"groupalign\") => { $ crate :: ATOM_LOCALNAME__67_72_6F_75_70_61_6C_69_67_6E } ;\n(\"fediffuselighting\") => { $ crate :: ATOM_LOCALNAME__66_65_64_69_66_66_75_73_65_6C_69_67_68_74_69_6E_67 } ;\n(\"filterres\") => { $ crate :: ATOM_LOCALNAME__66_69_6C_74_65_72_72_65_73 } ;\n(\"onrowsinserted\") => { $ crate :: ATOM_LOCALNAME__6F_6E_72_6F_77_73_69_6E_73_65_72_74_65_64 } ;\n(\"imaginaryi\") => { $ crate :: ATOM_LOCALNAME__69_6D_61_67_69_6E_61_72_79_69 } ;\n(\"onmouseenter\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_65_6E_74_65_72 } ;\n(\"onpageshow\") => { $ crate :: ATOM_LOCALNAME__6F_6E_70_61_67_65_73_68_6F_77 } ;\n(\"feOffset\") => { $ crate :: ATOM_LOCALNAME__66_65_4F_66_66_73_65_74 } ;\n(\"superscriptshift\") => { $ crate :: ATOM_LOCALNAME__73_75_70_65_72_73_63_72_69_70_74_73_68_69_66_74 } ;\n(\"requiredfeatures\") => { $ crate :: ATOM_LOCALNAME__72_65_71_75_69_72_65_64_66_65_61_74_75_72_65_73 } ;\n(\"nomodule\") => { $ crate :: ATOM_LOCALNAME__6E_6F_6D_6F_64_75_6C_65 } ;\n(\"missing-glyph\") => { $ crate :: ATOM_LOCALNAME__6D_69_73_73_69_6E_67_2D_67_6C_79_70_68 } ;\n(\"factorof\") => { $ crate :: ATOM_LOCALNAME__66_61_63_74_6F_72_6F_66 } ;\n(\"multicol\") => { $ crate :: ATOM_LOCALNAME__6D_75_6C_74_69_63_6F_6C } ;\n(\"fill-opacity\") => { $ crate :: ATOM_LOCALNAME__66_69_6C_6C_2D_6F_70_61_63_69_74_79 } ;\n(\"ondblclick\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_62_6C_63_6C_69_63_6B } ;\n(\"basefrequency\") => { $ crate :: ATOM_LOCALNAME__62_61_73_65_66_72_65_71_75_65_6E_63_79 } ;\n(\"onscroll\") => { $ crate :: ATOM_LOCALNAME__6F_6E_73_63_72_6F_6C_6C } ;\n(\"onerrorupdate\") => { $ crate :: ATOM_LOCALNAME__6F_6E_65_72_72_6F_72_75_70_64_61_74_65 } ;\n(\"aria-channel\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_68_61_6E_6E_65_6C } ;\n(\"aria-brailleroledescription\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_62_72_61_69_6C_6C_65_72_6F_6C_65_64_65_73_63_72_69_70_74_69_6F_6E } ;\n(\"keySplines\") => { $ crate :: ATOM_LOCALNAME__6B_65_79_53_70_6C_69_6E_65_73 } ;\n(\"onmouseout\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6F_75_74 } ;\n(\"separators\") => { $ crate :: ATOM_LOCALNAME__73_65_70_61_72_61_74_6F_72_73 } ;\n(\"rowspacing\") => { $ crate :: ATOM_LOCALNAME__72_6F_77_73_70_61_63_69_6E_67 } ;\n(\"fePointLight\") => { $ crate :: ATOM_LOCALNAME__66_65_50_6F_69_6E_74_4C_69_67_68_74 } ;\n(\"requiredExtensions\") => { $ crate :: ATOM_LOCALNAME__72_65_71_75_69_72_65_64_45_78_74_65_6E_73_69_6F_6E_73 } ;\n(\"aria-multiselectable\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6D_75_6C_74_69_73_65_6C_65_63_74_61_62_6C_65 } ;\n(\"onpagehide\") => { $ crate :: ATOM_LOCALNAME__6F_6E_70_61_67_65_68_69_64_65 } ;\n(\"viewtarget\") => { $ crate :: ATOM_LOCALNAME__76_69_65_77_74_61_72_67_65_74 } ;\n(\"onchange\") => { $ crate :: ATOM_LOCALNAME__6F_6E_63_68_61_6E_67_65 } ;\n(\"pointsAtY\") => { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_59 } ;\n(\"mathsize\") => { $ crate :: ATOM_LOCALNAME__6D_61_74_68_73_69_7A_65 } ;\n(\"baseFrequency\") => { $ crate :: ATOM_LOCALNAME__62_61_73_65_46_72_65_71_75_65_6E_63_79 } ;\n(\"itemtype\") => { $ crate :: ATOM_LOCALNAME__69_74_65_6D_74_79_70_65 } ;\n(\"factorial\") => { $ crate :: ATOM_LOCALNAME__66_61_63_74_6F_72_69_61_6C } ;\n(\"externalresourcesrequired\") => { $ crate :: ATOM_LOCALNAME__65_78_74_65_72_6E_61_6C_72_65_73_6F_75_72_63_65_73_72_65_71_75_69_72_65_64 } ;\n(\"textlength\") => { $ crate :: ATOM_LOCALNAME__74_65_78_74_6C_65_6E_67_74_68 } ;\n(\"selector\") => { $ crate :: ATOM_LOCALNAME__73_65_6C_65_63_74_6F_72 } ;\n(\"animatemotion\") => { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_6D_6F_74_69_6F_6E } ;\n(\"onmoveend\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_76_65_65_6E_64 } ;\n(\"enable-background\") => { $ crate :: ATOM_LOCALNAME__65_6E_61_62_6C_65_2D_62_61_63_6B_67_72_6F_75_6E_64 } ;\n(\"onforminput\") => { $ crate :: ATOM_LOCALNAME__6F_6E_66_6F_72_6D_69_6E_70_75_74 } ;\n(\"intercept\") => { $ crate :: ATOM_LOCALNAME__69_6E_74_65_72_63_65_70_74 } ;\n(\"feoffset\") => { $ crate :: ATOM_LOCALNAME__66_65_6F_66_66_73_65_74 } ;\n(\"exponent\") => { $ crate :: ATOM_LOCALNAME__65_78_70_6F_6E_65_6E_74 } ;\n(\"selected\") => { $ crate :: ATOM_LOCALNAME__73_65_6C_65_63_74_65_64 } ;\n(\"formenctype\") => { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_65_6E_63_74_79_70_65 } ;\n(\"panose-1\") => { $ crate :: ATOM_LOCALNAME__70_61_6E_6F_73_65_2D_31 } ;\n(\"altglyph\") => { $ crate :: ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68 } ;\n(\"pointsaty\") => { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_79 } ;\n(\"xlink:href\") => { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_68_72_65_66 } ;\n(\"onbefordeactivate\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_64_65_61_63_74_69_76_61_74_65 } ;\n(\"font-face-format\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_66_6F_72_6D_61_74 } ;\n(\"dominant-baseline\") => { $ crate :: ATOM_LOCALNAME__64_6F_6D_69_6E_61_6E_74_2D_62_61_73_65_6C_69_6E_65 } ;\n(\"integrity\") => { $ crate :: ATOM_LOCALNAME__69_6E_74_65_67_72_69_74_79 } ;\n(\"autofocus\") => { $ crate :: ATOM_LOCALNAME__61_75_74_6F_66_6F_63_75_73 } ;\n(\"text-decoration\") => { $ crate :: ATOM_LOCALNAME__74_65_78_74_2D_64_65_63_6F_72_61_74_69_6F_6E } ;\n(\"feDistantLight\") => { $ crate :: ATOM_LOCALNAME__66_65_44_69_73_74_61_6E_74_4C_69_67_68_74 } ;\n(\"aria-invalid\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_69_6E_76_61_6C_69_64 } ;\n(\"ondragstart\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_73_74_61_72_74 } ;\n(\"repeat-max\") => { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_2D_6D_61_78 } ;\n(\"operator\") => { $ crate :: ATOM_LOCALNAME__6F_70_65_72_61_74_6F_72 } ;\n(\"specularExponent\") => { $ crate :: ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_45_78_70_6F_6E_65_6E_74 } ;\n(\"aria-templateid\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_74_65_6D_70_6C_61_74_65_69_64 } ;\n(\"menclose\") => { $ crate :: ATOM_LOCALNAME__6D_65_6E_63_6C_6F_73_65 } ;\n(\"aria-details\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_65_74_61_69_6C_73 } ;\n(\"mathcolor\") => { $ crate :: ATOM_LOCALNAME__6D_61_74_68_63_6F_6C_6F_72 } ;\n(\"animation\") => { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_69_6F_6E } ;\n(\"fespecularlighting\") => { $ crate :: ATOM_LOCALNAME__66_65_73_70_65_63_75_6C_61_72_6C_69_67_68_74_69_6E_67 } ;\n(\"cellpadding\") => { $ crate :: ATOM_LOCALNAME__63_65_6C_6C_70_61_64_64_69_6E_67 } ;\n(\"mathematical\") => { $ crate :: ATOM_LOCALNAME__6D_61_74_68_65_6D_61_74_69_63_61_6C } ;\n(\"stitchtiles\") => { $ crate :: ATOM_LOCALNAME__73_74_69_74_63_68_74_69_6C_65_73 } ;\n(\"crossorigin\") => { $ crate :: ATOM_LOCALNAME__63_72_6F_73_73_6F_72_69_67_69_6E } ;\n(\"textpath\") => { $ crate :: ATOM_LOCALNAME__74_65_78_74_70_61_74_68 } ;\n(\"xlink:role\") => { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_72_6F_6C_65 } ;\n(\"outerproduct\") => { $ crate :: ATOM_LOCALNAME__6F_75_74_65_72_70_72_6F_64_75_63_74 } ;\n(\"hreflang\") => { $ crate :: ATOM_LOCALNAME__68_72_65_66_6C_61_6E_67 } ;\n(\"annotation\") => { $ crate :: ATOM_LOCALNAME__61_6E_6E_6F_74_61_74_69_6F_6E } ;\n(\"onmousemove\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6D_6F_76_65 } ;\n(\"stroke-linejoin\") => { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6C_69_6E_65_6A_6F_69_6E } ;\n(\"patternunits\") => { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_75_6E_69_74_73 } ;\n(\"ondataavailable\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_61_74_61_61_76_61_69_6C_61_62_6C_65 } ;\n(\"codetype\") => { $ crate :: ATOM_LOCALNAME__63_6F_64_65_74_79_70_65 } ;\n(\"animatetransform\") => { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_74_72_61_6E_73_66_6F_72_6D } ;\n(\"onreadystatechange\") => { $ crate :: ATOM_LOCALNAME__6F_6E_72_65_61_64_79_73_74_61_74_65_63_68_61_6E_67_65 } ;\n(\"infinity\") => { $ crate :: ATOM_LOCALNAME__69_6E_66_69_6E_69_74_79 } ;\n(\"surfaceScale\") => { $ crate :: ATOM_LOCALNAME__73_75_72_66_61_63_65_53_63_61_6C_65 } ;\n(\"onselect\") => { $ crate :: ATOM_LOCALNAME__6F_6E_73_65_6C_65_63_74 } ;\n(\"line-height\") => { $ crate :: ATOM_LOCALNAME__6C_69_6E_65_2D_68_65_69_67_68_74 } ;\n(\"onmessage\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_65_73_73_61_67_65 } ;\n(\"aria-colindextext\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_69_6E_64_65_78_74_65_78_74 } ;\n(\"\") => { $ crate :: ATOM_LOCALNAME_ } ;\n(\"separator\") => { $ crate :: ATOM_LOCALNAME__73_65_70_61_72_61_74_6F_72 } ;\n(\"altglyphitem\") => { $ crate :: ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68_69_74_65_6D } ;\n(\"horiz-origin-y\") => { $ crate :: ATOM_LOCALNAME__68_6F_72_69_7A_2D_6F_72_69_67_69_6E_2D_79 } ;\n(\"determinant\") => { $ crate :: ATOM_LOCALNAME__64_65_74_65_72_6D_69_6E_61_6E_74 } ;\n(\"condition\") => { $ crate :: ATOM_LOCALNAME__63_6F_6E_64_69_74_69_6F_6E } ;\n(\"xchannelselector\") => { $ crate :: ATOM_LOCALNAME__78_63_68_61_6E_6E_65_6C_73_65_6C_65_63_74_6F_72 } ;\n(\"repeatdur\") => { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_64_75_72 } ;\n(\"datalist\") => { $ crate :: ATOM_LOCALNAME__64_61_74_61_6C_69_73_74 } ;\n(\"cap-height\") => { $ crate :: ATOM_LOCALNAME__63_61_70_2D_68_65_69_67_68_74 } ;\n(\"equivalent\") => { $ crate :: ATOM_LOCALNAME__65_71_75_69_76_61_6C_65_6E_74 } ;\n(\"fieldset\") => { $ crate :: ATOM_LOCALNAME__66_69_65_6C_64_73_65_74 } ;\n(\"linebreak\") => { $ crate :: ATOM_LOCALNAME__6C_69_6E_65_62_72_65_61_6B } ;\n(\"gradienttransform\") => { $ crate :: ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_74_72_61_6E_73_66_6F_72_6D } ;\n(\"amplitude\") => { $ crate :: ATOM_LOCALNAME__61_6D_70_6C_69_74_75_64_65 } ;\n(\"aria-readonly\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_65_61_64_6F_6E_6C_79 } ;\n(\"feSpotLight\") => { $ crate :: ATOM_LOCALNAME__66_65_53_70_6F_74_4C_69_67_68_74 } ;\n(\"bevelled\") => { $ crate :: ATOM_LOCALNAME__62_65_76_65_6C_6C_65_64 } ;\n(\"fedisplacementmap\") => { $ crate :: ATOM_LOCALNAME__66_65_64_69_73_70_6C_61_63_65_6D_65_6E_74_6D_61_70 } ;\n(\"animateColor\") => { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_43_6F_6C_6F_72 } ;\n(\"aria-selected\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_73_65_6C_65_63_74_65_64 } ;\n(\"onmessageerror\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_65_73_73_61_67_65_65_72_72_6F_72 } ;\n(\"foreignobject\") => { $ crate :: ATOM_LOCALNAME__66_6F_72_65_69_67_6E_6F_62_6A_65_63_74 } ;\n(\"attributetype\") => { $ crate :: ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_74_79_70_65 } ;\n(\"prsubset\") => { $ crate :: ATOM_LOCALNAME__70_72_73_75_62_73_65_74 } ;\n(\"radiogroup\") => { $ crate :: ATOM_LOCALNAME__72_61_64_69_6F_67_72_6F_75_70 } ;\n(\"requiredextensions\") => { $ crate :: ATOM_LOCALNAME__72_65_71_75_69_72_65_64_65_78_74_65_6E_73_69_6F_6E_73 } ;\n(\"definitionURL\") => { $ crate :: ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_55_52_4C } ;\n(\"listener\") => { $ crate :: ATOM_LOCALNAME__6C_69_73_74_65_6E_65_72 } ;\n(\"colgroup\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_67_72_6F_75_70 } ;\n(\"diffuseconstant\") => { $ crate :: ATOM_LOCALNAME__64_69_66_66_75_73_65_63_6F_6E_73_74_61_6E_74 } ;\n(\"draggable\") => { $ crate :: ATOM_LOCALNAME__64_72_61_67_67_61_62_6C_65 } ;\n(\"columnwidth\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_75_6D_6E_77_69_64_74_68 } ;\n(\"markerheight\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_68_65_69_67_68_74 } ;\n(\"ondragend\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_65_6E_64 } ;\n(\"altGlyphDef\") => { $ crate :: ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68_44_65_66 } ;\n(\"xlink:show\") => { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_73_68_6F_77 } ;\n(\"pointsatx\") => { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_78 } ;\n(\"ondragdrop\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_64_72_6F_70 } ;\n(\"feGaussianBlur\") => { $ crate :: ATOM_LOCALNAME__66_65_47_61_75_73_73_69_61_6E_42_6C_75_72 } ;\n(\"unicode-range\") => { $ crate :: ATOM_LOCALNAME__75_6E_69_63_6F_64_65_2D_72_61_6E_67_65 } ;\n(\"onbounce\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_6F_75_6E_63_65 } ;\n(\"aria-valuemin\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6D_69_6E } ;\n(\"glyph-orientation-vertical\") => { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68_2D_6F_72_69_65_6E_74_61_74_69_6F_6E_2D_76_65_72_74_69_63_61_6C } ;\n(\"altGlyph\") => { $ crate :: ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68 } ;\n(\"thickmathspace\") => { $ crate :: ATOM_LOCALNAME__74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 } ;\n(\"formaction\") => { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_61_63_74_69_6F_6E } ;\n(\"aria-owns\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6F_77_6E_73 } ;\n(\"onbeforeeditfocus\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_65_64_69_74_66_6F_63_75_73 } ;\n(\"autocomplete\") => { $ crate :: ATOM_LOCALNAME__61_75_74_6F_63_6F_6D_70_6C_65_74_65 } ;\n(\"aria-placeholder\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_70_6C_61_63_65_68_6F_6C_64_65_72 } ;\n(\"filterunits\") => { $ crate :: ATOM_LOCALNAME__66_69_6C_74_65_72_75_6E_69_74_73 } ;\n(\"noscript\") => { $ crate :: ATOM_LOCALNAME__6E_6F_73_63_72_69_70_74 } ;\n(\"onrowexit\") => { $ crate :: ATOM_LOCALNAME__6F_6E_72_6F_77_65_78_69_74 } ;\n(\"mozbrowser\") => { $ crate :: ATOM_LOCALNAME__6D_6F_7A_62_72_6F_77_73_65_72 } ;\n(\"onfocusin\") => { $ crate :: ATOM_LOCALNAME__6F_6E_66_6F_63_75_73_69_6E } ;\n(\"onhashchange\") => { $ crate :: ATOM_LOCALNAME__6F_6E_68_61_73_68_63_68_61_6E_67_65 } ;\n(\"fontfamily\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_66_61_6D_69_6C_79 } ;\n(\"aria-keyshortcuts\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6B_65_79_73_68_6F_72_74_63_75_74_73 } ;\n(\"mediummathspace\") => { $ crate :: ATOM_LOCALNAME__6D_65_64_69_75_6D_6D_61_74_68_73_70_61_63_65 } ;\n(\"stroke-miterlimit\") => { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6D_69_74_65_72_6C_69_6D_69_74 } ;\n(\"valuetype\") => { $ crate :: ATOM_LOCALNAME__76_61_6C_75_65_74_79_70_65 } ;\n(\"clippath\") => { $ crate :: ATOM_LOCALNAME__63_6C_69_70_70_61_74_68 } ;\n(\"definitionurl\") => { $ crate :: ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_75_72_6C } ;\n(\"datatemplate\") => { $ crate :: ATOM_LOCALNAME__64_61_74_61_74_65_6D_70_6C_61_74_65 } ;\n(\"spreadmethod\") => { $ crate :: ATOM_LOCALNAME__73_70_72_65_61_64_6D_65_74_68_6F_64 } ;\n(\"munderover\") => { $ crate :: ATOM_LOCALNAME__6D_75_6E_64_65_72_6F_76_65_72 } ;\n(\"language\") => { $ crate :: ATOM_LOCALNAME__6C_61_6E_67_75_61_67_65 } ;\n(\"font-style\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_73_74_79_6C_65 } ;\n(\"glyphRef\") => { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68_52_65_66 } ;\n(\"marker-end\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_65_6E_64 } ;\n(\"piecewise\") => { $ crate :: ATOM_LOCALNAME__70_69_65_63_65_77_69_73_65 } ;\n(\"numOctaves\") => { $ crate :: ATOM_LOCALNAME__6E_75_6D_4F_63_74_61_76_65_73 } ;\n(\"placeholder\") => { $ crate :: ATOM_LOCALNAME__70_6C_61_63_65_68_6F_6C_64_65_72 } ;\n(\"frameset\") => { $ crate :: ATOM_LOCALNAME__66_72_61_6D_65_73_65_74 } ;\n(\"innertext\") => { $ crate :: ATOM_LOCALNAME__69_6E_6E_65_72_74_65_78_74 } ;\n(\"onkeydown\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6B_65_79_64_6F_77_6E } ;\n(\"download\") => { $ crate :: ATOM_LOCALNAME__64_6F_77_6E_6C_6F_61_64 } ;\n(\"onpropertychange\") => { $ crate :: ATOM_LOCALNAME__6F_6E_70_72_6F_70_65_72_74_79_63_68_61_6E_67_65 } ;\n(\"shadowrootserializable\") => { $ crate :: ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_73_65_72_69_61_6C_69_7A_61_62_6C_65 } ;\n(\"onpopstate\") => { $ crate :: ATOM_LOCALNAME__6F_6E_70_6F_70_73_74_61_74_65 } ;\n(\"animateTransform\") => { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_54_72_61_6E_73_66_6F_72_6D } ;\n(\"repeat-template\") => { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_2D_74_65_6D_70_6C_61_74_65 } ;\n(\"color-profile\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_6F_72_2D_70_72_6F_66_69_6C_65 } ;\n(\"kernelmatrix\") => { $ crate :: ATOM_LOCALNAME__6B_65_72_6E_65_6C_6D_61_74_72_69_78 } ;\n(\"xChannelSelector\") => { $ crate :: ATOM_LOCALNAME__78_43_68_61_6E_6E_65_6C_53_65_6C_65_63_74_6F_72 } ;\n(\"solidcolor\") => { $ crate :: ATOM_LOCALNAME__73_6F_6C_69_64_63_6F_6C_6F_72 } ;\n(\"gradientUnits\") => { $ crate :: ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_55_6E_69_74_73 } ;\n(\"horiz-origin-x\") => { $ crate :: ATOM_LOCALNAME__68_6F_72_69_7A_2D_6F_72_69_67_69_6E_2D_78 } ;\n(\"template\") => { $ crate :: ATOM_LOCALNAME__74_65_6D_70_6C_61_74_65 } ;\n(\"mathbackground\") => { $ crate :: ATOM_LOCALNAME__6D_61_74_68_62_61_63_6B_67_72_6F_75_6E_64 } ;\n(\"codomain\") => { $ crate :: ATOM_LOCALNAME__63_6F_64_6F_6D_61_69_6E } ;\n(\"semantics\") => { $ crate :: ATOM_LOCALNAME__73_65_6D_61_6E_74_69_63_73 } ;\n(\"preserveAlpha\") => { $ crate :: ATOM_LOCALNAME__70_72_65_73_65_72_76_65_41_6C_70_68_61 } ;\n(\"stddeviation\") => { $ crate :: ATOM_LOCALNAME__73_74_64_64_65_76_69_61_74_69_6F_6E } ;\n(\"fecomponenttransfer\") => { $ crate :: ATOM_LOCALNAME__66_65_63_6F_6D_70_6F_6E_65_6E_74_74_72_61_6E_73_66_65_72 } ;\n(\"patterncontentunits\") => { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_63_6F_6E_74_65_6E_74_75_6E_69_74_73 } ;\n(\"glyph-name\") => { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68_2D_6E_61_6D_65 } ;\n(\"subscriptshift\") => { $ crate :: ATOM_LOCALNAME__73_75_62_73_63_72_69_70_74_73_68_69_66_74 } ;\n(\"aria-current\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_75_72_72_65_6E_74 } ;\n(\"vert-adv-y\") => { $ crate :: ATOM_LOCALNAME__76_65_72_74_2D_61_64_76_2D_79 } ;\n(\"word-spacing\") => { $ crate :: ATOM_LOCALNAME__77_6F_72_64_2D_73_70_61_63_69_6E_67 } ;\n(\"alignment-baseline\") => { $ crate :: ATOM_LOCALNAME__61_6C_69_67_6E_6D_65_6E_74_2D_62_61_73_65_6C_69_6E_65 } ;\n(\"aria-busy\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_62_75_73_79 } ;\n(\"baseline-shift\") => { $ crate :: ATOM_LOCALNAME__62_61_73_65_6C_69_6E_65_2D_73_68_69_66_74 } ;\n(\"edgeMode\") => { $ crate :: ATOM_LOCALNAME__65_64_67_65_4D_6F_64_65 } ;\n(\"controls\") => { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_72_6F_6C_73 } ;\n(\"onbeforecopy\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_63_6F_70_79 } ;\n(\"feDropShadow\") => { $ crate :: ATOM_LOCALNAME__66_65_44_72_6F_70_53_68_61_64_6F_77 } ;\n(\"altglyphdef\") => { $ crate :: ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68_64_65_66 } ;\n(\"letter-spacing\") => { $ crate :: ATOM_LOCALNAME__6C_65_74_74_65_72_2D_73_70_61_63_69_6E_67 } ;\n(\"aria-level\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6C_65_76_65_6C } ;\n(\"onlanguagechange\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6C_61_6E_67_75_61_67_65_63_68_61_6E_67_65 } ;\n(\"xlink:type\") => { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_74_79_70_65 } ;\n(\"stitchTiles\") => { $ crate :: ATOM_LOCALNAME__73_74_69_74_63_68_54_69_6C_65_73 } ;\n(\"movablelimits\") => { $ crate :: ATOM_LOCALNAME__6D_6F_76_61_62_6C_65_6C_69_6D_69_74_73 } ;\n(\"feconvolvematrix\") => { $ crate :: ATOM_LOCALNAME__66_65_63_6F_6E_76_6F_6C_76_65_6D_61_74_72_69_78 } ;\n(\"xml:lang\") => { $ crate :: ATOM_LOCALNAME__78_6D_6C_3A_6C_61_6E_67 } ;\n(\"onrowsdelete\") => { $ crate :: ATOM_LOCALNAME__6F_6E_72_6F_77_73_64_65_6C_65_74_65 } ;\n(\"vert-origin-x\") => { $ crate :: ATOM_LOCALNAME__76_65_72_74_2D_6F_72_69_67_69_6E_2D_78 } ;\n(\"overflow\") => { $ crate :: ATOM_LOCALNAME__6F_76_65_72_66_6C_6F_77 } ;\n(\"novalidate\") => { $ crate :: ATOM_LOCALNAME__6E_6F_76_61_6C_69_64_61_74_65 } ;\n(\"feComponentTransfer\") => { $ crate :: ATOM_LOCALNAME__66_65_43_6F_6D_70_6F_6E_65_6E_74_54_72_61_6E_73_66_65_72 } ;\n(\"preserveaspectratio\") => { $ crate :: ATOM_LOCALNAME__70_72_65_73_65_72_76_65_61_73_70_65_63_74_72_61_74_69_6F } ;\n(\"specularexponent\") => { $ crate :: ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_65_78_70_6F_6E_65_6E_74 } ;\n(\"stroke-opacity\") => { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6F_70_61_63_69_74_79 } ;\n(\"aria-setsize\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_73_65_74_73_69_7A_65 } ;\n(\"image-rendering\") => { $ crate :: ATOM_LOCALNAME__69_6D_61_67_65_2D_72_65_6E_64_65_72_69_6E_67 } ;\n(\"primitiveunits\") => { $ crate :: ATOM_LOCALNAME__70_72_69_6D_69_74_69_76_65_75_6E_69_74_73 } ;\n(\"font-variant\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_76_61_72_69_61_6E_74 } ;\n(\"repeatDur\") => { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_44_75_72 } ;\n(\"ondeactivate\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_65_61_63_74_69_76_61_74_65 } ;\n(\"malignmark\") => { $ crate :: ATOM_LOCALNAME__6D_61_6C_69_67_6E_6D_61_72_6B } ;\n(\"formtarget\") => { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_74_61_72_67_65_74 } ;\n(\"limitingconeangle\") => { $ crate :: ATOM_LOCALNAME__6C_69_6D_69_74_69_6E_67_63_6F_6E_65_61_6E_67_6C_65 } ;\n(\"text-rendering\") => { $ crate :: ATOM_LOCALNAME__74_65_78_74_2D_72_65_6E_64_65_72_69_6E_67 } ;\n(\"innerText\") => { $ crate :: ATOM_LOCALNAME__69_6E_6E_65_72_54_65_78_74 } ;\n(\"feturbulence\") => { $ crate :: ATOM_LOCALNAME__66_65_74_75_72_62_75_6C_65_6E_63_65 } ;\n(\"fegaussianblur\") => { $ crate :: ATOM_LOCALNAME__66_65_67_61_75_73_73_69_61_6E_62_6C_75_72 } ;\n(\"onstorage\") => { $ crate :: ATOM_LOCALNAME__6F_6E_73_74_6F_72_61_67_65 } ;\n(\"imaginary\") => { $ crate :: ATOM_LOCALNAME__69_6D_61_67_69_6E_61_72_79 } ;\n(\"onmouseup\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_75_70 } ;\n(\"onafterupdate\") => { $ crate :: ATOM_LOCALNAME__6F_6E_61_66_74_65_72_75_70_64_61_74_65 } ;\n(\"attributeName\") => { $ crate :: ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_4E_61_6D_65 } ;\n(\"flood-opacity\") => { $ crate :: ATOM_LOCALNAME__66_6C_6F_6F_64_2D_6F_70_61_63_69_74_79 } ;\n(\"reversed\") => { $ crate :: ATOM_LOCALNAME__72_65_76_65_72_73_65_64 } ;\n(\"color-rendering\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_6F_72_2D_72_65_6E_64_65_72_69_6E_67 } ;\n(\"required\") => { $ crate :: ATOM_LOCALNAME__72_65_71_75_69_72_65_64 } ;\n(\"pointsAtZ\") => { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_5A } ;\n(\"tableValues\") => { $ crate :: ATOM_LOCALNAME__74_61_62_6C_65_56_61_6C_75_65_73 } ;\n(\"aria-colindex\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_69_6E_64_65_78 } ;\n(\"aria-checked\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_68_65_63_6B_65_64 } ;\n(\"cartesianproduct\") => { $ crate :: ATOM_LOCALNAME__63_61_72_74_65_73_69_61_6E_70_72_6F_64_75_63_74 } ;\n(\"complexes\") => { $ crate :: ATOM_LOCALNAME__63_6F_6D_70_6C_65_78_65_73 } ;\n(\"transform\") => { $ crate :: ATOM_LOCALNAME__74_72_61_6E_73_66_6F_72_6D } ;\n(\"aria-sort\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_73_6F_72_74 } ;\n(\"tablevalues\") => { $ crate :: ATOM_LOCALNAME__74_61_62_6C_65_76_61_6C_75_65_73 } ;\n(\"onresize\") => { $ crate :: ATOM_LOCALNAME__6F_6E_72_65_73_69_7A_65 } ;\n(\"oncontextmenu\") => { $ crate :: ATOM_LOCALNAME__6F_6E_63_6F_6E_74_65_78_74_6D_65_6E_75 } ;\n(\"font-size\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_73_69_7A_65 } ;\n(\"aria-dropeffect\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_72_6F_70_65_66_66_65_63_74 } ;\n(\"linethickness\") => { $ crate :: ATOM_LOCALNAME__6C_69_6E_65_74_68_69_63_6B_6E_65_73_73 } ;\n(\"integers\") => { $ crate :: ATOM_LOCALNAME__69_6E_74_65_67_65_72_73 } ;\n(\"font-face-name\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_6E_61_6D_65 } ;\n(\"divergence\") => { $ crate :: ATOM_LOCALNAME__64_69_76_65_72_67_65_6E_63_65 } ;\n(\"figcaption\") => { $ crate :: ATOM_LOCALNAME__66_69_67_63_61_70_74_69_6F_6E } ;\n(\"notsubset\") => { $ crate :: ATOM_LOCALNAME__6E_6F_74_73_75_62_73_65_74 } ;\n(\"color-interpolation\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_6F_72_2D_69_6E_74_65_72_70_6F_6C_61_74_69_6F_6E } ;\n(\"gradientunits\") => { $ crate :: ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_75_6E_69_74_73 } ;\n(\"horiz-adv-x\") => { $ crate :: ATOM_LOCALNAME__68_6F_72_69_7A_2D_61_64_76_2D_78 } ;\n(\"onpageswap\") => { $ crate :: ATOM_LOCALNAME__6F_6E_70_61_67_65_73_77_61_70 } ;\n(\"font-size-adjust\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_73_69_7A_65_2D_61_64_6A_75_73_74 } ;\n(\"onrepeat\") => { $ crate :: ATOM_LOCALNAME__6F_6E_72_65_70_65_61_74 } ;\n(\"specularConstant\") => { $ crate :: ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_43_6F_6E_73_74_61_6E_74 } ;\n(\"stretchy\") => { $ crate :: ATOM_LOCALNAME__73_74_72_65_74_63_68_79 } ;\n(\"encoding\") => { $ crate :: ATOM_LOCALNAME__65_6E_63_6F_64_69_6E_67 } ;\n(\"stroke-dasharray\") => { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_64_61_73_68_61_72_72_61_79 } ;\n(\"thinmathspace\") => { $ crate :: ATOM_LOCALNAME__74_68_69_6E_6D_61_74_68_73_70_61_63_65 } ;\n(\"aria-rowindextext\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_69_6E_64_65_78_74_65_78_74 } ;\n(\"shape-rendering\") => { $ crate :: ATOM_LOCALNAME__73_68_61_70_65_2D_72_65_6E_64_65_72_69_6E_67 } ;\n(\"aria-hidden\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_68_69_64_64_65_6E } ;\n(\"clip-rule\") => { $ crate :: ATOM_LOCALNAME__63_6C_69_70_2D_72_75_6C_65 } ;\n(\"decoding\") => { $ crate :: ATOM_LOCALNAME__64_65_63_6F_64_69_6E_67 } ;\n(\"systemLanguage\") => { $ crate :: ATOM_LOCALNAME__73_79_73_74_65_6D_4C_61_6E_67_75_61_67_65 } ;\n(\"feDiffuseLighting\") => { $ crate :: ATOM_LOCALNAME__66_65_44_69_66_66_75_73_65_4C_69_67_68_74_69_6E_67 } ;\n(\"feTurbulence\") => { $ crate :: ATOM_LOCALNAME__66_65_54_75_72_62_75_6C_65_6E_63_65 } ;\n(\"marker-mid\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_6D_69_64 } ;\n(\"underline-position\") => { $ crate :: ATOM_LOCALNAME__75_6E_64_65_72_6C_69_6E_65_2D_70_6F_73_69_74_69_6F_6E } ;\n(\"numoctaves\") => { $ crate :: ATOM_LOCALNAME__6E_75_6D_6F_63_74_61_76_65_73 } ;\n(\"autosubmit\") => { $ crate :: ATOM_LOCALNAME__61_75_74_6F_73_75_62_6D_69_74 } ;\n(\"underline-thickness\") => { $ crate :: ATOM_LOCALNAME__75_6E_64_65_72_6C_69_6E_65_2D_74_68_69_63_6B_6E_65_73_73 } ;\n(\"additive\") => { $ crate :: ATOM_LOCALNAME__61_64_64_69_74_69_76_65 } ;\n(\"aria-label\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6C_61_62_65_6C } ;\n(\"xlink:actuate\") => { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_61_63_74_75_61_74_65 } ;\n(\"onbeforeprint\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_70_72_69_6E_74 } ;\n(\"alphabetic\") => { $ crate :: ATOM_LOCALNAME__61_6C_70_68_61_62_65_74_69_63 } ;\n(\"preservealpha\") => { $ crate :: ATOM_LOCALNAME__70_72_65_73_65_72_76_65_61_6C_70_68_61 } ;\n(\"markerWidth\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_57_69_64_74_68 } ;\n(\"oncellchange\") => { $ crate :: ATOM_LOCALNAME__6F_6E_63_65_6C_6C_63_68_61_6E_67_65 } ;\n(\"gradientTransform\") => { $ crate :: ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_54_72_61_6E_73_66_6F_72_6D } ;\n(\"noframes\") => { $ crate :: ATOM_LOCALNAME__6E_6F_66_72_61_6D_65_73 } ;\n(\"rendering-intent\") => { $ crate :: ATOM_LOCALNAME__72_65_6E_64_65_72_69_6E_67_2D_69_6E_74_65_6E_74 } ;\n(\"aria-valuenow\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6E_6F_77 } ;\n(\"onbeforepaste\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_70_61_73_74_65 } ;\n(\"framespacing\") => { $ crate :: ATOM_LOCALNAME__66_72_61_6D_65_73_70_61_63_69_6E_67 } ;\n(\"aria-colcount\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_63_6F_75_6E_74 } ;\n(\"repeatCount\") => { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_43_6F_75_6E_74 } ;\n(\"clip-path\") => { $ crate :: ATOM_LOCALNAME__63_6C_69_70_2D_70_61_74_68 } ;\n(\"patterntransform\") => { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_74_72_61_6E_73_66_6F_72_6D } ;\n(\"xmlns:xlink\") => { $ crate :: ATOM_LOCALNAME__78_6D_6C_6E_73_3A_78_6C_69_6E_6B } ;\n(\"otherwise\") => { $ crate :: ATOM_LOCALNAME__6F_74_68_65_72_77_69_73_65 } ;\n(\"radialGradient\") => { $ crate :: ATOM_LOCALNAME__72_61_64_69_61_6C_47_72_61_64_69_65_6E_74 } ;\n(\"onactivate\") => { $ crate :: ATOM_LOCALNAME__6F_6E_61_63_74_69_76_61_74_65 } ;\n(\"lengthAdjust\") => { $ crate :: ATOM_LOCALNAME__6C_65_6E_67_74_68_41_64_6A_75_73_74 } ;\n(\"aria-atomic\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_61_74_6F_6D_69_63 } ;\n(\"stop-opacity\") => { $ crate :: ATOM_LOCALNAME__73_74_6F_70_2D_6F_70_61_63_69_74_79 } ;\n(\"keypoints\") => { $ crate :: ATOM_LOCALNAME__6B_65_79_70_6F_69_6E_74_73 } ;\n(\"disabled\") => { $ crate :: ATOM_LOCALNAME__64_69_73_61_62_6C_65_64 } ;\n(\"maskUnits\") => { $ crate :: ATOM_LOCALNAME__6D_61_73_6B_55_6E_69_74_73 } ;\n(\"textLength\") => { $ crate :: ATOM_LOCALNAME__74_65_78_74_4C_65_6E_67_74_68 } ;\n(\"repeat-start\") => { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_2D_73_74_61_72_74 } ;\n(\"overline-position\") => { $ crate :: ATOM_LOCALNAME__6F_76_65_72_6C_69_6E_65_2D_70_6F_73_69_74_69_6F_6E } ;\n(\"onbeforeunload\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_75_6E_6C_6F_61_64 } ;\n(\"primitiveUnits\") => { $ crate :: ATOM_LOCALNAME__70_72_69_6D_69_74_69_76_65_55_6E_69_74_73 } ;\n(\"controllerchange\") => { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_72_6F_6C_6C_65_72_63_68_61_6E_67_65 } ;\n(\"x-height\") => { $ crate :: ATOM_LOCALNAME__78_2D_68_65_69_67_68_74 } ;\n(\"onfinish\") => { $ crate :: ATOM_LOCALNAME__6F_6E_66_69_6E_69_73_68 } ;\n(\"scrolling\") => { $ crate :: ATOM_LOCALNAME__73_63_72_6F_6C_6C_69_6E_67 } ;\n(\"hidefocus\") => { $ crate :: ATOM_LOCALNAME__68_69_64_65_66_6F_63_75_73 } ;\n(\"onmousedown\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_64_6F_77_6E } ;\n(\"referrerpolicy\") => { $ crate :: ATOM_LOCALNAME__72_65_66_65_72_72_65_72_70_6F_6C_69_63_79 } ;\n(\"specification\") => { $ crate :: ATOM_LOCALNAME__73_70_65_63_69_66_69_63_61_74_69_6F_6E } ;\n(\"color-interpolation-filters\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_6F_72_2D_69_6E_74_65_72_70_6F_6C_61_74_69_6F_6E_2D_66_69_6C_74_65_72_73 } ;\n(\"glyph-orientation-horizontal\") => { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68_2D_6F_72_69_65_6E_74_61_74_69_6F_6E_2D_68_6F_72_69_7A_6F_6E_74_61_6C } ;\n(\"aria-disabled\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_69_73_61_62_6C_65_64 } ;\n(\"oncontrolselect\") => { $ crate :: ATOM_LOCALNAME__6F_6E_63_6F_6E_74_72_6F_6C_73_65_6C_65_63_74 } ;\n(\"veryverythinmathspace\") => { $ crate :: ATOM_LOCALNAME__76_65_72_79_76_65_72_79_74_68_69_6E_6D_61_74_68_73_70_61_63_65 } ;\n(\"optgroup\") => { $ crate :: ATOM_LOCALNAME__6F_70_74_67_72_6F_75_70 } ;\n(\"fetchpriority\") => { $ crate :: ATOM_LOCALNAME__66_65_74_63_68_70_72_69_6F_72_69_74_79 } ;\n(\"aria-secret\") => { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_73_65_63_72_65_74 } ;\n(\"orientation\") => { $ crate :: ATOM_LOCALNAME__6F_72_69_65_6E_74_61_74_69_6F_6E } ;\n(\"patternUnits\") => { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_55_6E_69_74_73 } ;\n(\"laplacian\") => { $ crate :: ATOM_LOCALNAME__6C_61_70_6C_61_63_69_61_6E } ;\n(\"transpose\") => { $ crate :: ATOM_LOCALNAME__74_72_61_6E_73_70_6F_73_65 } ;\n(\"*\") => { $ crate :: ATOM_LOCALNAME__2A } ;\n(\"a\") => { $ crate :: ATOM_LOCALNAME__61 } ;\n(\"abbr\") => { $ crate :: ATOM_LOCALNAME__61_62_62_72 } ;\n(\"abs\") => { $ crate :: ATOM_LOCALNAME__61_62_73 } ;\n(\"accent\") => { $ crate :: ATOM_LOCALNAME__61_63_63_65_6E_74 } ;\n(\"accept\") => { $ crate :: ATOM_LOCALNAME__61_63_63_65_70_74 } ;\n(\"acronym\") => { $ crate :: ATOM_LOCALNAME__61_63_72_6F_6E_79_6D } ;\n(\"action\") => { $ crate :: ATOM_LOCALNAME__61_63_74_69_6F_6E } ;\n(\"active\") => { $ crate :: ATOM_LOCALNAME__61_63_74_69_76_65 } ;\n(\"actuate\") => { $ crate :: ATOM_LOCALNAME__61_63_74_75_61_74_65 } ;\n(\"address\") => { $ crate :: ATOM_LOCALNAME__61_64_64_72_65_73_73 } ;\n(\"align\") => { $ crate :: ATOM_LOCALNAME__61_6C_69_67_6E } ;\n(\"alink\") => { $ crate :: ATOM_LOCALNAME__61_6C_69_6E_6B } ;\n(\"alt\") => { $ crate :: ATOM_LOCALNAME__61_6C_74 } ;\n(\"altimg\") => { $ crate :: ATOM_LOCALNAME__61_6C_74_69_6D_67 } ;\n(\"alttext\") => { $ crate :: ATOM_LOCALNAME__61_6C_74_74_65_78_74 } ;\n(\"and\") => { $ crate :: ATOM_LOCALNAME__61_6E_64 } ;\n(\"animate\") => { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65 } ;\n(\"applet\") => { $ crate :: ATOM_LOCALNAME__61_70_70_6C_65_74 } ;\n(\"apply\") => { $ crate :: ATOM_LOCALNAME__61_70_70_6C_79 } ;\n(\"approx\") => { $ crate :: ATOM_LOCALNAME__61_70_70_72_6F_78 } ;\n(\"arccos\") => { $ crate :: ATOM_LOCALNAME__61_72_63_63_6F_73 } ;\n(\"arccosh\") => { $ crate :: ATOM_LOCALNAME__61_72_63_63_6F_73_68 } ;\n(\"arccot\") => { $ crate :: ATOM_LOCALNAME__61_72_63_63_6F_74 } ;\n(\"arccoth\") => { $ crate :: ATOM_LOCALNAME__61_72_63_63_6F_74_68 } ;\n(\"arccsc\") => { $ crate :: ATOM_LOCALNAME__61_72_63_63_73_63 } ;\n(\"arccsch\") => { $ crate :: ATOM_LOCALNAME__61_72_63_63_73_63_68 } ;\n(\"archive\") => { $ crate :: ATOM_LOCALNAME__61_72_63_68_69_76_65 } ;\n(\"arcrole\") => { $ crate :: ATOM_LOCALNAME__61_72_63_72_6F_6C_65 } ;\n(\"arcsec\") => { $ crate :: ATOM_LOCALNAME__61_72_63_73_65_63 } ;\n(\"arcsech\") => { $ crate :: ATOM_LOCALNAME__61_72_63_73_65_63_68 } ;\n(\"arcsin\") => { $ crate :: ATOM_LOCALNAME__61_72_63_73_69_6E } ;\n(\"arcsinh\") => { $ crate :: ATOM_LOCALNAME__61_72_63_73_69_6E_68 } ;\n(\"arctan\") => { $ crate :: ATOM_LOCALNAME__61_72_63_74_61_6E } ;\n(\"arctanh\") => { $ crate :: ATOM_LOCALNAME__61_72_63_74_61_6E_68 } ;\n(\"area\") => { $ crate :: ATOM_LOCALNAME__61_72_65_61 } ;\n(\"arg\") => { $ crate :: ATOM_LOCALNAME__61_72_67 } ;\n(\"article\") => { $ crate :: ATOM_LOCALNAME__61_72_74_69_63_6C_65 } ;\n(\"as\") => { $ crate :: ATOM_LOCALNAME__61_73 } ;\n(\"ascent\") => { $ crate :: ATOM_LOCALNAME__61_73_63_65_6E_74 } ;\n(\"aside\") => { $ crate :: ATOM_LOCALNAME__61_73_69_64_65 } ;\n(\"async\") => { $ crate :: ATOM_LOCALNAME__61_73_79_6E_63 } ;\n(\"audio\") => { $ crate :: ATOM_LOCALNAME__61_75_64_69_6F } ;\n(\"axis\") => { $ crate :: ATOM_LOCALNAME__61_78_69_73 } ;\n(\"azimuth\") => { $ crate :: ATOM_LOCALNAME__61_7A_69_6D_75_74_68 } ;\n(\"b\") => { $ crate :: ATOM_LOCALNAME__62 } ;\n(\"base\") => { $ crate :: ATOM_LOCALNAME__62_61_73_65 } ;\n(\"bbox\") => { $ crate :: ATOM_LOCALNAME__62_62_6F_78 } ;\n(\"bdi\") => { $ crate :: ATOM_LOCALNAME__62_64_69 } ;\n(\"bdo\") => { $ crate :: ATOM_LOCALNAME__62_64_6F } ;\n(\"begin\") => { $ crate :: ATOM_LOCALNAME__62_65_67_69_6E } ;\n(\"bgcolor\") => { $ crate :: ATOM_LOCALNAME__62_67_63_6F_6C_6F_72 } ;\n(\"bgsound\") => { $ crate :: ATOM_LOCALNAME__62_67_73_6F_75_6E_64 } ;\n(\"bias\") => { $ crate :: ATOM_LOCALNAME__62_69_61_73 } ;\n(\"big\") => { $ crate :: ATOM_LOCALNAME__62_69_67 } ;\n(\"blink\") => { $ crate :: ATOM_LOCALNAME__62_6C_69_6E_6B } ;\n(\"body\") => { $ crate :: ATOM_LOCALNAME__62_6F_64_79 } ;\n(\"border\") => { $ crate :: ATOM_LOCALNAME__62_6F_72_64_65_72 } ;\n(\"br\") => { $ crate :: ATOM_LOCALNAME__62_72 } ;\n(\"button\") => { $ crate :: ATOM_LOCALNAME__62_75_74_74_6F_6E } ;\n(\"bvar\") => { $ crate :: ATOM_LOCALNAME__62_76_61_72 } ;\n(\"by\") => { $ crate :: ATOM_LOCALNAME__62_79 } ;\n(\"canvas\") => { $ crate :: ATOM_LOCALNAME__63_61_6E_76_61_73 } ;\n(\"caption\") => { $ crate :: ATOM_LOCALNAME__63_61_70_74_69_6F_6E } ;\n(\"card\") => { $ crate :: ATOM_LOCALNAME__63_61_72_64 } ;\n(\"ceiling\") => { $ crate :: ATOM_LOCALNAME__63_65_69_6C_69_6E_67 } ;\n(\"center\") => { $ crate :: ATOM_LOCALNAME__63_65_6E_74_65_72 } ;\n(\"char\") => { $ crate :: ATOM_LOCALNAME__63_68_61_72 } ;\n(\"charoff\") => { $ crate :: ATOM_LOCALNAME__63_68_61_72_6F_66_66 } ;\n(\"charset\") => { $ crate :: ATOM_LOCALNAME__63_68_61_72_73_65_74 } ;\n(\"checked\") => { $ crate :: ATOM_LOCALNAME__63_68_65_63_6B_65_64 } ;\n(\"ci\") => { $ crate :: ATOM_LOCALNAME__63_69 } ;\n(\"circle\") => { $ crate :: ATOM_LOCALNAME__63_69_72_63_6C_65 } ;\n(\"cite\") => { $ crate :: ATOM_LOCALNAME__63_69_74_65 } ;\n(\"class\") => { $ crate :: ATOM_LOCALNAME__63_6C_61_73_73 } ;\n(\"classid\") => { $ crate :: ATOM_LOCALNAME__63_6C_61_73_73_69_64 } ;\n(\"clear\") => { $ crate :: ATOM_LOCALNAME__63_6C_65_61_72 } ;\n(\"clip\") => { $ crate :: ATOM_LOCALNAME__63_6C_69_70 } ;\n(\"close\") => { $ crate :: ATOM_LOCALNAME__63_6C_6F_73_65 } ;\n(\"closure\") => { $ crate :: ATOM_LOCALNAME__63_6C_6F_73_75_72_65 } ;\n(\"cn\") => { $ crate :: ATOM_LOCALNAME__63_6E } ;\n(\"code\") => { $ crate :: ATOM_LOCALNAME__63_6F_64_65 } ;\n(\"col\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C } ;\n(\"color\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_6F_72 } ;\n(\"cols\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_73 } ;\n(\"colspan\") => { $ crate :: ATOM_LOCALNAME__63_6F_6C_73_70_61_6E } ;\n(\"compact\") => { $ crate :: ATOM_LOCALNAME__63_6F_6D_70_61_63_74 } ;\n(\"compose\") => { $ crate :: ATOM_LOCALNAME__63_6F_6D_70_6F_73_65 } ;\n(\"content\") => { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74 } ;\n(\"coords\") => { $ crate :: ATOM_LOCALNAME__63_6F_6F_72_64_73 } ;\n(\"cos\") => { $ crate :: ATOM_LOCALNAME__63_6F_73 } ;\n(\"cosh\") => { $ crate :: ATOM_LOCALNAME__63_6F_73_68 } ;\n(\"cot\") => { $ crate :: ATOM_LOCALNAME__63_6F_74 } ;\n(\"coth\") => { $ crate :: ATOM_LOCALNAME__63_6F_74_68 } ;\n(\"csc\") => { $ crate :: ATOM_LOCALNAME__63_73_63 } ;\n(\"csch\") => { $ crate :: ATOM_LOCALNAME__63_73_63_68 } ;\n(\"csymbol\") => { $ crate :: ATOM_LOCALNAME__63_73_79_6D_62_6F_6C } ;\n(\"curl\") => { $ crate :: ATOM_LOCALNAME__63_75_72_6C } ;\n(\"cursor\") => { $ crate :: ATOM_LOCALNAME__63_75_72_73_6F_72 } ;\n(\"cx\") => { $ crate :: ATOM_LOCALNAME__63_78 } ;\n(\"cy\") => { $ crate :: ATOM_LOCALNAME__63_79 } ;\n(\"d\") => { $ crate :: ATOM_LOCALNAME__64 } ;\n(\"data\") => { $ crate :: ATOM_LOCALNAME__64_61_74_61 } ;\n(\"datafld\") => { $ crate :: ATOM_LOCALNAME__64_61_74_61_66_6C_64 } ;\n(\"datasrc\") => { $ crate :: ATOM_LOCALNAME__64_61_74_61_73_72_63 } ;\n(\"dd\") => { $ crate :: ATOM_LOCALNAME__64_64 } ;\n(\"declare\") => { $ crate :: ATOM_LOCALNAME__64_65_63_6C_61_72_65 } ;\n(\"default\") => { $ crate :: ATOM_LOCALNAME__64_65_66_61_75_6C_74 } ;\n(\"defer\") => { $ crate :: ATOM_LOCALNAME__64_65_66_65_72 } ;\n(\"defs\") => { $ crate :: ATOM_LOCALNAME__64_65_66_73 } ;\n(\"degree\") => { $ crate :: ATOM_LOCALNAME__64_65_67_72_65_65 } ;\n(\"del\") => { $ crate :: ATOM_LOCALNAME__64_65_6C } ;\n(\"depth\") => { $ crate :: ATOM_LOCALNAME__64_65_70_74_68 } ;\n(\"desc\") => { $ crate :: ATOM_LOCALNAME__64_65_73_63 } ;\n(\"descent\") => { $ crate :: ATOM_LOCALNAME__64_65_73_63_65_6E_74 } ;\n(\"details\") => { $ crate :: ATOM_LOCALNAME__64_65_74_61_69_6C_73 } ;\n(\"dfn\") => { $ crate :: ATOM_LOCALNAME__64_66_6E } ;\n(\"dialog\") => { $ crate :: ATOM_LOCALNAME__64_69_61_6C_6F_67 } ;\n(\"diff\") => { $ crate :: ATOM_LOCALNAME__64_69_66_66 } ;\n(\"dir\") => { $ crate :: ATOM_LOCALNAME__64_69_72 } ;\n(\"dirname\") => { $ crate :: ATOM_LOCALNAME__64_69_72_6E_61_6D_65 } ;\n(\"discard\") => { $ crate :: ATOM_LOCALNAME__64_69_73_63_61_72_64 } ;\n(\"display\") => { $ crate :: ATOM_LOCALNAME__64_69_73_70_6C_61_79 } ;\n(\"div\") => { $ crate :: ATOM_LOCALNAME__64_69_76 } ;\n(\"divide\") => { $ crate :: ATOM_LOCALNAME__64_69_76_69_64_65 } ;\n(\"divisor\") => { $ crate :: ATOM_LOCALNAME__64_69_76_69_73_6F_72 } ;\n(\"dl\") => { $ crate :: ATOM_LOCALNAME__64_6C } ;\n(\"domain\") => { $ crate :: ATOM_LOCALNAME__64_6F_6D_61_69_6E } ;\n(\"dt\") => { $ crate :: ATOM_LOCALNAME__64_74 } ;\n(\"dur\") => { $ crate :: ATOM_LOCALNAME__64_75_72 } ;\n(\"dx\") => { $ crate :: ATOM_LOCALNAME__64_78 } ;\n(\"dy\") => { $ crate :: ATOM_LOCALNAME__64_79 } ;\n(\"edge\") => { $ crate :: ATOM_LOCALNAME__65_64_67_65 } ;\n(\"ellipse\") => { $ crate :: ATOM_LOCALNAME__65_6C_6C_69_70_73_65 } ;\n(\"em\") => { $ crate :: ATOM_LOCALNAME__65_6D } ;\n(\"embed\") => { $ crate :: ATOM_LOCALNAME__65_6D_62_65_64 } ;\n(\"enctype\") => { $ crate :: ATOM_LOCALNAME__65_6E_63_74_79_70_65 } ;\n(\"end\") => { $ crate :: ATOM_LOCALNAME__65_6E_64 } ;\n(\"eq\") => { $ crate :: ATOM_LOCALNAME__65_71 } ;\n(\"event\") => { $ crate :: ATOM_LOCALNAME__65_76_65_6E_74 } ;\n(\"exists\") => { $ crate :: ATOM_LOCALNAME__65_78_69_73_74_73 } ;\n(\"exp\") => { $ crate :: ATOM_LOCALNAME__65_78_70 } ;\n(\"face\") => { $ crate :: ATOM_LOCALNAME__66_61_63_65 } ;\n(\"false\") => { $ crate :: ATOM_LOCALNAME__66_61_6C_73_65 } ;\n(\"feBlend\") => { $ crate :: ATOM_LOCALNAME__66_65_42_6C_65_6E_64 } ;\n(\"feFlood\") => { $ crate :: ATOM_LOCALNAME__66_65_46_6C_6F_6F_64 } ;\n(\"feFuncA\") => { $ crate :: ATOM_LOCALNAME__66_65_46_75_6E_63_41 } ;\n(\"feFuncB\") => { $ crate :: ATOM_LOCALNAME__66_65_46_75_6E_63_42 } ;\n(\"feFuncG\") => { $ crate :: ATOM_LOCALNAME__66_65_46_75_6E_63_47 } ;\n(\"feFuncR\") => { $ crate :: ATOM_LOCALNAME__66_65_46_75_6E_63_52 } ;\n(\"feImage\") => { $ crate :: ATOM_LOCALNAME__66_65_49_6D_61_67_65 } ;\n(\"feMerge\") => { $ crate :: ATOM_LOCALNAME__66_65_4D_65_72_67_65 } ;\n(\"feTile\") => { $ crate :: ATOM_LOCALNAME__66_65_54_69_6C_65 } ;\n(\"feblend\") => { $ crate :: ATOM_LOCALNAME__66_65_62_6C_65_6E_64 } ;\n(\"feflood\") => { $ crate :: ATOM_LOCALNAME__66_65_66_6C_6F_6F_64 } ;\n(\"fefunca\") => { $ crate :: ATOM_LOCALNAME__66_65_66_75_6E_63_61 } ;\n(\"fefuncb\") => { $ crate :: ATOM_LOCALNAME__66_65_66_75_6E_63_62 } ;\n(\"fefuncg\") => { $ crate :: ATOM_LOCALNAME__66_65_66_75_6E_63_67 } ;\n(\"fefuncr\") => { $ crate :: ATOM_LOCALNAME__66_65_66_75_6E_63_72 } ;\n(\"feimage\") => { $ crate :: ATOM_LOCALNAME__66_65_69_6D_61_67_65 } ;\n(\"femerge\") => { $ crate :: ATOM_LOCALNAME__66_65_6D_65_72_67_65 } ;\n(\"fence\") => { $ crate :: ATOM_LOCALNAME__66_65_6E_63_65 } ;\n(\"fetch\") => { $ crate :: ATOM_LOCALNAME__66_65_74_63_68 } ;\n(\"fetile\") => { $ crate :: ATOM_LOCALNAME__66_65_74_69_6C_65 } ;\n(\"figure\") => { $ crate :: ATOM_LOCALNAME__66_69_67_75_72_65 } ;\n(\"fill\") => { $ crate :: ATOM_LOCALNAME__66_69_6C_6C } ;\n(\"filter\") => { $ crate :: ATOM_LOCALNAME__66_69_6C_74_65_72 } ;\n(\"floor\") => { $ crate :: ATOM_LOCALNAME__66_6C_6F_6F_72 } ;\n(\"fn\") => { $ crate :: ATOM_LOCALNAME__66_6E } ;\n(\"font\") => { $ crate :: ATOM_LOCALNAME__66_6F_6E_74 } ;\n(\"footer\") => { $ crate :: ATOM_LOCALNAME__66_6F_6F_74_65_72 } ;\n(\"for\") => { $ crate :: ATOM_LOCALNAME__66_6F_72 } ;\n(\"forall\") => { $ crate :: ATOM_LOCALNAME__66_6F_72_61_6C_6C } ;\n(\"form\") => { $ crate :: ATOM_LOCALNAME__66_6F_72_6D } ;\n(\"format\") => { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_61_74 } ;\n(\"frame\") => { $ crate :: ATOM_LOCALNAME__66_72_61_6D_65 } ;\n(\"from\") => { $ crate :: ATOM_LOCALNAME__66_72_6F_6D } ;\n(\"fx\") => { $ crate :: ATOM_LOCALNAME__66_78 } ;\n(\"fy\") => { $ crate :: ATOM_LOCALNAME__66_79 } ;\n(\"g\") => { $ crate :: ATOM_LOCALNAME__67 } ;\n(\"g1\") => { $ crate :: ATOM_LOCALNAME__67_31 } ;\n(\"g2\") => { $ crate :: ATOM_LOCALNAME__67_32 } ;\n(\"gcd\") => { $ crate :: ATOM_LOCALNAME__67_63_64 } ;\n(\"geq\") => { $ crate :: ATOM_LOCALNAME__67_65_71 } ;\n(\"glyph\") => { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68 } ;\n(\"grad\") => { $ crate :: ATOM_LOCALNAME__67_72_61_64 } ;\n(\"gt\") => { $ crate :: ATOM_LOCALNAME__67_74 } ;\n(\"h1\") => { $ crate :: ATOM_LOCALNAME__68_31 } ;\n(\"h2\") => { $ crate :: ATOM_LOCALNAME__68_32 } ;\n(\"h3\") => { $ crate :: ATOM_LOCALNAME__68_33 } ;\n(\"h4\") => { $ crate :: ATOM_LOCALNAME__68_34 } ;\n(\"h5\") => { $ crate :: ATOM_LOCALNAME__68_35 } ;\n(\"h6\") => { $ crate :: ATOM_LOCALNAME__68_36 } ;\n(\"handler\") => { $ crate :: ATOM_LOCALNAME__68_61_6E_64_6C_65_72 } ;\n(\"hanging\") => { $ crate :: ATOM_LOCALNAME__68_61_6E_67_69_6E_67 } ;\n(\"head\") => { $ crate :: ATOM_LOCALNAME__68_65_61_64 } ;\n(\"header\") => { $ crate :: ATOM_LOCALNAME__68_65_61_64_65_72 } ;\n(\"headers\") => { $ crate :: ATOM_LOCALNAME__68_65_61_64_65_72_73 } ;\n(\"height\") => { $ crate :: ATOM_LOCALNAME__68_65_69_67_68_74 } ;\n(\"hgroup\") => { $ crate :: ATOM_LOCALNAME__68_67_72_6F_75_70 } ;\n(\"hidden\") => { $ crate :: ATOM_LOCALNAME__68_69_64_64_65_6E } ;\n(\"high\") => { $ crate :: ATOM_LOCALNAME__68_69_67_68 } ;\n(\"hkern\") => { $ crate :: ATOM_LOCALNAME__68_6B_65_72_6E } ;\n(\"hr\") => { $ crate :: ATOM_LOCALNAME__68_72 } ;\n(\"href\") => { $ crate :: ATOM_LOCALNAME__68_72_65_66 } ;\n(\"hspace\") => { $ crate :: ATOM_LOCALNAME__68_73_70_61_63_65 } ;\n(\"html\") => { $ crate :: ATOM_LOCALNAME__68_74_6D_6C } ;\n(\"i\") => { $ crate :: ATOM_LOCALNAME__69 } ;\n(\"icon\") => { $ crate :: ATOM_LOCALNAME__69_63_6F_6E } ;\n(\"id\") => { $ crate :: ATOM_LOCALNAME__69_64 } ;\n(\"ident\") => { $ crate :: ATOM_LOCALNAME__69_64_65_6E_74 } ;\n(\"iframe\") => { $ crate :: ATOM_LOCALNAME__69_66_72_61_6D_65 } ;\n(\"image\") => { $ crate :: ATOM_LOCALNAME__69_6D_61_67_65 } ;\n(\"img\") => { $ crate :: ATOM_LOCALNAME__69_6D_67 } ;\n(\"implies\") => { $ crate :: ATOM_LOCALNAME__69_6D_70_6C_69_65_73 } ;\n(\"in\") => { $ crate :: ATOM_LOCALNAME__69_6E } ;\n(\"in2\") => { $ crate :: ATOM_LOCALNAME__69_6E_32 } ;\n(\"index\") => { $ crate :: ATOM_LOCALNAME__69_6E_64_65_78 } ;\n(\"input\") => { $ crate :: ATOM_LOCALNAME__69_6E_70_75_74 } ;\n(\"ins\") => { $ crate :: ATOM_LOCALNAME__69_6E_73 } ;\n(\"int\") => { $ crate :: ATOM_LOCALNAME__69_6E_74 } ;\n(\"inverse\") => { $ crate :: ATOM_LOCALNAME__69_6E_76_65_72_73_65 } ;\n(\"isindex\") => { $ crate :: ATOM_LOCALNAME__69_73_69_6E_64_65_78 } ;\n(\"ismap\") => { $ crate :: ATOM_LOCALNAME__69_73_6D_61_70 } ;\n(\"itemid\") => { $ crate :: ATOM_LOCALNAME__69_74_65_6D_69_64 } ;\n(\"itemref\") => { $ crate :: ATOM_LOCALNAME__69_74_65_6D_72_65_66 } ;\n(\"k\") => { $ crate :: ATOM_LOCALNAME__6B } ;\n(\"k1\") => { $ crate :: ATOM_LOCALNAME__6B_31 } ;\n(\"k2\") => { $ crate :: ATOM_LOCALNAME__6B_32 } ;\n(\"k3\") => { $ crate :: ATOM_LOCALNAME__6B_33 } ;\n(\"k4\") => { $ crate :: ATOM_LOCALNAME__6B_34 } ;\n(\"kbd\") => { $ crate :: ATOM_LOCALNAME__6B_62_64 } ;\n(\"kerning\") => { $ crate :: ATOM_LOCALNAME__6B_65_72_6E_69_6E_67 } ;\n(\"keygen\") => { $ crate :: ATOM_LOCALNAME__6B_65_79_67_65_6E } ;\n(\"kind\") => { $ crate :: ATOM_LOCALNAME__6B_69_6E_64 } ;\n(\"label\") => { $ crate :: ATOM_LOCALNAME__6C_61_62_65_6C } ;\n(\"lambda\") => { $ crate :: ATOM_LOCALNAME__6C_61_6D_62_64_61 } ;\n(\"lang\") => { $ crate :: ATOM_LOCALNAME__6C_61_6E_67 } ;\n(\"largeop\") => { $ crate :: ATOM_LOCALNAME__6C_61_72_67_65_6F_70 } ;\n(\"lcm\") => { $ crate :: ATOM_LOCALNAME__6C_63_6D } ;\n(\"legend\") => { $ crate :: ATOM_LOCALNAME__6C_65_67_65_6E_64 } ;\n(\"leq\") => { $ crate :: ATOM_LOCALNAME__6C_65_71 } ;\n(\"li\") => { $ crate :: ATOM_LOCALNAME__6C_69 } ;\n(\"limit\") => { $ crate :: ATOM_LOCALNAME__6C_69_6D_69_74 } ;\n(\"line\") => { $ crate :: ATOM_LOCALNAME__6C_69_6E_65 } ;\n(\"link\") => { $ crate :: ATOM_LOCALNAME__6C_69_6E_6B } ;\n(\"list\") => { $ crate :: ATOM_LOCALNAME__6C_69_73_74 } ;\n(\"listing\") => { $ crate :: ATOM_LOCALNAME__6C_69_73_74_69_6E_67 } ;\n(\"ln\") => { $ crate :: ATOM_LOCALNAME__6C_6E } ;\n(\"loading\") => { $ crate :: ATOM_LOCALNAME__6C_6F_61_64_69_6E_67 } ;\n(\"local\") => { $ crate :: ATOM_LOCALNAME__6C_6F_63_61_6C } ;\n(\"log\") => { $ crate :: ATOM_LOCALNAME__6C_6F_67 } ;\n(\"logbase\") => { $ crate :: ATOM_LOCALNAME__6C_6F_67_62_61_73_65 } ;\n(\"loop\") => { $ crate :: ATOM_LOCALNAME__6C_6F_6F_70 } ;\n(\"low\") => { $ crate :: ATOM_LOCALNAME__6C_6F_77 } ;\n(\"lowsrc\") => { $ crate :: ATOM_LOCALNAME__6C_6F_77_73_72_63 } ;\n(\"lquote\") => { $ crate :: ATOM_LOCALNAME__6C_71_75_6F_74_65 } ;\n(\"lspace\") => { $ crate :: ATOM_LOCALNAME__6C_73_70_61_63_65 } ;\n(\"lt\") => { $ crate :: ATOM_LOCALNAME__6C_74 } ;\n(\"macros\") => { $ crate :: ATOM_LOCALNAME__6D_61_63_72_6F_73 } ;\n(\"maction\") => { $ crate :: ATOM_LOCALNAME__6D_61_63_74_69_6F_6E } ;\n(\"main\") => { $ crate :: ATOM_LOCALNAME__6D_61_69_6E } ;\n(\"map\") => { $ crate :: ATOM_LOCALNAME__6D_61_70 } ;\n(\"mark\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_6B } ;\n(\"marker\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72 } ;\n(\"marquee\") => { $ crate :: ATOM_LOCALNAME__6D_61_72_71_75_65_65 } ;\n(\"mask\") => { $ crate :: ATOM_LOCALNAME__6D_61_73_6B } ;\n(\"math\") => { $ crate :: ATOM_LOCALNAME__6D_61_74_68 } ;\n(\"matrix\") => { $ crate :: ATOM_LOCALNAME__6D_61_74_72_69_78 } ;\n(\"max\") => { $ crate :: ATOM_LOCALNAME__6D_61_78 } ;\n(\"maxsize\") => { $ crate :: ATOM_LOCALNAME__6D_61_78_73_69_7A_65 } ;\n(\"mean\") => { $ crate :: ATOM_LOCALNAME__6D_65_61_6E } ;\n(\"media\") => { $ crate :: ATOM_LOCALNAME__6D_65_64_69_61 } ;\n(\"median\") => { $ crate :: ATOM_LOCALNAME__6D_65_64_69_61_6E } ;\n(\"menu\") => { $ crate :: ATOM_LOCALNAME__6D_65_6E_75 } ;\n(\"merror\") => { $ crate :: ATOM_LOCALNAME__6D_65_72_72_6F_72 } ;\n(\"meta\") => { $ crate :: ATOM_LOCALNAME__6D_65_74_61 } ;\n(\"meter\") => { $ crate :: ATOM_LOCALNAME__6D_65_74_65_72 } ;\n(\"method\") => { $ crate :: ATOM_LOCALNAME__6D_65_74_68_6F_64 } ;\n(\"mfenced\") => { $ crate :: ATOM_LOCALNAME__6D_66_65_6E_63_65_64 } ;\n(\"mfrac\") => { $ crate :: ATOM_LOCALNAME__6D_66_72_61_63 } ;\n(\"mglyph\") => { $ crate :: ATOM_LOCALNAME__6D_67_6C_79_70_68 } ;\n(\"mi\") => { $ crate :: ATOM_LOCALNAME__6D_69 } ;\n(\"min\") => { $ crate :: ATOM_LOCALNAME__6D_69_6E } ;\n(\"minsize\") => { $ crate :: ATOM_LOCALNAME__6D_69_6E_73_69_7A_65 } ;\n(\"minus\") => { $ crate :: ATOM_LOCALNAME__6D_69_6E_75_73 } ;\n(\"mn\") => { $ crate :: ATOM_LOCALNAME__6D_6E } ;\n(\"mo\") => { $ crate :: ATOM_LOCALNAME__6D_6F } ;\n(\"mode\") => { $ crate :: ATOM_LOCALNAME__6D_6F_64_65 } ;\n(\"moment\") => { $ crate :: ATOM_LOCALNAME__6D_6F_6D_65_6E_74 } ;\n(\"mover\") => { $ crate :: ATOM_LOCALNAME__6D_6F_76_65_72 } ;\n(\"mpadded\") => { $ crate :: ATOM_LOCALNAME__6D_70_61_64_64_65_64 } ;\n(\"mpath\") => { $ crate :: ATOM_LOCALNAME__6D_70_61_74_68 } ;\n(\"mroot\") => { $ crate :: ATOM_LOCALNAME__6D_72_6F_6F_74 } ;\n(\"mrow\") => { $ crate :: ATOM_LOCALNAME__6D_72_6F_77 } ;\n(\"ms\") => { $ crate :: ATOM_LOCALNAME__6D_73 } ;\n(\"mspace\") => { $ crate :: ATOM_LOCALNAME__6D_73_70_61_63_65 } ;\n(\"msqrt\") => { $ crate :: ATOM_LOCALNAME__6D_73_71_72_74 } ;\n(\"mstyle\") => { $ crate :: ATOM_LOCALNAME__6D_73_74_79_6C_65 } ;\n(\"msub\") => { $ crate :: ATOM_LOCALNAME__6D_73_75_62 } ;\n(\"msubsup\") => { $ crate :: ATOM_LOCALNAME__6D_73_75_62_73_75_70 } ;\n(\"msup\") => { $ crate :: ATOM_LOCALNAME__6D_73_75_70 } ;\n(\"mtable\") => { $ crate :: ATOM_LOCALNAME__6D_74_61_62_6C_65 } ;\n(\"mtd\") => { $ crate :: ATOM_LOCALNAME__6D_74_64 } ;\n(\"mtext\") => { $ crate :: ATOM_LOCALNAME__6D_74_65_78_74 } ;\n(\"mtr\") => { $ crate :: ATOM_LOCALNAME__6D_74_72 } ;\n(\"munder\") => { $ crate :: ATOM_LOCALNAME__6D_75_6E_64_65_72 } ;\n(\"muted\") => { $ crate :: ATOM_LOCALNAME__6D_75_74_65_64 } ;\n(\"name\") => { $ crate :: ATOM_LOCALNAME__6E_61_6D_65 } ;\n(\"nargs\") => { $ crate :: ATOM_LOCALNAME__6E_61_72_67_73 } ;\n(\"nav\") => { $ crate :: ATOM_LOCALNAME__6E_61_76 } ;\n(\"neq\") => { $ crate :: ATOM_LOCALNAME__6E_65_71 } ;\n(\"nest\") => { $ crate :: ATOM_LOCALNAME__6E_65_73_74 } ;\n(\"nextid\") => { $ crate :: ATOM_LOCALNAME__6E_65_78_74_69_64 } ;\n(\"nobr\") => { $ crate :: ATOM_LOCALNAME__6E_6F_62_72 } ;\n(\"noembed\") => { $ crate :: ATOM_LOCALNAME__6E_6F_65_6D_62_65_64 } ;\n(\"nohref\") => { $ crate :: ATOM_LOCALNAME__6E_6F_68_72_65_66 } ;\n(\"nonce\") => { $ crate :: ATOM_LOCALNAME__6E_6F_6E_63_65 } ;\n(\"none\") => { $ crate :: ATOM_LOCALNAME__6E_6F_6E_65 } ;\n(\"noshade\") => { $ crate :: ATOM_LOCALNAME__6E_6F_73_68_61_64_65 } ;\n(\"not\") => { $ crate :: ATOM_LOCALNAME__6E_6F_74 } ;\n(\"notin\") => { $ crate :: ATOM_LOCALNAME__6E_6F_74_69_6E } ;\n(\"nowrap\") => { $ crate :: ATOM_LOCALNAME__6E_6F_77_72_61_70 } ;\n(\"object\") => { $ crate :: ATOM_LOCALNAME__6F_62_6A_65_63_74 } ;\n(\"offset\") => { $ crate :: ATOM_LOCALNAME__6F_66_66_73_65_74 } ;\n(\"ol\") => { $ crate :: ATOM_LOCALNAME__6F_6C } ;\n(\"onabort\") => { $ crate :: ATOM_LOCALNAME__6F_6E_61_62_6F_72_74 } ;\n(\"onbegin\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_67_69_6E } ;\n(\"onblur\") => { $ crate :: ATOM_LOCALNAME__6F_6E_62_6C_75_72 } ;\n(\"onclick\") => { $ crate :: ATOM_LOCALNAME__6F_6E_63_6C_69_63_6B } ;\n(\"oncopy\") => { $ crate :: ATOM_LOCALNAME__6F_6E_63_6F_70_79 } ;\n(\"oncut\") => { $ crate :: ATOM_LOCALNAME__6F_6E_63_75_74 } ;\n(\"ondrag\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67 } ;\n(\"ondrop\") => { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_6F_70 } ;\n(\"onend\") => { $ crate :: ATOM_LOCALNAME__6F_6E_65_6E_64 } ;\n(\"onerror\") => { $ crate :: ATOM_LOCALNAME__6F_6E_65_72_72_6F_72 } ;\n(\"onfocus\") => { $ crate :: ATOM_LOCALNAME__6F_6E_66_6F_63_75_73 } ;\n(\"onhelp\") => { $ crate :: ATOM_LOCALNAME__6F_6E_68_65_6C_70 } ;\n(\"oninput\") => { $ crate :: ATOM_LOCALNAME__6F_6E_69_6E_70_75_74 } ;\n(\"onkeyup\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6B_65_79_75_70 } ;\n(\"onload\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6C_6F_61_64 } ;\n(\"onmove\") => { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_76_65 } ;\n(\"onpaste\") => { $ crate :: ATOM_LOCALNAME__6F_6E_70_61_73_74_65 } ;\n(\"onreset\") => { $ crate :: ATOM_LOCALNAME__6F_6E_72_65_73_65_74 } ;\n(\"onstart\") => { $ crate :: ATOM_LOCALNAME__6F_6E_73_74_61_72_74 } ;\n(\"onstop\") => { $ crate :: ATOM_LOCALNAME__6F_6E_73_74_6F_70 } ;\n(\"onzoom\") => { $ crate :: ATOM_LOCALNAME__6F_6E_7A_6F_6F_6D } ;\n(\"opacity\") => { $ crate :: ATOM_LOCALNAME__6F_70_61_63_69_74_79 } ;\n(\"open\") => { $ crate :: ATOM_LOCALNAME__6F_70_65_6E } ;\n(\"optimum\") => { $ crate :: ATOM_LOCALNAME__6F_70_74_69_6D_75_6D } ;\n(\"option\") => { $ crate :: ATOM_LOCALNAME__6F_70_74_69_6F_6E } ;\n(\"or\") => { $ crate :: ATOM_LOCALNAME__6F_72 } ;\n(\"order\") => { $ crate :: ATOM_LOCALNAME__6F_72_64_65_72 } ;\n(\"orient\") => { $ crate :: ATOM_LOCALNAME__6F_72_69_65_6E_74 } ;\n(\"origin\") => { $ crate :: ATOM_LOCALNAME__6F_72_69_67_69_6E } ;\n(\"other\") => { $ crate :: ATOM_LOCALNAME__6F_74_68_65_72 } ;\n(\"output\") => { $ crate :: ATOM_LOCALNAME__6F_75_74_70_75_74 } ;\n(\"p\") => { $ crate :: ATOM_LOCALNAME__70 } ;\n(\"param\") => { $ crate :: ATOM_LOCALNAME__70_61_72_61_6D } ;\n(\"parse\") => { $ crate :: ATOM_LOCALNAME__70_61_72_73_65 } ;\n(\"part\") => { $ crate :: ATOM_LOCALNAME__70_61_72_74 } ;\n(\"path\") => { $ crate :: ATOM_LOCALNAME__70_61_74_68 } ;\n(\"pattern\") => { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E } ;\n(\"pi\") => { $ crate :: ATOM_LOCALNAME__70_69 } ;\n(\"picture\") => { $ crate :: ATOM_LOCALNAME__70_69_63_74_75_72_65 } ;\n(\"piece\") => { $ crate :: ATOM_LOCALNAME__70_69_65_63_65 } ;\n(\"ping\") => { $ crate :: ATOM_LOCALNAME__70_69_6E_67 } ;\n(\"plus\") => { $ crate :: ATOM_LOCALNAME__70_6C_75_73 } ;\n(\"points\") => { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73 } ;\n(\"polygon\") => { $ crate :: ATOM_LOCALNAME__70_6F_6C_79_67_6F_6E } ;\n(\"poster\") => { $ crate :: ATOM_LOCALNAME__70_6F_73_74_65_72 } ;\n(\"power\") => { $ crate :: ATOM_LOCALNAME__70_6F_77_65_72 } ;\n(\"pre\") => { $ crate :: ATOM_LOCALNAME__70_72_65 } ;\n(\"preload\") => { $ crate :: ATOM_LOCALNAME__70_72_65_6C_6F_61_64 } ;\n(\"primes\") => { $ crate :: ATOM_LOCALNAME__70_72_69_6D_65_73 } ;\n(\"product\") => { $ crate :: ATOM_LOCALNAME__70_72_6F_64_75_63_74 } ;\n(\"profile\") => { $ crate :: ATOM_LOCALNAME__70_72_6F_66_69_6C_65 } ;\n(\"prompt\") => { $ crate :: ATOM_LOCALNAME__70_72_6F_6D_70_74 } ;\n(\"q\") => { $ crate :: ATOM_LOCALNAME__71 } ;\n(\"r\") => { $ crate :: ATOM_LOCALNAME__72 } ;\n(\"radius\") => { $ crate :: ATOM_LOCALNAME__72_61_64_69_75_73 } ;\n(\"rb\") => { $ crate :: ATOM_LOCALNAME__72_62 } ;\n(\"real\") => { $ crate :: ATOM_LOCALNAME__72_65_61_6C } ;\n(\"reals\") => { $ crate :: ATOM_LOCALNAME__72_65_61_6C_73 } ;\n(\"rect\") => { $ crate :: ATOM_LOCALNAME__72_65_63_74 } ;\n(\"refX\") => { $ crate :: ATOM_LOCALNAME__72_65_66_58 } ;\n(\"refY\") => { $ crate :: ATOM_LOCALNAME__72_65_66_59 } ;\n(\"refx\") => { $ crate :: ATOM_LOCALNAME__72_65_66_78 } ;\n(\"refy\") => { $ crate :: ATOM_LOCALNAME__72_65_66_79 } ;\n(\"rel\") => { $ crate :: ATOM_LOCALNAME__72_65_6C } ;\n(\"reln\") => { $ crate :: ATOM_LOCALNAME__72_65_6C_6E } ;\n(\"rem\") => { $ crate :: ATOM_LOCALNAME__72_65_6D } ;\n(\"repeat\") => { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74 } ;\n(\"replace\") => { $ crate :: ATOM_LOCALNAME__72_65_70_6C_61_63_65 } ;\n(\"restart\") => { $ crate :: ATOM_LOCALNAME__72_65_73_74_61_72_74 } ;\n(\"result\") => { $ crate :: ATOM_LOCALNAME__72_65_73_75_6C_74 } ;\n(\"rev\") => { $ crate :: ATOM_LOCALNAME__72_65_76 } ;\n(\"role\") => { $ crate :: ATOM_LOCALNAME__72_6F_6C_65 } ;\n(\"root\") => { $ crate :: ATOM_LOCALNAME__72_6F_6F_74 } ;\n(\"rotate\") => { $ crate :: ATOM_LOCALNAME__72_6F_74_61_74_65 } ;\n(\"rows\") => { $ crate :: ATOM_LOCALNAME__72_6F_77_73 } ;\n(\"rowspan\") => { $ crate :: ATOM_LOCALNAME__72_6F_77_73_70_61_6E } ;\n(\"rp\") => { $ crate :: ATOM_LOCALNAME__72_70 } ;\n(\"rquote\") => { $ crate :: ATOM_LOCALNAME__72_71_75_6F_74_65 } ;\n(\"rspace\") => { $ crate :: ATOM_LOCALNAME__72_73_70_61_63_65 } ;\n(\"rt\") => { $ crate :: ATOM_LOCALNAME__72_74 } ;\n(\"rtc\") => { $ crate :: ATOM_LOCALNAME__72_74_63 } ;\n(\"ruby\") => { $ crate :: ATOM_LOCALNAME__72_75_62_79 } ;\n(\"rule\") => { $ crate :: ATOM_LOCALNAME__72_75_6C_65 } ;\n(\"rules\") => { $ crate :: ATOM_LOCALNAME__72_75_6C_65_73 } ;\n(\"rx\") => { $ crate :: ATOM_LOCALNAME__72_78 } ;\n(\"ry\") => { $ crate :: ATOM_LOCALNAME__72_79 } ;\n(\"s\") => { $ crate :: ATOM_LOCALNAME__73 } ;\n(\"samp\") => { $ crate :: ATOM_LOCALNAME__73_61_6D_70 } ;\n(\"sandbox\") => { $ crate :: ATOM_LOCALNAME__73_61_6E_64_62_6F_78 } ;\n(\"scale\") => { $ crate :: ATOM_LOCALNAME__73_63_61_6C_65 } ;\n(\"scheme\") => { $ crate :: ATOM_LOCALNAME__73_63_68_65_6D_65 } ;\n(\"scope\") => { $ crate :: ATOM_LOCALNAME__73_63_6F_70_65 } ;\n(\"scoped\") => { $ crate :: ATOM_LOCALNAME__73_63_6F_70_65_64 } ;\n(\"script\") => { $ crate :: ATOM_LOCALNAME__73_63_72_69_70_74 } ;\n(\"sdev\") => { $ crate :: ATOM_LOCALNAME__73_64_65_76 } ;\n(\"search\") => { $ crate :: ATOM_LOCALNAME__73_65_61_72_63_68 } ;\n(\"sec\") => { $ crate :: ATOM_LOCALNAME__73_65_63 } ;\n(\"sech\") => { $ crate :: ATOM_LOCALNAME__73_65_63_68 } ;\n(\"section\") => { $ crate :: ATOM_LOCALNAME__73_65_63_74_69_6F_6E } ;\n(\"seed\") => { $ crate :: ATOM_LOCALNAME__73_65_65_64 } ;\n(\"select\") => { $ crate :: ATOM_LOCALNAME__73_65_6C_65_63_74 } ;\n(\"sep\") => { $ crate :: ATOM_LOCALNAME__73_65_70 } ;\n(\"set\") => { $ crate :: ATOM_LOCALNAME__73_65_74 } ;\n(\"setdiff\") => { $ crate :: ATOM_LOCALNAME__73_65_74_64_69_66_66 } ;\n(\"shape\") => { $ crate :: ATOM_LOCALNAME__73_68_61_70_65 } ;\n(\"show\") => { $ crate :: ATOM_LOCALNAME__73_68_6F_77 } ;\n(\"sin\") => { $ crate :: ATOM_LOCALNAME__73_69_6E } ;\n(\"sinh\") => { $ crate :: ATOM_LOCALNAME__73_69_6E_68 } ;\n(\"size\") => { $ crate :: ATOM_LOCALNAME__73_69_7A_65 } ;\n(\"sizes\") => { $ crate :: ATOM_LOCALNAME__73_69_7A_65_73 } ;\n(\"slope\") => { $ crate :: ATOM_LOCALNAME__73_6C_6F_70_65 } ;\n(\"slot\") => { $ crate :: ATOM_LOCALNAME__73_6C_6F_74 } ;\n(\"small\") => { $ crate :: ATOM_LOCALNAME__73_6D_61_6C_6C } ;\n(\"source\") => { $ crate :: ATOM_LOCALNAME__73_6F_75_72_63_65 } ;\n(\"space\") => { $ crate :: ATOM_LOCALNAME__73_70_61_63_65 } ;\n(\"spacer\") => { $ crate :: ATOM_LOCALNAME__73_70_61_63_65_72 } ;\n(\"spacing\") => { $ crate :: ATOM_LOCALNAME__73_70_61_63_69_6E_67 } ;\n(\"span\") => { $ crate :: ATOM_LOCALNAME__73_70_61_6E } ;\n(\"speed\") => { $ crate :: ATOM_LOCALNAME__73_70_65_65_64 } ;\n(\"src\") => { $ crate :: ATOM_LOCALNAME__73_72_63 } ;\n(\"srcdoc\") => { $ crate :: ATOM_LOCALNAME__73_72_63_64_6F_63 } ;\n(\"srclang\") => { $ crate :: ATOM_LOCALNAME__73_72_63_6C_61_6E_67 } ;\n(\"srcset\") => { $ crate :: ATOM_LOCALNAME__73_72_63_73_65_74 } ;\n(\"standby\") => { $ crate :: ATOM_LOCALNAME__73_74_61_6E_64_62_79 } ;\n(\"start\") => { $ crate :: ATOM_LOCALNAME__73_74_61_72_74 } ;\n(\"stemh\") => { $ crate :: ATOM_LOCALNAME__73_74_65_6D_68 } ;\n(\"stemv\") => { $ crate :: ATOM_LOCALNAME__73_74_65_6D_76 } ;\n(\"step\") => { $ crate :: ATOM_LOCALNAME__73_74_65_70 } ;\n(\"stop\") => { $ crate :: ATOM_LOCALNAME__73_74_6F_70 } ;\n(\"strike\") => { $ crate :: ATOM_LOCALNAME__73_74_72_69_6B_65 } ;\n(\"string\") => { $ crate :: ATOM_LOCALNAME__73_74_72_69_6E_67 } ;\n(\"stroke\") => { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65 } ;\n(\"strong\") => { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6E_67 } ;\n(\"style\") => { $ crate :: ATOM_LOCALNAME__73_74_79_6C_65 } ;\n(\"sub\") => { $ crate :: ATOM_LOCALNAME__73_75_62 } ;\n(\"subset\") => { $ crate :: ATOM_LOCALNAME__73_75_62_73_65_74 } ;\n(\"sum\") => { $ crate :: ATOM_LOCALNAME__73_75_6D } ;\n(\"summary\") => { $ crate :: ATOM_LOCALNAME__73_75_6D_6D_61_72_79 } ;\n(\"sup\") => { $ crate :: ATOM_LOCALNAME__73_75_70 } ;\n(\"svg\") => { $ crate :: ATOM_LOCALNAME__73_76_67 } ;\n(\"switch\") => { $ crate :: ATOM_LOCALNAME__73_77_69_74_63_68 } ;\n(\"symbol\") => { $ crate :: ATOM_LOCALNAME__73_79_6D_62_6F_6C } ;\n(\"table\") => { $ crate :: ATOM_LOCALNAME__74_61_62_6C_65 } ;\n(\"tan\") => { $ crate :: ATOM_LOCALNAME__74_61_6E } ;\n(\"tanh\") => { $ crate :: ATOM_LOCALNAME__74_61_6E_68 } ;\n(\"target\") => { $ crate :: ATOM_LOCALNAME__74_61_72_67_65_74 } ;\n(\"targetX\") => { $ crate :: ATOM_LOCALNAME__74_61_72_67_65_74_58 } ;\n(\"targetY\") => { $ crate :: ATOM_LOCALNAME__74_61_72_67_65_74_59 } ;\n(\"targetx\") => { $ crate :: ATOM_LOCALNAME__74_61_72_67_65_74_78 } ;\n(\"targety\") => { $ crate :: ATOM_LOCALNAME__74_61_72_67_65_74_79 } ;\n(\"tbody\") => { $ crate :: ATOM_LOCALNAME__74_62_6F_64_79 } ;\n(\"tbreak\") => { $ crate :: ATOM_LOCALNAME__74_62_72_65_61_6B } ;\n(\"td\") => { $ crate :: ATOM_LOCALNAME__74_64 } ;\n(\"tendsto\") => { $ crate :: ATOM_LOCALNAME__74_65_6E_64_73_74_6F } ;\n(\"text\") => { $ crate :: ATOM_LOCALNAME__74_65_78_74 } ;\n(\"tfoot\") => { $ crate :: ATOM_LOCALNAME__74_66_6F_6F_74 } ;\n(\"th\") => { $ crate :: ATOM_LOCALNAME__74_68 } ;\n(\"thead\") => { $ crate :: ATOM_LOCALNAME__74_68_65_61_64 } ;\n(\"time\") => { $ crate :: ATOM_LOCALNAME__74_69_6D_65 } ;\n(\"times\") => { $ crate :: ATOM_LOCALNAME__74_69_6D_65_73 } ;\n(\"title\") => { $ crate :: ATOM_LOCALNAME__74_69_74_6C_65 } ;\n(\"to\") => { $ crate :: ATOM_LOCALNAME__74_6F } ;\n(\"toggle\") => { $ crate :: ATOM_LOCALNAME__74_6F_67_67_6C_65 } ;\n(\"tr\") => { $ crate :: ATOM_LOCALNAME__74_72 } ;\n(\"track\") => { $ crate :: ATOM_LOCALNAME__74_72_61_63_6B } ;\n(\"tref\") => { $ crate :: ATOM_LOCALNAME__74_72_65_66 } ;\n(\"true\") => { $ crate :: ATOM_LOCALNAME__74_72_75_65 } ;\n(\"tspan\") => { $ crate :: ATOM_LOCALNAME__74_73_70_61_6E } ;\n(\"tt\") => { $ crate :: ATOM_LOCALNAME__74_74 } ;\n(\"type\") => { $ crate :: ATOM_LOCALNAME__74_79_70_65 } ;\n(\"u\") => { $ crate :: ATOM_LOCALNAME__75 } ;\n(\"u1\") => { $ crate :: ATOM_LOCALNAME__75_31 } ;\n(\"u2\") => { $ crate :: ATOM_LOCALNAME__75_32 } ;\n(\"ul\") => { $ crate :: ATOM_LOCALNAME__75_6C } ;\n(\"unicode\") => { $ crate :: ATOM_LOCALNAME__75_6E_69_63_6F_64_65 } ;\n(\"union\") => { $ crate :: ATOM_LOCALNAME__75_6E_69_6F_6E } ;\n(\"uplimit\") => { $ crate :: ATOM_LOCALNAME__75_70_6C_69_6D_69_74 } ;\n(\"use\") => { $ crate :: ATOM_LOCALNAME__75_73_65 } ;\n(\"usemap\") => { $ crate :: ATOM_LOCALNAME__75_73_65_6D_61_70 } ;\n(\"valign\") => { $ crate :: ATOM_LOCALNAME__76_61_6C_69_67_6E } ;\n(\"value\") => { $ crate :: ATOM_LOCALNAME__76_61_6C_75_65 } ;\n(\"values\") => { $ crate :: ATOM_LOCALNAME__76_61_6C_75_65_73 } ;\n(\"var\") => { $ crate :: ATOM_LOCALNAME__76_61_72 } ;\n(\"vector\") => { $ crate :: ATOM_LOCALNAME__76_65_63_74_6F_72 } ;\n(\"version\") => { $ crate :: ATOM_LOCALNAME__76_65_72_73_69_6F_6E } ;\n(\"video\") => { $ crate :: ATOM_LOCALNAME__76_69_64_65_6F } ;\n(\"view\") => { $ crate :: ATOM_LOCALNAME__76_69_65_77 } ;\n(\"viewBox\") => { $ crate :: ATOM_LOCALNAME__76_69_65_77_42_6F_78 } ;\n(\"viewbox\") => { $ crate :: ATOM_LOCALNAME__76_69_65_77_62_6F_78 } ;\n(\"vkern\") => { $ crate :: ATOM_LOCALNAME__76_6B_65_72_6E } ;\n(\"vlink\") => { $ crate :: ATOM_LOCALNAME__76_6C_69_6E_6B } ;\n(\"vspace\") => { $ crate :: ATOM_LOCALNAME__76_73_70_61_63_65 } ;\n(\"wbr\") => { $ crate :: ATOM_LOCALNAME__77_62_72 } ;\n(\"when\") => { $ crate :: ATOM_LOCALNAME__77_68_65_6E } ;\n(\"width\") => { $ crate :: ATOM_LOCALNAME__77_69_64_74_68 } ;\n(\"widths\") => { $ crate :: ATOM_LOCALNAME__77_69_64_74_68_73 } ;\n(\"wrap\") => { $ crate :: ATOM_LOCALNAME__77_72_61_70 } ;\n(\"x\") => { $ crate :: ATOM_LOCALNAME__78 } ;\n(\"x1\") => { $ crate :: ATOM_LOCALNAME__78_31 } ;\n(\"x2\") => { $ crate :: ATOM_LOCALNAME__78_32 } ;\n(\"xlink\") => { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B } ;\n(\"xmlns\") => { $ crate :: ATOM_LOCALNAME__78_6D_6C_6E_73 } ;\n(\"xmp\") => { $ crate :: ATOM_LOCALNAME__78_6D_70 } ;\n(\"xor\") => { $ crate :: ATOM_LOCALNAME__78_6F_72 } ;\n(\"xref\") => { $ crate :: ATOM_LOCALNAME__78_72_65_66 } ;\n(\"y\") => { $ crate :: ATOM_LOCALNAME__79 } ;\n(\"y1\") => { $ crate :: ATOM_LOCALNAME__79_31 } ;\n(\"y2\") => { $ crate :: ATOM_LOCALNAME__79_32 } ;\n(\"z\") => { $ crate :: ATOM_LOCALNAME__7A } ;\n}pub type Prefix = :: string_cache :: Atom < PrefixStaticSet > ;\n# [derive (PartialEq , Eq , PartialOrd , Ord)] pub struct PrefixStaticSet ;\nimpl :: string_cache :: StaticAtomSet for PrefixStaticSet { fn get () -> & 'static :: string_cache :: PhfStrSet { static SET : :: string_cache :: PhfStrSet = :: string_cache :: PhfStrSet { key : 12913932095322966823u64 , disps : & [(0u32 , 0u32)] , atoms : & [\"\"] , hashes : & [4082073077u32] } ;\n& SET } fn empty_string_index () -> u32 { 0u32 } } pub const ATOM_PREFIX_ : Prefix = Prefix :: pack_static (0u32) ;\npub const ATOM_PREFIX__2A : Prefix = Prefix :: pack_inline (10752u64 , 1u8) ;\npub const ATOM_PREFIX__68_74_6D_6C : Prefix = Prefix :: pack_inline (465692813312u64 , 4u8) ;\npub const ATOM_PREFIX__6D_61_74_68_6D_6C : Prefix = Prefix :: pack_inline (30519592881319168u64 , 6u8) ;\npub const ATOM_PREFIX__73_76_67 : Prefix = Prefix :: pack_inline (1735815936u64 , 3u8) ;\npub const ATOM_PREFIX__78_6C_69_6E_6B : Prefix = Prefix :: pack_inline (118121959290880u64 , 5u8) ;\npub const ATOM_PREFIX__78_6D_6C : Prefix = Prefix :: pack_inline (1819113472u64 , 3u8) ;\npub const ATOM_PREFIX__78_6D_6C_6E_73 : Prefix = Prefix :: pack_inline (126918102710272u64 , 5u8) ;\n# [doc = \"Takes a namespace prefix string and returns its key in a string cache.\"] # [macro_export] macro_rules ! namespace_prefix { (\"\") => { $ crate :: ATOM_PREFIX_ } ;\n(\"*\") => { $ crate :: ATOM_PREFIX__2A } ;\n(\"html\") => { $ crate :: ATOM_PREFIX__68_74_6D_6C } ;\n(\"mathml\") => { $ crate :: ATOM_PREFIX__6D_61_74_68_6D_6C } ;\n(\"svg\") => { $ crate :: ATOM_PREFIX__73_76_67 } ;\n(\"xlink\") => { $ crate :: ATOM_PREFIX__78_6C_69_6E_6B } ;\n(\"xml\") => { $ crate :: ATOM_PREFIX__78_6D_6C } ;\n(\"xmlns\") => { $ crate :: ATOM_PREFIX__78_6D_6C_6E_73 } ;\n}pub type Namespace = :: string_cache :: Atom < NamespaceStaticSet > ;\n# [derive (PartialEq , Eq , PartialOrd , Ord)] pub struct NamespaceStaticSet ;\nimpl :: string_cache :: StaticAtomSet for NamespaceStaticSet { fn get () -> & 'static :: string_cache :: PhfStrSet { static SET : :: string_cache :: PhfStrSet = :: string_cache :: PhfStrSet { key : 15467950696543387533u64 , disps : & [(1u32 , 0u32) , (1u32 , 4u32)] , atoms : & [\"http://www.w3.org/1999/xhtml\",\n\"http://www.w3.org/2000/svg\",\n\"http://www.w3.org/XML/1998/namespace\",\n\"http://www.w3.org/1998/Math/MathML\",\n\"http://www.w3.org/1999/xlink\",\n\"\",\n\"http://www.w3.org/2000/xmlns/\"] , hashes : & [1895391709u32 , 3069293938u32 , 2770585642u32 , 1216229735u32 , 2535599242u32 , 811901650u32 , 830072559u32] } ;\n& SET } fn empty_string_index () -> u32 { 5u32 } } pub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_39_2F_78_68_74_6D_6C : Namespace = Namespace :: pack_static (0u32) ;\npub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_32_30_30_30_2F_73_76_67 : Namespace = Namespace :: pack_static (1u32) ;\npub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_58_4D_4C_2F_31_39_39_38_2F_6E_61_6D_65_73_70_61_63_65 : Namespace = Namespace :: pack_static (2u32) ;\npub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_38_2F_4D_61_74_68_2F_4D_61_74_68_4D_4C : Namespace = Namespace :: pack_static (3u32) ;\npub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_39_2F_78_6C_69_6E_6B : Namespace = Namespace :: pack_static (4u32) ;\npub const ATOM_NAMESPACE_ : Namespace = Namespace :: pack_static (5u32) ;\npub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_32_30_30_30_2F_78_6D_6C_6E_73_2F : Namespace = Namespace :: pack_static (6u32) ;\npub const ATOM_NAMESPACE__2A : Namespace = Namespace :: pack_inline (10752u64 , 1u8) ;\n# [doc = \"Takes a namespace url string and returns its key in a string cache.\"] # [macro_export] macro_rules ! namespace_url { (\"http://www.w3.org/1999/xhtml\") => { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_39_2F_78_68_74_6D_6C } ;\n(\"http://www.w3.org/2000/svg\") => { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_32_30_30_30_2F_73_76_67 } ;\n(\"http://www.w3.org/XML/1998/namespace\") => { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_58_4D_4C_2F_31_39_39_38_2F_6E_61_6D_65_73_70_61_63_65 } ;\n(\"http://www.w3.org/1998/Math/MathML\") => { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_38_2F_4D_61_74_68_2F_4D_61_74_68_4D_4C } ;\n(\"http://www.w3.org/1999/xlink\") => { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_39_2F_78_6C_69_6E_6B } ;\n(\"\") => { $ crate :: ATOM_NAMESPACE_ } ;\n(\"http://www.w3.org/2000/xmlns/\") => { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_32_30_30_30_2F_78_6D_6C_6E_73_2F } ;\n(\"*\") => { $ crate :: ATOM_NAMESPACE__2A } ;\n}\n        /// Maps the input of [`namespace_prefix!`](macro.namespace_prefix.html) to \n        /// the output of [`namespace_url!`](macro.namespace_url.html).\n        ///\n        #[macro_export] macro_rules! ns {\n        \n() => { $crate::namespace_url!(\"\") };\n(*) => { $crate::namespace_url!(\"*\") };\n(html) => { $crate::namespace_url!(\"http://www.w3.org/1999/xhtml\") };\n(xml) => { $crate::namespace_url!(\"http://www.w3.org/XML/1998/namespace\") };\n(xmlns) => { $crate::namespace_url!(\"http://www.w3.org/2000/xmlns/\") };\n(xlink) => { $crate::namespace_url!(\"http://www.w3.org/1999/xlink\") };\n(svg) => { $crate::namespace_url!(\"http://www.w3.org/2000/svg\") };\n(mathml) => { $crate::namespace_url!(\"http://www.w3.org/1998/Math/MathML\") };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","analysis","humidor","target","debug","build","web_atoms-62bf835dc7c77f60","out","named_entities.rs"],"content":"\n/// A map of entity names to their codepoints. The second codepoint will\n/// be 0 if the entity contains a single codepoint. Entities have their preceding '&' removed.\n///\n/// # Examples\n///\n/// ```\n/// use web_atoms::NAMED_ENTITIES;\n///\n/// assert_eq!(NAMED_ENTITIES.get(\"gt;\").unwrap(), &(62, 0));\n/// ```\n\npub static NAMED_ENTITIES: Map<&'static str, (u32, u32)> = ::phf::Map {\n    key: 12913932095322966823,\n    disps: &[\n        (0, 147),\n        (0, 2),\n        (0, 236),\n        (0, 9),\n        (0, 66),\n        (0, 0),\n        (0, 38),\n        (0, 154),\n        (0, 0),\n        (0, 2),\n        (0, 777),\n        (0, 73),\n        (0, 65),\n        (0, 0),\n        (0, 1),\n        (0, 0),\n        (0, 24),\n        (0, 131),\n        (0, 0),\n        (0, 5),\n        (0, 0),\n        (0, 193),\n        (0, 25),\n        (0, 7),\n        (0, 442),\n        (0, 154),\n        (0, 240),\n        (0, 8),\n        (0, 6),\n        (0, 53),\n        (0, 17),\n        (0, 4),\n        (0, 35),\n        (0, 346),\n        (0, 91),\n        (0, 85),\n        (0, 89),\n        (0, 0),\n        (0, 787),\n        (0, 27),\n        (0, 1),\n        (0, 4),\n        (0, 7),\n        (0, 79),\n        (0, 7),\n        (0, 44),\n        (0, 82),\n        (0, 437),\n        (0, 4),\n        (0, 58),\n        (0, 3),\n        (0, 51),\n        (0, 1),\n        (0, 65),\n        (0, 249),\n        (0, 9),\n        (0, 1),\n        (0, 66),\n        (0, 30),\n        (0, 1244),\n        (0, 21),\n        (0, 1),\n        (0, 15),\n        (0, 510),\n        (0, 5),\n        (0, 0),\n        (0, 9),\n        (0, 0),\n        (0, 5),\n        (0, 86),\n        (0, 46),\n        (0, 118),\n        (0, 28),\n        (0, 30),\n        (0, 0),\n        (0, 0),\n        (0, 0),\n        (0, 1009),\n        (0, 1),\n        (0, 10),\n        (0, 259),\n        (0, 326),\n        (0, 29),\n        (0, 1),\n        (0, 0),\n        (0, 889),\n        (0, 9),\n        (0, 165),\n        (0, 73),\n        (0, 19),\n        (0, 69),\n        (0, 237),\n        (0, 6),\n        (0, 686),\n        (0, 2),\n        (0, 6),\n        (0, 83),\n        (0, 1955),\n        (0, 116),\n        (0, 161),\n        (0, 2),\n        (0, 88),\n        (0, 10),\n        (0, 1066),\n        (0, 1),\n        (0, 1414),\n        (0, 3),\n        (0, 57),\n        (0, 10),\n        (0, 9),\n        (0, 276),\n        (0, 464),\n        (0, 26),\n        (0, 458),\n        (0, 9),\n        (0, 699),\n        (0, 117),\n        (0, 1136),\n        (0, 26),\n        (0, 218),\n        (0, 31),\n        (0, 46),\n        (0, 261),\n        (0, 183),\n        (0, 319),\n        (0, 1553),\n        (0, 232),\n        (0, 1),\n        (0, 1279),\n        (0, 13),\n        (0, 8),\n        (0, 1),\n        (0, 1728),\n        (0, 600),\n        (0, 4),\n        (0, 584),\n        (0, 1),\n        (0, 146),\n        (0, 342),\n        (0, 1442),\n        (0, 223),\n        (0, 473),\n        (0, 230),\n        (0, 510),\n        (0, 19),\n        (0, 255),\n        (0, 90),\n        (0, 152),\n        (0, 1),\n        (0, 1773),\n        (0, 3333),\n        (0, 1),\n        (0, 1855),\n        (0, 30),\n        (0, 1151),\n        (0, 132),\n        (0, 980),\n        (0, 0),\n        (0, 11),\n        (0, 1021),\n        (0, 398),\n        (0, 2985),\n        (0, 936),\n        (0, 26),\n        (0, 1563),\n        (0, 15),\n        (0, 26),\n        (0, 2),\n        (0, 570),\n        (0, 868),\n        (0, 200),\n        (0, 302),\n        (0, 27),\n        (0, 686),\n        (0, 196),\n        (0, 16),\n        (0, 33),\n        (0, 19),\n        (0, 162),\n        (0, 11),\n        (0, 24),\n        (0, 8),\n        (0, 7),\n        (0, 83),\n        (0, 766),\n        (0, 8),\n        (0, 1639),\n        (0, 555),\n        (0, 191),\n        (0, 0),\n        (0, 4),\n        (0, 28),\n        (0, 32),\n        (0, 25),\n        (0, 564),\n        (0, 11),\n        (0, 3),\n        (0, 8),\n        (0, 25),\n        (0, 3),\n        (0, 225),\n        (0, 47),\n        (0, 274),\n        (0, 51),\n        (0, 60),\n        (0, 2),\n        (0, 142),\n        (0, 84),\n        (0, 1236),\n        (0, 374),\n        (0, 528),\n        (0, 742),\n        (0, 156),\n        (0, 1),\n        (0, 0),\n        (0, 148),\n        (0, 7),\n        (0, 1),\n        (0, 5),\n        (0, 174),\n        (0, 479),\n        (0, 465),\n        (0, 125),\n        (0, 94),\n        (0, 8),\n        (0, 63),\n        (0, 119),\n        (0, 844),\n        (0, 147),\n        (0, 1),\n        (0, 325),\n        (0, 224),\n        (0, 1),\n        (0, 757),\n        (0, 4),\n        (0, 2),\n        (0, 69),\n        (0, 17),\n        (0, 165),\n        (0, 118),\n        (0, 20),\n        (0, 88),\n        (0, 12),\n        (0, 184),\n        (0, 1),\n        (0, 349),\n        (0, 319),\n        (0, 22),\n        (0, 247),\n        (0, 15),\n        (0, 255),\n        (0, 0),\n        (0, 0),\n        (0, 4),\n        (0, 0),\n        (0, 1951),\n        (0, 18),\n        (0, 58),\n        (0, 620),\n        (0, 495),\n        (0, 5),\n        (0, 2),\n        (0, 1166),\n        (0, 2),\n        (0, 0),\n        (0, 29),\n        (0, 2),\n        (0, 51),\n        (0, 7),\n        (0, 1075),\n        (0, 48),\n        (0, 680),\n        (0, 2970),\n        (0, 1),\n        (0, 255),\n        (0, 16),\n        (0, 57),\n        (0, 13),\n        (0, 2),\n        (0, 364),\n        (0, 75),\n        (0, 1821),\n        (0, 1),\n        (0, 0),\n        (0, 2),\n        (0, 10),\n        (0, 372),\n        (0, 6),\n        (0, 123),\n        (0, 1753),\n        (0, 103),\n        (0, 2),\n        (0, 2),\n        (0, 441),\n        (0, 38),\n        (0, 3),\n        (0, 4),\n        (0, 79),\n        (0, 0),\n        (0, 1),\n        (0, 272),\n        (0, 3),\n        (0, 2),\n        (0, 0),\n        (0, 42),\n        (0, 522),\n        (0, 42),\n        (0, 462),\n        (0, 31),\n        (0, 3),\n        (0, 18),\n        (0, 88),\n        (0, 13),\n        (0, 47),\n        (0, 2005),\n        (0, 76),\n        (0, 88),\n        (0, 18),\n        (0, 36),\n        (0, 26),\n        (0, 29),\n        (0, 7),\n        (0, 47),\n        (0, 14),\n        (0, 46),\n        (0, 169),\n        (0, 205),\n        (0, 1),\n        (0, 100),\n        (0, 523),\n        (0, 93),\n        (0, 23),\n        (0, 6),\n        (0, 74),\n        (0, 1),\n        (0, 4),\n        (0, 4),\n        (0, 115),\n        (0, 6),\n        (0, 5511),\n        (0, 6),\n        (0, 815),\n        (0, 2),\n        (0, 123),\n        (0, 332),\n        (0, 693),\n        (0, 328),\n        (0, 752),\n        (0, 39),\n        (0, 13),\n        (0, 101),\n        (0, 0),\n        (0, 2031),\n        (0, 65),\n        (0, 842),\n        (0, 13),\n        (0, 5),\n        (0, 1114),\n        (0, 25),\n        (0, 167),\n        (0, 457),\n        (0, 828),\n        (0, 156),\n        (0, 2),\n        (0, 500),\n        (0, 0),\n        (0, 348),\n        (0, 0),\n        (0, 15),\n        (0, 4),\n        (0, 7),\n        (0, 0),\n        (0, 596),\n        (0, 531),\n        (0, 92),\n        (0, 79),\n        (0, 1122),\n        (0, 108),\n        (0, 44),\n        (0, 75),\n        (0, 225),\n        (0, 438),\n        (0, 37),\n        (0, 12),\n        (0, 1),\n        (0, 1095),\n        (0, 131),\n        (0, 36),\n        (0, 299),\n        (0, 784),\n        (0, 1576),\n        (0, 396),\n        (0, 6),\n        (0, 0),\n        (0, 219),\n        (0, 6),\n        (0, 233),\n        (0, 726),\n        (0, 22),\n        (0, 301),\n        (0, 28),\n        (0, 1363),\n        (0, 45),\n        (0, 1761),\n        (0, 0),\n        (0, 744),\n        (0, 25),\n        (0, 2),\n        (0, 10),\n        (0, 6),\n        (0, 2),\n        (0, 1417),\n        (0, 822),\n        (0, 101),\n        (0, 4),\n        (0, 60),\n        (0, 226),\n        (0, 28),\n        (0, 13),\n        (0, 598),\n        (0, 4),\n        (0, 75),\n        (0, 2555),\n        (0, 6),\n        (0, 0),\n        (0, 74),\n        (0, 256),\n        (0, 11),\n        (0, 0),\n        (0, 231),\n        (0, 0),\n        (0, 4),\n        (0, 409),\n        (0, 68),\n        (0, 19),\n        (0, 176),\n        (0, 1),\n        (0, 416),\n        (0, 903),\n        (0, 28),\n        (0, 4),\n        (0, 287),\n        (0, 1781),\n        (0, 2163),\n        (0, 19),\n        (0, 3),\n        (0, 173),\n        (0, 1),\n        (0, 195),\n        (0, 67),\n        (0, 14),\n        (0, 157),\n        (0, 1),\n        (0, 130),\n        (0, 44),\n        (0, 68),\n        (0, 19),\n        (0, 11),\n        (0, 14),\n        (0, 198),\n        (0, 2),\n        (0, 30),\n        (0, 457),\n        (0, 634),\n        (0, 365),\n        (0, 10),\n        (0, 68),\n        (0, 63),\n        (0, 850),\n        (0, 28),\n        (0, 57),\n        (0, 638),\n        (0, 33),\n        (0, 250),\n        (0, 228),\n        (0, 2719),\n        (0, 21),\n        (0, 1),\n        (0, 71),\n        (0, 0),\n        (0, 132),\n        (0, 551),\n        (0, 23),\n        (0, 0),\n        (0, 831),\n        (0, 3),\n        (0, 2),\n        (0, 0),\n        (0, 7),\n        (0, 4873),\n        (0, 285),\n        (0, 21),\n        (0, 232),\n        (0, 1950),\n        (0, 164),\n        (0, 33),\n        (0, 237),\n        (0, 0),\n        (0, 1755),\n        (0, 0),\n        (0, 1922),\n        (0, 80),\n        (0, 4),\n        (0, 319),\n        (0, 6),\n        (0, 65),\n        (0, 1664),\n        (0, 319),\n        (0, 176),\n        (0, 784),\n        (0, 4),\n        (0, 15),\n        (0, 15),\n        (0, 4),\n        (0, 1),\n        (0, 8),\n        (0, 1009),\n        (0, 123),\n        (0, 83),\n        (0, 0),\n        (0, 25),\n        (0, 66),\n        (0, 11),\n        (0, 18),\n        (0, 7),\n        (0, 136),\n        (0, 0),\n        (0, 6),\n        (0, 648),\n        (0, 424),\n        (0, 0),\n        (0, 100),\n        (0, 579),\n        (0, 74),\n        (0, 6),\n        (0, 188),\n        (0, 3469),\n        (0, 293),\n        (0, 1),\n        (0, 145),\n        (0, 87),\n        (0, 46),\n        (0, 1088),\n        (0, 45),\n        (0, 131),\n        (0, 2375),\n        (0, 87),\n        (0, 2),\n        (0, 0),\n        (0, 1),\n        (0, 0),\n        (0, 167),\n        (0, 29),\n        (0, 121),\n        (0, 249),\n        (0, 9),\n        (0, 260),\n        (0, 24),\n        (0, 143),\n        (0, 59),\n        (0, 321),\n        (0, 273),\n        (0, 86),\n        (0, 457),\n        (0, 1028),\n        (0, 1327),\n        (0, 1093),\n        (0, 53),\n        (0, 324),\n        (0, 17),\n        (0, 7),\n        (0, 441),\n        (0, 312),\n        (0, 701),\n        (0, 10),\n        (0, 473),\n        (0, 2398),\n        (0, 460),\n        (0, 0),\n        (0, 364),\n        (0, 394),\n        (0, 334),\n        (0, 156),\n        (0, 560),\n        (0, 366),\n        (0, 456),\n        (0, 609),\n        (0, 224),\n        (0, 51),\n        (0, 972),\n        (0, 48),\n        (0, 964),\n        (0, 0),\n        (0, 0),\n        (0, 1371),\n        (0, 104),\n        (0, 73),\n        (0, 463),\n        (0, 1),\n        (0, 24),\n        (0, 40),\n        (0, 2),\n        (0, 162),\n        (0, 1),\n        (0, 49),\n        (0, 0),\n        (0, 0),\n        (0, 352),\n        (0, 243),\n        (0, 679),\n        (0, 64),\n        (0, 473),\n        (0, 95),\n        (0, 215),\n        (0, 312),\n        (0, 141),\n        (0, 4),\n        (0, 1024),\n        (0, 0),\n        (0, 1211),\n        (0, 11),\n        (0, 8),\n        (0, 25),\n        (0, 194),\n        (0, 261),\n        (0, 25),\n        (0, 145),\n        (0, 69),\n        (0, 125),\n        (0, 1),\n        (0, 2),\n        (0, 198),\n        (0, 180),\n        (0, 350),\n        (0, 1),\n        (0, 36),\n        (0, 340),\n        (0, 29),\n        (0, 99),\n        (0, 868),\n        (0, 0),\n        (0, 542),\n        (0, 255),\n        (0, 273),\n        (0, 12),\n        (0, 975),\n        (0, 3664),\n        (0, 206),\n        (0, 240),\n        (0, 2),\n        (0, 838),\n        (0, 316),\n        (0, 107),\n        (0, 1),\n        (0, 53),\n        (0, 62),\n        (0, 3),\n        (0, 1500),\n        (0, 1009),\n        (0, 145),\n        (0, 243),\n        (0, 1418),\n        (0, 6),\n        (0, 51),\n        (0, 225),\n        (0, 85),\n        (0, 10),\n        (0, 1),\n        (0, 69),\n        (0, 36),\n        (0, 22),\n        (0, 3),\n        (0, 69),\n        (0, 8),\n        (0, 47),\n        (0, 1351),\n        (0, 283),\n        (0, 12),\n        (0, 226),\n        (0, 603),\n        (0, 62),\n        (0, 2070),\n        (0, 8),\n        (0, 2),\n        (0, 631),\n        (0, 276),\n        (0, 449),\n        (0, 115),\n        (0, 240),\n        (0, 27),\n        (0, 1106),\n        (0, 7),\n        (0, 1),\n        (0, 85),\n        (0, 0),\n        (0, 42),\n        (0, 7),\n        (0, 1),\n        (0, 1611),\n        (0, 17),\n        (0, 0),\n        (0, 1),\n        (0, 143),\n        (0, 257),\n        (0, 220),\n        (0, 397),\n        (0, 353),\n        (0, 1),\n        (0, 5),\n        (0, 935),\n        (0, 1),\n        (0, 9),\n        (0, 5),\n        (0, 53),\n        (0, 4),\n        (0, 2559),\n        (0, 37),\n        (0, 75),\n        (0, 540),\n        (0, 2488),\n        (0, 136),\n        (0, 236),\n        (0, 57),\n        (0, 12),\n        (0, 54),\n        (0, 14),\n        (0, 648),\n        (0, 4),\n        (0, 0),\n        (0, 9),\n        (0, 635),\n        (0, 0),\n        (0, 357),\n        (0, 115),\n        (0, 91),\n        (0, 7),\n        (0, 221),\n        (0, 892),\n        (0, 2383),\n        (0, 551),\n        (0, 29),\n        (0, 18),\n        (0, 1416),\n        (0, 2697),\n        (0, 69),\n        (0, 131),\n        (0, 97),\n        (0, 1671),\n        (0, 39),\n        (0, 0),\n        (0, 179),\n        (0, 0),\n        (0, 360),\n        (0, 144),\n        (0, 649),\n        (0, 1516),\n        (0, 163),\n        (0, 52),\n        (0, 5),\n        (0, 531),\n        (0, 1028),\n        (0, 121),\n        (0, 204),\n        (0, 364),\n        (0, 867),\n        (0, 123),\n        (0, 38),\n        (0, 8),\n        (0, 2334),\n        (0, 9),\n        (0, 34),\n        (0, 351),\n        (0, 166),\n        (0, 1),\n        (0, 902),\n        (0, 832),\n        (0, 117),\n        (0, 256),\n        (0, 41),\n        (0, 4846),\n        (0, 444),\n        (0, 225),\n        (0, 25),\n        (0, 0),\n        (0, 1963),\n        (0, 0),\n        (0, 1834),\n        (0, 90),\n        (0, 30),\n        (0, 1786),\n        (0, 6),\n        (0, 42),\n        (0, 284),\n        (0, 281),\n        (0, 192),\n        (0, 11),\n        (0, 187),\n        (0, 2),\n        (0, 7),\n        (0, 4),\n        (0, 33),\n        (0, 847),\n        (0, 1),\n        (0, 0),\n        (0, 223),\n        (0, 52),\n        (0, 979),\n        (0, 11),\n        (0, 6),\n        (0, 121),\n        (0, 337),\n        (0, 92),\n        (0, 49),\n        (0, 87),\n        (0, 596),\n        (0, 58),\n        (0, 0),\n        (0, 0),\n        (0, 30),\n        (0, 19),\n        (0, 4),\n        (0, 849),\n        (0, 0),\n        (0, 12),\n        (0, 145),\n        (0, 857),\n        (0, 1),\n        (0, 177),\n        (0, 45),\n        (0, 3),\n        (0, 18),\n        (0, 5),\n        (0, 59),\n        (0, 1254),\n        (0, 335),\n        (0, 16),\n        (0, 26),\n        (0, 15),\n        (0, 1733),\n        (0, 1),\n        (0, 0),\n        (0, 1006),\n        (0, 1001),\n        (0, 219),\n        (0, 12),\n        (0, 271),\n        (0, 5),\n        (0, 34),\n        (0, 7),\n        (0, 11),\n        (0, 1),\n        (0, 12),\n        (0, 102),\n        (0, 31),\n        (0, 65),\n        (0, 408),\n        (0, 12),\n        (0, 2),\n        (0, 88),\n        (0, 3280),\n        (0, 93),\n        (0, 4546),\n        (0, 1530),\n        (0, 14),\n        (0, 26),\n        (0, 34),\n        (0, 4),\n        (0, 1),\n        (0, 279),\n        (0, 696),\n        (0, 64),\n        (0, 221),\n        (0, 39),\n        (0, 71),\n        (0, 81),\n        (0, 0),\n        (0, 15),\n        (0, 210),\n        (0, 72),\n        (0, 696),\n        (0, 2337),\n        (0, 954),\n        (0, 170),\n        (0, 1415),\n        (0, 180),\n        (0, 2104),\n        (0, 4),\n        (0, 38),\n        (0, 2),\n        (0, 5),\n        (0, 14),\n        (0, 98),\n        (0, 1),\n        (0, 193),\n        (0, 188),\n        (0, 61),\n        (0, 91),\n        (0, 1085),\n        (0, 586),\n        (0, 20),\n        (0, 611),\n        (0, 33),\n        (0, 5063),\n        (0, 0),\n        (0, 3200),\n        (0, 22),\n        (0, 757),\n        (0, 51),\n        (0, 1),\n        (0, 6),\n        (0, 150),\n        (0, 7),\n        (0, 1),\n        (0, 51),\n        (0, 526),\n        (0, 30),\n        (0, 0),\n        (0, 193),\n        (0, 482),\n        (0, 38),\n        (0, 2391),\n        (0, 2),\n        (0, 27),\n        (0, 30),\n        (0, 35),\n        (0, 0),\n        (0, 0),\n        (0, 1),\n        (0, 131),\n        (0, 2952),\n        (0, 38),\n        (0, 215),\n        (0, 5),\n        (0, 0),\n        (0, 1659),\n        (0, 181),\n        (0, 39),\n        (0, 23),\n        (0, 14),\n        (0, 3862),\n        (0, 197),\n        (0, 1),\n        (0, 0),\n        (0, 2428),\n        (0, 239),\n        (0, 1),\n        (0, 0),\n        (0, 106),\n        (0, 0),\n        (0, 9),\n        (0, 0),\n        (0, 85),\n        (0, 867),\n        (0, 205),\n        (0, 138),\n        (0, 1413),\n        (0, 70),\n        (0, 498),\n        (0, 1),\n        (0, 2269),\n        (0, 16),\n        (0, 6),\n        (0, 0),\n        (0, 2),\n        (0, 30),\n        (0, 282),\n        (0, 566),\n        (0, 54),\n        (0, 54),\n        (0, 182),\n        (0, 131),\n        (0, 1240),\n        (0, 89),\n        (0, 15),\n        (0, 36),\n        (0, 450),\n        (0, 9),\n        (0, 79),\n        (0, 2435),\n        (0, 5),\n        (0, 1589),\n        (0, 2),\n        (0, 97),\n        (0, 962),\n        (0, 21),\n        (0, 36),\n        (0, 409),\n        (0, 537),\n        (0, 1068),\n        (0, 9),\n        (0, 126),\n        (0, 830),\n        (0, 1),\n        (0, 1392),\n        (0, 1),\n        (0, 55),\n        (0, 2),\n        (0, 1),\n        (0, 305),\n        (0, 3260),\n        (0, 427),\n        (0, 262),\n        (0, 5),\n        (0, 253),\n        (0, 879),\n        (0, 52),\n        (0, 160),\n        (0, 4056),\n        (0, 3806),\n        (0, 6),\n        (0, 1539),\n        (0, 9),\n        (0, 580),\n        (0, 198),\n        (0, 617),\n        (0, 65),\n        (0, 14),\n        (0, 2),\n        (0, 50),\n        (0, 0),\n        (0, 50),\n        (0, 32),\n        (0, 6),\n        (0, 1402),\n        (0, 1074),\n        (0, 4601),\n        (0, 230),\n        (0, 23),\n        (0, 40),\n        (0, 789),\n        (0, 938),\n        (0, 1555),\n        (0, 2),\n        (0, 594),\n        (0, 2),\n        (0, 14),\n        (0, 223),\n        (0, 8),\n        (0, 75),\n        (0, 1198),\n        (0, 136),\n        (0, 0),\n        (0, 3),\n        (0, 864),\n        (0, 137),\n        (0, 9290),\n        (0, 0),\n        (0, 209),\n        (0, 165),\n        (0, 836),\n        (0, 103),\n        (0, 720),\n        (0, 708),\n        (0, 2),\n        (0, 0),\n        (0, 150),\n        (0, 1021),\n        (0, 41),\n        (0, 3329),\n        (0, 1),\n        (0, 191),\n        (0, 1),\n        (0, 148),\n        (0, 27),\n        (0, 154),\n        (0, 1498),\n        (0, 733),\n        (0, 154),\n        (0, 1),\n        (0, 3982),\n        (0, 8095),\n        (0, 3),\n        (0, 67),\n        (0, 1001),\n        (0, 703),\n        (0, 756),\n        (0, 76),\n        (0, 34),\n        (0, 963),\n        (0, 1197),\n        (0, 0),\n        (0, 2),\n        (0, 121),\n        (0, 1062),\n        (0, 776),\n        (0, 145),\n        (0, 276),\n        (0, 0),\n        (0, 20),\n        (0, 5030),\n        (0, 100),\n        (0, 3104),\n        (0, 1),\n        (0, 1),\n        (0, 15),\n        (0, 0),\n        (0, 2313),\n        (0, 31),\n        (0, 5277),\n        (0, 11),\n        (0, 434),\n        (0, 112),\n        (0, 2),\n        (0, 635),\n        (0, 339),\n        (0, 1103),\n        (0, 23),\n        (0, 86),\n        (0, 1),\n        (0, 145),\n        (0, 61),\n        (0, 1242),\n        (0, 0),\n        (0, 0),\n        (0, 2),\n        (0, 4),\n        (0, 28),\n        (0, 7),\n        (0, 5580),\n        (0, 22),\n        (0, 1125),\n        (0, 20),\n        (0, 137),\n        (0, 3609),\n        (0, 131),\n        (0, 6),\n        (0, 0),\n        (0, 1289),\n        (0, 2),\n        (0, 1559),\n        (0, 598),\n        (0, 11),\n        (0, 1909),\n        (0, 1591),\n        (0, 22),\n        (0, 0),\n        (0, 23),\n        (0, 296),\n        (0, 19),\n        (0, 8441),\n        (0, 0),\n        (0, 9),\n        (0, 8),\n        (0, 2),\n        (0, 1993),\n        (0, 69),\n        (0, 19),\n        (0, 19),\n        (0, 5),\n        (0, 331),\n        (0, 16),\n        (0, 6),\n        (0, 3347),\n        (0, 49),\n        (0, 17),\n        (0, 1),\n        (0, 516),\n        (0, 156),\n        (0, 26),\n        (0, 501),\n        (0, 72),\n        (0, 106),\n        (0, 2),\n        (0, 336),\n        (0, 22),\n        (0, 0),\n        (0, 107),\n        (0, 939),\n        (0, 341),\n        (0, 19),\n        (0, 2877),\n        (0, 6),\n        (0, 177),\n        (0, 821),\n        (0, 1100),\n        (0, 194),\n        (0, 24),\n        (0, 599),\n        (0, 18),\n        (0, 21),\n        (0, 17),\n        (0, 42),\n        (0, 7),\n        (0, 86),\n        (0, 0),\n        (0, 238),\n        (0, 8),\n        (0, 5),\n        (0, 1),\n        (0, 68),\n        (0, 9193),\n        (0, 11),\n        (0, 6763),\n        (0, 158),\n        (0, 386),\n        (0, 4041),\n        (0, 63),\n        (0, 1819),\n        (0, 18),\n        (0, 0),\n        (0, 2036),\n        (0, 345),\n        (0, 2203),\n        (0, 113),\n        (0, 6),\n        (0, 371),\n        (0, 7),\n        (0, 194),\n        (0, 26),\n        (0, 3184),\n        (0, 185),\n        (0, 136),\n        (0, 35),\n        (0, 1883),\n        (0, 981),\n        (0, 1497),\n        (0, 140),\n        (0, 6),\n        (0, 0),\n        (0, 5),\n        (0, 4246),\n        (0, 121),\n        (0, 404),\n        (0, 398),\n        (0, 260),\n        (0, 368),\n        (0, 212),\n        (0, 2),\n        (0, 30),\n        (0, 45),\n        (0, 988),\n        (0, 82),\n        (0, 79),\n        (0, 1556),\n        (0, 5),\n        (0, 168),\n        (0, 0),\n        (0, 336),\n        (0, 1699),\n        (0, 141),\n        (0, 13),\n        (0, 0),\n        (0, 242),\n        (0, 40),\n        (0, 263),\n        (0, 6464),\n        (0, 1332),\n        (0, 4),\n        (0, 459),\n        (0, 7),\n        (0, 20),\n        (0, 1),\n        (0, 3523),\n        (0, 19),\n        (0, 0),\n        (0, 11),\n        (0, 8),\n        (0, 24),\n        (0, 608),\n        (0, 8),\n        (0, 50),\n        (0, 1),\n        (0, 2),\n        (0, 1723),\n        (0, 157),\n        (1, 108),\n        (0, 3),\n        (0, 0),\n        (0, 7122),\n        (0, 151),\n        (0, 4),\n        (0, 0),\n        (0, 1),\n        (0, 30),\n        (0, 5289),\n        (0, 2),\n        (0, 122),\n        (0, 66),\n        (0, 3),\n        (0, 7),\n        (0, 8258),\n        (0, 227),\n        (0, 3),\n        (0, 652),\n        (0, 574),\n        (0, 376),\n        (0, 522),\n        (0, 110),\n        (0, 1),\n        (0, 920),\n        (0, 2012),\n        (0, 4754),\n        (0, 412),\n        (0, 2774),\n        (0, 12),\n        (0, 1262),\n        (0, 144),\n        (0, 181),\n        (0, 94),\n        (0, 1903),\n        (0, 249),\n        (0, 8),\n        (0, 9),\n        (0, 96),\n        (0, 1323),\n        (0, 65),\n        (0, 20),\n        (0, 1270),\n        (0, 0),\n        (0, 1551),\n        (0, 13),\n        (0, 0),\n        (0, 5090),\n        (0, 2007),\n        (0, 6405),\n        (1, 891),\n        (0, 2327),\n        (0, 2029),\n        (0, 1078),\n        (0, 2),\n        (0, 3),\n        (0, 1),\n        (0, 661),\n        (0, 71),\n        (0, 43),\n        (0, 73),\n        (0, 12),\n        (0, 223),\n        (0, 90),\n        (0, 1360),\n        (0, 5),\n        (0, 329),\n        (0, 29),\n        (0, 398),\n        (0, 25),\n        (0, 14),\n        (0, 980),\n        (0, 271),\n        (0, 0),\n        (0, 466),\n        (0, 6142),\n        (0, 247),\n        (0, 172),\n        (0, 47),\n        (0, 38),\n        (0, 1576),\n        (0, 364),\n        (0, 4167),\n        (0, 3656),\n        (0, 3934),\n        (0, 721),\n        (0, 1329),\n        (0, 96),\n        (0, 625),\n        (0, 82),\n        (0, 72),\n        (0, 1763),\n        (0, 20),\n        (0, 947),\n        (0, 62),\n        (0, 478),\n        (0, 0),\n        (0, 1),\n        (0, 5),\n        (0, 1),\n        (0, 272),\n        (0, 1522),\n        (0, 857),\n        (0, 10),\n        (0, 4),\n        (0, 51),\n        (0, 252),\n        (0, 4),\n        (0, 90),\n        (0, 65),\n        (0, 1148),\n        (0, 990),\n        (0, 39),\n        (0, 6),\n        (0, 3926),\n        (0, 49),\n        (0, 1362),\n        (0, 9),\n        (0, 35),\n        (0, 0),\n        (0, 3880),\n        (0, 330),\n        (0, 32),\n        (0, 16),\n        (0, 5919),\n        (0, 22),\n        (0, 122),\n        (0, 3527),\n        (0, 16),\n        (0, 1085),\n        (0, 308),\n        (0, 134),\n        (0, 185),\n        (0, 138),\n        (0, 2443),\n        (0, 754),\n        (0, 506),\n        (0, 184),\n        (0, 6121),\n        (0, 1),\n        (0, 162),\n        (0, 17),\n        (0, 28),\n        (0, 17),\n        (0, 3843),\n        (0, 5),\n        (0, 158),\n        (0, 29),\n        (0, 42),\n        (0, 664),\n        (0, 388),\n        (0, 1209),\n        (0, 0),\n        (0, 1640),\n        (0, 58),\n        (0, 1),\n        (0, 18),\n        (0, 41),\n        (0, 7498),\n        (0, 7138),\n        (0, 5),\n        (0, 134),\n        (0, 9),\n        (0, 1),\n        (0, 207),\n        (0, 82),\n        (0, 7984),\n        (0, 42),\n        (0, 903),\n        (0, 258),\n        (0, 9392),\n        (0, 36),\n        (0, 46),\n        (0, 0),\n        (0, 228),\n        (0, 1633),\n        (0, 2445),\n        (0, 163),\n        (0, 885),\n        (0, 2340),\n        (0, 1173),\n        (0, 137),\n        (0, 5859),\n        (0, 202),\n        (0, 12),\n        (0, 1147),\n        (0, 3825),\n        (0, 525),\n        (0, 198),\n        (0, 182),\n        (0, 326),\n        (0, 210),\n        (0, 3107),\n        (0, 50),\n        (0, 257),\n        (0, 47),\n        (0, 832),\n        (0, 4166),\n        (0, 1592),\n        (0, 16),\n        (0, 10),\n        (1, 6970),\n        (0, 36),\n        (0, 16),\n        (0, 1),\n        (0, 9),\n        (0, 31),\n        (0, 4294),\n        (0, 4069),\n        (0, 28),\n        (0, 476),\n        (0, 2810),\n        (0, 403),\n        (0, 225),\n        (0, 583),\n        (0, 29),\n        (0, 261),\n        (0, 705),\n        (0, 5),\n        (0, 1938),\n        (0, 948),\n        (0, 7),\n        (0, 3653),\n        (0, 612),\n        (0, 7244),\n        (0, 29),\n        (0, 154),\n        (0, 111),\n        (0, 164),\n        (0, 61),\n        (0, 36),\n        (0, 226),\n        (0, 7905),\n        (0, 767),\n        (0, 0),\n        (0, 32),\n        (0, 6),\n        (0, 949),\n        (0, 2011),\n        (0, 25),\n        (0, 0),\n        (0, 27),\n        (0, 993),\n        (0, 108),\n        (0, 496),\n        (0, 2591),\n        (0, 2225),\n        (1, 1620),\n        (0, 182),\n        (0, 369),\n        (0, 2765),\n        (0, 165),\n        (0, 78),\n        (0, 313),\n        (0, 163),\n        (0, 26),\n        (0, 5609),\n        (0, 123),\n        (0, 8),\n        (0, 750),\n        (0, 3621),\n        (0, 272),\n        (0, 1),\n        (0, 0),\n        (0, 2785),\n        (0, 1),\n        (0, 9118),\n        (0, 1166),\n        (0, 1564),\n        (0, 0),\n        (0, 2468),\n        (0, 20),\n        (0, 4),\n        (0, 1506),\n        (1, 371),\n        (0, 533),\n        (0, 7),\n        (0, 38),\n        (0, 1051),\n        (0, 4),\n        (0, 7),\n        (0, 5),\n        (0, 1),\n        (0, 1177),\n        (0, 6404),\n        (0, 64),\n        (0, 51),\n        (0, 17),\n        (0, 4),\n        (0, 3),\n        (0, 0),\n        (0, 31),\n        (0, 367),\n        (0, 211),\n        (0, 1066),\n        (0, 693),\n        (0, 74),\n        (0, 1175),\n        (0, 25),\n        (0, 900),\n        (0, 1848),\n        (0, 19),\n        (0, 64),\n        (0, 18),\n        (0, 28),\n        (1, 4212),\n        (0, 1909),\n        (0, 1480),\n        (0, 176),\n        (0, 33),\n        (0, 0),\n        (0, 223),\n        (0, 2),\n        (0, 34),\n        (0, 444),\n        (0, 1564),\n        (0, 25),\n        (0, 1085),\n        (0, 808),\n        (0, 5),\n        (0, 0),\n        (0, 27),\n        (0, 6328),\n        (0, 9),\n        (0, 69),\n        (0, 282),\n        (0, 1832),\n        (1, 8685),\n        (0, 299),\n        (0, 6813),\n        (0, 4),\n        (0, 167),\n        (0, 348),\n        (0, 4403),\n        (1, 3801),\n        (0, 66),\n        (0, 6324),\n        (0, 1879),\n        (0, 33),\n        (0, 145),\n        (0, 180),\n        (0, 4675),\n        (0, 11),\n        (0, 0),\n        (0, 38),\n        (0, 1119),\n        (0, 100),\n        (0, 430),\n        (0, 843),\n        (0, 77),\n        (0, 8663),\n        (0, 7),\n        (0, 6805),\n        (1, 2379),\n        (0, 1556),\n        (0, 6029),\n        (0, 6596),\n        (0, 99),\n        (0, 6554),\n        (0, 1025),\n        (0, 1223),\n        (0, 58),\n        (0, 7),\n        (0, 737),\n        (0, 443),\n        (0, 407),\n        (0, 219),\n        (0, 2227),\n        (0, 2286),\n        (0, 4165),\n        (0, 54),\n        (0, 298),\n        (2, 3184),\n        (0, 185),\n        (0, 8251),\n        (0, 0),\n        (0, 33),\n        (0, 30),\n        (0, 2),\n        (0, 310),\n        (0, 802),\n        (0, 5196),\n        (0, 2985),\n        (0, 211),\n        (0, 66),\n        (0, 74),\n        (0, 97),\n        (0, 40),\n        (0, 1),\n        (0, 521),\n        (0, 8),\n        (0, 813),\n        (0, 974),\n        (0, 3396),\n        (1, 5828),\n        (0, 40),\n        (0, 277),\n        (0, 17),\n        (0, 597),\n        (0, 718),\n        (0, 280),\n        (0, 9),\n        (0, 4),\n        (0, 340),\n        (0, 0),\n        (0, 552),\n        (0, 1),\n        (0, 275),\n        (1, 5278),\n        (0, 58),\n        (0, 3),\n        (0, 5371),\n        (0, 1),\n        (0, 16),\n        (0, 162),\n        (1, 8009),\n        (0, 835),\n        (0, 4572),\n        (0, 242),\n        (0, 510),\n        (0, 1),\n        (0, 52),\n        (0, 57),\n        (0, 517),\n        (0, 4415),\n        (0, 16),\n        (0, 3225),\n        (0, 31),\n        (0, 99),\n        (0, 0),\n        (0, 146),\n        (0, 0),\n        (0, 161),\n        (0, 4),\n        (0, 4),\n        (0, 216),\n        (0, 0),\n        (0, 1160),\n        (0, 5675),\n        (0, 154),\n        (0, 112),\n        (0, 132),\n        (0, 2),\n        (0, 66),\n        (0, 53),\n        (0, 51),\n        (0, 0),\n        (0, 325),\n        (0, 2296),\n        (0, 109),\n        (0, 7514),\n        (0, 2850),\n        (0, 44),\n        (0, 1530),\n        (0, 248),\n        (0, 654),\n        (0, 44),\n        (0, 2282),\n        (0, 299),\n        (0, 2151),\n        (0, 2886),\n        (0, 114),\n        (0, 5823),\n        (0, 182),\n        (0, 872),\n        (0, 0),\n        (0, 3170),\n        (0, 0),\n        (0, 50),\n        (0, 71),\n        (0, 33),\n        (0, 11),\n        (0, 1),\n        (0, 1258),\n        (0, 14),\n        (0, 3255),\n        (0, 216),\n        (0, 6127),\n        (0, 2144),\n        (0, 0),\n        (0, 2588),\n        (0, 1169),\n        (0, 1311),\n        (0, 588),\n        (0, 5),\n        (0, 174),\n        (0, 1393),\n        (0, 63),\n        (0, 50),\n        (0, 3955),\n        (0, 473),\n        (0, 1519),\n        (0, 0),\n        (0, 327),\n        (0, 2475),\n        (0, 15),\n        (0, 0),\n        (2, 2826),\n        (0, 2896),\n        (0, 0),\n        (0, 7005),\n        (1, 2910),\n        (0, 217),\n        (0, 2121),\n        (0, 75),\n        (0, 336),\n        (0, 9830),\n        (1, 1127),\n        (0, 26),\n        (0, 250),\n        (0, 1550),\n        (0, 31),\n        (0, 170),\n        (0, 21),\n        (0, 3383),\n        (0, 3241),\n        (0, 8864),\n        (0, 426),\n        (0, 45),\n        (0, 5113),\n        (0, 622),\n        (0, 288),\n        (0, 3),\n        (0, 3236),\n        (0, 23),\n        (0, 3996),\n        (0, 2),\n        (0, 2),\n        (0, 584),\n        (0, 0),\n        (0, 4),\n        (0, 0),\n        (0, 6088),\n        (0, 5672),\n        (0, 3725),\n        (0, 1803),\n        (0, 230),\n        (0, 251),\n        (0, 725),\n        (0, 2059),\n        (0, 421),\n        (0, 86),\n        (0, 5),\n        (0, 6924),\n        (0, 28),\n        (0, 1440),\n        (0, 1976),\n        (0, 1836),\n        (0, 2),\n        (1, 1615),\n        (0, 4462),\n        (0, 4846),\n        (0, 5436),\n        (0, 123),\n        (1, 519),\n        (0, 87),\n        (0, 1595),\n        (0, 2401),\n        (0, 5),\n        (0, 0),\n        (1, 341),\n        (0, 4),\n        (0, 899),\n        (0, 1939),\n        (0, 2),\n        (0, 1105),\n        (0, 1273),\n        (0, 74),\n        (0, 56),\n        (0, 1685),\n        (0, 1154),\n        (0, 1130),\n        (0, 19),\n        (0, 5971),\n        (0, 2940),\n        (0, 8020),\n        (0, 0),\n        (0, 116),\n        (2, 5930),\n        (0, 41),\n        (0, 162),\n        (0, 57),\n        (0, 1375),\n        (0, 398),\n        (0, 4008),\n        (0, 9287),\n        (0, 817),\n        (0, 0),\n        (0, 2793),\n        (0, 556),\n        (0, 997),\n        (0, 282),\n        (0, 0),\n        (0, 553),\n        (0, 5742),\n        (0, 382),\n        (0, 6670),\n        (0, 5301),\n        (0, 0),\n        (2, 9658),\n        (0, 463),\n        (1, 2981),\n        (0, 3716),\n        (0, 4894),\n        (0, 35),\n        (1, 75),\n        (0, 86),\n        (0, 3384),\n        (0, 0),\n        (0, 73),\n        (0, 635),\n        (0, 2),\n        (0, 7793),\n        (1, 126),\n        (0, 21),\n        (0, 173),\n        (0, 505),\n        (0, 1558),\n        (0, 45),\n        (0, 3137),\n        (2, 9424),\n        (0, 4030),\n        (0, 1749),\n        (0, 172),\n        (0, 1309),\n        (0, 240),\n        (0, 735),\n        (0, 400),\n        (0, 4),\n        (0, 160),\n        (0, 0),\n        (0, 1),\n        (0, 105),\n        (0, 1),\n        (0, 5051),\n        (0, 365),\n        (0, 146),\n        (0, 30),\n        (0, 3),\n        (0, 470),\n        (0, 452),\n        (0, 1824),\n        (0, 1716),\n        (0, 15),\n        (0, 1028),\n        (0, 332),\n        (0, 3606),\n        (0, 19),\n        (0, 6),\n        (0, 405),\n        (0, 7770),\n        (0, 4300),\n        (0, 247),\n        (0, 7550),\n        (0, 6643),\n        (2, 1261),\n        (0, 7147),\n        (0, 30),\n        (0, 9),\n        (0, 223),\n        (0, 403),\n        (0, 372),\n        (3, 4276),\n        (0, 9288),\n        (0, 6212),\n        (0, 714),\n        (4, 6377),\n        (0, 4),\n        (0, 46),\n        (1, 8403),\n        (0, 142),\n        (0, 4462),\n        (0, 7581),\n        (0, 12),\n        (0, 0),\n        (0, 4864),\n        (0, 2961),\n        (0, 265),\n        (0, 19),\n        (0, 119),\n        (0, 5454),\n        (2, 2981),\n        (0, 3230),\n        (0, 3),\n        (0, 0),\n        (0, 6000),\n        (1, 9805),\n        (0, 354),\n        (0, 61),\n        (0, 8529),\n        (0, 0),\n        (0, 2076),\n        (0, 629),\n        (1, 1194),\n        (0, 3377),\n        (0, 0),\n        (0, 1956),\n        (0, 1749),\n        (3, 3998),\n        (0, 109),\n        (0, 16),\n        (0, 1467),\n        (0, 5195),\n        (0, 35),\n        (0, 9700),\n        (0, 4738),\n    ],\n    entries: &[\n        (\"blacktrianglel\", (0, 0)),\n        (\"sharp\", (0, 0)),\n        (\"bowtie\", (0, 0)),\n        (\"NotPrecedesSlantEqual;\", (8928, 0)),\n        (\"Aci\", (0, 0)),\n        (\"Atilde;\", (195, 0)),\n        (\"Zacute;\", (377, 0)),\n        (\"gvertn\", (0, 0)),\n        (\"ordm\", (186, 0)),\n        (\"LeftV\", (0, 0)),\n        (\"circlearrowl\", (0, 0)),\n        (\"updo\", (0, 0)),\n        (\"wcirc\", (0, 0)),\n        (\"gtlPar;\", (10645, 0)),\n        (\"leftharpoondow\", (0, 0)),\n        (\"NotGreaterLess\", (0, 0)),\n        (\"curlyeqpr\", (0, 0)),\n        (\"Downarrow\", (0, 0)),\n        (\"mdas\", (0, 0)),\n        (\"timesd;\", (10800, 0)),\n        (\"smash\", (0, 0)),\n        (\"VerticalL\", (0, 0)),\n        (\"LessSlantE\", (0, 0)),\n        (\"Lamb\", (0, 0)),\n        (\"prap;\", (10935, 0)),\n        (\"Updownarro\", (0, 0)),\n        (\"right\", (0, 0)),\n        (\"bull\", (0, 0)),\n        (\"plusdo\", (0, 0)),\n        (\"Iuk\", (0, 0)),\n        (\"xmap;\", (10236, 0)),\n        (\"We\", (0, 0)),\n        (\"iiiin\", (0, 0)),\n        (\"Rsh;\", (8625, 0)),\n        (\"sac\", (0, 0)),\n        (\"nVDash;\", (8879, 0)),\n        (\"ns\", (0, 0)),\n        (\"NotNestedGr\", (0, 0)),\n        (\"RightCe\", (0, 0)),\n        (\"lce\", (0, 0)),\n        (\"lb\", (0, 0)),\n        (\"dArr;\", (8659, 0)),\n        (\"Hfr;\", (8460, 0)),\n        (\"lnE\", (0, 0)),\n        (\"emsp14\", (0, 0)),\n        (\"Ubre\", (0, 0)),\n        (\"bumpE\", (0, 0)),\n        (\"DoubleDo\", (0, 0)),\n        (\"g\", (0, 0)),\n        (\"grave\", (0, 0)),\n        (\"DoubleDownAr\", (0, 0)),\n        (\"bigt\", (0, 0)),\n        (\"nbu\", (0, 0)),\n        (\"Becau\", (0, 0)),\n        (\"curvearrowright;\", (8631, 0)),\n        (\"RightDownVector\", (0, 0)),\n        (\"xwedge;\", (8896, 0)),\n        (\"CircleTi\", (0, 0)),\n        (\"dashv\", (0, 0)),\n        (\"CupCa\", (0, 0)),\n        (\"vpro\", (0, 0)),\n        (\"scsim\", (0, 0)),\n        (\"kgr\", (0, 0)),\n        (\"fpartint\", (0, 0)),\n        (\"ShortDo\", (0, 0)),\n        (\"iiot\", (0, 0)),\n        (\"escr\", (0, 0)),\n        (\"lmidot\", (0, 0)),\n        (\"na\", (0, 0)),\n        (\"bigcup;\", (8899, 0)),\n        (\"bn\", (0, 0)),\n        (\"gneq\", (0, 0)),\n        (\"rBar\", (0, 0)),\n        (\"preceq;\", (10927, 0)),\n        (\"MediumSp\", (0, 0)),\n        (\"Ha\", (0, 0)),\n        (\"xve\", (0, 0)),\n        (\"tce\", (0, 0)),\n        (\"bsim\", (0, 0)),\n        (\"NotGreaterSlantEq\", (0, 0)),\n        (\"LeftAngleBra\", (0, 0)),\n        (\"nat\", (0, 0)),\n        (\"Acirc\", (194, 0)),\n        (\"Kappa\", (0, 0)),\n        (\"Uscr\", (0, 0)),\n        (\"intca\", (0, 0)),\n        (\"cylct\", (0, 0)),\n        (\"blk14\", (0, 0)),\n        (\"vdash\", (0, 0)),\n        (\"Laplacetr\", (0, 0)),\n        (\"Imaginar\", (0, 0)),\n        (\"Uma\", (0, 0)),\n        (\"DoubleLongRightArrow\", (0, 0)),\n        (\"lurd\", (0, 0)),\n        (\"icirc\", (238, 0)),\n        (\"lsquor;\", (8218, 0)),\n        (\"Idot\", (0, 0)),\n        (\"LessFull\", (0, 0)),\n        (\"ShortRightAr\", (0, 0)),\n        (\"DownLeftTeeVe\", (0, 0)),\n        (\"iiiint;\", (10764, 0)),\n        (\"ods\", (0, 0)),\n        (\"cwcon\", (0, 0)),\n        (\"ruluha\", (0, 0)),\n        (\"leftrightsquiga\", (0, 0)),\n        (\"odash\", (0, 0)),\n        (\"gel\", (0, 0)),\n        (\"Bu\", (0, 0)),\n        (\"xscr;\", (120013, 0)),\n        (\"succn\", (0, 0)),\n        (\"capdot;\", (10816, 0)),\n        (\"rat\", (0, 0)),\n        (\"topfor\", (0, 0)),\n        (\"NestedG\", (0, 0)),\n        (\"ContourIn\", (0, 0)),\n        (\"EqualT\", (0, 0)),\n        (\"Gscr;\", (119970, 0)),\n        (\"UpperLeftAr\", (0, 0)),\n        (\"pc\", (0, 0)),\n        (\"drcro\", (0, 0)),\n        (\"Vsc\", (0, 0)),\n        (\"thetasy\", (0, 0)),\n        (\"Clockwise\", (0, 0)),\n        (\"bigvee;\", (8897, 0)),\n        (\"jopf;\", (120155, 0)),\n        (\"Hcir\", (0, 0)),\n        (\"sw\", (0, 0)),\n        (\"Upsilon\", (0, 0)),\n        (\"CounterClockwiseContourIntegral;\", (8755, 0)),\n        (\"plusdu\", (0, 0)),\n        (\"searr;\", (8600, 0)),\n        (\"mnplus;\", (8723, 0)),\n        (\"shchc\", (0, 0)),\n        (\"clubsuit\", (0, 0)),\n        (\"epars\", (0, 0)),\n        (\"SquareUni\", (0, 0)),\n        (\"NotSubs\", (0, 0)),\n        (\"nltr\", (0, 0)),\n        (\"curly\", (0, 0)),\n        (\"NotGreater\", (0, 0)),\n        (\"DoubleLe\", (0, 0)),\n        (\"DoubleLongLeftRigh\", (0, 0)),\n        (\"ori\", (0, 0)),\n        (\"LeftAngl\", (0, 0)),\n        (\"jma\", (0, 0)),\n        (\"SquareSubs\", (0, 0)),\n        (\"Or\", (0, 0)),\n        (\"gna\", (0, 0)),\n        (\"circledast\", (0, 0)),\n        (\"RightUpVe\", (0, 0)),\n        (\"leftt\", (0, 0)),\n        (\"EmptySmallS\", (0, 0)),\n        (\"natu\", (0, 0)),\n        (\"succe\", (0, 0)),\n        (\"downdownar\", (0, 0)),\n        (\"Ogr\", (0, 0)),\n        (\"GT\", (62, 0)),\n        (\"YAcy;\", (1071, 0)),\n        (\"lcedil\", (0, 0)),\n        (\"clu\", (0, 0)),\n        (\"sd\", (0, 0)),\n        (\"nprec;\", (8832, 0)),\n        (\"NotSucceedsEq\", (0, 0)),\n        (\"slar\", (0, 0)),\n        (\"LongLeftRightA\", (0, 0)),\n        (\"smt;\", (10922, 0)),\n        (\"UnionPlus\", (0, 0)),\n        (\"col\", (0, 0)),\n        (\"clubsu\", (0, 0)),\n        (\"ruluh\", (0, 0)),\n        (\"vprop;\", (8733, 0)),\n        (\"gtreqles\", (0, 0)),\n        (\"succcurl\", (0, 0)),\n        (\"dotminus;\", (8760, 0)),\n        (\"DoubleLeftTee\", (0, 0)),\n        (\"duhar;\", (10607, 0)),\n        (\"Suc\", (0, 0)),\n        (\"DiacriticalDoubleAc\", (0, 0)),\n        (\"eqcolon;\", (8789, 0)),\n        (\"upharpoo\", (0, 0)),\n        (\"looparrow\", (0, 0)),\n        (\"ycirc;\", (375, 0)),\n        (\"gtra\", (0, 0)),\n        (\"succnsim;\", (8937, 0)),\n        (\"LeftRightV\", (0, 0)),\n        (\"dag\", (0, 0)),\n        (\"NotLessSlantEqual\", (0, 0)),\n        (\"varsigm\", (0, 0)),\n        (\"m\", (0, 0)),\n        (\"ouml\", (246, 0)),\n        (\"hkse\", (0, 0)),\n        (\"NotEqualTilde\", (0, 0)),\n        (\"NotGreaterTi\", (0, 0)),\n        (\"approxe\", (0, 0)),\n        (\"LeftTeeVe\", (0, 0)),\n        (\"sem\", (0, 0)),\n        (\"ou\", (0, 0)),\n        (\"straight\", (0, 0)),\n        (\"scc\", (0, 0)),\n        (\"ReverseElem\", (0, 0)),\n        (\"curlyeqprec;\", (8926, 0)),\n        (\"efr;\", (120098, 0)),\n        (\"ropl\", (0, 0)),\n        (\"downarro\", (0, 0)),\n        (\"Tild\", (0, 0)),\n        (\"SquareSubsetEqual;\", (8849, 0)),\n        (\"NotV\", (0, 0)),\n        (\"Ea\", (0, 0)),\n        (\"Lopf\", (0, 0)),\n        (\"swarr;\", (8601, 0)),\n        (\"rtimes;\", (8906, 0)),\n        (\"h\", (0, 0)),\n        (\"ntlg;\", (8824, 0)),\n        (\"Omicron;\", (927, 0)),\n        (\"Map;\", (10501, 0)),\n        (\"Gce\", (0, 0)),\n        (\"ZeroWidthSpac\", (0, 0)),\n        (\"Topf;\", (120139, 0)),\n        (\"ic\", (0, 0)),\n        (\"uarr;\", (8593, 0)),\n        (\"util\", (0, 0)),\n        (\"frac13\", (0, 0)),\n        (\"Longleftrightarro\", (0, 0)),\n        (\"Ufr\", (0, 0)),\n        (\"infin\", (0, 0)),\n        (\"Eq\", (0, 0)),\n        (\"cudarrl;\", (10552, 0)),\n        (\"Beta\", (0, 0)),\n        (\"NotEl\", (0, 0)),\n        (\"KHcy;\", (1061, 0)),\n        (\"diamonds\", (0, 0)),\n        (\"cca\", (0, 0)),\n        (\"LessF\", (0, 0)),\n        (\"nshortparallel;\", (8742, 0)),\n        (\"vsc\", (0, 0)),\n        (\"OverParenthe\", (0, 0)),\n        (\"Diamond\", (0, 0)),\n        (\"RightTri\", (0, 0)),\n        (\"iscr\", (0, 0)),\n        (\"HumpEqu\", (0, 0)),\n        (\"centerdot;\", (183, 0)),\n        (\"DownArrowUpA\", (0, 0)),\n        (\"lagran;\", (8466, 0)),\n        (\"dotpl\", (0, 0)),\n        (\"ulcorne\", (0, 0)),\n        (\"UpperLeftArr\", (0, 0)),\n        (\"lAarr\", (0, 0)),\n        (\"lhb\", (0, 0)),\n        (\"supnE\", (0, 0)),\n        (\"Brev\", (0, 0)),\n        (\"ulco\", (0, 0)),\n        (\"ccap\", (0, 0)),\n        (\"OverBracket\", (0, 0)),\n        (\"lArr\", (0, 0)),\n        (\"supplus\", (0, 0)),\n        (\"expe\", (0, 0)),\n        (\"expecta\", (0, 0)),\n        (\"om\", (0, 0)),\n        (\"eg;\", (10906, 0)),\n        (\"Ici\", (0, 0)),\n        (\"leftthreetime\", (0, 0)),\n        (\"iprod\", (0, 0)),\n        (\"ssetmn;\", (8726, 0)),\n        (\"A\", (0, 0)),\n        (\"ntrianglelefteq;\", (8940, 0)),\n        (\"Laplac\", (0, 0)),\n        (\"smeparsl;\", (10724, 0)),\n        (\"RightT\", (0, 0)),\n        (\"rsq\", (0, 0)),\n        (\"LeftUpDownVector;\", (10577, 0)),\n        (\"Rcedil;\", (342, 0)),\n        (\"Iot\", (0, 0)),\n        (\"NotSucceeds;\", (8833, 0)),\n        (\"uum\", (0, 0)),\n        (\"Llef\", (0, 0)),\n        (\"NegativeThinS\", (0, 0)),\n        (\"fj\", (0, 0)),\n        (\"breve\", (0, 0)),\n        (\"tbr\", (0, 0)),\n        (\"bkarow;\", (10509, 0)),\n        (\"NotSquare\", (0, 0)),\n        (\"RightArrowBar;\", (8677, 0)),\n        (\"RightDownVecto\", (0, 0)),\n        (\"Fi\", (0, 0)),\n        (\"Kfr\", (0, 0)),\n        (\"rightarrow;\", (8594, 0)),\n        (\"UpEquilib\", (0, 0)),\n        (\"leftrightsqu\", (0, 0)),\n        (\"succcurlye\", (0, 0)),\n        (\"blacktrianglele\", (0, 0)),\n        (\"Lcedi\", (0, 0)),\n        (\"djcy\", (0, 0)),\n        (\"ndash\", (0, 0)),\n        (\"LeftUpDownV\", (0, 0)),\n        (\"LessSlantEqu\", (0, 0)),\n        (\"RightDownTe\", (0, 0)),\n        (\"Ycy\", (0, 0)),\n        (\"exc\", (0, 0)),\n        (\"lef\", (0, 0)),\n        (\"ratai\", (0, 0)),\n        (\"LessFullEqual\", (0, 0)),\n        (\"icirc;\", (238, 0)),\n        (\"Nf\", (0, 0)),\n        (\"NotLessGr\", (0, 0)),\n        (\"gtreq\", (0, 0)),\n        (\"nvDa\", (0, 0)),\n        (\"Gcirc\", (0, 0)),\n        (\"otil\", (0, 0)),\n        (\"Hf\", (0, 0)),\n        (\"LeftUpTe\", (0, 0)),\n        (\"ThinSpace;\", (8201, 0)),\n        (\"el;\", (10905, 0)),\n        (\"Qf\", (0, 0)),\n        (\"backprime\", (0, 0)),\n        (\"LeftTr\", (0, 0)),\n        (\"DownRig\", (0, 0)),\n        (\"xhArr;\", (10234, 0)),\n        (\"Rop\", (0, 0)),\n        (\"DownTeeArrow\", (0, 0)),\n        (\"lozeng\", (0, 0)),\n        (\"CloseCurlyDoubleQu\", (0, 0)),\n        (\"Kcy\", (0, 0)),\n        (\"gsc\", (0, 0)),\n        (\"ReverseEquilibriu\", (0, 0)),\n        (\"GreaterSla\", (0, 0)),\n        (\"larrsim\", (0, 0)),\n        (\"vangrt;\", (10652, 0)),\n        (\"Rcaro\", (0, 0)),\n        (\"nco\", (0, 0)),\n        (\"LessEqual\", (0, 0)),\n        (\"uHar;\", (10595, 0)),\n        (\"andd\", (0, 0)),\n        (\"hstrok;\", (295, 0)),\n        (\"hyb\", (0, 0)),\n        (\"PrecedesTild\", (0, 0)),\n        (\"rangle;\", (10217, 0)),\n        (\"ContourIntegr\", (0, 0)),\n        (\"RBarr\", (0, 0)),\n        (\"Vscr\", (0, 0)),\n        (\"Negativ\", (0, 0)),\n        (\"Yo\", (0, 0)),\n        (\"cula\", (0, 0)),\n        (\"nGt\", (0, 0)),\n        (\"lesseqqg\", (0, 0)),\n        (\"rscr;\", (120007, 0)),\n        (\"nesim\", (0, 0)),\n        (\"LeftDownTeeVector;\", (10593, 0)),\n        (\"barv\", (0, 0)),\n        (\"succnapprox;\", (10938, 0)),\n        (\"lbrksld;\", (10639, 0)),\n        (\"triangl\", (0, 0)),\n        (\"CircleDo\", (0, 0)),\n        (\"xlarr\", (0, 0)),\n        (\"larrbf\", (0, 0)),\n        (\"larr\", (0, 0)),\n        (\"fal\", (0, 0)),\n        (\"Triple\", (0, 0)),\n        (\"opar\", (0, 0)),\n        (\"Uci\", (0, 0)),\n        (\"Roun\", (0, 0)),\n        (\"DoubleRightAr\", (0, 0)),\n        (\"planckh\", (0, 0)),\n        (\"EmptyVer\", (0, 0)),\n        (\"Prim\", (0, 0)),\n        (\"apo\", (0, 0)),\n        (\"RightTriangleEqua\", (0, 0)),\n        (\"blackt\", (0, 0)),\n        (\"Diac\", (0, 0)),\n        (\"UnderBracket\", (0, 0)),\n        (\"larrlp\", (0, 0)),\n        (\"Dot;\", (168, 0)),\n        (\"asympeq\", (0, 0)),\n        (\"mDDo\", (0, 0)),\n        (\"Uuml;\", (220, 0)),\n        (\"Tce\", (0, 0)),\n        (\"Integral\", (0, 0)),\n        (\"llcor\", (0, 0)),\n        (\"Prece\", (0, 0)),\n        (\"Part\", (0, 0)),\n        (\"herco\", (0, 0)),\n        (\"cacute\", (0, 0)),\n        (\"profli\", (0, 0)),\n        (\"of\", (0, 0)),\n        (\"uopf\", (0, 0)),\n        (\"Ti\", (0, 0)),\n        (\"edot;\", (279, 0)),\n        (\"drcor\", (0, 0)),\n        (\"RightArrowLeftArro\", (0, 0)),\n        (\"rightsquigarrow;\", (8605, 0)),\n        (\"upuparr\", (0, 0)),\n        (\"queste\", (0, 0)),\n        (\"Longleft\", (0, 0)),\n        (\"laemptyv\", (0, 0)),\n        (\"trie\", (0, 0)),\n        (\"hAr\", (0, 0)),\n        (\"xutr\", (0, 0)),\n        (\"siml;\", (10909, 0)),\n        (\"sup1\", (185, 0)),\n        (\"PrecedesSlan\", (0, 0)),\n        (\"Ntilde\", (209, 0)),\n        (\"uwa\", (0, 0)),\n        (\"frac34\", (190, 0)),\n        (\"boxVR;\", (9568, 0)),\n        (\"zig\", (0, 0)),\n        (\"dotsqua\", (0, 0)),\n        (\"dtr\", (0, 0)),\n        (\"Diacritic\", (0, 0)),\n        (\"gjcy;\", (1107, 0)),\n        (\"epsiv;\", (1013, 0)),\n        (\"IE\", (0, 0)),\n        (\"boxDR\", (0, 0)),\n        (\"fa\", (0, 0)),\n        (\"npara\", (0, 0)),\n        (\"frac45\", (0, 0)),\n        (\"pi;\", (960, 0)),\n        (\"cirmi\", (0, 0)),\n        (\"leftthreeti\", (0, 0)),\n        (\"bigotimes\", (0, 0)),\n        (\"bigsqc\", (0, 0)),\n        (\"xlarr;\", (10229, 0)),\n        (\"lhbl\", (0, 0)),\n        (\"ldc\", (0, 0)),\n        (\"ugrave;\", (249, 0)),\n        (\"NotHumpDownHump;\", (8782, 824)),\n        (\"Rho;\", (929, 0)),\n        (\"rarrs\", (0, 0)),\n        (\"NotLessS\", (0, 0)),\n        (\"inca\", (0, 0)),\n        (\"RoundImplies\", (0, 0)),\n        (\"FilledVerySmallS\", (0, 0)),\n        (\"esi\", (0, 0)),\n        (\"orslo\", (0, 0)),\n        (\"ddag\", (0, 0)),\n        (\"curre\", (0, 0)),\n        (\"uuarr;\", (8648, 0)),\n        (\"up\", (0, 0)),\n        (\"ccar\", (0, 0)),\n        (\"ri\", (0, 0)),\n        (\"lhard\", (0, 0)),\n        (\"nles\", (0, 0)),\n        (\"Utild\", (0, 0)),\n        (\"eqcirc;\", (8790, 0)),\n        (\"ltime\", (0, 0)),\n        (\"yacy;\", (1103, 0)),\n        (\"malt;\", (10016, 0)),\n        (\"aac\", (0, 0)),\n        (\"RoundImp\", (0, 0)),\n        (\"phmmat\", (0, 0)),\n        (\"RightDownTeeVect\", (0, 0)),\n        (\"cap;\", (8745, 0)),\n        (\"jm\", (0, 0)),\n        (\"looparrowle\", (0, 0)),\n        (\"profline;\", (8978, 0)),\n        (\"plus\", (0, 0)),\n        (\"straightepsi\", (0, 0)),\n        (\"RightCeili\", (0, 0)),\n        (\"awconin\", (0, 0)),\n        (\"mapstodown\", (0, 0)),\n        (\"triangleleft\", (0, 0)),\n        (\"gc\", (0, 0)),\n        (\"oo\", (0, 0)),\n        (\"zet\", (0, 0)),\n        (\"setmin\", (0, 0)),\n        (\"twix\", (0, 0)),\n        (\"mapstoleft\", (0, 0)),\n        (\"LowerLeftArrow\", (0, 0)),\n        (\"sqsub\", (0, 0)),\n        (\"iocy\", (0, 0)),\n        (\"imagpar\", (0, 0)),\n        (\"softcy\", (0, 0)),\n        (\"acd;\", (8767, 0)),\n        (\"Ium\", (0, 0)),\n        (\"DoubleLongRightArrow;\", (10233, 0)),\n        (\"Pri\", (0, 0)),\n        (\"tfr\", (0, 0)),\n        (\"DoubleLo\", (0, 0)),\n        (\"Tilde;\", (8764, 0)),\n        (\"Equal\", (0, 0)),\n        (\"Iu\", (0, 0)),\n        (\"Hs\", (0, 0)),\n        (\"nvl\", (0, 0)),\n        (\"ClockwiseContourIntegra\", (0, 0)),\n        (\"RightTriangleBar\", (0, 0)),\n        (\"downharpoonle\", (0, 0)),\n        (\"expec\", (0, 0)),\n        (\"bigotim\", (0, 0)),\n        (\"AMP;\", (38, 0)),\n        (\"boxH;\", (9552, 0)),\n        (\"Intersectio\", (0, 0)),\n        (\"aum\", (0, 0)),\n        (\"niv\", (0, 0)),\n        (\"nlefta\", (0, 0)),\n        (\"lesseq\", (0, 0)),\n        (\"mar\", (0, 0)),\n        (\"male\", (0, 0)),\n        (\"curlyeqpre\", (0, 0)),\n        (\"LowerRight\", (0, 0)),\n        (\"lon\", (0, 0)),\n        (\"Exponenti\", (0, 0)),\n        (\"nexist\", (0, 0)),\n        (\"siml\", (0, 0)),\n        (\"NotGreaterT\", (0, 0)),\n        (\"rfloor;\", (8971, 0)),\n        (\"Bsc\", (0, 0)),\n        (\"Otim\", (0, 0)),\n        (\"capbrcup\", (0, 0)),\n        (\"varkappa;\", (1008, 0)),\n        (\"circ\", (0, 0)),\n        (\"plan\", (0, 0)),\n        (\"Sacu\", (0, 0)),\n        (\"varsig\", (0, 0)),\n        (\"RoundImpli\", (0, 0)),\n        (\"jsercy;\", (1112, 0)),\n        (\"di\", (0, 0)),\n        (\"bepsi\", (0, 0)),\n        (\"hearts\", (0, 0)),\n        (\"nleqsla\", (0, 0)),\n        (\"RuleDel\", (0, 0)),\n        (\"boxhd\", (0, 0)),\n        (\"profl\", (0, 0)),\n        (\"downharpo\", (0, 0)),\n        (\"raemptyv;\", (10675, 0)),\n        (\"ominus\", (0, 0)),\n        (\"bsolb;\", (10693, 0)),\n        (\"straightepsilon;\", (1013, 0)),\n        (\"nsub\", (0, 0)),\n        (\"DoubleLongLeftArro\", (0, 0)),\n        (\"ensp\", (0, 0)),\n        (\"Aopf\", (0, 0)),\n        (\"gacute\", (0, 0)),\n        (\"Colone;\", (10868, 0)),\n        (\"zw\", (0, 0)),\n        (\"leftharpoo\", (0, 0)),\n        (\"UpArrowDownAr\", (0, 0)),\n        (\"IEcy\", (0, 0)),\n        (\"shortpar\", (0, 0)),\n        (\"nGtv;\", (8811, 824)),\n        (\"downh\", (0, 0)),\n        (\"commat;\", (64, 0)),\n        (\"ContourIntegral;\", (8750, 0)),\n        (\"eacut\", (0, 0)),\n        (\"gnapprox;\", (10890, 0)),\n        (\"breve;\", (728, 0)),\n        (\"iinf\", (0, 0)),\n        (\"hom\", (0, 0)),\n        (\"nlA\", (0, 0)),\n        (\"cupdo\", (0, 0)),\n        (\"ee\", (0, 0)),\n        (\"TScy;\", (1062, 0)),\n        (\"LeftDoubl\", (0, 0)),\n        (\"Succee\", (0, 0)),\n        (\"curlyv\", (0, 0)),\n        (\"rightarro\", (0, 0)),\n        (\"rbrace\", (0, 0)),\n        (\"NotGreaterFullE\", (0, 0)),\n        (\"quest;\", (63, 0)),\n        (\"cuvee\", (0, 0)),\n        (\"Cou\", (0, 0)),\n        (\"ReverseE\", (0, 0)),\n        (\"barwedg\", (0, 0)),\n        (\"succc\", (0, 0)),\n        (\"B\", (0, 0)),\n        (\"Uring\", (0, 0)),\n        (\"supne;\", (8843, 0)),\n        (\"capca\", (0, 0)),\n        (\"ohba\", (0, 0)),\n        (\"CloseCurlyQuote\", (0, 0)),\n        (\"nleqs\", (0, 0)),\n        (\"thksi\", (0, 0)),\n        (\"dol\", (0, 0)),\n        (\"ro\", (0, 0)),\n        (\"NotSucceedsSlantEqu\", (0, 0)),\n        (\"VerticalTi\", (0, 0)),\n        (\"LessGrea\", (0, 0)),\n        (\"copro\", (0, 0)),\n        (\"LessSlantEqual\", (0, 0)),\n        (\"upsilo\", (0, 0)),\n        (\"osol\", (0, 0)),\n        (\"peri\", (0, 0)),\n        (\"NotTildeE\", (0, 0)),\n        (\"varsupse\", (0, 0)),\n        (\"Eogon;\", (280, 0)),\n        (\"Ys\", (0, 0)),\n        (\"NotGreaterSlant\", (0, 0)),\n        (\"PrecedesEqual;\", (10927, 0)),\n        (\"FilledSmall\", (0, 0)),\n        (\"updownarrow;\", (8597, 0)),\n        (\"cupdot;\", (8845, 0)),\n        (\"Verb\", (0, 0)),\n        (\"subse\", (0, 0)),\n        (\"swar\", (0, 0)),\n        (\"pop\", (0, 0)),\n        (\"YAcy\", (0, 0)),\n        (\"PrecedesEqual\", (0, 0)),\n        (\"rHa\", (0, 0)),\n        (\"Bernoullis;\", (8492, 0)),\n        (\"DownRigh\", (0, 0)),\n        (\"circlearrowlef\", (0, 0)),\n        (\"hair\", (0, 0)),\n        (\"odi\", (0, 0)),\n        (\"NotTildeFullEqu\", (0, 0)),\n        (\"ntrianglele\", (0, 0)),\n        (\"Verbar;\", (8214, 0)),\n        (\"llcorner;\", (8990, 0)),\n        (\"AMP\", (38, 0)),\n        (\"hardc\", (0, 0)),\n        (\"LessFullEqu\", (0, 0)),\n        (\"ucy\", (0, 0)),\n        (\"rtri\", (0, 0)),\n        (\"Longleftarrow;\", (10232, 0)),\n        (\"SquareSupersetE\", (0, 0)),\n        (\"gesles;\", (10900, 0)),\n        (\"gg\", (0, 0)),\n        (\"Nscr;\", (119977, 0)),\n        (\"sqsubsete\", (0, 0)),\n        (\"twoheadrig\", (0, 0)),\n        (\"curvear\", (0, 0)),\n        (\"eqcirc\", (0, 0)),\n        (\"ClockwiseContourInt\", (0, 0)),\n        (\"Mop\", (0, 0)),\n        (\"pointint\", (0, 0)),\n        (\"NotTild\", (0, 0)),\n        (\"empt\", (0, 0)),\n        (\"Sma\", (0, 0)),\n        (\"aleph;\", (8501, 0)),\n        (\"copysr;\", (8471, 0)),\n        (\"la\", (0, 0)),\n        (\"lAa\", (0, 0)),\n        (\"Iop\", (0, 0)),\n        (\"CloseCurlyDoubleQuot\", (0, 0)),\n        (\"ltrie;\", (8884, 0)),\n        (\"rul\", (0, 0)),\n        (\"Umacr;\", (362, 0)),\n        (\"NJcy;\", (1034, 0)),\n        (\"NotSupersetEqual;\", (8841, 0)),\n        (\"rlar\", (0, 0)),\n        (\"NotPrecedesEqual\", (0, 0)),\n        (\"sopf;\", (120164, 0)),\n        (\"fork;\", (8916, 0)),\n        (\"Jopf;\", (120129, 0)),\n        (\"nsccue\", (0, 0)),\n        (\"leftrightarrow;\", (8596, 0)),\n        (\"ForAll\", (0, 0)),\n        (\"urin\", (0, 0)),\n        (\"nvap\", (0, 0)),\n        (\"squf;\", (9642, 0)),\n        (\"Gbreve\", (0, 0)),\n        (\"lmidot;\", (320, 0)),\n        (\"mapstoleft;\", (8612, 0)),\n        (\"er\", (0, 0)),\n        (\"LeftDownTeeVe\", (0, 0)),\n        (\"ominu\", (0, 0)),\n        (\"sharp;\", (9839, 0)),\n        (\"ccaps;\", (10829, 0)),\n        (\"Thet\", (0, 0)),\n        (\"Upsilo\", (0, 0)),\n        (\"rightharpoonup;\", (8640, 0)),\n        (\"spades;\", (9824, 0)),\n        (\"rightharpoond\", (0, 0)),\n        (\"SquareSubset;\", (8847, 0)),\n        (\"yscr;\", (120014, 0)),\n        (\"iac\", (0, 0)),\n        (\"permil\", (0, 0)),\n        (\"Rsh\", (0, 0)),\n        (\"rangd\", (0, 0)),\n        (\"els\", (0, 0)),\n        (\"cuepr\", (0, 0)),\n        (\"Ama\", (0, 0)),\n        (\"TripleDot;\", (8411, 0)),\n        (\"OpenCurlyDoubleQuote;\", (8220, 0)),\n        (\"gesl;\", (8923, 65024)),\n        (\"yci\", (0, 0)),\n        (\"nlAr\", (0, 0)),\n        (\"notnivc\", (0, 0)),\n        (\"gscr;\", (8458, 0)),\n        (\"NegativeMe\", (0, 0)),\n        (\"twi\", (0, 0)),\n        (\"lvertneqq\", (0, 0)),\n        (\"eth\", (240, 0)),\n        (\"Pi\", (0, 0)),\n        (\"MediumSpac\", (0, 0)),\n        (\"ultri\", (0, 0)),\n        (\"LongLeftA\", (0, 0)),\n        (\"SquareSupers\", (0, 0)),\n        (\"TildeT\", (0, 0)),\n        (\"FilledSmallSquare;\", (9724, 0)),\n        (\"nvrAr\", (0, 0)),\n        (\"nsho\", (0, 0)),\n        (\"RightAngl\", (0, 0)),\n        (\"dcy;\", (1076, 0)),\n        (\"RightVecto\", (0, 0)),\n        (\"szlig\", (223, 0)),\n        (\"NotSucce\", (0, 0)),\n        (\"lna\", (0, 0)),\n        (\"Not;\", (10988, 0)),\n        (\"InvisibleTimes\", (0, 0)),\n        (\"acir\", (0, 0)),\n        (\"uharr\", (0, 0)),\n        (\"RightFloor\", (0, 0)),\n        (\"npars\", (0, 0)),\n        (\"DownArro\", (0, 0)),\n        (\"squ\", (0, 0)),\n        (\"numer\", (0, 0)),\n        (\"Cc\", (0, 0)),\n        (\"succappr\", (0, 0)),\n        (\"cwco\", (0, 0)),\n        (\"dso\", (0, 0)),\n        (\"bu\", (0, 0)),\n        (\"Alph\", (0, 0)),\n        (\"UpTeeArrow;\", (8613, 0)),\n        (\"upharpoonrig\", (0, 0)),\n        (\"rarrt\", (0, 0)),\n        (\"expectati\", (0, 0)),\n        (\"easter\", (0, 0)),\n        (\"nsime\", (0, 0)),\n        (\"OpenC\", (0, 0)),\n        (\"lparl\", (0, 0)),\n        (\"LongRightA\", (0, 0)),\n        (\"NotGreate\", (0, 0)),\n        (\"LeftTria\", (0, 0)),\n        (\"sscr\", (0, 0)),\n        (\"drbkarow;\", (10512, 0)),\n        (\"Fscr;\", (8497, 0)),\n        (\"scap\", (0, 0)),\n        (\"minusdu\", (0, 0)),\n        (\"ycy\", (0, 0)),\n        (\"curlyve\", (0, 0)),\n        (\"trpezium\", (0, 0)),\n        (\"smtes\", (0, 0)),\n        (\"subr\", (0, 0)),\n        (\"For\", (0, 0)),\n        (\"dzcy;\", (1119, 0)),\n        (\"UpEquilibriu\", (0, 0)),\n        (\"order\", (0, 0)),\n        (\"iogon;\", (303, 0)),\n        (\"racute;\", (341, 0)),\n        (\"shortparallel\", (0, 0)),\n        (\"TildeFul\", (0, 0)),\n        (\"Ro\", (0, 0)),\n        (\"proflin\", (0, 0)),\n        (\"iukc\", (0, 0)),\n        (\"VeryThi\", (0, 0)),\n        (\"blo\", (0, 0)),\n        (\"Lmidot;\", (319, 0)),\n        (\"IJlig\", (0, 0)),\n        (\"LeftAng\", (0, 0)),\n        (\"circe\", (0, 0)),\n        (\"Ts\", (0, 0)),\n        (\"exponentiale;\", (8519, 0)),\n        (\"TildeFullE\", (0, 0)),\n        (\"angmsdab;\", (10665, 0)),\n        (\"Jo\", (0, 0)),\n        (\"Lscr;\", (8466, 0)),\n        (\"dis\", (0, 0)),\n        (\"Ut\", (0, 0)),\n        (\"odo\", (0, 0)),\n        (\"uwangle;\", (10663, 0)),\n        (\"apaci\", (0, 0)),\n        (\"comm\", (0, 0)),\n        (\"cirs\", (0, 0)),\n        (\"risin\", (0, 0)),\n        (\"NotSquareSupe\", (0, 0)),\n        (\"uparrow\", (0, 0)),\n        (\"UnderBracke\", (0, 0)),\n        (\"xlar\", (0, 0)),\n        (\"NotPrecedesEqual;\", (10927, 824)),\n        (\"Zscr;\", (119989, 0)),\n        (\"barwedge\", (0, 0)),\n        (\"Oop\", (0, 0)),\n        (\"bigsq\", (0, 0)),\n        (\"llcorn\", (0, 0)),\n        (\"backepsil\", (0, 0)),\n        (\"LJc\", (0, 0)),\n        (\"kh\", (0, 0)),\n        (\"varsupsetneq;\", (8843, 65024)),\n        (\"ve\", (0, 0)),\n        (\"omicron;\", (959, 0)),\n        (\"leftrightarro\", (0, 0)),\n        (\"leftrightarr\", (0, 0)),\n        (\"caret\", (0, 0)),\n        (\"topf\", (0, 0)),\n        (\"sdot\", (0, 0)),\n        (\"thickappr\", (0, 0)),\n        (\"radi\", (0, 0)),\n        (\"dopf;\", (120149, 0)),\n        (\"nex\", (0, 0)),\n        (\"copy\", (169, 0)),\n        (\"NotLessE\", (0, 0)),\n        (\"vltri\", (0, 0)),\n        (\"comma;\", (44, 0)),\n        (\"hoar\", (0, 0)),\n        (\"orig\", (0, 0)),\n        (\"nshortparal\", (0, 0)),\n        (\"rightsquiga\", (0, 0)),\n        (\"RightDown\", (0, 0)),\n        (\"ap\", (0, 0)),\n        (\"nltrie\", (0, 0)),\n        (\"HumpDow\", (0, 0)),\n        (\"straightph\", (0, 0)),\n        (\"circlearrowleft;\", (8634, 0)),\n        (\"tw\", (0, 0)),\n        (\"olci\", (0, 0)),\n        (\"phmm\", (0, 0)),\n        (\"SOFT\", (0, 0)),\n        (\"gopf\", (0, 0)),\n        (\"dotsquare\", (0, 0)),\n        (\"Bumpeq\", (0, 0)),\n        (\"erar\", (0, 0)),\n        (\"boxbo\", (0, 0)),\n        (\"nVDas\", (0, 0)),\n        (\"shch\", (0, 0)),\n        (\"OverBra\", (0, 0)),\n        (\"angmsdac\", (0, 0)),\n        (\"RightArrowLef\", (0, 0)),\n        (\"bigca\", (0, 0)),\n        (\"NotReverseElemen\", (0, 0)),\n        (\"perp\", (0, 0)),\n        (\"appr\", (0, 0)),\n        (\"js\", (0, 0)),\n        (\"profline\", (0, 0)),\n        (\"Wedge\", (0, 0)),\n        (\"LeftArrow;\", (8592, 0)),\n        (\"nwnear;\", (10535, 0)),\n        (\"eqvparsl\", (0, 0)),\n        (\"Vbar;\", (10987, 0)),\n        (\"lpa\", (0, 0)),\n        (\"searrow\", (0, 0)),\n        (\"DJ\", (0, 0)),\n        (\"nlarr;\", (8602, 0)),\n        (\"bigci\", (0, 0)),\n        (\"Clockwi\", (0, 0)),\n        (\"Sups\", (0, 0)),\n        (\"loarr\", (0, 0)),\n        (\"Cro\", (0, 0)),\n        (\"Beca\", (0, 0)),\n        (\"cirf\", (0, 0)),\n        (\"NotLeftTriangleEqu\", (0, 0)),\n        (\"vartriangl\", (0, 0)),\n        (\"real\", (0, 0)),\n        (\"ZeroWidthSp\", (0, 0)),\n        (\"lba\", (0, 0)),\n        (\"NotRightTriangleBar\", (0, 0)),\n        (\"oplus;\", (8853, 0)),\n        (\"times\", (215, 0)),\n        (\"rightr\", (0, 0)),\n        (\"leftri\", (0, 0)),\n        (\"Dcaron\", (0, 0)),\n        (\"rarrbfs;\", (10528, 0)),\n        (\"nLeftrightarr\", (0, 0)),\n        (\"ReverseUpE\", (0, 0)),\n        (\"DownLeftRightVector;\", (10576, 0)),\n        (\"pert\", (0, 0)),\n        (\"DoubleLongRightArro\", (0, 0)),\n        (\"iukcy;\", (1110, 0)),\n        (\"lowa\", (0, 0)),\n        (\"og\", (0, 0)),\n        (\"Cente\", (0, 0)),\n        (\"kcedil;\", (311, 0)),\n        (\"DoubleLongLeftRightArro\", (0, 0)),\n        (\"bnot\", (0, 0)),\n        (\"nrarrw;\", (8605, 824)),\n        (\"rfr;\", (120111, 0)),\n        (\"oti\", (0, 0)),\n        (\"Left\", (0, 0)),\n        (\"OverParenthesis;\", (9180, 0)),\n        (\"measuredangle\", (0, 0)),\n        (\"fpart\", (0, 0)),\n        (\"dotsquar\", (0, 0)),\n        (\"NotSquareSubsetEq\", (0, 0)),\n        (\"DiacriticalAcute\", (0, 0)),\n        (\"DS\", (0, 0)),\n        (\"downharpoonleft;\", (8643, 0)),\n        (\"harrcir\", (0, 0)),\n        (\"DownLeftRightVec\", (0, 0)),\n        (\"Egr\", (0, 0)),\n        (\"Jserc\", (0, 0)),\n        (\"ShortL\", (0, 0)),\n        (\"lessd\", (0, 0)),\n        (\"succcu\", (0, 0)),\n        (\"dotplu\", (0, 0)),\n        (\"PlusM\", (0, 0)),\n        (\"hyph\", (0, 0)),\n        (\"rightleftarrows;\", (8644, 0)),\n        (\"LeftTe\", (0, 0)),\n        (\"EmptySmallSqua\", (0, 0)),\n        (\"NotGreaterFullEq\", (0, 0)),\n        (\"cl\", (0, 0)),\n        (\"rppo\", (0, 0)),\n        (\"ldqu\", (0, 0)),\n        (\"DiacriticalDot\", (0, 0)),\n        (\"nvdas\", (0, 0)),\n        (\"LessTil\", (0, 0)),\n        (\"LowerRightArrow\", (0, 0)),\n        (\"dalet\", (0, 0)),\n        (\"Otilde\", (213, 0)),\n        (\"sh\", (0, 0)),\n        (\"lbrke;\", (10635, 0)),\n        (\"seArr;\", (8664, 0)),\n        (\"oma\", (0, 0)),\n        (\"gEl\", (0, 0)),\n        (\"NonBreakingSpace\", (0, 0)),\n        (\"LessEqualGreat\", (0, 0)),\n        (\"uhblk;\", (9600, 0)),\n        (\"timesba\", (0, 0)),\n        (\"bopf\", (0, 0)),\n        (\"CloseCu\", (0, 0)),\n        (\"curlyvee\", (0, 0)),\n        (\"thksim;\", (8764, 0)),\n        (\"boxvH;\", (9578, 0)),\n        (\"luruha\", (0, 0)),\n        (\"vns\", (0, 0)),\n        (\"Hopf;\", (8461, 0)),\n        (\"CloseCurlyDoub\", (0, 0)),\n        (\"Square;\", (9633, 0)),\n        (\"subs\", (0, 0)),\n        (\"fltn\", (0, 0)),\n        (\"diga\", (0, 0)),\n        (\"rfloo\", (0, 0)),\n        (\"nspar;\", (8742, 0)),\n        (\"rightleftar\", (0, 0)),\n        (\"precnapprox;\", (10937, 0)),\n        (\"leftharpo\", (0, 0)),\n        (\"nleq;\", (8816, 0)),\n        (\"boxVR\", (0, 0)),\n        (\"range\", (0, 0)),\n        (\"robrk\", (0, 0)),\n        (\"xup\", (0, 0)),\n        (\"vangrt\", (0, 0)),\n        (\"nLeftrightarro\", (0, 0)),\n        (\"var\", (0, 0)),\n        (\"nRi\", (0, 0)),\n        (\"gnE\", (0, 0)),\n        (\"cros\", (0, 0)),\n        (\"pla\", (0, 0)),\n        (\"RightF\", (0, 0)),\n        (\"DoubleUpDownArrow;\", (8661, 0)),\n        (\"trianglerighte\", (0, 0)),\n        (\"Sfr\", (0, 0)),\n        (\"copys\", (0, 0)),\n        (\"xcir\", (0, 0)),\n        (\"odbla\", (0, 0)),\n        (\"rHar\", (0, 0)),\n        (\"yuc\", (0, 0)),\n        (\"alefsy\", (0, 0)),\n        (\"bigwedge;\", (8896, 0)),\n        (\"olar\", (0, 0)),\n        (\"Igrave\", (204, 0)),\n        (\"EmptyVerySmallSquar\", (0, 0)),\n        (\"ContourInte\", (0, 0)),\n        (\"vartrianglerigh\", (0, 0)),\n        (\"NegativeThinSpac\", (0, 0)),\n        (\"twoheadrightarrow;\", (8608, 0)),\n        (\"subne\", (0, 0)),\n        (\"NegativeTh\", (0, 0)),\n        (\"lBarr\", (0, 0)),\n        (\"oeli\", (0, 0)),\n        (\"Iota\", (0, 0)),\n        (\"intcal;\", (8890, 0)),\n        (\"equals\", (0, 0)),\n        (\"frac2\", (0, 0)),\n        (\"abreve;\", (259, 0)),\n        (\"upharpoonri\", (0, 0)),\n        (\"DiacriticalDoub\", (0, 0)),\n        (\"pe\", (0, 0)),\n        (\"SquareSubsetEqua\", (0, 0)),\n        (\"Lambda;\", (923, 0)),\n        (\"Dashv;\", (10980, 0)),\n        (\"Za\", (0, 0)),\n        (\"NonBreak\", (0, 0)),\n        (\"LeftUpDownVe\", (0, 0)),\n        (\"setm\", (0, 0)),\n        (\"spadesu\", (0, 0)),\n        (\"Nacut\", (0, 0)),\n        (\"approx;\", (8776, 0)),\n        (\"parsl;\", (11005, 0)),\n        (\"leftrightharpoons\", (0, 0)),\n        (\"rarrap\", (0, 0)),\n        (\"NestedGreaterGreat\", (0, 0)),\n        (\"plusacir;\", (10787, 0)),\n        (\"CircleTimes\", (0, 0)),\n        (\"dwa\", (0, 0)),\n        (\"cul\", (0, 0)),\n        (\"SupersetEqua\", (0, 0)),\n        (\"downha\", (0, 0)),\n        (\"sqcaps;\", (8851, 65024)),\n        (\"Therefo\", (0, 0)),\n        (\"hookrightarrow;\", (8618, 0)),\n        (\"boxDL;\", (9559, 0)),\n        (\"complexes;\", (8450, 0)),\n        (\"dopf\", (0, 0)),\n        (\"nLeftrightarrow;\", (8654, 0)),\n        (\"leftthr\", (0, 0)),\n        (\"rulu\", (0, 0)),\n        (\"NotElemen\", (0, 0)),\n        (\"LessFullE\", (0, 0)),\n        (\"EmptySmallSq\", (0, 0)),\n        (\"rAtail;\", (10524, 0)),\n        (\"zigrar\", (0, 0)),\n        (\"DownArr\", (0, 0)),\n        (\"Yopf\", (0, 0)),\n        (\"boxtimes\", (0, 0)),\n        (\"Upsil\", (0, 0)),\n        (\"nrarrc;\", (10547, 824)),\n        (\"DownLe\", (0, 0)),\n        (\"Bopf\", (0, 0)),\n        (\"minusdu;\", (10794, 0)),\n        (\"TSHc\", (0, 0)),\n        (\"Gdot;\", (288, 0)),\n        (\"LessEqua\", (0, 0)),\n        (\"Re\", (0, 0)),\n        (\"icy;\", (1080, 0)),\n        (\"im\", (0, 0)),\n        (\"bumpE;\", (10926, 0)),\n        (\"Ema\", (0, 0)),\n        (\"or\", (0, 0)),\n        (\"djc\", (0, 0)),\n        (\"phmma\", (0, 0)),\n        (\"ocir\", (0, 0)),\n        (\"profsurf;\", (8979, 0)),\n        (\"looparrowleft;\", (8619, 0)),\n        (\"lefth\", (0, 0)),\n        (\"nabl\", (0, 0)),\n        (\"iq\", (0, 0)),\n        (\"emac\", (0, 0)),\n        (\"odot\", (0, 0)),\n        (\"RightAngleBracke\", (0, 0)),\n        (\"wcir\", (0, 0)),\n        (\"LeftTeeArro\", (0, 0)),\n        (\"oelig;\", (339, 0)),\n        (\"nlef\", (0, 0)),\n        (\"imagline;\", (8464, 0)),\n        (\"ssm\", (0, 0)),\n        (\"NotGrea\", (0, 0)),\n        (\"LowerLef\", (0, 0)),\n        (\"Lfr;\", (120079, 0)),\n        (\"DownRightVecto\", (0, 0)),\n        (\"longmaps\", (0, 0)),\n        (\"sol\", (0, 0)),\n        (\"exponential\", (0, 0)),\n        (\"barwedge;\", (8965, 0)),\n        (\"ltq\", (0, 0)),\n        (\"LongRightArr\", (0, 0)),\n        (\"aa\", (0, 0)),\n        (\"ofr;\", (120108, 0)),\n        (\"numsp;\", (8199, 0)),\n        (\"oscr\", (0, 0)),\n        (\"Iacut\", (0, 0)),\n        (\"lvertneq\", (0, 0)),\n        (\"udar\", (0, 0)),\n        (\"to\", (0, 0)),\n        (\"varsupsetn\", (0, 0)),\n        (\"racute\", (0, 0)),\n        (\"kfr;\", (120104, 0)),\n        (\"mid;\", (8739, 0)),\n        (\"npolint\", (0, 0)),\n        (\"ContourIntegra\", (0, 0)),\n        (\"rightthree\", (0, 0)),\n        (\"velli\", (0, 0)),\n        (\"ngeq\", (0, 0)),\n        (\"nums\", (0, 0)),\n        (\"upd\", (0, 0)),\n        (\"thor\", (0, 0)),\n        (\"rthree;\", (8908, 0)),\n        (\"Pf\", (0, 0)),\n        (\"mapstoup\", (0, 0)),\n        (\"NotGreaterSlantE\", (0, 0)),\n        (\"Poin\", (0, 0)),\n        (\"Laplacetrf\", (0, 0)),\n        (\"roa\", (0, 0)),\n        (\"precn\", (0, 0)),\n        (\"imaglin\", (0, 0)),\n        (\"hookl\", (0, 0)),\n        (\"Ccedil;\", (199, 0)),\n        (\"searhk;\", (10533, 0)),\n        (\"downharpoon\", (0, 0)),\n        (\"RightUpDownVe\", (0, 0)),\n        (\"cf\", (0, 0)),\n        (\"Efr\", (0, 0)),\n        (\"Rrightarrow;\", (8667, 0)),\n        (\"bigodo\", (0, 0)),\n        (\"Wcir\", (0, 0)),\n        (\"loang;\", (10220, 0)),\n        (\"rightsquig\", (0, 0)),\n        (\"langd\", (0, 0)),\n        (\"laem\", (0, 0)),\n        (\"nsqsu\", (0, 0)),\n        (\"smallsetminu\", (0, 0)),\n        (\"dl\", (0, 0)),\n        (\"DiacriticalD\", (0, 0)),\n        (\"DownLeftVe\", (0, 0)),\n        (\"DownLeftVectorBar;\", (10582, 0)),\n        (\"vzig\", (0, 0)),\n        (\"varnothing;\", (8709, 0)),\n        (\"Rri\", (0, 0)),\n        (\"NonBre\", (0, 0)),\n        (\"andv;\", (10842, 0)),\n        (\"NotLessSlantEqual;\", (10877, 824)),\n        (\"isindot\", (0, 0)),\n        (\"nspa\", (0, 0)),\n        (\"complemen\", (0, 0)),\n        (\"frac56;\", (8538, 0)),\n        (\"ReverseUpEqui\", (0, 0)),\n        (\"varsubs\", (0, 0)),\n        (\"sacut\", (0, 0)),\n        (\"bnequi\", (0, 0)),\n        (\"DownArrow\", (0, 0)),\n        (\"UpperRight\", (0, 0)),\n        (\"Jsercy\", (0, 0)),\n        (\"ac\", (0, 0)),\n        (\"lfi\", (0, 0)),\n        (\"natura\", (0, 0)),\n        (\"TildeEqua\", (0, 0)),\n        (\"UpArrowBar;\", (10514, 0)),\n        (\"uparr\", (0, 0)),\n        (\"Uogon;\", (370, 0)),\n        (\"pcy\", (0, 0)),\n        (\"Dcaron;\", (270, 0)),\n        (\"Cconint;\", (8752, 0)),\n        (\"LessFul\", (0, 0)),\n        (\"ReverseUpEq\", (0, 0)),\n        (\"cylc\", (0, 0)),\n        (\"DoubleLeftTee;\", (10980, 0)),\n        (\"oopf;\", (120160, 0)),\n        (\"nR\", (0, 0)),\n        (\"hami\", (0, 0)),\n        (\"nesea\", (0, 0)),\n        (\"mcy\", (0, 0)),\n        (\"boxm\", (0, 0)),\n        (\"RightTeeArro\", (0, 0)),\n        (\"varsubsetneqq\", (0, 0)),\n        (\"lthr\", (0, 0)),\n        (\"dharl\", (0, 0)),\n        (\"mD\", (0, 0)),\n        (\"OpenCurly\", (0, 0)),\n        (\"UpperLeftA\", (0, 0)),\n        (\"DownLeftRightVector\", (0, 0)),\n        (\"lneqq;\", (8808, 0)),\n        (\"rightsq\", (0, 0)),\n        (\"DotE\", (0, 0)),\n        (\"SquareIntersect\", (0, 0)),\n        (\"Succeeds;\", (8827, 0)),\n        (\"ReverseElemen\", (0, 0)),\n        (\"RightArrowLeftArr\", (0, 0)),\n        (\"gla\", (0, 0)),\n        (\"CircleM\", (0, 0)),\n        (\"VeryThinSpac\", (0, 0)),\n        (\"elin\", (0, 0)),\n        (\"xu\", (0, 0)),\n        (\"UpEquil\", (0, 0)),\n        (\"big\", (0, 0)),\n        (\"Bfr;\", (120069, 0)),\n        (\"Cross;\", (10799, 0)),\n        (\"gdo\", (0, 0)),\n        (\"ctdot\", (0, 0)),\n        (\"larrfs\", (0, 0)),\n        (\"vnsub;\", (8834, 8402)),\n        (\"leftharpoonu\", (0, 0)),\n        (\"cdot;\", (267, 0)),\n        (\"NotExist\", (0, 0)),\n        (\"NotCongru\", (0, 0)),\n        (\"lB\", (0, 0)),\n        (\"curlyvee;\", (8910, 0)),\n        (\"ShortLe\", (0, 0)),\n        (\"prece\", (0, 0)),\n        (\"Aring;\", (197, 0)),\n        (\"tar\", (0, 0)),\n        (\"Zdo\", (0, 0)),\n        (\"Bscr\", (0, 0)),\n        (\"upupar\", (0, 0)),\n        (\"NotSquareSuperset;\", (8848, 824)),\n        (\"origof\", (0, 0)),\n        (\"sset\", (0, 0)),\n        (\"Differential\", (0, 0)),\n        (\"NegativeThickSpace\", (0, 0)),\n        (\"CloseCurlyQuote;\", (8217, 0)),\n        (\"SquareIntersection\", (0, 0)),\n        (\"su\", (0, 0)),\n        (\"downarr\", (0, 0)),\n        (\"GreaterEq\", (0, 0)),\n        (\"leftrightharpo\", (0, 0)),\n        (\"LessFu\", (0, 0)),\n        (\"ecolon;\", (8789, 0)),\n        (\"LeftVe\", (0, 0)),\n        (\"ks\", (0, 0)),\n        (\"Theref\", (0, 0)),\n        (\"Sci\", (0, 0)),\n        (\"lrhar\", (0, 0)),\n        (\"ntilde;\", (241, 0)),\n        (\"iop\", (0, 0)),\n        (\"suphso\", (0, 0)),\n        (\"DoubleLongLeftRightArr\", (0, 0)),\n        (\"hyp\", (0, 0)),\n        (\"Ntild\", (0, 0)),\n        (\"rdldh\", (0, 0)),\n        (\"notni\", (0, 0)),\n        (\"rdca;\", (10551, 0)),\n        (\"Ccedi\", (0, 0)),\n        (\"leftarrow\", (0, 0)),\n        (\"Leftarrow\", (0, 0)),\n        (\"Dia\", (0, 0)),\n        (\"IOcy\", (0, 0)),\n        (\"Vcy;\", (1042, 0)),\n        (\"zd\", (0, 0)),\n        (\"QUOT;\", (34, 0)),\n        (\"YAc\", (0, 0)),\n        (\"angz\", (0, 0)),\n        (\"co\", (0, 0)),\n        (\"Lleftarro\", (0, 0)),\n        (\"odiv;\", (10808, 0)),\n        (\"Leftri\", (0, 0)),\n        (\"Horizo\", (0, 0)),\n        (\"Longlefta\", (0, 0)),\n        (\"LeftVecto\", (0, 0)),\n        (\"Nscr\", (0, 0)),\n        (\"Aa\", (0, 0)),\n        (\"RightUpVectorBar;\", (10580, 0)),\n        (\"Con\", (0, 0)),\n        (\"ldrdhar\", (0, 0)),\n        (\"Iuml\", (207, 0)),\n        (\"sacu\", (0, 0)),\n        (\"nLt\", (0, 0)),\n        (\"circlearr\", (0, 0)),\n        (\"AEli\", (0, 0)),\n        (\"Lacute\", (0, 0)),\n        (\"NotSuc\", (0, 0)),\n        (\"llarr\", (0, 0)),\n        (\"Negat\", (0, 0)),\n        (\"intercal\", (0, 0)),\n        (\"twoheadrighta\", (0, 0)),\n        (\"lefthar\", (0, 0)),\n        (\"middot\", (183, 0)),\n        (\"prc\", (0, 0)),\n        (\"Minu\", (0, 0)),\n        (\"tau\", (0, 0)),\n        (\"yacy\", (0, 0)),\n        (\"andand;\", (10837, 0)),\n        (\"LeftDownTeeVecto\", (0, 0)),\n        (\"ntriangl\", (0, 0)),\n        (\"scpolin\", (0, 0)),\n        (\"DownArrowUpArr\", (0, 0)),\n        (\"jmath;\", (567, 0)),\n        (\"ique\", (0, 0)),\n        (\"Ho\", (0, 0)),\n        (\"Ari\", (0, 0)),\n        (\"nscr;\", (120003, 0)),\n        (\"utilde;\", (361, 0)),\n        (\"succnsim\", (0, 0)),\n        (\"Bopf;\", (120121, 0)),\n        (\"InvisibleCo\", (0, 0)),\n        (\"barwe\", (0, 0)),\n        (\"lam\", (0, 0)),\n        (\"capcu\", (0, 0)),\n        (\"NotCu\", (0, 0)),\n        (\"rarrhk;\", (8618, 0)),\n        (\"bf\", (0, 0)),\n        (\"wfr;\", (120116, 0)),\n        (\"GreaterSl\", (0, 0)),\n        (\"wreat\", (0, 0)),\n        (\"leftthreetimes;\", (8907, 0)),\n        (\"a\", (0, 0)),\n        (\"mapsto\", (0, 0)),\n        (\"acute\", (180, 0)),\n        (\"mldr\", (0, 0)),\n        (\"VerticalLi\", (0, 0)),\n        (\"rnmid\", (0, 0)),\n        (\"Succ\", (0, 0)),\n        (\"LeftTriangle\", (0, 0)),\n        (\"dz\", (0, 0)),\n        (\"hy\", (0, 0)),\n        (\"LongLeftRig\", (0, 0)),\n        (\"LeftDoubleBrac\", (0, 0)),\n        (\"NonB\", (0, 0)),\n        (\"DownLeftTe\", (0, 0)),\n        (\"frac18;\", (8539, 0)),\n        (\"disi\", (0, 0)),\n        (\"Longleftrightarrow;\", (10234, 0)),\n        (\"lambda;\", (955, 0)),\n        (\"rBarr;\", (10511, 0)),\n        (\"boxt\", (0, 0)),\n        (\"nvle\", (0, 0)),\n        (\"ograv\", (0, 0)),\n        (\"poin\", (0, 0)),\n        (\"xlArr;\", (10232, 0)),\n        (\"rdquor;\", (8221, 0)),\n        (\"Iukcy\", (0, 0)),\n        (\"tp\", (0, 0)),\n        (\"ge;\", (8805, 0)),\n        (\"rceil;\", (8969, 0)),\n        (\"Lt;\", (8810, 0)),\n        (\"acirc;\", (226, 0)),\n        (\"bullet;\", (8226, 0)),\n        (\"sm\", (0, 0)),\n        (\"LJ\", (0, 0)),\n        (\"rightha\", (0, 0)),\n        (\"NotGreaterSlantEqual\", (0, 0)),\n        (\"hookleftarrow;\", (8617, 0)),\n        (\"qopf\", (0, 0)),\n        (\"ShortRightArrow\", (0, 0)),\n        (\"rppol\", (0, 0)),\n        (\"caps\", (0, 0)),\n        (\"quo\", (0, 0)),\n        (\"ycirc\", (0, 0)),\n        (\"digamm\", (0, 0)),\n        (\"LT\", (60, 0)),\n        (\"rlarr\", (0, 0)),\n        (\"Udblac\", (0, 0)),\n        (\"yen;\", (165, 0)),\n        (\"luruhar\", (0, 0)),\n        (\"ddarr\", (0, 0)),\n        (\"nexist;\", (8708, 0)),\n        (\"RoundImplie\", (0, 0)),\n        (\"rightharpoondo\", (0, 0)),\n        (\"nsqsupe;\", (8931, 0)),\n        (\"Minus\", (0, 0)),\n        (\"bigv\", (0, 0)),\n        (\"Backs\", (0, 0)),\n        (\"nleftrigh\", (0, 0)),\n        (\"plusa\", (0, 0)),\n        (\"rtr\", (0, 0)),\n        (\"NotLessG\", (0, 0)),\n        (\"Barw\", (0, 0)),\n        (\"ShortRightA\", (0, 0)),\n        (\"vrt\", (0, 0)),\n        (\"epl\", (0, 0)),\n        (\"lbra\", (0, 0)),\n        (\"nh\", (0, 0)),\n        (\"bigtriangledown\", (0, 0)),\n        (\"longmapst\", (0, 0)),\n        (\"LeftTriangleEqu\", (0, 0)),\n        (\"zac\", (0, 0)),\n        (\"bigtriangleup\", (0, 0)),\n        (\"lesdot;\", (10879, 0)),\n        (\"hai\", (0, 0)),\n        (\"llar\", (0, 0)),\n        (\"sma\", (0, 0)),\n        (\"fltns\", (0, 0)),\n        (\"Icirc\", (206, 0)),\n        (\"MediumSpa\", (0, 0)),\n        (\"cwconint;\", (8754, 0)),\n        (\"blacklo\", (0, 0)),\n        (\"Cl\", (0, 0)),\n        (\"ncedil;\", (326, 0)),\n        (\"lopf\", (0, 0)),\n        (\"Is\", (0, 0)),\n        (\"eqslan\", (0, 0)),\n        (\"ohbar\", (0, 0)),\n        (\"xodot;\", (10752, 0)),\n        (\"rarrb\", (0, 0)),\n        (\"supds\", (0, 0)),\n        (\"down\", (0, 0)),\n        (\"Differentia\", (0, 0)),\n        (\"nhA\", (0, 0)),\n        (\"LeftCeiling\", (0, 0)),\n        (\"measure\", (0, 0)),\n        (\"NotLessSlantE\", (0, 0)),\n        (\"supseteq\", (0, 0)),\n        (\"Ecir\", (0, 0)),\n        (\"Afr;\", (120068, 0)),\n        (\"barve\", (0, 0)),\n        (\"LeftDoubleBracket\", (0, 0)),\n        (\"downdowna\", (0, 0)),\n        (\"planckh;\", (8462, 0)),\n        (\"Aogon\", (0, 0)),\n        (\"plusb;\", (8862, 0)),\n        (\"center\", (0, 0)),\n        (\"PrecedesEqu\", (0, 0)),\n        (\"rsh;\", (8625, 0)),\n        (\"Mellin\", (0, 0)),\n        (\"SubsetEqu\", (0, 0)),\n        (\"gve\", (0, 0)),\n        (\"LeftArrowRightArrow\", (0, 0)),\n        (\"Ar\", (0, 0)),\n        (\"loang\", (0, 0)),\n        (\"supmul\", (0, 0)),\n        (\"Horizontal\", (0, 0)),\n        (\"Cac\", (0, 0)),\n        (\"supe;\", (8839, 0)),\n        (\"LeftRightArrow\", (0, 0)),\n        (\"gbreve;\", (287, 0)),\n        (\"LeftVect\", (0, 0)),\n        (\"micro;\", (181, 0)),\n        (\"fl\", (0, 0)),\n        (\"RightCeiling\", (0, 0)),\n        (\"em\", (0, 0)),\n        (\"Rca\", (0, 0)),\n        (\"OpenCurlyDoubl\", (0, 0)),\n        (\"bcong;\", (8780, 0)),\n        (\"HorizontalLin\", (0, 0)),\n        (\"nvHa\", (0, 0)),\n        (\"CloseCurlyDoubleQuo\", (0, 0)),\n        (\"rAr\", (0, 0)),\n        (\"RightDownVectorB\", (0, 0)),\n        (\"NotNestedGreaterGr\", (0, 0)),\n        (\"rightthreetime\", (0, 0)),\n        (\"nlArr;\", (8653, 0)),\n        (\"DownArrowUpAr\", (0, 0)),\n        (\"Iti\", (0, 0)),\n        (\"nsupseteqq\", (0, 0)),\n        (\"nrarr;\", (8603, 0)),\n        (\"lesdoto;\", (10881, 0)),\n        (\"angmsdah;\", (10671, 0)),\n        (\"OverPare\", (0, 0)),\n        (\"kfr\", (0, 0)),\n        (\"lsi\", (0, 0)),\n        (\"Be\", (0, 0)),\n        (\"ReverseU\", (0, 0)),\n        (\"low\", (0, 0)),\n        (\"asympeq;\", (8781, 0)),\n        (\"leftarrowtail\", (0, 0)),\n        (\"andv\", (0, 0)),\n        (\"iquest;\", (191, 0)),\n        (\"heartsuit\", (0, 0)),\n        (\"blacktrian\", (0, 0)),\n        (\"UnderBrack\", (0, 0)),\n        (\"vert\", (0, 0)),\n        (\"quat\", (0, 0)),\n        (\"cir\", (0, 0)),\n        (\"wf\", (0, 0)),\n        (\"downdownarrows\", (0, 0)),\n        (\"smallset\", (0, 0)),\n        (\"sccue\", (0, 0)),\n        (\"RightTriangleEqual;\", (8885, 0)),\n        (\"quaternio\", (0, 0)),\n        (\"DownRightTeeVecto\", (0, 0)),\n        (\"eqv\", (0, 0)),\n        (\"npreceq\", (0, 0)),\n        (\"Zac\", (0, 0)),\n        (\"oli\", (0, 0)),\n        (\"parsim\", (0, 0)),\n        (\"supdsub\", (0, 0)),\n        (\"equiv;\", (8801, 0)),\n        (\"ola\", (0, 0)),\n        (\"dtdot;\", (8945, 0)),\n        (\"raempt\", (0, 0)),\n        (\"LeftAngle\", (0, 0)),\n        (\"nshort\", (0, 0)),\n        (\"Rarrtl\", (0, 0)),\n        (\"frac4\", (0, 0)),\n        (\"ltrP\", (0, 0)),\n        (\"curvearrow\", (0, 0)),\n        (\"mdash\", (0, 0)),\n        (\"nearhk\", (0, 0)),\n        (\"suplar\", (0, 0)),\n        (\"GreaterEqualLes\", (0, 0)),\n        (\"kjcy\", (0, 0)),\n        (\"vartheta;\", (977, 0)),\n        (\"llco\", (0, 0)),\n        (\"boxHU;\", (9577, 0)),\n        (\"rightthr\", (0, 0)),\n        (\"nharr\", (0, 0)),\n        (\"para\", (182, 0)),\n        (\"W\", (0, 0)),\n        (\"andslope\", (0, 0)),\n        (\"sqsupsete\", (0, 0)),\n        (\"CircleMinus;\", (8854, 0)),\n        (\"nexi\", (0, 0)),\n        (\"Hilber\", (0, 0)),\n        (\"iex\", (0, 0)),\n        (\"UnionPlu\", (0, 0)),\n        (\"Bumpe\", (0, 0)),\n        (\"acu\", (0, 0)),\n        (\"cw\", (0, 0)),\n        (\"Eop\", (0, 0)),\n        (\"bigupl\", (0, 0)),\n        (\"mapstodown;\", (8615, 0)),\n        (\"hslash\", (0, 0)),\n        (\"Congruent\", (0, 0)),\n        (\"nGg\", (0, 0)),\n        (\"supE;\", (10950, 0)),\n        (\"parsl\", (0, 0)),\n        (\"lsa\", (0, 0)),\n        (\"spadesuit;\", (9824, 0)),\n        (\"ju\", (0, 0)),\n        (\"Juk\", (0, 0)),\n        (\"cwint;\", (8753, 0)),\n        (\"Equilibrium;\", (8652, 0)),\n        (\"Lon\", (0, 0)),\n        (\"NotNestedLe\", (0, 0)),\n        (\"succsim\", (0, 0)),\n        (\"varr\", (0, 0)),\n        (\"rbrke\", (0, 0)),\n        (\"Precedes\", (0, 0)),\n        (\"angmsd;\", (8737, 0)),\n        (\"lth\", (0, 0)),\n        (\"dal\", (0, 0)),\n        (\"GJc\", (0, 0)),\n        (\"ldrushar\", (0, 0)),\n        (\"Upsi;\", (978, 0)),\n        (\"nLtv\", (0, 0)),\n        (\"rationa\", (0, 0)),\n        (\"downharpoonr\", (0, 0)),\n        (\"DoubleDownArrow\", (0, 0)),\n        (\"urcorner\", (0, 0)),\n        (\"tscy;\", (1094, 0)),\n        (\"upharpoonleft;\", (8639, 0)),\n        (\"vBarv\", (0, 0)),\n        (\"square;\", (9633, 0)),\n        (\"HumpEqua\", (0, 0)),\n        (\"jcy;\", (1081, 0)),\n        (\"gtlPar\", (0, 0)),\n        (\"nsucceq\", (0, 0)),\n        (\"sacute;\", (347, 0)),\n        (\"eta;\", (951, 0)),\n        (\"bop\", (0, 0)),\n        (\"PrecedesSlantEqual;\", (8828, 0)),\n        (\"VerticalB\", (0, 0)),\n        (\"NotSucceedsSlantEq\", (0, 0)),\n        (\"vsupnE;\", (10956, 65024)),\n        (\"hoa\", (0, 0)),\n        (\"ea\", (0, 0)),\n        (\"leftrighth\", (0, 0)),\n        (\"LT;\", (60, 0)),\n        (\"divo\", (0, 0)),\n        (\"sra\", (0, 0)),\n        (\"DownLeftR\", (0, 0)),\n        (\"lopa\", (0, 0)),\n        (\"Esim;\", (10867, 0)),\n        (\"rhov\", (0, 0)),\n        (\"xha\", (0, 0)),\n        (\"NotNestedLessLess\", (0, 0)),\n        (\"DoubleLongLeftRightAr\", (0, 0)),\n        (\"kcy\", (0, 0)),\n        (\"Zop\", (0, 0)),\n        (\"nvdash;\", (8876, 0)),\n        (\"NonBreakin\", (0, 0)),\n        (\"NotLeftTriangleE\", (0, 0)),\n        (\"subedot\", (0, 0)),\n        (\"LeftDouble\", (0, 0)),\n        (\"hba\", (0, 0)),\n        (\"DoubleUpArr\", (0, 0)),\n        (\"D\", (0, 0)),\n        (\"bull;\", (8226, 0)),\n        (\"EmptySmallSqu\", (0, 0)),\n        (\"Rule\", (0, 0)),\n        (\"RightTeeV\", (0, 0)),\n        (\"Imag\", (0, 0)),\n        (\"Sh\", (0, 0)),\n        (\"lesdo\", (0, 0)),\n        (\"EmptyVery\", (0, 0)),\n        (\"nla\", (0, 0)),\n        (\"nv\", (0, 0)),\n        (\"botto\", (0, 0)),\n        (\"NotEle\", (0, 0)),\n        (\"InvisibleComm\", (0, 0)),\n        (\"cen\", (0, 0)),\n        (\"QU\", (0, 0)),\n        (\"llt\", (0, 0)),\n        (\"boxhu\", (0, 0)),\n        (\"psi\", (0, 0)),\n        (\"LongLeftArr\", (0, 0)),\n        (\"NotSucceedsEqual;\", (10928, 824)),\n        (\"bempt\", (0, 0)),\n        (\"mcom\", (0, 0)),\n        (\"p\", (0, 0)),\n        (\"Abrev\", (0, 0)),\n        (\"Longl\", (0, 0)),\n        (\"ClockwiseContour\", (0, 0)),\n        (\"NotSucceedsTi\", (0, 0)),\n        (\"curlyeqsuc\", (0, 0)),\n        (\"rpargt\", (0, 0)),\n        (\"lacut\", (0, 0)),\n        (\"TildeFullEqual;\", (8773, 0)),\n        (\"NotRightTri\", (0, 0)),\n        (\"rsaqu\", (0, 0)),\n        (\"shortparall\", (0, 0)),\n        (\"homt\", (0, 0)),\n        (\"nvg\", (0, 0)),\n        (\"rlhar\", (0, 0)),\n        (\"nr\", (0, 0)),\n        (\"bprime;\", (8245, 0)),\n        (\"zeta;\", (950, 0)),\n        (\"LeftTriangleBa\", (0, 0)),\n        (\"supsetn\", (0, 0)),\n        (\"kgreen;\", (312, 0)),\n        (\"uua\", (0, 0)),\n        (\"exi\", (0, 0)),\n        (\"LongLeftRightArro\", (0, 0)),\n        (\"dzc\", (0, 0)),\n        (\"Pcy;\", (1055, 0)),\n        (\"SquareSupersetEq\", (0, 0)),\n        (\"rba\", (0, 0)),\n        (\"Clockwis\", (0, 0)),\n        (\"DJc\", (0, 0)),\n        (\"fpartint;\", (10765, 0)),\n        (\"gesles\", (0, 0)),\n        (\"CloseCurly\", (0, 0)),\n        (\"lowbar;\", (95, 0)),\n        (\"toea\", (0, 0)),\n        (\"OverParenthesis\", (0, 0)),\n        (\"measu\", (0, 0)),\n        (\"inodo\", (0, 0)),\n        (\"jop\", (0, 0)),\n        (\"Psi\", (0, 0)),\n        (\"Yscr\", (0, 0)),\n        (\"RightUpVect\", (0, 0)),\n        (\"NotGreaterGreat\", (0, 0)),\n        (\"acy;\", (1072, 0)),\n        (\"ulcor\", (0, 0)),\n        (\"gla;\", (10917, 0)),\n        (\"emacr\", (0, 0)),\n        (\"nsupe\", (0, 0)),\n        (\"lltri;\", (9722, 0)),\n        (\"COPY;\", (169, 0)),\n        (\"NotSucceedsSl\", (0, 0)),\n        (\"lagran\", (0, 0)),\n        (\"thetav\", (0, 0)),\n        (\"boxVL\", (0, 0)),\n        (\"risingdo\", (0, 0)),\n        (\"NotSucceedsTil\", (0, 0)),\n        (\"blan\", (0, 0)),\n        (\"NotTildeFullEqual\", (0, 0)),\n        (\"DoubleLongLef\", (0, 0)),\n        (\"top\", (0, 0)),\n        (\"tin\", (0, 0)),\n        (\"olcross\", (0, 0)),\n        (\"intege\", (0, 0)),\n        (\"YIcy\", (0, 0)),\n        (\"dw\", (0, 0)),\n        (\"nleftrightar\", (0, 0)),\n        (\"doteq\", (0, 0)),\n        (\"S\", (0, 0)),\n        (\"egs\", (0, 0)),\n        (\"jmat\", (0, 0)),\n        (\"vdas\", (0, 0)),\n        (\"vsup\", (0, 0)),\n        (\"DZcy;\", (1039, 0)),\n        (\"rational\", (0, 0)),\n        (\"rthr\", (0, 0)),\n        (\"imagpart\", (0, 0)),\n        (\"RightUpDownVect\", (0, 0)),\n        (\"GreaterGrea\", (0, 0)),\n        (\"Uri\", (0, 0)),\n        (\"blacktriang\", (0, 0)),\n        (\"GreaterSlantE\", (0, 0)),\n        (\"ncy\", (0, 0)),\n        (\"colone;\", (8788, 0)),\n        (\"rpargt;\", (10644, 0)),\n        (\"lH\", (0, 0)),\n        (\"lgE\", (0, 0)),\n        (\"ari\", (0, 0)),\n        (\"Vf\", (0, 0)),\n        (\"Oma\", (0, 0)),\n        (\"lAtail;\", (10523, 0)),\n        (\"escr;\", (8495, 0)),\n        (\"cylcty\", (0, 0)),\n        (\"Updownarr\", (0, 0)),\n        (\"spades\", (0, 0)),\n        (\"DDotrahd;\", (10513, 0)),\n        (\"AEl\", (0, 0)),\n        (\"fem\", (0, 0)),\n        (\"image;\", (8465, 0)),\n        (\"CapitalDifferential\", (0, 0)),\n        (\"leftrightsquig\", (0, 0)),\n        (\"prurel\", (0, 0)),\n        (\"fallin\", (0, 0)),\n        (\"agr\", (0, 0)),\n        (\"DoubleUpA\", (0, 0)),\n        (\"uhar\", (0, 0)),\n        (\"DownLeftVectorB\", (0, 0)),\n        (\"RightAngleBrac\", (0, 0)),\n        (\"dsol;\", (10742, 0)),\n        (\"vcy;\", (1074, 0)),\n        (\"NestedGr\", (0, 0)),\n        (\"lopar\", (0, 0)),\n        (\"Lmid\", (0, 0)),\n        (\"aeli\", (0, 0)),\n        (\"nsubset;\", (8834, 8402)),\n        (\"LeftRightArr\", (0, 0)),\n        (\"longlef\", (0, 0)),\n        (\"leftleft\", (0, 0)),\n        (\"NewLin\", (0, 0)),\n        (\"dash;\", (8208, 0)),\n        (\"Udbl\", (0, 0)),\n        (\"thickappro\", (0, 0)),\n        (\"LeftUpV\", (0, 0)),\n        (\"awconint\", (0, 0)),\n        (\"DoubleLeftArr\", (0, 0)),\n        (\"qfr\", (0, 0)),\n        (\"DoubleVert\", (0, 0)),\n        (\"rob\", (0, 0)),\n        (\"hArr;\", (8660, 0)),\n        (\"backepsilo\", (0, 0)),\n        (\"DSc\", (0, 0)),\n        (\"RightVe\", (0, 0)),\n        (\"ba\", (0, 0)),\n        (\"bigcup\", (0, 0)),\n        (\"lv\", (0, 0)),\n        (\"Rev\", (0, 0)),\n        (\"fltns;\", (9649, 0)),\n        (\"lAtail\", (0, 0)),\n        (\"OElig\", (0, 0)),\n        (\"looparrowlef\", (0, 0)),\n        (\"swarr\", (0, 0)),\n        (\"olt;\", (10688, 0)),\n        (\"Zc\", (0, 0)),\n        (\"rightlefta\", (0, 0)),\n        (\"OEl\", (0, 0)),\n        (\"triangleright;\", (9657, 0)),\n        (\"cupbrca\", (0, 0)),\n        (\"square\", (0, 0)),\n        (\"Cr\", (0, 0)),\n        (\"longleftrig\", (0, 0)),\n        (\"lced\", (0, 0)),\n        (\"As\", (0, 0)),\n        (\"eacute\", (233, 0)),\n        (\"backsimeq;\", (8909, 0)),\n        (\"rightharp\", (0, 0)),\n        (\"not;\", (172, 0)),\n        (\"ord\", (0, 0)),\n        (\"Gbreve;\", (286, 0)),\n        (\"lve\", (0, 0)),\n        (\"rarrb;\", (8677, 0)),\n        (\"hairsp\", (0, 0)),\n        (\"Pi;\", (928, 0)),\n        (\"ltc\", (0, 0)),\n        (\"Dcar\", (0, 0)),\n        (\"nvlA\", (0, 0)),\n        (\"Dag\", (0, 0)),\n        (\"Imacr;\", (298, 0)),\n        (\"fi\", (0, 0)),\n        (\"leftarrowtai\", (0, 0)),\n        (\"Ascr\", (0, 0)),\n        (\"midast;\", (42, 0)),\n        (\"aogo\", (0, 0)),\n        (\"AElig\", (198, 0)),\n        (\"RightArrowL\", (0, 0)),\n        (\"oh\", (0, 0)),\n        (\"I\", (0, 0)),\n        (\"DiacriticalG\", (0, 0)),\n        (\"NestedLessLess;\", (8810, 0)),\n        (\"Int;\", (8748, 0)),\n        (\"capdo\", (0, 0)),\n        (\"straighte\", (0, 0)),\n        (\"NotExis\", (0, 0)),\n        (\"CupC\", (0, 0)),\n        (\"napprox\", (0, 0)),\n        (\"NotSquareSubsetEqual;\", (8930, 0)),\n        (\"ssmi\", (0, 0)),\n        (\"loti\", (0, 0)),\n        (\"SucceedsEqu\", (0, 0)),\n        (\"hf\", (0, 0)),\n        (\"Dash\", (0, 0)),\n        (\"lceil;\", (8968, 0)),\n        (\"sim\", (0, 0)),\n        (\"tcar\", (0, 0)),\n        (\"ccaps\", (0, 0)),\n        (\"frac12;\", (189, 0)),\n        (\"ufr\", (0, 0)),\n        (\"iff\", (0, 0)),\n        (\"noti\", (0, 0)),\n        (\"Das\", (0, 0)),\n        (\"Tfr\", (0, 0)),\n        (\"apE;\", (10864, 0)),\n        (\"equa\", (0, 0)),\n        (\"leftleftarr\", (0, 0)),\n        (\"NewL\", (0, 0)),\n        (\"ShortRi\", (0, 0)),\n        (\"ddagge\", (0, 0)),\n        (\"diamondsu\", (0, 0)),\n        (\"Ya\", (0, 0)),\n        (\"ul\", (0, 0)),\n        (\"LongRightArrow\", (0, 0)),\n        (\"Hilbe\", (0, 0)),\n        (\"ntgl;\", (8825, 0)),\n        (\"DoubleLeftRigh\", (0, 0)),\n        (\"sstarf\", (0, 0)),\n        (\"blank\", (0, 0)),\n        (\"vopf;\", (120167, 0)),\n        (\"uhbl\", (0, 0)),\n        (\"NotLessEqual\", (0, 0)),\n        (\"NotElem\", (0, 0)),\n        (\"NotLeftTria\", (0, 0)),\n        (\"DoubleContou\", (0, 0)),\n        (\"vopf\", (0, 0)),\n        (\"Xo\", (0, 0)),\n        (\"lmoust\", (0, 0)),\n        (\"NestedGreaterGrea\", (0, 0)),\n        (\"nt\", (0, 0)),\n        (\"NegativeV\", (0, 0)),\n        (\"ShortUpArr\", (0, 0)),\n        (\"alep\", (0, 0)),\n        (\"uopf;\", (120166, 0)),\n        (\"LeftDoubleBrack\", (0, 0)),\n        (\"ngE\", (0, 0)),\n        (\"NJc\", (0, 0)),\n        (\"Precede\", (0, 0)),\n        (\"hybull\", (0, 0)),\n        (\"hybu\", (0, 0)),\n        (\"vartrianglele\", (0, 0)),\n        (\"DoubleLeftRightArr\", (0, 0)),\n        (\"Ccaron;\", (268, 0)),\n        (\"range;\", (10661, 0)),\n        (\"angle\", (0, 0)),\n        (\"Cco\", (0, 0)),\n        (\"SucceedsEqua\", (0, 0)),\n        (\"nisd;\", (8954, 0)),\n        (\"NotSubset\", (0, 0)),\n        (\"rcedi\", (0, 0)),\n        (\"kjcy;\", (1116, 0)),\n        (\"Wedge;\", (8896, 0)),\n        (\"nleftarrow;\", (8602, 0)),\n        (\"there4\", (0, 0)),\n        (\"Iogon;\", (302, 0)),\n        (\"minusb\", (0, 0)),\n        (\"longl\", (0, 0)),\n        (\"NotSupersetEqua\", (0, 0)),\n        (\"trianglele\", (0, 0)),\n        (\"hel\", (0, 0)),\n        (\"ltrPar;\", (10646, 0)),\n        (\"NotGreaterFullEqua\", (0, 0)),\n        (\"CloseCur\", (0, 0)),\n        (\"aelig\", (230, 0)),\n        (\"ltrie\", (0, 0)),\n        (\"tstrok;\", (359, 0)),\n        (\"fopf\", (0, 0)),\n        (\"upharpoonl\", (0, 0)),\n        (\"tshc\", (0, 0)),\n        (\"imo\", (0, 0)),\n        (\"rthree\", (0, 0)),\n        (\"iinfin\", (0, 0)),\n        (\"Longleftri\", (0, 0)),\n        (\"oda\", (0, 0)),\n        (\"EmptyVerySma\", (0, 0)),\n        (\"lang;\", (10216, 0)),\n        (\"rbbrk;\", (10099, 0)),\n        (\"nbump\", (0, 0)),\n        (\"Wscr\", (0, 0)),\n        (\"LeftRightA\", (0, 0)),\n        (\"sesw\", (0, 0)),\n        (\"oint\", (0, 0)),\n        (\"pm;\", (177, 0)),\n        (\"nparal\", (0, 0)),\n        (\"subsup;\", (10963, 0)),\n        (\"Tced\", (0, 0)),\n        (\"xnis\", (0, 0)),\n        (\"lst\", (0, 0)),\n        (\"utdot;\", (8944, 0)),\n        (\"Yfr\", (0, 0)),\n        (\"NegativeThin\", (0, 0)),\n        (\"orv\", (0, 0)),\n        (\"Mu;\", (924, 0)),\n        (\"agrave\", (224, 0)),\n        (\"del\", (0, 0)),\n        (\"GreaterEqualL\", (0, 0)),\n        (\"dwangl\", (0, 0)),\n        (\"approx\", (0, 0)),\n        (\"ClockwiseC\", (0, 0)),\n        (\"Dsc\", (0, 0)),\n        (\"doublebarwedg\", (0, 0)),\n        (\"DownArrowU\", (0, 0)),\n        (\"lrtri\", (0, 0)),\n        (\"NegativeVeryThinSpace;\", (8203, 0)),\n        (\"bump;\", (8782, 0)),\n        (\"bigcirc\", (0, 0)),\n        (\"divideontime\", (0, 0)),\n        (\"uph\", (0, 0)),\n        (\"upharpoonleft\", (0, 0)),\n        (\"bigwed\", (0, 0)),\n        (\"GreaterLess\", (0, 0)),\n        (\"Invisible\", (0, 0)),\n        (\"RightTee\", (0, 0)),\n        (\"measuredan\", (0, 0)),\n        (\"DoubleLef\", (0, 0)),\n        (\"NestedGre\", (0, 0)),\n        (\"eDDot;\", (10871, 0)),\n        (\"Ccirc;\", (264, 0)),\n        (\"RightUpD\", (0, 0)),\n        (\"Sig\", (0, 0)),\n        (\"Scedi\", (0, 0)),\n        (\"NotNestedGrea\", (0, 0)),\n        (\"cwconi\", (0, 0)),\n        (\"DoubleContourInteg\", (0, 0)),\n        (\"curvearrowri\", (0, 0)),\n        (\"lfr;\", (120105, 0)),\n        (\"olin\", (0, 0)),\n        (\"vlt\", (0, 0)),\n        (\"RuleDela\", (0, 0)),\n        (\"imof;\", (8887, 0)),\n        (\"RightTeeVect\", (0, 0)),\n        (\"Mu\", (0, 0)),\n        (\"gescc\", (0, 0)),\n        (\"NotSuperset;\", (8835, 8402)),\n        (\"curlyeqsu\", (0, 0)),\n        (\"Element\", (0, 0)),\n        (\"ut\", (0, 0)),\n        (\"boxminu\", (0, 0)),\n        (\"DoubleUpDownA\", (0, 0)),\n        (\"xoplus\", (0, 0)),\n        (\"varkapp\", (0, 0)),\n        (\"Clock\", (0, 0)),\n        (\"Superset\", (0, 0)),\n        (\"sha\", (0, 0)),\n        (\"cap\", (0, 0)),\n        (\"Ucy\", (0, 0)),\n        (\"neAr\", (0, 0)),\n        (\"isind\", (0, 0)),\n        (\"npolint;\", (10772, 0)),\n        (\"bemptyv\", (0, 0)),\n        (\"cuw\", (0, 0)),\n        (\"Leftarro\", (0, 0)),\n        (\"EmptyVerySmallSqu\", (0, 0)),\n        (\"Cu\", (0, 0)),\n        (\"squar\", (0, 0)),\n        (\"Bec\", (0, 0)),\n        (\"Longleftarrow\", (0, 0)),\n        (\"LeftTriangl\", (0, 0)),\n        (\"nva\", (0, 0)),\n        (\"odsold\", (0, 0)),\n        (\"straightepsil\", (0, 0)),\n        (\"circlearrowleft\", (0, 0)),\n        (\"Cros\", (0, 0)),\n        (\"OEli\", (0, 0)),\n        (\"boxUL\", (0, 0)),\n        (\"DoubleLongR\", (0, 0)),\n        (\"NotTildeT\", (0, 0)),\n        (\"boxVl;\", (9570, 0)),\n        (\"gE;\", (8807, 0)),\n        (\"ThickSpac\", (0, 0)),\n        (\"NotL\", (0, 0)),\n        (\"longri\", (0, 0)),\n        (\"eas\", (0, 0)),\n        (\"ThickSpace\", (0, 0)),\n        (\"Rfr\", (0, 0)),\n        (\"Prod\", (0, 0)),\n        (\"pr;\", (8826, 0)),\n        (\"dot;\", (729, 0)),\n        (\"duarr;\", (8693, 0)),\n        (\"T\", (0, 0)),\n        (\"hbar\", (0, 0)),\n        (\"ange\", (0, 0)),\n        (\"duarr\", (0, 0)),\n        (\"ufish\", (0, 0)),\n        (\"Del;\", (8711, 0)),\n        (\"xv\", (0, 0)),\n        (\"SucceedsSlant\", (0, 0)),\n        (\"ofcir;\", (10687, 0)),\n        (\"forall;\", (8704, 0)),\n        (\"reals;\", (8477, 0)),\n        (\"afr;\", (120094, 0)),\n        (\"rightrigh\", (0, 0)),\n        (\"cirfni\", (0, 0)),\n        (\"rfisht;\", (10621, 0)),\n        (\"nacut\", (0, 0)),\n        (\"Sa\", (0, 0)),\n        (\"VeryThin\", (0, 0)),\n        (\"emp\", (0, 0)),\n        (\"angrtvbd\", (0, 0)),\n        (\"iot\", (0, 0)),\n        (\"cup;\", (8746, 0)),\n        (\"ngsim;\", (8821, 0)),\n        (\"latail\", (0, 0)),\n        (\"dtd\", (0, 0)),\n        (\"neA\", (0, 0)),\n        (\"NotSupersetEqual\", (0, 0)),\n        (\"Lang\", (0, 0)),\n        (\"Exp\", (0, 0)),\n        (\"supedot;\", (10948, 0)),\n        (\"SquareSupe\", (0, 0)),\n        (\"eta\", (0, 0)),\n        (\"slarr;\", (8592, 0)),\n        (\"xdtr\", (0, 0)),\n        (\"euro;\", (8364, 0)),\n        (\"nvrA\", (0, 0)),\n        (\"NotSuccee\", (0, 0)),\n        (\"mnplus\", (0, 0)),\n        (\"emptyset\", (0, 0)),\n        (\"gopf;\", (120152, 0)),\n        (\"profsu\", (0, 0)),\n        (\"RightDoubleBra\", (0, 0)),\n        (\"angmsdab\", (0, 0)),\n        (\"Leftrightar\", (0, 0)),\n        (\"zcaron;\", (382, 0)),\n        (\"timesb;\", (8864, 0)),\n        (\"curlywedg\", (0, 0)),\n        (\"QUO\", (0, 0)),\n        (\"NotReverse\", (0, 0)),\n        (\"ogra\", (0, 0)),\n        (\"hstr\", (0, 0)),\n        (\"NotNe\", (0, 0)),\n        (\"l\", (0, 0)),\n        (\"nab\", (0, 0)),\n        (\"bepsi;\", (1014, 0)),\n        (\"upar\", (0, 0)),\n        (\"Subse\", (0, 0)),\n        (\"rs\", (0, 0)),\n        (\"Congruent;\", (8801, 0)),\n        (\"NotGreaterLes\", (0, 0)),\n        (\"juk\", (0, 0)),\n        (\"Cfr;\", (8493, 0)),\n        (\"nleftrightarrow;\", (8622, 0)),\n        (\"gel;\", (8923, 0)),\n        (\"Leftrig\", (0, 0)),\n        (\"Uarroci\", (0, 0)),\n        (\"fnof\", (0, 0)),\n        (\"angmsdaf;\", (10669, 0)),\n        (\"YUc\", (0, 0)),\n        (\"Tcedi\", (0, 0)),\n        (\"les\", (0, 0)),\n        (\"loze\", (0, 0)),\n        (\"lesseqqgtr\", (0, 0)),\n        (\"percnt;\", (37, 0)),\n        (\"bne;\", (61, 8421)),\n        (\"nrightarrow\", (0, 0)),\n        (\"piv;\", (982, 0)),\n        (\"lsim;\", (8818, 0)),\n        (\"COP\", (0, 0)),\n        (\"blacksquar\", (0, 0)),\n        (\"DoubleVertica\", (0, 0)),\n        (\"Reverse\", (0, 0)),\n        (\"vsupne\", (0, 0)),\n        (\"It\", (0, 0)),\n        (\"Popf;\", (8473, 0)),\n        (\"GreaterGr\", (0, 0)),\n        (\"bbrk;\", (9141, 0)),\n        (\"Pl\", (0, 0)),\n        (\"NotCupCa\", (0, 0)),\n        (\"simd\", (0, 0)),\n        (\"boxtim\", (0, 0)),\n        (\"GreaterSlantEqu\", (0, 0)),\n        (\"GreaterLes\", (0, 0)),\n        (\"LessEqualG\", (0, 0)),\n        (\"ntrianglerighteq\", (0, 0)),\n        (\"ho\", (0, 0)),\n        (\"HumpEqual\", (0, 0)),\n        (\"hookleftarro\", (0, 0)),\n        (\"smid\", (0, 0)),\n        (\"shchcy;\", (1097, 0)),\n        (\"rbra\", (0, 0)),\n        (\"LeftArrowRig\", (0, 0)),\n        (\"Doub\", (0, 0)),\n        (\"bernou;\", (8492, 0)),\n        (\"Vdas\", (0, 0)),\n        (\"dote\", (0, 0)),\n        (\"eac\", (0, 0)),\n        (\"gneqq\", (0, 0)),\n        (\"ApplyFunc\", (0, 0)),\n        (\"rationals;\", (8474, 0)),\n        (\"kapp\", (0, 0)),\n        (\"NotG\", (0, 0)),\n        (\"ag\", (0, 0)),\n        (\"supplu\", (0, 0)),\n        (\"sec\", (0, 0)),\n        (\"Expone\", (0, 0)),\n        (\"ctdo\", (0, 0)),\n        (\"pound\", (163, 0)),\n        (\"NotGreaterGreater;\", (8811, 824)),\n        (\"simplu\", (0, 0)),\n        (\"Exi\", (0, 0)),\n        (\"st\", (0, 0)),\n        (\"kopf;\", (120156, 0)),\n        (\"zwnj;\", (8204, 0)),\n        (\"UnionPlus;\", (8846, 0)),\n        (\"ntriangleri\", (0, 0)),\n        (\"xdtri\", (0, 0)),\n        (\"supmult\", (0, 0)),\n        (\"The\", (0, 0)),\n        (\"blacklozenge\", (0, 0)),\n        (\"ngeqsl\", (0, 0)),\n        (\"iio\", (0, 0)),\n        (\"fallingdotseq;\", (8786, 0)),\n        (\"Co\", (0, 0)),\n        (\"bcong\", (0, 0)),\n        (\"lvertneqq;\", (8808, 65024)),\n        (\"LeftUpTeeVec\", (0, 0)),\n        (\"triangledow\", (0, 0)),\n        (\"Uparrow;\", (8657, 0)),\n        (\"varep\", (0, 0)),\n        (\"R\", (0, 0)),\n        (\"alefsym\", (0, 0)),\n        (\"RBar\", (0, 0)),\n        (\"lceil\", (0, 0)),\n        (\"DownRightVector\", (0, 0)),\n        (\"suph\", (0, 0)),\n        (\"DownAr\", (0, 0)),\n        (\"ZeroWidth\", (0, 0)),\n        (\"NotRi\", (0, 0)),\n        (\"precsim\", (0, 0)),\n        (\"xop\", (0, 0)),\n        (\"Mfr\", (0, 0)),\n        (\"pluss\", (0, 0)),\n        (\"ogt;\", (10689, 0)),\n        (\"gtlP\", (0, 0)),\n        (\"nwArr;\", (8662, 0)),\n        (\"rarrl\", (0, 0)),\n        (\"larrp\", (0, 0)),\n        (\"ShortRigh\", (0, 0)),\n        (\"lneqq\", (0, 0)),\n        (\"Cconint\", (0, 0)),\n        (\"CounterClockwi\", (0, 0)),\n        (\"inodot;\", (305, 0)),\n        (\"planc\", (0, 0)),\n        (\"nsupseteqq;\", (10950, 824)),\n        (\"Updownarrow;\", (8661, 0)),\n        (\"DD;\", (8517, 0)),\n        (\"black\", (0, 0)),\n        (\"gtcir;\", (10874, 0)),\n        (\"righta\", (0, 0)),\n        (\"Uum\", (0, 0)),\n        (\"NotLess;\", (8814, 0)),\n        (\"pu\", (0, 0)),\n        (\"SquareIntersecti\", (0, 0)),\n        (\"rarr;\", (8594, 0)),\n        (\"capand\", (0, 0)),\n        (\"nrtri;\", (8939, 0)),\n        (\"LeftUpDownVect\", (0, 0)),\n        (\"trade;\", (8482, 0)),\n        (\"Eacut\", (0, 0)),\n        (\"sqsups\", (0, 0)),\n        (\"CircleD\", (0, 0)),\n        (\"rsaquo;\", (8250, 0)),\n        (\"sum\", (0, 0)),\n        (\"vell\", (0, 0)),\n        (\"ZeroWid\", (0, 0)),\n        (\"hscr\", (0, 0)),\n        (\"Subset\", (0, 0)),\n        (\"Gcirc;\", (284, 0)),\n        (\"awconi\", (0, 0)),\n        (\"VDas\", (0, 0)),\n        (\"Ouml\", (214, 0)),\n        (\"Im\", (0, 0)),\n        (\"sdo\", (0, 0)),\n        (\"Ecirc\", (202, 0)),\n        (\"supsetneqq;\", (10956, 0)),\n        (\"Scar\", (0, 0)),\n        (\"kgreen\", (0, 0)),\n        (\"ncaron;\", (328, 0)),\n        (\"doublebarwedge\", (0, 0)),\n        (\"femal\", (0, 0)),\n        (\"gammad;\", (989, 0)),\n        (\"dlcorn\", (0, 0)),\n        (\"twoh\", (0, 0)),\n        (\"RuleDelay\", (0, 0)),\n        (\"submul\", (0, 0)),\n        (\"mapsto;\", (8614, 0)),\n        (\"rtime\", (0, 0)),\n        (\"scar\", (0, 0)),\n        (\"Ecaron;\", (282, 0)),\n        (\"late;\", (10925, 0)),\n        (\"QUOT\", (34, 0)),\n        (\"aring\", (229, 0)),\n        (\"Rscr;\", (8475, 0)),\n        (\"Hstro\", (0, 0)),\n        (\"ZHcy\", (0, 0)),\n        (\"anda\", (0, 0)),\n        (\"Elem\", (0, 0)),\n        (\"nsucc\", (0, 0)),\n        (\"prna\", (0, 0)),\n        (\"NotHumpDownHum\", (0, 0)),\n        (\"succapp\", (0, 0)),\n        (\"DoubleVerticalBar\", (0, 0)),\n        (\"sigmav;\", (962, 0)),\n        (\"TRA\", (0, 0)),\n        (\"ofci\", (0, 0)),\n        (\"UpTee;\", (8869, 0)),\n        (\"zdo\", (0, 0)),\n        (\"NotDoubleVer\", (0, 0)),\n        (\"delta\", (0, 0)),\n        (\"rbrke;\", (10636, 0)),\n        (\"zopf\", (0, 0)),\n        (\"lesdotor;\", (10883, 0)),\n        (\"sig\", (0, 0)),\n        (\"epa\", (0, 0)),\n        (\"divideontimes;\", (8903, 0)),\n        (\"NotTilde;\", (8769, 0)),\n        (\"NotPrecedesSlantEq\", (0, 0)),\n        (\"Eo\", (0, 0)),\n        (\"UpDownA\", (0, 0)),\n        (\"frown;\", (8994, 0)),\n        (\"DotEqual\", (0, 0)),\n        (\"IO\", (0, 0)),\n        (\"iuml\", (239, 0)),\n        (\"lharul\", (0, 0)),\n        (\"falli\", (0, 0)),\n        (\"udhar;\", (10606, 0)),\n        (\"dfr;\", (120097, 0)),\n        (\"Qopf;\", (8474, 0)),\n        (\"frac14;\", (188, 0)),\n        (\"raemptyv\", (0, 0)),\n        (\"nprece\", (0, 0)),\n        (\"rdquor\", (0, 0)),\n        (\"vnsup;\", (8835, 8402)),\n        (\"iacu\", (0, 0)),\n        (\"longrightarrow\", (0, 0)),\n        (\"leftrightarrows\", (0, 0)),\n        (\"prop\", (0, 0)),\n        (\"orde\", (0, 0)),\n        (\"otimesa\", (0, 0)),\n        (\"suplarr;\", (10619, 0)),\n        (\"macr;\", (175, 0)),\n        (\"grav\", (0, 0)),\n        (\"napos\", (0, 0)),\n        (\"weierp;\", (8472, 0)),\n        (\"leftharpoon\", (0, 0)),\n        (\"RightTeeVec\", (0, 0)),\n        (\"GreaterEqualLe\", (0, 0)),\n        (\"SO\", (0, 0)),\n        (\"bdquo;\", (8222, 0)),\n        (\"NegativeMediumSpac\", (0, 0)),\n        (\"vscr\", (0, 0)),\n        (\"nop\", (0, 0)),\n        (\"nsups\", (0, 0)),\n        (\"boxhd;\", (9516, 0)),\n        (\"nea\", (0, 0)),\n        (\"Ne\", (0, 0)),\n        (\"EmptyVerySm\", (0, 0)),\n        (\"zh\", (0, 0)),\n        (\"Smal\", (0, 0)),\n        (\"oopf\", (0, 0)),\n        (\"hA\", (0, 0)),\n        (\"Au\", (0, 0)),\n        (\"apE\", (0, 0)),\n        (\"Eogo\", (0, 0)),\n        (\"int;\", (8747, 0)),\n        (\"Urin\", (0, 0)),\n        (\"fras\", (0, 0)),\n        (\"leftrightha\", (0, 0)),\n        (\"rtrie;\", (8885, 0)),\n        (\"nvsi\", (0, 0)),\n        (\"eogon;\", (281, 0)),\n        (\"OpenCurlyQuot\", (0, 0)),\n        (\"lscr\", (0, 0)),\n        (\"ufisht;\", (10622, 0)),\n        (\"Gbr\", (0, 0)),\n        (\"NotSquareSupersetEq\", (0, 0)),\n        (\"capcup;\", (10823, 0)),\n        (\"DoubleLeft\", (0, 0)),\n        (\"oplus\", (0, 0)),\n        (\"equivDD\", (0, 0)),\n        (\"LeftRightVec\", (0, 0)),\n        (\"dj\", (0, 0)),\n        (\"DownArrowUp\", (0, 0)),\n        (\"Epsilon;\", (917, 0)),\n        (\"Ubrev\", (0, 0)),\n        (\"RightDownVect\", (0, 0)),\n        (\"Lang;\", (10218, 0)),\n        (\"laq\", (0, 0)),\n        (\"Poincarep\", (0, 0)),\n        (\"vpr\", (0, 0)),\n        (\"straighteps\", (0, 0)),\n        (\"phi\", (0, 0)),\n        (\"quaternions;\", (8461, 0)),\n        (\"nsqsupe\", (0, 0)),\n        (\"RB\", (0, 0)),\n        (\"varnoth\", (0, 0)),\n        (\"realine\", (0, 0)),\n        (\"rB\", (0, 0)),\n        (\"curvea\", (0, 0)),\n        (\"UpperL\", (0, 0)),\n        (\"Io\", (0, 0)),\n        (\"RightUpTeeVector\", (0, 0)),\n        (\"NotRightTriangle\", (0, 0)),\n        (\"ltdo\", (0, 0)),\n        (\"nVd\", (0, 0)),\n        (\"bc\", (0, 0)),\n        (\"nshortpa\", (0, 0)),\n        (\"nu\", (0, 0)),\n        (\"midas\", (0, 0)),\n        (\"angmsd\", (0, 0)),\n        (\"cup\", (0, 0)),\n        (\"heartsu\", (0, 0)),\n        (\"Tstro\", (0, 0)),\n        (\"dfis\", (0, 0)),\n        (\"lesseqgtr;\", (8922, 0)),\n        (\"bnequiv;\", (8801, 8421)),\n        (\"rcub\", (0, 0)),\n        (\"orsl\", (0, 0)),\n        (\"Lstr\", (0, 0)),\n        (\"ForAl\", (0, 0)),\n        (\"downdo\", (0, 0)),\n        (\"npar;\", (8742, 0)),\n        (\"rx;\", (8478, 0)),\n        (\"curarr;\", (8631, 0)),\n        (\"Emacr\", (0, 0)),\n        (\"sigma\", (0, 0)),\n        (\"topc\", (0, 0)),\n        (\"Gcy;\", (1043, 0)),\n        (\"nLef\", (0, 0)),\n        (\"spad\", (0, 0)),\n        (\"NotRightTriangleEqu\", (0, 0)),\n        (\"gi\", (0, 0)),\n        (\"vfr\", (0, 0)),\n        (\"CounterClockwiseContou\", (0, 0)),\n        (\"lsc\", (0, 0)),\n        (\"downd\", (0, 0)),\n        (\"ap;\", (8776, 0)),\n        (\"ubrcy\", (0, 0)),\n        (\"piv\", (0, 0)),\n        (\"backpr\", (0, 0)),\n        (\"DiacriticalTil\", (0, 0)),\n        (\"Hori\", (0, 0)),\n        (\"supdsub;\", (10968, 0)),\n        (\"scns\", (0, 0)),\n        (\"precnsi\", (0, 0)),\n        (\"Horizonta\", (0, 0)),\n        (\"VerticalSeparat\", (0, 0)),\n        (\"angst\", (0, 0)),\n        (\"VeryThinS\", (0, 0)),\n        (\"uring\", (0, 0)),\n        (\"Itild\", (0, 0)),\n        (\"ShortDownArr\", (0, 0)),\n        (\"nd\", (0, 0)),\n        (\"Preced\", (0, 0)),\n        (\"glE\", (0, 0)),\n        (\"G\", (0, 0)),\n        (\"plustwo;\", (10791, 0)),\n        (\"notindo\", (0, 0)),\n        (\"CounterC\", (0, 0)),\n        (\"Iacute;\", (205, 0)),\n        (\"looparrowrigh\", (0, 0)),\n        (\"Hfr\", (0, 0)),\n        (\"isinE;\", (8953, 0)),\n        (\"gtques\", (0, 0)),\n        (\"Oscr\", (0, 0)),\n        (\"Ps\", (0, 0)),\n        (\"DoubleLeftArro\", (0, 0)),\n        (\"Ot\", (0, 0)),\n        (\"Qs\", (0, 0)),\n        (\"curarr\", (0, 0)),\n        (\"RightUpT\", (0, 0)),\n        (\"check;\", (10003, 0)),\n        (\"trpezi\", (0, 0)),\n        (\"bla\", (0, 0)),\n        (\"intcal\", (0, 0)),\n        (\"LeftUpVe\", (0, 0)),\n        (\"Fscr\", (0, 0)),\n        (\"uplu\", (0, 0)),\n        (\"npoli\", (0, 0)),\n        (\"lfisht;\", (10620, 0)),\n        (\"precc\", (0, 0)),\n        (\"lotime\", (0, 0)),\n        (\"nleftar\", (0, 0)),\n        (\"Tr\", (0, 0)),\n        (\"quot;\", (34, 0)),\n        (\"gimel;\", (8503, 0)),\n        (\"twoheadlefta\", (0, 0)),\n        (\"jcir\", (0, 0)),\n        (\"Dstr\", (0, 0)),\n        (\"Backslash;\", (8726, 0)),\n        (\"hookleftarrow\", (0, 0)),\n        (\"Oslash\", (216, 0)),\n        (\"orslop\", (0, 0)),\n        (\"Wfr;\", (120090, 0)),\n        (\"NestedLe\", (0, 0)),\n        (\"nvap;\", (8781, 8402)),\n        (\"Vopf\", (0, 0)),\n        (\"strns;\", (175, 0)),\n        (\"nLl;\", (8920, 824)),\n        (\"varkap\", (0, 0)),\n        (\"backp\", (0, 0)),\n        (\"ffilig\", (0, 0)),\n        (\"image\", (0, 0)),\n        (\"Zcaron;\", (381, 0)),\n        (\"OE\", (0, 0)),\n        (\"frown\", (0, 0)),\n        (\"Implies;\", (8658, 0)),\n        (\"dca\", (0, 0)),\n        (\"ApplyFunction\", (0, 0)),\n        (\"DoubleLongRig\", (0, 0)),\n        (\"oas\", (0, 0)),\n        (\"prs\", (0, 0)),\n        (\"HAR\", (0, 0)),\n        (\"SmallCirc\", (0, 0)),\n        (\"succnappro\", (0, 0)),\n        (\"Unde\", (0, 0)),\n        (\"RightDownTeeV\", (0, 0)),\n        (\"star;\", (9734, 0)),\n        (\"notinvb;\", (8951, 0)),\n        (\"nvlAr\", (0, 0)),\n        (\"NotRightTriangl\", (0, 0)),\n        (\"prure\", (0, 0)),\n        (\"DownRightT\", (0, 0)),\n        (\"P\", (0, 0)),\n        (\"subpl\", (0, 0)),\n        (\"Thic\", (0, 0)),\n        (\"TRADE\", (0, 0)),\n        (\"rH\", (0, 0)),\n        (\"elinter\", (0, 0)),\n        (\"M\", (0, 0)),\n        (\"boxvL\", (0, 0)),\n        (\"NotSubsetEq\", (0, 0)),\n        (\"lagr\", (0, 0)),\n        (\"vDa\", (0, 0)),\n        (\"itilde;\", (297, 0)),\n        (\"blacktrianglerig\", (0, 0)),\n        (\"agrave;\", (224, 0)),\n        (\"Lcy;\", (1051, 0)),\n        (\"apacir;\", (10863, 0)),\n        (\"sqsube;\", (8849, 0)),\n        (\"roan\", (0, 0)),\n        (\"ts\", (0, 0)),\n        (\"lesge\", (0, 0)),\n        (\"vartrianglerig\", (0, 0)),\n        (\"cemptyv;\", (10674, 0)),\n        (\"nscc\", (0, 0)),\n        (\"verb\", (0, 0)),\n        (\"ubrcy;\", (1118, 0)),\n        (\"dotminu\", (0, 0)),\n        (\"dstr\", (0, 0)),\n        (\"auml;\", (228, 0)),\n        (\"rtrif\", (0, 0)),\n        (\"NotGreaterG\", (0, 0)),\n        (\"nvltrie\", (0, 0)),\n        (\"Leftrightarrow;\", (8660, 0)),\n        (\"CHcy;\", (1063, 0)),\n        (\"curvearrowr\", (0, 0)),\n        (\"NotLessGreater;\", (8824, 0)),\n        (\"suppl\", (0, 0)),\n        (\"FilledSmallSquar\", (0, 0)),\n        (\"Horiz\", (0, 0)),\n        (\"CloseC\", (0, 0)),\n        (\"precappr\", (0, 0)),\n        (\"Atil\", (0, 0)),\n        (\"opl\", (0, 0)),\n        (\"nLeft\", (0, 0)),\n        (\"Ba\", (0, 0)),\n        (\"LeftVector\", (0, 0)),\n        (\"UpArrowB\", (0, 0)),\n        (\"InvisibleC\", (0, 0)),\n        (\"kgree\", (0, 0)),\n        (\"Dfr;\", (120071, 0)),\n        (\"bigcirc;\", (9711, 0)),\n        (\"NotCong\", (0, 0)),\n        (\"gesdotol\", (0, 0)),\n        (\"DownLeftRight\", (0, 0)),\n        (\"hcir\", (0, 0)),\n        (\"sqsubseteq;\", (8849, 0)),\n        (\"succnappr\", (0, 0)),\n        (\"rang;\", (10217, 0)),\n        (\"leg\", (0, 0)),\n        (\"Utilde\", (0, 0)),\n        (\"eqvparsl;\", (10725, 0)),\n        (\"LeftAngleBracket;\", (10216, 0)),\n        (\"pcy;\", (1087, 0)),\n        (\"RightDownVector;\", (8642, 0)),\n        (\"vartrianglel\", (0, 0)),\n        (\"HorizontalLine;\", (9472, 0)),\n        (\"downar\", (0, 0)),\n        (\"backepsilon;\", (1014, 0)),\n        (\"t\", (0, 0)),\n        (\"spadesuit\", (0, 0)),\n        (\"nsubE\", (0, 0)),\n        (\"rightt\", (0, 0)),\n        (\"LessTild\", (0, 0)),\n        (\"rightharpoondow\", (0, 0)),\n        (\"Umac\", (0, 0)),\n        (\"ange;\", (10660, 0)),\n        (\"circlearrowri\", (0, 0)),\n        (\"lrhar;\", (8651, 0)),\n        (\"NotEqualT\", (0, 0)),\n        (\"squ;\", (9633, 0)),\n        (\"tstrok\", (0, 0)),\n        (\"lmoustac\", (0, 0)),\n        (\"dcaron\", (0, 0)),\n        (\"succappro\", (0, 0)),\n        (\"gcirc;\", (285, 0)),\n        (\"RBarr;\", (10512, 0)),\n        (\"multimap;\", (8888, 0)),\n        (\"cempt\", (0, 0)),\n        (\"Right\", (0, 0)),\n        (\"Atilde\", (195, 0)),\n        (\"nvltr\", (0, 0)),\n        (\"NotLeftTrian\", (0, 0)),\n        (\"nV\", (0, 0)),\n        (\"Rarrtl;\", (10518, 0)),\n        (\"drco\", (0, 0)),\n        (\"GT;\", (62, 0)),\n        (\"Al\", (0, 0)),\n        (\"shortparal\", (0, 0)),\n        (\"ljc\", (0, 0)),\n        (\"sse\", (0, 0)),\n        (\"MinusP\", (0, 0)),\n        (\"Cayle\", (0, 0)),\n        (\"bigtriangledo\", (0, 0)),\n        (\"erDo\", (0, 0)),\n        (\"mcomm\", (0, 0)),\n        (\"intpr\", (0, 0)),\n        (\"Scirc\", (0, 0)),\n        (\"Kf\", (0, 0)),\n        (\"Coni\", (0, 0)),\n        (\"llha\", (0, 0)),\n        (\"xuplus\", (0, 0)),\n        (\"leftrightharpoons;\", (8651, 0)),\n        (\"dzigra\", (0, 0)),\n        (\"Lcedil;\", (315, 0)),\n        (\"diam;\", (8900, 0)),\n        (\"CircleTim\", (0, 0)),\n        (\"nwArr\", (0, 0)),\n        (\"pa\", (0, 0)),\n        (\"ordf;\", (170, 0)),\n        (\"tra\", (0, 0)),\n        (\"kce\", (0, 0)),\n        (\"ocirc;\", (244, 0)),\n        (\"Itil\", (0, 0)),\n        (\"Nfr;\", (120081, 0)),\n        (\"RightUpDownVector;\", (10575, 0)),\n        (\"cupcap;\", (10822, 0)),\n        (\"intpro\", (0, 0)),\n        (\"SubsetEqual;\", (8838, 0)),\n        (\"nleftri\", (0, 0)),\n        (\"easter;\", (10862, 0)),\n        (\"erDot\", (0, 0)),\n        (\"NotLeftTriangleEqua\", (0, 0)),\n        (\"betwe\", (0, 0)),\n        (\"cirmid;\", (10991, 0)),\n        (\"gtrar\", (0, 0)),\n        (\"SquareI\", (0, 0)),\n        (\"boxmi\", (0, 0)),\n        (\"realpart;\", (8476, 0)),\n        (\"varsups\", (0, 0)),\n        (\"hArr\", (0, 0)),\n        (\"NotNestedGreaterG\", (0, 0)),\n        (\"par;\", (8741, 0)),\n        (\"DoubleUpDo\", (0, 0)),\n        (\"zhc\", (0, 0)),\n        (\"DoubleContourInte\", (0, 0)),\n        (\"cop\", (0, 0)),\n        (\"xscr\", (0, 0)),\n        (\"nvgt;\", (62, 8402)),\n        (\"rightarr\", (0, 0)),\n        (\"xcap\", (0, 0)),\n        (\"blacktriangleleft;\", (9666, 0)),\n        (\"Ascr;\", (119964, 0)),\n        (\"pscr;\", (120005, 0)),\n        (\"straightepsilo\", (0, 0)),\n        (\"Upd\", (0, 0)),\n        (\"rnm\", (0, 0)),\n        (\"nright\", (0, 0)),\n        (\"NotNestedLessLe\", (0, 0)),\n        (\"cupc\", (0, 0)),\n        (\"rightthreet\", (0, 0)),\n        (\"ordf\", (170, 0)),\n        (\"notind\", (0, 0)),\n        (\"lBa\", (0, 0)),\n        (\"varsubsetne\", (0, 0)),\n        (\"Pr;\", (10939, 0)),\n        (\"Scaro\", (0, 0)),\n        (\"odot;\", (8857, 0)),\n        (\"OverPa\", (0, 0)),\n        (\"TSHcy\", (0, 0)),\n        (\"drcrop\", (0, 0)),\n        (\"Clos\", (0, 0)),\n        (\"UnderPar\", (0, 0)),\n        (\"dagge\", (0, 0)),\n        (\"nvsim\", (0, 0)),\n        (\"lowast;\", (8727, 0)),\n        (\"succa\", (0, 0)),\n        (\"ncup;\", (10818, 0)),\n        (\"v\", (0, 0)),\n        (\"backsime\", (0, 0)),\n        (\"frac25\", (0, 0)),\n        (\"backcong;\", (8780, 0)),\n        (\"DownRightTeeVe\", (0, 0)),\n        (\"Sc\", (0, 0)),\n        (\"odblac;\", (337, 0)),\n        (\"oslash\", (248, 0)),\n        (\"HumpDownHump;\", (8782, 0)),\n        (\"dHar;\", (10597, 0)),\n        (\"Circle\", (0, 0)),\n        (\"xcup\", (0, 0)),\n        (\"centerdo\", (0, 0)),\n        (\"yc\", (0, 0)),\n        (\"searhk\", (0, 0)),\n        (\"aw\", (0, 0)),\n        (\"Ograve;\", (210, 0)),\n        (\"HumpDo\", (0, 0)),\n        (\"nLe\", (0, 0)),\n        (\"DoubleUpArrow\", (0, 0)),\n        (\"DownRightVec\", (0, 0)),\n        (\"Nfr\", (0, 0)),\n        (\"lambd\", (0, 0)),\n        (\"Exis\", (0, 0)),\n        (\"CupCap;\", (8781, 0)),\n        (\"angl\", (0, 0)),\n        (\"trade\", (0, 0)),\n        (\"straightp\", (0, 0)),\n        (\"swarhk\", (0, 0)),\n        (\"llhard;\", (10603, 0)),\n        (\"fallingdotseq\", (0, 0)),\n        (\"roti\", (0, 0)),\n        (\"excl\", (0, 0)),\n        (\"NegativeMediumS\", (0, 0)),\n        (\"Righ\", (0, 0)),\n        (\"Uparro\", (0, 0)),\n        (\"Barwed;\", (8966, 0)),\n        (\"LeftDownTeeV\", (0, 0)),\n        (\"demptyv;\", (10673, 0)),\n        (\"udblac;\", (369, 0)),\n        (\"sub;\", (8834, 0)),\n        (\"urtr\", (0, 0)),\n        (\"vartriang\", (0, 0)),\n        (\"race;\", (8765, 817)),\n        (\"LeftRight\", (0, 0)),\n        (\"doubleb\", (0, 0)),\n        (\"Delt\", (0, 0)),\n        (\"DoubleRightA\", (0, 0)),\n        (\"RightDownVectorBar;\", (10581, 0)),\n        (\"DD\", (0, 0)),\n        (\"boxUL;\", (9565, 0)),\n        (\"uacut\", (0, 0)),\n        (\"NonBreaking\", (0, 0)),\n        (\"aacute\", (225, 0)),\n        (\"rarrfs;\", (10526, 0)),\n        (\"Prime;\", (8243, 0)),\n        (\"blk34\", (0, 0)),\n        (\"capcap;\", (10827, 0)),\n        (\"sext\", (0, 0)),\n        (\"cups;\", (8746, 65024)),\n        (\"LeftArrowBa\", (0, 0)),\n        (\"upharpoon\", (0, 0)),\n        (\"gl\", (0, 0)),\n        (\"ngs\", (0, 0)),\n        (\"lsh\", (0, 0)),\n        (\"NegativeThi\", (0, 0)),\n        (\"circledast;\", (8859, 0)),\n        (\"GreaterEqual\", (0, 0)),\n        (\"paral\", (0, 0)),\n        (\"Bernoul\", (0, 0)),\n        (\"Vert;\", (8214, 0)),\n        (\"swarh\", (0, 0)),\n        (\"spade\", (0, 0)),\n        (\"Aacute;\", (193, 0)),\n        (\"boxhU\", (0, 0)),\n        (\"LowerLeftAr\", (0, 0)),\n        (\"NotGreaterEq\", (0, 0)),\n        (\"csup;\", (10960, 0)),\n        (\"vee;\", (8744, 0)),\n        (\"DownTeeAr\", (0, 0)),\n        (\"Pr\", (0, 0)),\n        (\"gvertneqq;\", (8809, 65024)),\n        (\"NotPrecedesS\", (0, 0)),\n        (\"boxV\", (0, 0)),\n        (\"ngsim\", (0, 0)),\n        (\"NotGreaterF\", (0, 0)),\n        (\"vArr\", (0, 0)),\n        (\"origof;\", (8886, 0)),\n        (\"RightUpDown\", (0, 0)),\n        (\"DoubleCont\", (0, 0)),\n        (\"pitchfork;\", (8916, 0)),\n        (\"Iacu\", (0, 0)),\n        (\"rl\", (0, 0)),\n        (\"precneqq\", (0, 0)),\n        (\"larrlp;\", (8619, 0)),\n        (\"geqq\", (0, 0)),\n        (\"nb\", (0, 0)),\n        (\"simne;\", (8774, 0)),\n        (\"ldrdhar;\", (10599, 0)),\n        (\"nshortp\", (0, 0)),\n        (\"DownLeftVector\", (0, 0)),\n        (\"wp;\", (8472, 0)),\n        (\"LeftDownVectorBa\", (0, 0)),\n        (\"Cacute\", (0, 0)),\n        (\"swarhk;\", (10534, 0)),\n        (\"Rrightarr\", (0, 0)),\n        (\"NegativeMediumSp\", (0, 0)),\n        (\"Qscr\", (0, 0)),\n        (\"GJcy\", (0, 0)),\n        (\"imagpart;\", (8465, 0)),\n        (\"rmous\", (0, 0)),\n        (\"there4;\", (8756, 0)),\n        (\"larrb\", (0, 0)),\n        (\"angzar\", (0, 0)),\n        (\"me\", (0, 0)),\n        (\"Nacute\", (0, 0)),\n        (\"rbrkslu;\", (10640, 0)),\n        (\"RightUpTeeVec\", (0, 0)),\n        (\"EmptySmal\", (0, 0)),\n        (\"NotGreat\", (0, 0)),\n        (\"VerticalTild\", (0, 0)),\n        (\"pitchf\", (0, 0)),\n        (\"nexists\", (0, 0)),\n        (\"notinva;\", (8713, 0)),\n        (\"Conto\", (0, 0)),\n        (\"clubs\", (0, 0)),\n        (\"bigtriangleu\", (0, 0)),\n        (\"harrc\", (0, 0)),\n        (\"nwarr\", (0, 0)),\n        (\"wopf;\", (120168, 0)),\n        (\"downarrow;\", (8595, 0)),\n        (\"Partia\", (0, 0)),\n        (\"nvrArr\", (0, 0)),\n        (\"supse\", (0, 0)),\n        (\"And;\", (10835, 0)),\n        (\"thks\", (0, 0)),\n        (\"triangleq\", (0, 0)),\n        (\"Pc\", (0, 0)),\n        (\"GreaterTild\", (0, 0)),\n        (\"CounterClockwiseConto\", (0, 0)),\n        (\"szl\", (0, 0)),\n        (\"preccurlyeq\", (0, 0)),\n        (\"NotPrecedesSla\", (0, 0)),\n        (\"ac;\", (8766, 0)),\n        (\"lfloor\", (0, 0)),\n        (\"eplus\", (0, 0)),\n        (\"rbrace;\", (125, 0)),\n        (\"rarrap;\", (10613, 0)),\n        (\"awin\", (0, 0)),\n        (\"eqc\", (0, 0)),\n        (\"fscr;\", (119995, 0)),\n        (\"hairsp;\", (8202, 0)),\n        (\"searro\", (0, 0)),\n        (\"DoubleContourIntegra\", (0, 0)),\n        (\"VerticalSeparator\", (0, 0)),\n        (\"Cedil\", (0, 0)),\n        (\"smepars\", (0, 0)),\n        (\"LowerRig\", (0, 0)),\n        (\"NotPr\", (0, 0)),\n        (\"rha\", (0, 0)),\n        (\"boxhD;\", (9573, 0)),\n        (\"ems\", (0, 0)),\n        (\"efDot\", (0, 0)),\n        (\"shortmi\", (0, 0)),\n        (\"lmoustache\", (0, 0)),\n        (\"backs\", (0, 0)),\n        (\"rdldha\", (0, 0)),\n        (\"bsolhsub\", (0, 0)),\n        (\"mapstoup;\", (8613, 0)),\n        (\"fla\", (0, 0)),\n        (\"circledcir\", (0, 0)),\n        (\"uscr\", (0, 0)),\n        (\"bigopl\", (0, 0)),\n        (\"niv;\", (8715, 0)),\n        (\"RoundI\", (0, 0)),\n        (\"boxplus\", (0, 0)),\n        (\"dha\", (0, 0)),\n        (\"smtes;\", (10924, 65024)),\n        (\"vB\", (0, 0)),\n        (\"imagli\", (0, 0)),\n        (\"bfr;\", (120095, 0)),\n        (\"HilbertS\", (0, 0)),\n        (\"GreaterFullEqu\", (0, 0)),\n        (\"uri\", (0, 0)),\n        (\"circlearrow\", (0, 0)),\n        (\"Me\", (0, 0)),\n        (\"RightUpVector\", (0, 0)),\n        (\"njcy\", (0, 0)),\n        (\"Lcaron\", (0, 0)),\n        (\"ncaron\", (0, 0)),\n        (\"bigtri\", (0, 0)),\n        (\"nlsi\", (0, 0)),\n        (\"reg\", (174, 0)),\n        (\"lescc;\", (10920, 0)),\n        (\"gbrev\", (0, 0)),\n        (\"prnE;\", (10933, 0)),\n        (\"leq;\", (8804, 0)),\n        (\"Reve\", (0, 0)),\n        (\"cwconin\", (0, 0)),\n        (\"RightV\", (0, 0)),\n        (\"becaus;\", (8757, 0)),\n        (\"Racu\", (0, 0)),\n        (\"Ncedil;\", (325, 0)),\n        (\"SquareInte\", (0, 0)),\n        (\"hookrightarrow\", (0, 0)),\n        (\"qprim\", (0, 0)),\n        (\"Kced\", (0, 0)),\n        (\"nrtrie\", (0, 0)),\n        (\"lowast\", (0, 0)),\n        (\"ltquest;\", (10875, 0)),\n        (\"SucceedsTil\", (0, 0)),\n        (\"Amacr\", (0, 0)),\n        (\"Hilb\", (0, 0)),\n        (\"NotHumpDownH\", (0, 0)),\n        (\"sqsupse\", (0, 0)),\n        (\"bep\", (0, 0)),\n        (\"boxu\", (0, 0)),\n        (\"Ma\", (0, 0)),\n        (\"bem\", (0, 0)),\n        (\"ApplyFunctio\", (0, 0)),\n        (\"dagger;\", (8224, 0)),\n        (\"Colone\", (0, 0)),\n        (\"lesd\", (0, 0)),\n        (\"SubsetEq\", (0, 0)),\n        (\"khcy;\", (1093, 0)),\n        (\"nvrtr\", (0, 0)),\n        (\"Oopf;\", (120134, 0)),\n        (\"otimes;\", (8855, 0)),\n        (\"trianglelefteq;\", (8884, 0)),\n        (\"nVdash\", (0, 0)),\n        (\"profala\", (0, 0)),\n        (\"risingdotseq;\", (8787, 0)),\n        (\"NotReverseElement\", (0, 0)),\n        (\"nRighta\", (0, 0)),\n        (\"langle;\", (10216, 0)),\n        (\"Kc\", (0, 0)),\n        (\"numero;\", (8470, 0)),\n        (\"UpEquilibrium;\", (10606, 0)),\n        (\"DiacriticalDoubleA\", (0, 0)),\n        (\"Xs\", (0, 0)),\n        (\"lrc\", (0, 0)),\n        (\"Abre\", (0, 0)),\n        (\"iota;\", (953, 0)),\n        (\"Rcy\", (0, 0)),\n        (\"simlE;\", (10911, 0)),\n        (\"Os\", (0, 0)),\n        (\"ugr\", (0, 0)),\n        (\"PrecedesEqua\", (0, 0)),\n        (\"eo\", (0, 0)),\n        (\"kjc\", (0, 0)),\n        (\"SquareUnio\", (0, 0)),\n        (\"lacute\", (0, 0)),\n        (\"GreaterEqualLess\", (0, 0)),\n        (\"bec\", (0, 0)),\n        (\"backsim;\", (8765, 0)),\n        (\"DoubleLongLeftA\", (0, 0)),\n        (\"longmap\", (0, 0)),\n        (\"tho\", (0, 0)),\n        (\"ApplyFu\", (0, 0)),\n        (\"equ\", (0, 0)),\n        (\"Kopf\", (0, 0)),\n        (\"Agr\", (0, 0)),\n        (\"LongLeftArro\", (0, 0)),\n        (\"Scaron;\", (352, 0)),\n        (\"SquareSubsetEqual\", (0, 0)),\n        (\"frac18\", (0, 0)),\n        (\"succns\", (0, 0)),\n        (\"bigcap;\", (8898, 0)),\n        (\"plusdu;\", (10789, 0)),\n        (\"nsm\", (0, 0)),\n        (\"real;\", (8476, 0)),\n        (\"NJcy\", (0, 0)),\n        (\"blacklozen\", (0, 0)),\n        (\"ncaro\", (0, 0)),\n        (\"bkar\", (0, 0)),\n        (\"gtrap\", (0, 0)),\n        (\"rdq\", (0, 0)),\n        (\"SquareInt\", (0, 0)),\n        (\"rpar\", (0, 0)),\n        (\"VD\", (0, 0)),\n        (\"CapitalDiffere\", (0, 0)),\n        (\"Gam\", (0, 0)),\n        (\"geqslant\", (0, 0)),\n        (\"leq\", (0, 0)),\n        (\"dia\", (0, 0)),\n        (\"straightepsilon\", (0, 0)),\n        (\"ncap\", (0, 0)),\n        (\"vDash\", (0, 0)),\n        (\"ugrave\", (249, 0)),\n        (\"rightleftharpoons;\", (8652, 0)),\n        (\"approxeq\", (0, 0)),\n        (\"RightTriang\", (0, 0)),\n        (\"odiv\", (0, 0)),\n        (\"egsdo\", (0, 0)),\n        (\"Exist\", (0, 0)),\n        (\"RightTeeArr\", (0, 0)),\n        (\"Equilibriu\", (0, 0)),\n        (\"Qsc\", (0, 0)),\n        (\"rightleftharp\", (0, 0)),\n        (\"srar\", (0, 0)),\n        (\"gl;\", (8823, 0)),\n        (\"rmoust;\", (9137, 0)),\n        (\"Bern\", (0, 0)),\n        (\"hksearow\", (0, 0)),\n        (\"oacute\", (243, 0)),\n        (\"Xscr\", (0, 0)),\n        (\"gfr;\", (120100, 0)),\n        (\"bsime\", (0, 0)),\n        (\"ordero\", (0, 0)),\n        (\"uAr\", (0, 0)),\n        (\"UnderBrace\", (0, 0)),\n        (\"NotLes\", (0, 0)),\n        (\"lscr;\", (120001, 0)),\n        (\"ntrianglerigh\", (0, 0)),\n        (\"nleftright\", (0, 0)),\n        (\"rh\", (0, 0)),\n        (\"pra\", (0, 0)),\n        (\"SucceedsE\", (0, 0)),\n        (\"RightTriangleB\", (0, 0)),\n        (\"per\", (0, 0)),\n        (\"eqvpar\", (0, 0)),\n        (\"mlcp\", (0, 0)),\n        (\"NegativeVeryThi\", (0, 0)),\n        (\"TildeEqual\", (0, 0)),\n        (\"api\", (0, 0)),\n        (\"therefore;\", (8756, 0)),\n        (\"gdot;\", (289, 0)),\n        (\"ntrianglelefte\", (0, 0)),\n        (\"scpo\", (0, 0)),\n        (\"Ifr;\", (8465, 0)),\n        (\"Tst\", (0, 0)),\n        (\"Invisib\", (0, 0)),\n        (\"csu\", (0, 0)),\n        (\"RightD\", (0, 0)),\n        (\"Differe\", (0, 0)),\n        (\"nra\", (0, 0)),\n        (\"lesges;\", (10899, 0)),\n        (\"Psc\", (0, 0)),\n        (\"io\", (0, 0)),\n        (\"iprod;\", (10812, 0)),\n        (\"Int\", (0, 0)),\n        (\"DownLeftTeeVector;\", (10590, 0)),\n        (\"LeftDownVec\", (0, 0)),\n        (\"ml\", (0, 0)),\n        (\"DownLeftT\", (0, 0)),\n        (\"ReverseElement;\", (8715, 0)),\n        (\"lsim\", (0, 0)),\n        (\"nlar\", (0, 0)),\n        (\"CapitalDifferenti\", (0, 0)),\n        (\"Ua\", (0, 0)),\n        (\"uml\", (168, 0)),\n        (\"nmi\", (0, 0)),\n        (\"sce\", (0, 0)),\n        (\"Hacek;\", (711, 0)),\n        (\"Coun\", (0, 0)),\n        (\"poun\", (0, 0)),\n        (\"rhov;\", (1009, 0)),\n        (\"NotDoubleVe\", (0, 0)),\n        (\"UpTeeAr\", (0, 0)),\n        (\"larrf\", (0, 0)),\n        (\"Bump\", (0, 0)),\n        (\"nLeftarro\", (0, 0)),\n        (\"ddo\", (0, 0)),\n        (\"lflo\", (0, 0)),\n        (\"Wc\", (0, 0)),\n        (\"ovbar;\", (9021, 0)),\n        (\"starf\", (0, 0)),\n        (\"Wci\", (0, 0)),\n        (\"Longrightarr\", (0, 0)),\n        (\"looparr\", (0, 0)),\n        (\"Appl\", (0, 0)),\n        (\"ascr;\", (119990, 0)),\n        (\"NotNestedGreaterGreat\", (0, 0)),\n        (\"NotVertica\", (0, 0)),\n        (\"subset\", (0, 0)),\n        (\"npol\", (0, 0)),\n        (\"Ou\", (0, 0)),\n        (\"nsupseteq\", (0, 0)),\n        (\"Iscr;\", (8464, 0)),\n        (\"nscr\", (0, 0)),\n        (\"Q\", (0, 0)),\n        (\"lnap\", (0, 0)),\n        (\"sla\", (0, 0)),\n        (\"DiacriticalDoubleAcute\", (0, 0)),\n        (\"RightUpVectorB\", (0, 0)),\n        (\"NotPrecedesSlant\", (0, 0)),\n        (\"DoubleLongRightArr\", (0, 0)),\n        (\"LeftDownV\", (0, 0)),\n        (\"Ecirc;\", (202, 0)),\n        (\"lbrksld\", (0, 0)),\n        (\"NotGreaterLe\", (0, 0)),\n        (\"LongLeftRi\", (0, 0)),\n        (\"cyl\", (0, 0)),\n        (\"Longrightarro\", (0, 0)),\n        (\"DDotrahd\", (0, 0)),\n        (\"tscy\", (0, 0)),\n        (\"If\", (0, 0)),\n        (\"plustwo\", (0, 0)),\n        (\"rcu\", (0, 0)),\n        (\"ch\", (0, 0)),\n        (\"Diacritica\", (0, 0)),\n        (\"Hace\", (0, 0)),\n        (\"InvisibleT\", (0, 0)),\n        (\"Dfr\", (0, 0)),\n        (\"Yuml;\", (376, 0)),\n        (\"bcy\", (0, 0)),\n        (\"udhar\", (0, 0)),\n        (\"Propo\", (0, 0)),\n        (\"dashv;\", (8867, 0)),\n        (\"nprcue;\", (8928, 0)),\n        (\"Asc\", (0, 0)),\n        (\"commat\", (0, 0)),\n        (\"Grea\", (0, 0)),\n        (\"xvee;\", (8897, 0)),\n        (\"rbrksl\", (0, 0)),\n        (\"Tsc\", (0, 0)),\n        (\"ccupss\", (0, 0)),\n        (\"nesear\", (0, 0)),\n        (\"rightlefthar\", (0, 0)),\n        (\"DoubleLongRightAr\", (0, 0)),\n        (\"min\", (0, 0)),\n        (\"meas\", (0, 0)),\n        (\"npolin\", (0, 0)),\n        (\"swn\", (0, 0)),\n        (\"bd\", (0, 0)),\n        (\"nsuc\", (0, 0)),\n        (\"fra\", (0, 0)),\n        (\"dzigr\", (0, 0)),\n        (\"usc\", (0, 0)),\n        (\"risingdotse\", (0, 0)),\n        (\"ocirc\", (244, 0)),\n        (\"csup\", (0, 0)),\n        (\"tscr;\", (120009, 0)),\n        (\"hor\", (0, 0)),\n        (\"cuesc\", (0, 0)),\n        (\"cudarrr\", (0, 0)),\n        (\"boxDL\", (0, 0)),\n        (\"ncongdo\", (0, 0)),\n        (\"Mscr\", (0, 0)),\n        (\"DownLeftVec\", (0, 0)),\n        (\"Cay\", (0, 0)),\n        (\"cupb\", (0, 0)),\n        (\"checkma\", (0, 0)),\n        (\"gjc\", (0, 0)),\n        (\"lm\", (0, 0)),\n        (\"Gced\", (0, 0)),\n        (\"vee\", (0, 0)),\n        (\"xi\", (0, 0)),\n        (\"preccu\", (0, 0)),\n        (\"EmptyVerySmallS\", (0, 0)),\n        (\"Rightarrow\", (0, 0)),\n        (\"longleftr\", (0, 0)),\n        (\"ipro\", (0, 0)),\n        (\"frac23;\", (8532, 0)),\n        (\"lA\", (0, 0)),\n        (\"Cconin\", (0, 0)),\n        (\"Vba\", (0, 0)),\n        (\"ddar\", (0, 0)),\n        (\"mstpos;\", (8766, 0)),\n        (\"angsph;\", (8738, 0)),\n        (\"HARD\", (0, 0)),\n        (\"sup;\", (8835, 0)),\n        (\"HumpDown\", (0, 0)),\n        (\"Edot;\", (278, 0)),\n        (\"NotSucceedsTilde;\", (8831, 824)),\n        (\"Uog\", (0, 0)),\n        (\"NestedLessLe\", (0, 0)),\n        (\"Ocir\", (0, 0)),\n        (\"heart\", (0, 0)),\n        (\"Agrave;\", (192, 0)),\n        (\"SquareIntersection;\", (8851, 0)),\n        (\"uparro\", (0, 0)),\n        (\"strn\", (0, 0)),\n        (\"rsh\", (0, 0)),\n        (\"lHa\", (0, 0)),\n        (\"hci\", (0, 0)),\n        (\"bigotime\", (0, 0)),\n        (\"LessLe\", (0, 0)),\n        (\"Capit\", (0, 0)),\n        (\"Equ\", (0, 0)),\n        (\"nrt\", (0, 0)),\n        (\"Lam\", (0, 0)),\n        (\"centerdot\", (0, 0)),\n        (\"realpa\", (0, 0)),\n        (\"gammad\", (0, 0)),\n        (\"NotLessTi\", (0, 0)),\n        (\"OverBrace\", (0, 0)),\n        (\"vda\", (0, 0)),\n        (\"twoheadrightarr\", (0, 0)),\n        (\"ClockwiseContourInteg\", (0, 0)),\n        (\"dot\", (0, 0)),\n        (\"ii\", (0, 0)),\n        (\"curvearrowrigh\", (0, 0)),\n        (\"PrecedesSl\", (0, 0)),\n        (\"zi\", (0, 0)),\n        (\"tsh\", (0, 0)),\n        (\"vnsub\", (0, 0)),\n        (\"rb\", (0, 0)),\n        (\"lcub;\", (123, 0)),\n        (\"betwee\", (0, 0)),\n        (\"Super\", (0, 0)),\n        (\"NotGreaterTilde;\", (8821, 0)),\n        (\"dua\", (0, 0)),\n        (\"Great\", (0, 0)),\n        (\"NotS\", (0, 0)),\n        (\"nle\", (0, 0)),\n        (\"lharu\", (0, 0)),\n        (\"rin\", (0, 0)),\n        (\"Sacute;\", (346, 0)),\n        (\"rbrack;\", (93, 0)),\n        (\"DoubleDot;\", (168, 0)),\n        (\"Jcy;\", (1049, 0)),\n        (\"xsqcup;\", (10758, 0)),\n        (\"UpArrowDownArrow\", (0, 0)),\n        (\"Laplacet\", (0, 0)),\n        (\"Map\", (0, 0)),\n        (\"HARDc\", (0, 0)),\n        (\"bfr\", (0, 0)),\n        (\"preceq\", (0, 0)),\n        (\"rdsh\", (0, 0)),\n        (\"Mellintrf;\", (8499, 0)),\n        (\"LeftRightVector\", (0, 0)),\n        (\"Poinca\", (0, 0)),\n        (\"imp\", (0, 0)),\n        (\"varsubsetneqq;\", (10955, 65024)),\n        (\"nsupset;\", (8835, 8402)),\n        (\"exp\", (0, 0)),\n        (\"rmoust\", (0, 0)),\n        (\"NegativeVeryThinS\", (0, 0)),\n        (\"NotHumpEqual\", (0, 0)),\n        (\"rdquo;\", (8221, 0)),\n        (\"TildeEqu\", (0, 0)),\n        (\"sccue;\", (8829, 0)),\n        (\"ThinSpa\", (0, 0)),\n        (\"hairs\", (0, 0)),\n        (\"nes\", (0, 0)),\n        (\"Hat\", (0, 0)),\n        (\"Rcaron\", (0, 0)),\n        (\"TildeE\", (0, 0)),\n        (\"hslas\", (0, 0)),\n        (\"bcy;\", (1073, 0)),\n        (\"amalg\", (0, 0)),\n        (\"SquareSubse\", (0, 0)),\n        (\"NotGreater;\", (8815, 0)),\n        (\"bullet\", (0, 0)),\n        (\"otimesas;\", (10806, 0)),\n        (\"ed\", (0, 0)),\n        (\"NegativeVeryThinSpac\", (0, 0)),\n        (\"jukc\", (0, 0)),\n        (\"planck;\", (8463, 0)),\n        (\"VerticalLine\", (0, 0)),\n        (\"nvD\", (0, 0)),\n        (\"oel\", (0, 0)),\n        (\"nparall\", (0, 0)),\n        (\"qpr\", (0, 0)),\n        (\"capa\", (0, 0)),\n        (\"gtrd\", (0, 0)),\n        (\"nsupseteq;\", (8841, 0)),\n        (\"Conint;\", (8751, 0)),\n        (\"NonBr\", (0, 0)),\n        (\"twoheadrightar\", (0, 0)),\n        (\"Iuml;\", (207, 0)),\n        (\"rlarr;\", (8644, 0)),\n        (\"epar;\", (8917, 0)),\n        (\"LeftUpVectorBar;\", (10584, 0)),\n        (\"To\", (0, 0)),\n        (\"LessEqualGrea\", (0, 0)),\n        (\"jc\", (0, 0)),\n        (\"yacute\", (253, 0)),\n        (\"leftrightsquigar\", (0, 0)),\n        (\"targe\", (0, 0)),\n        (\"uArr\", (0, 0)),\n        (\"EmptyVerySmallSquare;\", (9643, 0)),\n        (\"Rang\", (0, 0)),\n        (\"uwangle\", (0, 0)),\n        (\"iopf\", (0, 0)),\n        (\"gtrappr\", (0, 0)),\n        (\"smte\", (0, 0)),\n        (\"hslash;\", (8463, 0)),\n        (\"Impli\", (0, 0)),\n        (\"nrig\", (0, 0)),\n        (\"imag\", (0, 0)),\n        (\"od\", (0, 0)),\n        (\"Thi\", (0, 0)),\n        (\"O\", (0, 0)),\n        (\"RightUpDownVector\", (0, 0)),\n        (\"vltri;\", (8882, 0)),\n        (\"ShortRight\", (0, 0)),\n        (\"ntr\", (0, 0)),\n        (\"ddotseq;\", (10871, 0)),\n        (\"LessLess\", (0, 0)),\n        (\"toea;\", (10536, 0)),\n        (\"macr\", (175, 0)),\n        (\"LeftUpVectorBa\", (0, 0)),\n        (\"tsc\", (0, 0)),\n        (\"ldru\", (0, 0)),\n        (\"simpl\", (0, 0)),\n        (\"bigtriangled\", (0, 0)),\n        (\"DownRightVect\", (0, 0)),\n        (\"zfr\", (0, 0)),\n        (\"CloseCurlyQu\", (0, 0)),\n        (\"bdqu\", (0, 0)),\n        (\"lessap\", (0, 0)),\n        (\"NegativeThinSpa\", (0, 0)),\n        (\"verba\", (0, 0)),\n        (\"gsi\", (0, 0)),\n        (\"ClockwiseContou\", (0, 0)),\n        (\"phone\", (0, 0)),\n        (\"Zopf;\", (8484, 0)),\n        (\"lbrke\", (0, 0)),\n        (\"wopf\", (0, 0)),\n        (\"clubs;\", (9827, 0)),\n        (\"parallel;\", (8741, 0)),\n        (\"mapstole\", (0, 0)),\n        (\"sfrown;\", (8994, 0)),\n        (\"rAar\", (0, 0)),\n        (\"lrhard;\", (10605, 0)),\n        (\"Nopf;\", (8469, 0)),\n        (\"rppolint\", (0, 0)),\n        (\"notniv\", (0, 0)),\n        (\"gtr\", (0, 0)),\n        (\"NotGre\", (0, 0)),\n        (\"ENG;\", (330, 0)),\n        (\"inter\", (0, 0)),\n        (\"Jcirc\", (0, 0)),\n        (\"Intersecti\", (0, 0)),\n        (\"bscr\", (0, 0)),\n        (\"order;\", (8500, 0)),\n        (\"fll\", (0, 0)),\n        (\"xc\", (0, 0)),\n        (\"supdo\", (0, 0)),\n        (\"DDotra\", (0, 0)),\n        (\"cylcty;\", (9005, 0)),\n        (\"DownRightTee\", (0, 0)),\n        (\"supseteq;\", (8839, 0)),\n        (\"gim\", (0, 0)),\n        (\"ctdot;\", (8943, 0)),\n        (\"mu;\", (956, 0)),\n        (\"part;\", (8706, 0)),\n        (\"Bc\", (0, 0)),\n        (\"npreceq;\", (10927, 824)),\n        (\"cupor;\", (10821, 0)),\n        (\"looparrowl\", (0, 0)),\n        (\"boxvR;\", (9566, 0)),\n        (\"doubl\", (0, 0)),\n        (\"ldquo;\", (8220, 0)),\n        (\"Ecy\", (0, 0)),\n        (\"minusb;\", (8863, 0)),\n        (\"RightUpDow\", (0, 0)),\n        (\"oin\", (0, 0)),\n        (\"lneq;\", (10887, 0)),\n        (\"DoubleLongLeftRi\", (0, 0)),\n        (\"awc\", (0, 0)),\n        (\"latail;\", (10521, 0)),\n        (\"blacktriangle\", (0, 0)),\n        (\"sfro\", (0, 0)),\n        (\"questeq;\", (8799, 0)),\n        (\"bigtria\", (0, 0)),\n        (\"ZeroWidthSpace\", (0, 0)),\n        (\"NotCupCap;\", (8813, 0)),\n        (\"urc\", (0, 0)),\n        (\"Hsc\", (0, 0)),\n        (\"llcorne\", (0, 0)),\n        (\"rscr\", (0, 0)),\n        (\"DoubleLeftT\", (0, 0)),\n        (\"LongRightArro\", (0, 0)),\n        (\"PlusMinus;\", (177, 0)),\n        (\"Lacu\", (0, 0)),\n        (\"SquareUnion\", (0, 0)),\n        (\"bne\", (0, 0)),\n        (\"Ccirc\", (0, 0)),\n        (\"FilledVerySmallSquare;\", (9642, 0)),\n        (\"rightrightarro\", (0, 0)),\n        (\"HARDcy;\", (1066, 0)),\n        (\"Barwe\", (0, 0)),\n        (\"Very\", (0, 0)),\n        (\"CircleDot;\", (8857, 0)),\n        (\"jo\", (0, 0)),\n        (\"lata\", (0, 0)),\n        (\"nge;\", (8817, 0)),\n        (\"imat\", (0, 0)),\n        (\"boxUR;\", (9562, 0)),\n        (\"DoubleContourIntegral\", (0, 0)),\n        (\"notin\", (0, 0)),\n        (\"curlyeqp\", (0, 0)),\n        (\"equi\", (0, 0)),\n        (\"npre;\", (10927, 824)),\n        (\"diamo\", (0, 0)),\n        (\"LeftDoub\", (0, 0)),\n        (\"Yu\", (0, 0)),\n        (\"leftarrowtail;\", (8610, 0)),\n        (\"CounterClockwiseContourInte\", (0, 0)),\n        (\"Ri\", (0, 0)),\n        (\"ThickSpace;\", (8287, 8202)),\n        (\"hscr;\", (119997, 0)),\n        (\"fcy;\", (1092, 0)),\n        (\"rang\", (0, 0)),\n        (\"longrigh\", (0, 0)),\n        (\"Ncaro\", (0, 0)),\n        (\"ses\", (0, 0)),\n        (\"LeftArrowRightArr\", (0, 0)),\n        (\"DoubleDown\", (0, 0)),\n        (\"lessgt\", (0, 0)),\n        (\"ReverseEquilibri\", (0, 0)),\n        (\"RightCei\", (0, 0)),\n        (\"fall\", (0, 0)),\n        (\"de\", (0, 0)),\n        (\"precnappr\", (0, 0)),\n        (\"NonBreaki\", (0, 0)),\n        (\"xoplus;\", (10753, 0)),\n        (\"jserc\", (0, 0)),\n        (\"updownar\", (0, 0)),\n        (\"N\", (0, 0)),\n        (\"frac38;\", (8540, 0)),\n        (\"Nes\", (0, 0)),\n        (\"subseteqq\", (0, 0)),\n        (\"NotLessTilde\", (0, 0)),\n        (\"NotHumpE\", (0, 0)),\n        (\"OverBa\", (0, 0)),\n        (\"Prop\", (0, 0)),\n        (\"bbrk\", (0, 0)),\n        (\"bno\", (0, 0)),\n        (\"nLt;\", (8810, 8402)),\n        (\"ltqu\", (0, 0)),\n        (\"looparrowrig\", (0, 0)),\n        (\"lsqb;\", (91, 0)),\n        (\"efDot;\", (8786, 0)),\n        (\"gamma\", (0, 0)),\n        (\"Rrightarro\", (0, 0)),\n        (\"longleft\", (0, 0)),\n        (\"TildeEq\", (0, 0)),\n        (\"mho;\", (8487, 0)),\n        (\"longrig\", (0, 0)),\n        (\"Kce\", (0, 0)),\n        (\"scnap\", (0, 0)),\n        (\"Scedil;\", (350, 0)),\n        (\"nVdas\", (0, 0)),\n        (\"Om\", (0, 0)),\n        (\"xwedg\", (0, 0)),\n        (\"vzigzag;\", (10650, 0)),\n        (\"Exists\", (0, 0)),\n        (\"rightleftharpo\", (0, 0)),\n        (\"gsiml;\", (10896, 0)),\n        (\"rsquor;\", (8217, 0)),\n        (\"LongLef\", (0, 0)),\n        (\"Capi\", (0, 0)),\n        (\"isinE\", (0, 0)),\n        (\"triangle;\", (9653, 0)),\n        (\"SucceedsSlantEqual\", (0, 0)),\n        (\"twoheadright\", (0, 0)),\n        (\"jcy\", (0, 0)),\n        (\"OverPar\", (0, 0)),\n        (\"Of\", (0, 0)),\n        (\"frac13;\", (8531, 0)),\n        (\"toe\", (0, 0)),\n        (\"lamb\", (0, 0)),\n        (\"nLeftri\", (0, 0)),\n        (\"stra\", (0, 0)),\n        (\"RightTe\", (0, 0)),\n        (\"rp\", (0, 0)),\n        (\"DownB\", (0, 0)),\n        (\"els;\", (10901, 0)),\n        (\"larrbfs\", (0, 0)),\n        (\"CH\", (0, 0)),\n        (\"bco\", (0, 0)),\n        (\"naturals\", (0, 0)),\n        (\"odsol\", (0, 0)),\n        (\"nsu\", (0, 0)),\n        (\"DiacriticalAcu\", (0, 0)),\n        (\"phi;\", (966, 0)),\n        (\"RuleDelaye\", (0, 0)),\n        (\"frac56\", (0, 0)),\n        (\"rtrilt\", (0, 0)),\n        (\"nsupE;\", (10950, 824)),\n        (\"doubleba\", (0, 0)),\n        (\"yac\", (0, 0)),\n        (\"curlywed\", (0, 0)),\n        (\"Hstrok;\", (294, 0)),\n        (\"cuda\", (0, 0)),\n        (\"capc\", (0, 0)),\n        (\"Kscr;\", (119974, 0)),\n        (\"seArr\", (0, 0)),\n        (\"LongRigh\", (0, 0)),\n        (\"larrl\", (0, 0)),\n        (\"ThinSp\", (0, 0)),\n        (\"scpol\", (0, 0)),\n        (\"raq\", (0, 0)),\n        (\"Tscr;\", (119983, 0)),\n        (\"rlm;\", (8207, 0)),\n        (\"xsqcup\", (0, 0)),\n        (\"varepsilo\", (0, 0)),\n        (\"RightUpDownVec\", (0, 0)),\n        (\"prn\", (0, 0)),\n        (\"NotRightTrian\", (0, 0)),\n        (\"Racute;\", (340, 0)),\n        (\"lacu\", (0, 0)),\n        (\"eg\", (0, 0)),\n        (\"scpolint;\", (10771, 0)),\n        (\"gbre\", (0, 0)),\n        (\"TScy\", (0, 0)),\n        (\"curvearrowleft;\", (8630, 0)),\n        (\"nedot\", (0, 0)),\n        (\"angzarr\", (0, 0)),\n        (\"Top\", (0, 0)),\n        (\"dolla\", (0, 0)),\n        (\"CapitalDifferent\", (0, 0)),\n        (\"amacr\", (0, 0)),\n        (\"ldquor;\", (8222, 0)),\n        (\"ecolo\", (0, 0)),\n        (\"notinE\", (0, 0)),\n        (\"Clo\", (0, 0)),\n        (\"nvinfi\", (0, 0)),\n        (\"succapprox\", (0, 0)),\n        (\"lesssim\", (0, 0)),\n        (\"para;\", (182, 0)),\n        (\"plankv;\", (8463, 0)),\n        (\"ClockwiseContourIn\", (0, 0)),\n        (\"nrarr\", (0, 0)),\n        (\"searh\", (0, 0)),\n        (\"precneq\", (0, 0)),\n        (\"ensp;\", (8194, 0)),\n        (\"RightC\", (0, 0)),\n        (\"Ce\", (0, 0)),\n        (\"rtriltri\", (0, 0)),\n        (\"LeftFlo\", (0, 0)),\n        (\"RightAngleBracket;\", (10217, 0)),\n        (\"boxdR\", (0, 0)),\n        (\"Contou\", (0, 0)),\n        (\"boxUR\", (0, 0)),\n        (\"Rarrt\", (0, 0)),\n        (\"FilledVerySmallSquar\", (0, 0)),\n        (\"Diacrit\", (0, 0)),\n        (\"NotLeftTriangleEq\", (0, 0)),\n        (\"dots\", (0, 0)),\n        (\"ijli\", (0, 0)),\n        (\"Od\", (0, 0)),\n        (\"ReverseUp\", (0, 0)),\n        (\"Colon\", (0, 0)),\n        (\"zc\", (0, 0)),\n        (\"DownLeftTeeVect\", (0, 0)),\n        (\"ecy;\", (1101, 0)),\n        (\"afr\", (0, 0)),\n        (\"emsp13\", (0, 0)),\n        (\"ulcrop;\", (8975, 0)),\n        (\"rarrw\", (0, 0)),\n        (\"nvsim;\", (8764, 8402)),\n        (\"rc\", (0, 0)),\n        (\"vartrian\", (0, 0)),\n        (\"dfish\", (0, 0)),\n        (\"acute;\", (180, 0)),\n        (\"edot\", (0, 0)),\n        (\"Vvda\", (0, 0)),\n        (\"RightUpVectorBa\", (0, 0)),\n        (\"LeftTee\", (0, 0)),\n        (\"notniva\", (0, 0)),\n        (\"Iota;\", (921, 0)),\n        (\"iocy;\", (1105, 0)),\n        (\"NotTildeTi\", (0, 0)),\n        (\"scnsim;\", (8937, 0)),\n        (\"PrecedesTilde;\", (8830, 0)),\n        (\"nsupe;\", (8841, 0)),\n        (\"bsim;\", (8765, 0)),\n        (\"se\", (0, 0)),\n        (\"asymp\", (0, 0)),\n        (\"EmptyVerySmallSq\", (0, 0)),\n        (\"omid;\", (10678, 0)),\n        (\"circledR\", (0, 0)),\n        (\"NotGreaterFull\", (0, 0)),\n        (\"acE\", (0, 0)),\n        (\"Congr\", (0, 0)),\n        (\"olarr;\", (8634, 0)),\n        (\"bigtrian\", (0, 0)),\n        (\"X\", (0, 0)),\n        (\"nl\", (0, 0)),\n        (\"lAarr;\", (8666, 0)),\n        (\"isinsv\", (0, 0)),\n        (\"SquareIntersec\", (0, 0)),\n        (\"udblac\", (0, 0)),\n        (\"Xfr\", (0, 0)),\n        (\"vBarv;\", (10985, 0)),\n        (\"capbrc\", (0, 0)),\n        (\"simrarr;\", (10610, 0)),\n        (\"prsim\", (0, 0)),\n        (\"CirclePlus\", (0, 0)),\n        (\"spadesui\", (0, 0)),\n        (\"varsigma;\", (962, 0)),\n        (\"TR\", (0, 0)),\n        (\"oper\", (0, 0)),\n        (\"diamondsuit;\", (9830, 0)),\n        (\"sqcap\", (0, 0)),\n        (\"ltl\", (0, 0)),\n        (\"NotRightTriang\", (0, 0)),\n        (\"ici\", (0, 0)),\n        (\"gtrappro\", (0, 0)),\n        (\"HorizontalL\", (0, 0)),\n        (\"boxHU\", (0, 0)),\n        (\"Imacr\", (0, 0)),\n        (\"rect;\", (9645, 0)),\n        (\"GJ\", (0, 0)),\n        (\"boxplu\", (0, 0)),\n        (\"circledd\", (0, 0)),\n        (\"gnsim\", (0, 0)),\n        (\"eque\", (0, 0)),\n        (\"boxHd\", (0, 0)),\n        (\"swAr\", (0, 0)),\n        (\"boxb\", (0, 0)),\n        (\"LessSlant\", (0, 0)),\n        (\"Ll;\", (8920, 0)),\n        (\"larr;\", (8592, 0)),\n        (\"Lowe\", (0, 0)),\n        (\"ma\", (0, 0)),\n        (\"vop\", (0, 0)),\n        (\"eog\", (0, 0)),\n        (\"Sac\", (0, 0)),\n        (\"nvrt\", (0, 0)),\n        (\"precnsim\", (0, 0)),\n        (\"fopf;\", (120151, 0)),\n        (\"loarr;\", (8701, 0)),\n        (\"lg;\", (8822, 0)),\n        (\"iiiint\", (0, 0)),\n        (\"approxeq;\", (8778, 0)),\n        (\"hookright\", (0, 0)),\n        (\"NotDoubl\", (0, 0)),\n        (\"nsc\", (0, 0)),\n        (\"Sscr;\", (119982, 0)),\n        (\"Diacriti\", (0, 0)),\n        (\"gtreqqless\", (0, 0)),\n        (\"NotGreaterSlan\", (0, 0)),\n        (\"icir\", (0, 0)),\n        (\"Sub\", (0, 0)),\n        (\"twoheadrightarrow\", (0, 0)),\n        (\"DoubleUpDown\", (0, 0)),\n        (\"NotSucceedsSlantE\", (0, 0)),\n        (\"subseteq\", (0, 0)),\n        (\"nsubE;\", (10949, 824)),\n        (\"rtri;\", (9657, 0)),\n        (\"LongLeft\", (0, 0)),\n        (\"Tca\", (0, 0)),\n        (\"vsupne;\", (8843, 65024)),\n        (\"Updow\", (0, 0)),\n        (\"xrArr;\", (10233, 0)),\n        (\"prec;\", (8826, 0)),\n        (\"efr\", (0, 0)),\n        (\"VerticalSeparator;\", (10072, 0)),\n        (\"OpenCurlyDoub\", (0, 0)),\n        (\"Qop\", (0, 0)),\n        (\"homtht\", (0, 0)),\n        (\"Ido\", (0, 0)),\n        (\"rightrig\", (0, 0)),\n        (\"andslo\", (0, 0)),\n        (\"lesc\", (0, 0)),\n        (\"Scy;\", (1057, 0)),\n        (\"LeftTriangleEq\", (0, 0)),\n        (\"simdot;\", (10858, 0)),\n        (\"ffllig\", (0, 0)),\n        (\"trim\", (0, 0)),\n        (\"larrtl\", (0, 0)),\n        (\"nri\", (0, 0)),\n        (\"GreaterSlantEqua\", (0, 0)),\n        (\"rightarrowta\", (0, 0)),\n        (\"nshortpar\", (0, 0)),\n        (\"ncedi\", (0, 0)),\n        (\"RightArrowLe\", (0, 0)),\n        (\"simdot\", (0, 0)),\n        (\"GreaterFu\", (0, 0)),\n        (\"RightUpTeeVector;\", (10588, 0)),\n        (\"gtrsim;\", (8819, 0)),\n        (\"lates;\", (10925, 65024)),\n        (\"NotTildeF\", (0, 0)),\n        (\"simra\", (0, 0)),\n        (\"zcaro\", (0, 0)),\n        (\"LeftTriangleE\", (0, 0)),\n        (\"DoubleVertical\", (0, 0)),\n        (\"awi\", (0, 0)),\n        (\"Ucir\", (0, 0)),\n        (\"qua\", (0, 0)),\n        (\"LessTilde;\", (8818, 0)),\n        (\"propto\", (0, 0)),\n        (\"precsi\", (0, 0)),\n        (\"compf\", (0, 0)),\n        (\"lsq\", (0, 0)),\n        (\"Wo\", (0, 0)),\n        (\"ltlarr\", (0, 0)),\n        (\"andand\", (0, 0)),\n        (\"LongRight\", (0, 0)),\n        (\"cire\", (0, 0)),\n        (\"DownTee\", (0, 0)),\n        (\"Jukcy\", (0, 0)),\n        (\"simr\", (0, 0)),\n        (\"infinti\", (0, 0)),\n        (\"upuparrow\", (0, 0)),\n        (\"SquareSubset\", (0, 0)),\n        (\"expon\", (0, 0)),\n        (\"DiacriticalT\", (0, 0)),\n        (\"apac\", (0, 0)),\n        (\"Superset;\", (8835, 0)),\n        (\"Iogon\", (0, 0)),\n        (\"NoBrea\", (0, 0)),\n        (\"circledc\", (0, 0)),\n        (\"LeftArrowRi\", (0, 0)),\n        (\"LongLeftRight\", (0, 0)),\n        (\"LeftUpDownVec\", (0, 0)),\n        (\"FilledSmallS\", (0, 0)),\n        (\"Vvdash\", (0, 0)),\n        (\"fflli\", (0, 0)),\n        (\"thkap;\", (8776, 0)),\n        (\"frac16;\", (8537, 0)),\n        (\"RightAr\", (0, 0)),\n        (\"DoubleRightArro\", (0, 0)),\n        (\"ur\", (0, 0)),\n        (\"DownLeftRig\", (0, 0)),\n        (\"DoubleLeftAr\", (0, 0)),\n        (\"rsaquo\", (0, 0)),\n        (\"succ;\", (8827, 0)),\n        (\"NotHumpDownHu\", (0, 0)),\n        (\"rightrightarrow\", (0, 0)),\n        (\"lrha\", (0, 0)),\n        (\"gap;\", (10886, 0)),\n        (\"Xf\", (0, 0)),\n        (\"bul\", (0, 0)),\n        (\"RuleDelayed;\", (10740, 0)),\n        (\"eparsl;\", (10723, 0)),\n        (\"gimel\", (0, 0)),\n        (\"telrec;\", (8981, 0)),\n        (\"lowas\", (0, 0)),\n        (\"PlusMinus\", (0, 0)),\n        (\"nleqq;\", (8806, 824)),\n        (\"precapprox;\", (10935, 0)),\n        (\"vartriangleright;\", (8883, 0)),\n        (\"uu\", (0, 0)),\n        (\"NegativeVeryThin\", (0, 0)),\n        (\"frac78;\", (8542, 0)),\n        (\"Iopf\", (0, 0)),\n        (\"LowerRightA\", (0, 0)),\n        (\"NotExi\", (0, 0)),\n        (\"xot\", (0, 0)),\n        (\"CapitalDifferentialD;\", (8517, 0)),\n        (\"lacute;\", (314, 0)),\n        (\"Cap;\", (8914, 0)),\n        (\"zeetrf\", (0, 0)),\n        (\"NotRevers\", (0, 0)),\n        (\"Ao\", (0, 0)),\n        (\"ulc\", (0, 0)),\n        (\"blacktrianglelef\", (0, 0)),\n        (\"eum\", (0, 0)),\n        (\"ltquest\", (0, 0)),\n        (\"mida\", (0, 0)),\n        (\"uda\", (0, 0)),\n        (\"DiacriticalDoubl\", (0, 0)),\n        (\"ltrif\", (0, 0)),\n        (\"rightharpoonu\", (0, 0)),\n        (\"OpenCurlyQu\", (0, 0)),\n        (\"Pcy\", (0, 0)),\n        (\"sdote\", (0, 0)),\n        (\"SubsetE\", (0, 0)),\n        (\"mst\", (0, 0)),\n        (\"NestedGreaterGreate\", (0, 0)),\n        (\"Ntil\", (0, 0)),\n        (\"Amac\", (0, 0)),\n        (\"nbumpe\", (0, 0)),\n        (\"Equa\", (0, 0)),\n        (\"eqsim\", (0, 0)),\n        (\"Cent\", (0, 0)),\n        (\"Aum\", (0, 0)),\n        (\"gnsim;\", (8935, 0)),\n        (\"Because\", (0, 0)),\n        (\"xotim\", (0, 0)),\n        (\"supset;\", (8835, 0)),\n        (\"simn\", (0, 0)),\n        (\"sqsubs\", (0, 0)),\n        (\"Equili\", (0, 0)),\n        (\"LeftArrowBar\", (0, 0)),\n        (\"nless\", (0, 0)),\n        (\"NotGreaterGreater\", (0, 0)),\n        (\"gvnE;\", (8809, 65024)),\n        (\"varth\", (0, 0)),\n        (\"veeeq;\", (8794, 0)),\n        (\"Dagge\", (0, 0)),\n        (\"bigtriangl\", (0, 0)),\n        (\"SuchThat\", (0, 0)),\n        (\"OverParenthesi\", (0, 0)),\n        (\"DoubleUp\", (0, 0)),\n        (\"cups\", (0, 0)),\n        (\"DScy;\", (1029, 0)),\n        (\"dAr\", (0, 0)),\n        (\"emsp13;\", (8196, 0)),\n        (\"Yacute\", (221, 0)),\n        (\"lsimg\", (0, 0)),\n        (\"mfr;\", (120106, 0)),\n        (\"nvin\", (0, 0)),\n        (\"osl\", (0, 0)),\n        (\"vnsup\", (0, 0)),\n        (\"RightArrowLeftAr\", (0, 0)),\n        (\"weier\", (0, 0)),\n        (\"zop\", (0, 0)),\n        (\"lessgtr\", (0, 0)),\n        (\"leftleftarro\", (0, 0)),\n        (\"lessa\", (0, 0)),\n        (\"varpi;\", (982, 0)),\n        (\"Gopf;\", (120126, 0)),\n        (\"OverBracket;\", (9140, 0)),\n        (\"isins;\", (8948, 0)),\n        (\"wedgeq;\", (8793, 0)),\n        (\"simplus\", (0, 0)),\n        (\"ufisht\", (0, 0)),\n        (\"lurds\", (0, 0)),\n        (\"verbar;\", (124, 0)),\n        (\"urco\", (0, 0)),\n        (\"Uuml\", (220, 0)),\n        (\"Cacut\", (0, 0)),\n        (\"NotSucceedsSlant\", (0, 0)),\n        (\"ReverseUpEquili\", (0, 0)),\n        (\"NotDoubleVert\", (0, 0)),\n        (\"sst\", (0, 0)),\n        (\"pertenk;\", (8241, 0)),\n        (\"blacksq\", (0, 0)),\n        (\"hal\", (0, 0)),\n        (\"NotNested\", (0, 0)),\n        (\"DiacriticalGrav\", (0, 0)),\n        (\"rharul;\", (10604, 0)),\n        (\"Cca\", (0, 0)),\n        (\"yuml\", (255, 0)),\n        (\"incare;\", (8453, 0)),\n        (\"varsubse\", (0, 0)),\n        (\"ru\", (0, 0)),\n        (\"vDas\", (0, 0)),\n        (\"ifr;\", (120102, 0)),\n        (\"LeftDoubleBracke\", (0, 0)),\n        (\"ThinSpace\", (0, 0)),\n        (\"supsetne\", (0, 0)),\n        (\"sqsupset\", (0, 0)),\n        (\"Uarrocir\", (0, 0)),\n        (\"nacute;\", (324, 0)),\n        (\"xsq\", (0, 0)),\n        (\"succnapp\", (0, 0)),\n        (\"topfork\", (0, 0)),\n        (\"tritim\", (0, 0)),\n        (\"nrtr\", (0, 0)),\n        (\"quot\", (34, 0)),\n        (\"ep\", (0, 0)),\n        (\"mho\", (0, 0)),\n        (\"Proportiona\", (0, 0)),\n        (\"NestedGreaterGre\", (0, 0)),\n        (\"DoubleCon\", (0, 0)),\n        (\"cire;\", (8791, 0)),\n        (\"RightTeeArrow\", (0, 0)),\n        (\"nedot;\", (8784, 824)),\n        (\"OpenCurlyDouble\", (0, 0)),\n        (\"NotGr\", (0, 0)),\n        (\"sea\", (0, 0)),\n        (\"geqq;\", (8807, 0)),\n        (\"um\", (0, 0)),\n        (\"rlh\", (0, 0)),\n        (\"jf\", (0, 0)),\n        (\"lc\", (0, 0)),\n        (\"das\", (0, 0)),\n        (\"swArr;\", (8665, 0)),\n        (\"DownLeftVectorBa\", (0, 0)),\n        (\"ssetmn\", (0, 0)),\n        (\"Eleme\", (0, 0)),\n        (\"upa\", (0, 0)),\n        (\"angsph\", (0, 0)),\n        (\"com\", (0, 0)),\n        (\"cirE;\", (10691, 0)),\n        (\"loan\", (0, 0)),\n        (\"Yacute;\", (221, 0)),\n        (\"dollar;\", (36, 0)),\n        (\"Contour\", (0, 0)),\n        (\"gvert\", (0, 0)),\n        (\"rceil\", (0, 0)),\n        (\"cuepr;\", (8926, 0)),\n        (\"La\", (0, 0)),\n        (\"CircleMi\", (0, 0)),\n        (\"DoubleLongLeftRight\", (0, 0)),\n        (\"nm\", (0, 0)),\n        (\"ltimes;\", (8905, 0)),\n        (\"UpperRigh\", (0, 0)),\n        (\"rae\", (0, 0)),\n        (\"Ocirc\", (212, 0)),\n        (\"gesl\", (0, 0)),\n        (\"pointi\", (0, 0)),\n        (\"rsqb;\", (93, 0)),\n        (\"ko\", (0, 0)),\n        (\"nhpar\", (0, 0)),\n        (\"scy\", (0, 0)),\n        (\"urcorner;\", (8989, 0)),\n        (\"ImaginaryI;\", (8520, 0)),\n        (\"Equil\", (0, 0)),\n        (\"vert;\", (124, 0)),\n        (\"leftlef\", (0, 0)),\n        (\"boxVH;\", (9580, 0)),\n        (\"yscr\", (0, 0)),\n        (\"uacute\", (250, 0)),\n        (\"RightArrowLeftArrow;\", (8644, 0)),\n        (\"Negative\", (0, 0)),\n        (\"Diamond;\", (8900, 0)),\n        (\"punc\", (0, 0)),\n        (\"Aogon;\", (260, 0)),\n        (\"LeftCe\", (0, 0)),\n        (\"NegativeMed\", (0, 0)),\n        (\"iques\", (0, 0)),\n        (\"forall\", (0, 0)),\n        (\"Supse\", (0, 0)),\n        (\"boxVH\", (0, 0)),\n        (\"NotRightTriangleBar;\", (10704, 824)),\n        (\"NotNestedLessLess;\", (10913, 824)),\n        (\"Diamo\", (0, 0)),\n        (\"NotRever\", (0, 0)),\n        (\"profsur\", (0, 0)),\n        (\"LeftTeeArrow\", (0, 0)),\n        (\"rarrlp;\", (8620, 0)),\n        (\"filig;\", (64257, 0)),\n        (\"Ex\", (0, 0)),\n        (\"nearh\", (0, 0)),\n        (\"ssc\", (0, 0)),\n        (\"Qfr\", (0, 0)),\n        (\"ecolon\", (0, 0)),\n        (\"Product\", (0, 0)),\n        (\"triangleright\", (0, 0)),\n        (\"mapstod\", (0, 0)),\n        (\"igrave;\", (236, 0)),\n        (\"bigstar;\", (9733, 0)),\n        (\"Uni\", (0, 0)),\n        (\"rightthreetim\", (0, 0)),\n        (\"Poincarepl\", (0, 0)),\n        (\"Gammad\", (0, 0)),\n        (\"bigoplu\", (0, 0)),\n        (\"varnothi\", (0, 0)),\n        (\"DownLeftVectorBar\", (0, 0)),\n        (\"fscr\", (0, 0)),\n        (\"Jscr\", (0, 0)),\n        (\"nsup\", (0, 0)),\n        (\"smil\", (0, 0)),\n        (\"Updowna\", (0, 0)),\n        (\"NotDoubleVertica\", (0, 0)),\n        (\"ropf\", (0, 0)),\n        (\"uH\", (0, 0)),\n        (\"hks\", (0, 0)),\n        (\"sce;\", (10928, 0)),\n        (\"xmap\", (0, 0)),\n        (\"loopar\", (0, 0)),\n        (\"SquareSupersetEqual;\", (8850, 0)),\n        (\"iota\", (0, 0)),\n        (\"delta;\", (948, 0)),\n        (\"xopf;\", (120169, 0)),\n        (\"wp\", (0, 0)),\n        (\"amal\", (0, 0)),\n        (\"nlt;\", (8814, 0)),\n        (\"NoB\", (0, 0)),\n        (\"yuml;\", (255, 0)),\n        (\"neArr;\", (8663, 0)),\n        (\"Cf\", (0, 0)),\n        (\"Gbrev\", (0, 0)),\n        (\"doll\", (0, 0)),\n        (\"oc\", (0, 0)),\n        (\"ulcorn\", (0, 0)),\n        (\"UnderP\", (0, 0)),\n        (\"nabla\", (0, 0)),\n        (\"leftleftarrows\", (0, 0)),\n        (\"Coproduct;\", (8720, 0)),\n        (\"nsqsube\", (0, 0)),\n        (\"angmsdaa\", (0, 0)),\n        (\"Dst\", (0, 0)),\n        (\"CapitalDifferentialD\", (0, 0)),\n        (\"shortm\", (0, 0)),\n        (\"doteqdot;\", (8785, 0)),\n        (\"SHcy\", (0, 0)),\n        (\"SOFTc\", (0, 0)),\n        (\"Gbre\", (0, 0)),\n        (\"quate\", (0, 0)),\n        (\"subnE;\", (10955, 0)),\n        (\"LessTilde\", (0, 0)),\n        (\"supd\", (0, 0)),\n        (\"doublebarwedge;\", (8966, 0)),\n        (\"iff;\", (8660, 0)),\n        (\"awcon\", (0, 0)),\n        (\"lfl\", (0, 0)),\n        (\"FilledSmallSqua\", (0, 0)),\n        (\"VeryThinSpace;\", (8202, 0)),\n        (\"subrarr;\", (10617, 0)),\n        (\"alpha\", (0, 0)),\n        (\"Csc\", (0, 0)),\n        (\"ovbar\", (0, 0)),\n        (\"lra\", (0, 0)),\n        (\"ubreve;\", (365, 0)),\n        (\"NotLessSla\", (0, 0)),\n        (\"Rce\", (0, 0)),\n        (\"nLeftrighta\", (0, 0)),\n        (\"NegativeVeryT\", (0, 0)),\n        (\"lrtr\", (0, 0)),\n        (\"Yuml\", (0, 0)),\n        (\"CloseCurlyDou\", (0, 0)),\n        (\"fork\", (0, 0)),\n        (\"ruluhar;\", (10600, 0)),\n        (\"rBa\", (0, 0)),\n        (\"varr;\", (8597, 0)),\n        (\"smallsetminus;\", (8726, 0)),\n        (\"lsqb\", (0, 0)),\n        (\"yu\", (0, 0)),\n        (\"olcr\", (0, 0)),\n        (\"bigcap\", (0, 0)),\n        (\"NotSubsetEqua\", (0, 0)),\n        (\"NotSucceedsSlantEqua\", (0, 0)),\n        (\"DoubleLongRightA\", (0, 0)),\n        (\"interca\", (0, 0)),\n        (\"larrbfs;\", (10527, 0)),\n        (\"apa\", (0, 0)),\n        (\"NotSquareSuperset\", (0, 0)),\n        (\"nvdash\", (0, 0)),\n        (\"DownTee;\", (8868, 0)),\n        (\"xuplus;\", (10756, 0)),\n        (\"OverBrace;\", (9182, 0)),\n        (\"tridot\", (0, 0)),\n        (\"bigtr\", (0, 0)),\n        (\"Osl\", (0, 0)),\n        (\"lmo\", (0, 0)),\n        (\"Sscr\", (0, 0)),\n        (\"OverBrac\", (0, 0)),\n        (\"rightleftarr\", (0, 0)),\n        (\"nsime;\", (8772, 0)),\n        (\"sqcups;\", (8852, 65024)),\n        (\"NotTildeFullEq\", (0, 0)),\n        (\"nsc;\", (8833, 0)),\n        (\"notinvc\", (0, 0)),\n        (\"erD\", (0, 0)),\n        (\"lcar\", (0, 0)),\n        (\"CounterClockwiseContourInt\", (0, 0)),\n        (\"Fouriertrf;\", (8497, 0)),\n        (\"Rh\", (0, 0)),\n        (\"near\", (0, 0)),\n        (\"Mo\", (0, 0)),\n        (\"DotD\", (0, 0)),\n        (\"sof\", (0, 0)),\n        (\"ngt;\", (8815, 0)),\n        (\"ccups\", (0, 0)),\n        (\"appro\", (0, 0)),\n        (\"LeftDownVector;\", (8643, 0)),\n        (\"beca\", (0, 0)),\n        (\"trpez\", (0, 0)),\n        (\"blacktriangleri\", (0, 0)),\n        (\"congd\", (0, 0)),\n        (\"sacute\", (0, 0)),\n        (\"b\", (0, 0)),\n        (\"Sop\", (0, 0)),\n        (\"fllig\", (0, 0)),\n        (\"doteqdot\", (0, 0)),\n        (\"rpp\", (0, 0)),\n        (\"cente\", (0, 0)),\n        (\"bse\", (0, 0)),\n        (\"NotDoubleVerticalBar\", (0, 0)),\n        (\"brvbar\", (166, 0)),\n        (\"backprim\", (0, 0)),\n        (\"ReverseUpEquil\", (0, 0)),\n        (\"crarr\", (0, 0)),\n        (\"Zd\", (0, 0)),\n        (\"Afr\", (0, 0)),\n        (\"nvinfin;\", (10718, 0)),\n        (\"csub\", (0, 0)),\n        (\"lEg;\", (10891, 0)),\n        (\"eopf\", (0, 0)),\n        (\"scaro\", (0, 0)),\n        (\"rra\", (0, 0)),\n        (\"ncongd\", (0, 0)),\n        (\"abrev\", (0, 0)),\n        (\"Ther\", (0, 0)),\n        (\"DiacriticalDoubleAcute;\", (733, 0)),\n        (\"NotElement\", (0, 0)),\n        (\"updownarrow\", (0, 0)),\n        (\"ShortDownArro\", (0, 0)),\n        (\"ig\", (0, 0)),\n        (\"vangr\", (0, 0)),\n        (\"cuesc;\", (8927, 0)),\n        (\"Yac\", (0, 0)),\n        (\"ljcy\", (0, 0)),\n        (\"sqsubseteq\", (0, 0)),\n        (\"map;\", (8614, 0)),\n        (\"ljcy;\", (1113, 0)),\n        (\"Under\", (0, 0)),\n        (\"LeftTeeVector\", (0, 0)),\n        (\"TildeTil\", (0, 0)),\n        (\"quati\", (0, 0)),\n        (\"DoubleVerticalBa\", (0, 0)),\n        (\"longleftar\", (0, 0)),\n        (\"Auml;\", (196, 0)),\n        (\"tcaro\", (0, 0)),\n        (\"equal\", (0, 0)),\n        (\"NotGreaterFullEqual;\", (8807, 824)),\n        (\"nsupE\", (0, 0)),\n        (\"Proportio\", (0, 0)),\n        (\"epsilon\", (0, 0)),\n        (\"dbkar\", (0, 0)),\n        (\"upharpoonright\", (0, 0)),\n        (\"rata\", (0, 0)),\n        (\"NotNestedGreaterGreate\", (0, 0)),\n        (\"lrm;\", (8206, 0)),\n        (\"ael\", (0, 0)),\n        (\"frac23\", (0, 0)),\n        (\"Emac\", (0, 0)),\n        (\"Counter\", (0, 0)),\n        (\"capcup\", (0, 0)),\n        (\"Wfr\", (0, 0)),\n        (\"VerticalSe\", (0, 0)),\n        (\"rAta\", (0, 0)),\n        (\"NotSupersetEqu\", (0, 0)),\n        (\"angmsda\", (0, 0)),\n        (\"subm\", (0, 0)),\n        (\"LowerLeftArro\", (0, 0)),\n        (\"scnap;\", (10938, 0)),\n        (\"rotimes;\", (10805, 0)),\n        (\"Lacut\", (0, 0)),\n        (\"bigodot\", (0, 0)),\n        (\"veebar;\", (8891, 0)),\n        (\"leg;\", (8922, 0)),\n        (\"du\", (0, 0)),\n        (\"aopf\", (0, 0)),\n        (\"hbar;\", (8463, 0)),\n        (\"ouml;\", (246, 0)),\n        (\"tbrk;\", (9140, 0)),\n        (\"lnapprox\", (0, 0)),\n        (\"lharu;\", (8636, 0)),\n        (\"upsih\", (0, 0)),\n        (\"nsi\", (0, 0)),\n        (\"nwne\", (0, 0)),\n        (\"Nest\", (0, 0)),\n        (\"plusacir\", (0, 0)),\n        (\"LeftTriangleBar;\", (10703, 0)),\n        (\"bsolhsub;\", (10184, 0)),\n        (\"Egra\", (0, 0)),\n        (\"ccaron;\", (269, 0)),\n        (\"vcy\", (0, 0)),\n        (\"Proportional\", (0, 0)),\n        (\"ShortLeftArrow\", (0, 0)),\n        (\"SubsetEqua\", (0, 0)),\n        (\"hearts;\", (9829, 0)),\n        (\"because;\", (8757, 0)),\n        (\"mcy;\", (1084, 0)),\n        (\"shortpa\", (0, 0)),\n        (\"NotGreaterS\", (0, 0)),\n        (\"lAr\", (0, 0)),\n        (\"realp\", (0, 0)),\n        (\"Cayley\", (0, 0)),\n        (\"RightTriangleBar;\", (10704, 0)),\n        (\"aop\", (0, 0)),\n        (\"NotLess\", (0, 0)),\n        (\"RightA\", (0, 0)),\n        (\"looparro\", (0, 0)),\n        (\"NotVe\", (0, 0)),\n        (\"equivD\", (0, 0)),\n        (\"Circl\", (0, 0)),\n        (\"leftthreetim\", (0, 0)),\n        (\"popf;\", (120161, 0)),\n        (\"DoubleVer\", (0, 0)),\n        (\"raqu\", (0, 0)),\n        (\"nbum\", (0, 0)),\n        (\"Larr\", (0, 0)),\n        (\"NotReverseElement;\", (8716, 0)),\n        (\"NotPrecedesSl\", (0, 0)),\n        (\"downharpoonl\", (0, 0)),\n        (\"nVDash\", (0, 0)),\n        (\"loopa\", (0, 0)),\n        (\"plusci\", (0, 0)),\n        (\"Eopf;\", (120124, 0)),\n        (\"larrhk;\", (8617, 0)),\n        (\"orarr\", (0, 0)),\n        (\"subnE\", (0, 0)),\n        (\"leftthreet\", (0, 0)),\n        (\"prop;\", (8733, 0)),\n        (\"nlsim\", (0, 0)),\n        (\"care\", (0, 0)),\n        (\"Inter\", (0, 0)),\n        (\"cc\", (0, 0)),\n        (\"CounterClo\", (0, 0)),\n        (\"nrar\", (0, 0)),\n        (\"DoubleLeftRightArro\", (0, 0)),\n        (\"permil;\", (8240, 0)),\n        (\"ps\", (0, 0)),\n        (\"Back\", (0, 0)),\n        (\"hookle\", (0, 0)),\n        (\"cs\", (0, 0)),\n        (\"ddagger\", (0, 0)),\n        (\"Succeeds\", (0, 0)),\n        (\"eqslantl\", (0, 0)),\n        (\"rbr\", (0, 0)),\n        (\"LeftArrowBar;\", (8676, 0)),\n        (\"Amacr;\", (256, 0)),\n        (\"angmsdaf\", (0, 0)),\n        (\"ImaginaryI\", (0, 0)),\n        (\"Ed\", (0, 0)),\n        (\"becau\", (0, 0)),\n        (\"Backslash\", (0, 0)),\n        (\"NotPrec\", (0, 0)),\n        (\"Rs\", (0, 0)),\n        (\"Rcedil\", (0, 0)),\n        (\"succcur\", (0, 0)),\n        (\"NotHumpEqual;\", (8783, 824)),\n        (\"Ssc\", (0, 0)),\n        (\"nsubsete\", (0, 0)),\n        (\"con\", (0, 0)),\n        (\"cdo\", (0, 0)),\n        (\"Fopf\", (0, 0)),\n        (\"Rrightarrow\", (0, 0)),\n        (\"scp\", (0, 0)),\n        (\"NotTildeEqua\", (0, 0)),\n        (\"napi\", (0, 0)),\n        (\"ab\", (0, 0)),\n        (\"Cap\", (0, 0)),\n        (\"lrh\", (0, 0)),\n        (\"NotHu\", (0, 0)),\n        (\"osla\", (0, 0)),\n        (\"rightsquigarro\", (0, 0)),\n        (\"exist\", (0, 0)),\n        (\"veeeq\", (0, 0)),\n        (\"DoubleLongLeftArr\", (0, 0)),\n        (\"Leftar\", (0, 0)),\n        (\"twoheadri\", (0, 0)),\n        (\"for\", (0, 0)),\n        (\"NotGreaterFullEqual\", (0, 0)),\n        (\"RightTr\", (0, 0)),\n        (\"Mellintrf\", (0, 0)),\n        (\"YIc\", (0, 0)),\n        (\"it;\", (8290, 0)),\n        (\"Uac\", (0, 0)),\n        (\"herc\", (0, 0)),\n        (\"mlcp;\", (10971, 0)),\n        (\"sqsupset;\", (8848, 0)),\n        (\"mp\", (0, 0)),\n        (\"rightthreetimes;\", (8908, 0)),\n        (\"MediumS\", (0, 0)),\n        (\"dharl;\", (8643, 0)),\n        (\"leftrightharp\", (0, 0)),\n        (\"cular\", (0, 0)),\n        (\"Sho\", (0, 0)),\n        (\"iexcl\", (161, 0)),\n        (\"pitc\", (0, 0)),\n        (\"L\", (0, 0)),\n        (\"LeftRightArro\", (0, 0)),\n        (\"Uring;\", (366, 0)),\n        (\"pars\", (0, 0)),\n        (\"asymp;\", (8776, 0)),\n        (\"Ati\", (0, 0)),\n        (\"angmsdad\", (0, 0)),\n        (\"malt\", (0, 0)),\n        (\"realin\", (0, 0)),\n        (\"RightVectorBar;\", (10579, 0)),\n        (\"Sc;\", (10940, 0)),\n        (\"NotTildeFull\", (0, 0)),\n        (\"Oci\", (0, 0)),\n        (\"rightharpoondown;\", (8641, 0)),\n        (\"trido\", (0, 0)),\n        (\"submult\", (0, 0)),\n        (\"elinters;\", (9191, 0)),\n        (\"cedil\", (184, 0)),\n        (\"eq\", (0, 0)),\n        (\"varepsi\", (0, 0)),\n        (\"circleddash;\", (8861, 0)),\n        (\"hoarr;\", (8703, 0)),\n        (\"ucirc\", (251, 0)),\n        (\"measureda\", (0, 0)),\n        (\"ContourInt\", (0, 0)),\n        (\"LowerLe\", (0, 0)),\n        (\"dzigrar\", (0, 0)),\n        (\"boxtimes;\", (8864, 0)),\n        (\"percnt\", (0, 0)),\n        (\"ogt\", (0, 0)),\n        (\"Iukc\", (0, 0)),\n        (\"DownTeeArrow;\", (8615, 0)),\n        (\"Agrav\", (0, 0)),\n        (\"gtrles\", (0, 0)),\n        (\"erDot;\", (8787, 0)),\n        (\"Mellint\", (0, 0)),\n        (\"PrecedesE\", (0, 0)),\n        (\"as\", (0, 0)),\n        (\"NotEx\", (0, 0)),\n        (\"sqsube\", (0, 0)),\n        (\"precsim;\", (8830, 0)),\n        (\"fs\", (0, 0)),\n        (\"realpart\", (0, 0)),\n        (\"Ropf\", (0, 0)),\n        (\"barvee;\", (8893, 0)),\n        (\"leftthre\", (0, 0)),\n        (\"NotSucceedsE\", (0, 0)),\n        (\"frac25;\", (8534, 0)),\n        (\"backe\", (0, 0)),\n        (\"Colo\", (0, 0)),\n        (\"vd\", (0, 0)),\n        (\"OverBar;\", (8254, 0)),\n        (\"exist;\", (8707, 0)),\n        (\"Cup;\", (8915, 0)),\n        (\"paralle\", (0, 0)),\n        (\"OverB\", (0, 0)),\n        (\"LessSlantEqual;\", (10877, 0)),\n        (\"zscr;\", (120015, 0)),\n        (\"DownL\", (0, 0)),\n        (\"mDD\", (0, 0)),\n        (\"boxH\", (0, 0)),\n        (\"fjl\", (0, 0)),\n        (\"Bre\", (0, 0)),\n        (\"NotLessEq\", (0, 0)),\n        (\"bso\", (0, 0)),\n        (\"blacklozenge;\", (10731, 0)),\n        (\"Rig\", (0, 0)),\n        (\"rparg\", (0, 0)),\n        (\"EmptyVerySmallSquare\", (0, 0)),\n        (\"smid;\", (8739, 0)),\n        (\"nis;\", (8956, 0)),\n        (\"DZcy\", (0, 0)),\n        (\"bigtriang\", (0, 0)),\n        (\"khc\", (0, 0)),\n        (\"lltr\", (0, 0)),\n        (\"OpenCurlyDo\", (0, 0)),\n        (\"NotRightTr\", (0, 0)),\n        (\"DiacriticalDoubleAcu\", (0, 0)),\n        (\"backepsi\", (0, 0)),\n        (\"OpenCurlyQ\", (0, 0)),\n        (\"trianglerigh\", (0, 0)),\n        (\"supe\", (0, 0)),\n        (\"Equi\", (0, 0)),\n        (\"NotHumpEqu\", (0, 0)),\n        (\"Usc\", (0, 0)),\n        (\"Msc\", (0, 0)),\n        (\"upsilon;\", (965, 0)),\n        (\"sex\", (0, 0)),\n        (\"FilledVerySmallSqu\", (0, 0)),\n        (\"RightUpDownV\", (0, 0)),\n        (\"copysr\", (0, 0)),\n        (\"ShortLeft\", (0, 0)),\n        (\"ultri;\", (9720, 0)),\n        (\"lsaquo\", (0, 0)),\n        (\"LeftUpT\", (0, 0)),\n        (\"De\", (0, 0)),\n        (\"twoheadleftarrow\", (0, 0)),\n        (\"nesear;\", (10536, 0)),\n        (\"NonBreakingS\", (0, 0)),\n        (\"thicksim;\", (8764, 0)),\n        (\"alefs\", (0, 0)),\n        (\"cupcap\", (0, 0)),\n        (\"hcirc\", (0, 0)),\n        (\"Kcedi\", (0, 0)),\n        (\"angrtvbd;\", (10653, 0)),\n        (\"capbr\", (0, 0)),\n        (\"UnderParen\", (0, 0)),\n        (\"GreaterS\", (0, 0)),\n        (\"solbar;\", (9023, 0)),\n        (\"fn\", (0, 0)),\n        (\"cularr;\", (8630, 0)),\n        (\"zee\", (0, 0)),\n        (\"laquo;\", (171, 0)),\n        (\"poi\", (0, 0)),\n        (\"roang;\", (10221, 0)),\n        (\"rHar;\", (10596, 0)),\n        (\"natur;\", (9838, 0)),\n        (\"Fill\", (0, 0)),\n        (\"y\", (0, 0)),\n        (\"NotSquareSubsetEqu\", (0, 0)),\n        (\"deg\", (176, 0)),\n        (\"ecy\", (0, 0)),\n        (\"aogon;\", (261, 0)),\n        (\"raemp\", (0, 0)),\n        (\"xlA\", (0, 0)),\n        (\"cupbrc\", (0, 0)),\n        (\"Imp\", (0, 0)),\n        (\"nang;\", (8736, 8402)),\n        (\"gtq\", (0, 0)),\n        (\"leftha\", (0, 0)),\n        (\"KHcy\", (0, 0)),\n        (\"xotime;\", (10754, 0)),\n        (\"nce\", (0, 0)),\n        (\"SquareIntersectio\", (0, 0)),\n        (\"varepsilon;\", (1013, 0)),\n        (\"DownBreve;\", (785, 0)),\n        (\"ulcr\", (0, 0)),\n        (\"vrtr\", (0, 0)),\n        (\"Js\", (0, 0)),\n        (\"gtrs\", (0, 0)),\n        (\"gtrl\", (0, 0)),\n        (\"VerticalSepara\", (0, 0)),\n        (\"blacktriangle;\", (9652, 0)),\n        (\"circlearrowright\", (0, 0)),\n        (\"bneq\", (0, 0)),\n        (\"frac\", (0, 0)),\n        (\"NotLessEqual;\", (8816, 0)),\n        (\"nrarrw\", (0, 0)),\n        (\"dzigrarr\", (0, 0)),\n        (\"cr\", (0, 0)),\n        (\"Xscr;\", (119987, 0)),\n        (\"rbbr\", (0, 0)),\n        (\"gb\", (0, 0)),\n        (\"hell\", (0, 0)),\n        (\"ntriangleleft;\", (8938, 0)),\n        (\"OverParent\", (0, 0)),\n        (\"longleftrightarr\", (0, 0)),\n        (\"rightar\", (0, 0)),\n        (\"pointint;\", (10773, 0)),\n        (\"ther\", (0, 0)),\n        (\"angsp\", (0, 0)),\n        (\"gime\", (0, 0)),\n        (\"Us\", (0, 0)),\n        (\"ropf;\", (120163, 0)),\n        (\"Df\", (0, 0)),\n        (\"dempty\", (0, 0)),\n        (\"complexe\", (0, 0)),\n        (\"Star;\", (8902, 0)),\n        (\"Idot;\", (304, 0)),\n        (\"soft\", (0, 0)),\n        (\"ccedil\", (231, 0)),\n        (\"nwarr;\", (8598, 0)),\n        (\"dfisht\", (0, 0)),\n        (\"Vert\", (0, 0)),\n        (\"dbk\", (0, 0)),\n        (\"gne\", (0, 0)),\n        (\"neq\", (0, 0)),\n        (\"boxHd;\", (9572, 0)),\n        (\"rfl\", (0, 0)),\n        (\"bigwedge\", (0, 0)),\n        (\"operp;\", (10681, 0)),\n        (\"lnapprox;\", (10889, 0)),\n        (\"times;\", (215, 0)),\n        (\"NestedGreaterGr\", (0, 0)),\n        (\"Ms\", (0, 0)),\n        (\"Vscr;\", (119985, 0)),\n        (\"UpEquilibr\", (0, 0)),\n        (\"inc\", (0, 0)),\n        (\"downdow\", (0, 0)),\n        (\"ApplyFuncti\", (0, 0)),\n        (\"lbrack\", (0, 0)),\n        (\"rce\", (0, 0)),\n        (\"ldrush\", (0, 0)),\n        (\"backsim\", (0, 0)),\n        (\"ph\", (0, 0)),\n        (\"LeftVector;\", (8636, 0)),\n        (\"umac\", (0, 0)),\n        (\"hsc\", (0, 0)),\n        (\"kscr\", (0, 0)),\n        (\"lrhard\", (0, 0)),\n        (\"NotEqual\", (0, 0)),\n        (\"map\", (0, 0)),\n        (\"fjlig\", (0, 0)),\n        (\"lsquo;\", (8216, 0)),\n        (\"sect\", (167, 0)),\n        (\"lbrkslu\", (0, 0)),\n        (\"Isc\", (0, 0)),\n        (\"K\", (0, 0)),\n        (\"ddagg\", (0, 0)),\n        (\"ReverseEquilibr\", (0, 0)),\n        (\"leftharpoonup\", (0, 0)),\n        (\"seswar;\", (10537, 0)),\n        (\"complement\", (0, 0)),\n        (\"Lleftarr\", (0, 0)),\n        (\"iuml;\", (239, 0)),\n        (\"simg\", (0, 0)),\n        (\"boxbox\", (0, 0)),\n        (\"Gg\", (0, 0)),\n        (\"cwc\", (0, 0)),\n        (\"NotSquareSupersetEqual\", (0, 0)),\n        (\"weie\", (0, 0)),\n        (\"agrav\", (0, 0)),\n        (\"UpEquilibrium\", (0, 0)),\n        (\"RightCeil\", (0, 0)),\n        (\"op\", (0, 0)),\n        (\"boxvl\", (0, 0)),\n        (\"dtri;\", (9663, 0)),\n        (\"nhp\", (0, 0)),\n        (\"rbrac\", (0, 0)),\n        (\"Leftrightarro\", (0, 0)),\n        (\"ccedil;\", (231, 0)),\n        (\"UnderBar;\", (95, 0)),\n        (\"UpperLe\", (0, 0)),\n        (\"pre\", (0, 0)),\n        (\"middot;\", (183, 0)),\n        (\"Hst\", (0, 0)),\n        (\"Downarro\", (0, 0)),\n        (\"Four\", (0, 0)),\n        (\"nshortmid\", (0, 0)),\n        (\"lesdoto\", (0, 0)),\n        (\"rnmid;\", (10990, 0)),\n        (\"leftlefta\", (0, 0)),\n        (\"rightleft\", (0, 0)),\n        (\"Bernoulli\", (0, 0)),\n        (\"qint;\", (10764, 0)),\n        (\"quatint\", (0, 0)),\n        (\"nsubseteqq;\", (10949, 824)),\n        (\"rot\", (0, 0)),\n        (\"Mscr;\", (8499, 0)),\n        (\"quatern\", (0, 0)),\n        (\"boxD\", (0, 0)),\n        (\"supmult;\", (10946, 0)),\n        (\"NotLeftTriangle\", (0, 0)),\n        (\"Gcedil\", (0, 0)),\n        (\"LeftUpDownVector\", (0, 0)),\n        (\"NotRightTria\", (0, 0)),\n        (\"wedbar;\", (10847, 0)),\n        (\"horbar\", (0, 0)),\n        (\"RightDownTee\", (0, 0)),\n        (\"Eog\", (0, 0)),\n        (\"boxVr\", (0, 0)),\n        (\"lesseqqgt\", (0, 0)),\n        (\"OverP\", (0, 0)),\n        (\"Eopf\", (0, 0)),\n        (\"Ograv\", (0, 0)),\n        (\"nearrow;\", (8599, 0)),\n        (\"ima\", (0, 0)),\n        (\"ffll\", (0, 0)),\n        (\"DownRightVector;\", (8641, 0)),\n        (\"dscy;\", (1109, 0)),\n        (\"Expon\", (0, 0)),\n        (\"DownRightTeeV\", (0, 0)),\n        (\"Darr\", (0, 0)),\n        (\"Tstrok;\", (358, 0)),\n        (\"boxHu\", (0, 0)),\n        (\"nearro\", (0, 0)),\n        (\"thkap\", (0, 0)),\n        (\"vartrianglelef\", (0, 0)),\n        (\"downdownarrow\", (0, 0)),\n        (\"sz\", (0, 0)),\n        (\"hookleftarr\", (0, 0)),\n        (\"Ll\", (0, 0)),\n        (\"vn\", (0, 0)),\n        (\"quaternion\", (0, 0)),\n        (\"omac\", (0, 0)),\n        (\"SquareSupersetEqua\", (0, 0)),\n        (\"thins\", (0, 0)),\n        (\"Lstrok;\", (321, 0)),\n        (\"dscr\", (0, 0)),\n        (\"longleftarrow;\", (10229, 0)),\n        (\"DoubleContourIn\", (0, 0)),\n        (\"LongLeftRightArrow;\", (10231, 0)),\n        (\"LongLeftArrow;\", (10229, 0)),\n        (\"trianglerighteq\", (0, 0)),\n        (\"lfloor;\", (8970, 0)),\n        (\"subseteqq;\", (10949, 0)),\n        (\"laquo\", (171, 0)),\n        (\"RightTeeA\", (0, 0)),\n        (\"brv\", (0, 0)),\n        (\"ltdot;\", (8918, 0)),\n        (\"brvba\", (0, 0)),\n        (\"fpartin\", (0, 0)),\n        (\"Downarr\", (0, 0)),\n        (\"swarrow\", (0, 0)),\n        (\"Assign\", (0, 0)),\n        (\"UpperRightArro\", (0, 0)),\n        (\"alefsym;\", (8501, 0)),\n        (\"DoubleLongLe\", (0, 0)),\n        (\"Lefta\", (0, 0)),\n        (\"khcy\", (0, 0)),\n        (\"NotSucceedsEqual\", (0, 0)),\n        (\"nsubseteq\", (0, 0)),\n        (\"drb\", (0, 0)),\n        (\"NonBreakingSp\", (0, 0)),\n        (\"Ta\", (0, 0)),\n        (\"succ\", (0, 0)),\n        (\"utd\", (0, 0)),\n        (\"exponentiale\", (0, 0)),\n        (\"gt;\", (62, 0)),\n        (\"eDDot\", (0, 0)),\n        (\"rlm\", (0, 0)),\n        (\"PrecedesSlantEq\", (0, 0)),\n        (\"DownArrowUpArrow\", (0, 0)),\n        (\"DDo\", (0, 0)),\n        (\"solb;\", (10692, 0)),\n        (\"laemptyv;\", (10676, 0)),\n        (\"bigve\", (0, 0)),\n        (\"Fourier\", (0, 0)),\n        (\"Epsilon\", (0, 0)),\n        (\"subd\", (0, 0)),\n        (\"CapitalDiffer\", (0, 0)),\n        (\"SHc\", (0, 0)),\n        (\"Gg;\", (8921, 0)),\n        (\"boxtime\", (0, 0)),\n        (\"OpenCurlyD\", (0, 0)),\n        (\"simrarr\", (0, 0)),\n        (\"Ksc\", (0, 0)),\n        (\"angrtvb;\", (8894, 0)),\n        (\"sbquo\", (0, 0)),\n        (\"precapp\", (0, 0)),\n        (\"Ef\", (0, 0)),\n        (\"OverBr\", (0, 0)),\n        (\"gns\", (0, 0)),\n        (\"Tstrok\", (0, 0)),\n        (\"setmi\", (0, 0)),\n        (\"LeftCeil\", (0, 0)),\n        (\"RightVectorBar\", (0, 0)),\n        (\"boxul\", (0, 0)),\n        (\"Lmidot\", (0, 0)),\n        (\"smepar\", (0, 0)),\n        (\"Zet\", (0, 0)),\n        (\"rising\", (0, 0)),\n        (\"ncedil\", (0, 0)),\n        (\"Longleftar\", (0, 0)),\n        (\"lsquo\", (0, 0)),\n        (\"Hop\", (0, 0)),\n        (\"elsdot;\", (10903, 0)),\n        (\"sigmaf\", (0, 0)),\n        (\"varsu\", (0, 0)),\n        (\"Ks\", (0, 0)),\n        (\"twoheadle\", (0, 0)),\n        (\"tri\", (0, 0)),\n        (\"blacks\", (0, 0)),\n        (\"wfr\", (0, 0)),\n        (\"ZeroWidthS\", (0, 0)),\n        (\"ZHc\", (0, 0)),\n        (\"ddotseq\", (0, 0)),\n        (\"DoubleLeftArrow\", (0, 0)),\n        (\"ijlig\", (0, 0)),\n        (\"straightep\", (0, 0)),\n        (\"Uarro\", (0, 0)),\n        (\"lj\", (0, 0)),\n        (\"LeftDownT\", (0, 0)),\n        (\"zeta\", (0, 0)),\n        (\"ssta\", (0, 0)),\n        (\"Un\", (0, 0)),\n        (\"mf\", (0, 0)),\n        (\"harrcir;\", (10568, 0)),\n        (\"UnderBar\", (0, 0)),\n        (\"midd\", (0, 0)),\n        (\"bsol\", (0, 0)),\n        (\"lrcorn\", (0, 0)),\n        (\"hooklefta\", (0, 0)),\n        (\"bsemi;\", (8271, 0)),\n        (\"searrow;\", (8600, 0)),\n        (\"thickapprox\", (0, 0)),\n        (\"scnE;\", (10934, 0)),\n        (\"elsdo\", (0, 0)),\n        (\"ao\", (0, 0)),\n        (\"Min\", (0, 0)),\n        (\"nlE\", (0, 0)),\n        (\"bigs\", (0, 0)),\n        (\"disin;\", (8946, 0)),\n        (\"NotTildeTil\", (0, 0)),\n        (\"Zacut\", (0, 0)),\n        (\"nwarrow\", (0, 0)),\n        (\"NotExists\", (0, 0)),\n        (\"oS\", (0, 0)),\n        (\"Ocy;\", (1054, 0)),\n        (\"scedil\", (0, 0)),\n        (\"there\", (0, 0)),\n        (\"notinv\", (0, 0)),\n        (\"Nacu\", (0, 0)),\n        (\"Lca\", (0, 0)),\n        (\"lha\", (0, 0)),\n        (\"vAr\", (0, 0)),\n        (\"Ugrave;\", (217, 0)),\n        (\"ntriangleleft\", (0, 0)),\n        (\"mid\", (0, 0)),\n        (\"DoubleC\", (0, 0)),\n        (\"GreaterSlantEqual;\", (10878, 0)),\n        (\"sc;\", (8827, 0)),\n        (\"NotTildeTild\", (0, 0)),\n        (\"LessEqualGreater\", (0, 0)),\n        (\"swA\", (0, 0)),\n        (\"ordm;\", (186, 0)),\n        (\"ominus;\", (8854, 0)),\n        (\"DotDot;\", (8412, 0)),\n        (\"LowerL\", (0, 0)),\n        (\"lbbr\", (0, 0)),\n        (\"lcu\", (0, 0)),\n        (\"vsub\", (0, 0)),\n        (\"Util\", (0, 0)),\n        (\"iog\", (0, 0)),\n        (\"ex\", (0, 0)),\n        (\"DotEq\", (0, 0)),\n        (\"scnsi\", (0, 0)),\n        (\"rmo\", (0, 0)),\n        (\"Sopf\", (0, 0)),\n        (\"empty;\", (8709, 0)),\n        (\"nang\", (0, 0)),\n        (\"upsilon\", (0, 0)),\n        (\"rightharpo\", (0, 0)),\n        (\"ee;\", (8519, 0)),\n        (\"vltr\", (0, 0)),\n        (\"yacute;\", (253, 0)),\n        (\"pscr\", (0, 0)),\n        (\"supla\", (0, 0)),\n        (\"sopf\", (0, 0)),\n        (\"varnothing\", (0, 0)),\n        (\"supdot;\", (10942, 0)),\n        (\"RightDoubl\", (0, 0)),\n        (\"RBa\", (0, 0)),\n        (\"precnap\", (0, 0)),\n        (\"hookrighta\", (0, 0)),\n        (\"setmn;\", (8726, 0)),\n        (\"angmsdah\", (0, 0)),\n        (\"Imaginary\", (0, 0)),\n        (\"ccedi\", (0, 0)),\n        (\"Union\", (0, 0)),\n        (\"xuplu\", (0, 0)),\n        (\"sum;\", (8721, 0)),\n        (\"trisb\", (0, 0)),\n        (\"amp;\", (38, 0)),\n        (\"rightle\", (0, 0)),\n        (\"theta\", (0, 0)),\n        (\"nleqq\", (0, 0)),\n        (\"preccur\", (0, 0)),\n        (\"lob\", (0, 0)),\n        (\"erarr\", (0, 0)),\n        (\"Icir\", (0, 0)),\n        (\"bum\", (0, 0)),\n        (\"amp\", (38, 0)),\n        (\"EmptySmallSquar\", (0, 0)),\n        (\"sp\", (0, 0)),\n        (\"Longleftrightarrow\", (0, 0)),\n        (\"hybul\", (0, 0)),\n        (\"Tcedil\", (0, 0)),\n        (\"tosa\", (0, 0)),\n        (\"SucceedsSl\", (0, 0)),\n        (\"Berno\", (0, 0)),\n        (\"RightDownVectorBar\", (0, 0)),\n        (\"half\", (0, 0)),\n        (\"emptys\", (0, 0)),\n        (\"rhard;\", (8641, 0)),\n        (\"nsim;\", (8769, 0)),\n        (\"solb\", (0, 0)),\n        (\"between\", (0, 0)),\n        (\"nwar\", (0, 0)),\n        (\"larrsim;\", (10611, 0)),\n        (\"UpEqui\", (0, 0)),\n        (\"ngtr;\", (8815, 0)),\n        (\"FilledSmallSquare\", (0, 0)),\n        (\"uogon\", (0, 0)),\n        (\"mi\", (0, 0)),\n        (\"cwin\", (0, 0)),\n        (\"varsupsetneq\", (0, 0)),\n        (\"LeftUpVec\", (0, 0)),\n        (\"nprcu\", (0, 0)),\n        (\"nan\", (0, 0)),\n        (\"blacksquare;\", (9642, 0)),\n        (\"rcedil\", (0, 0)),\n        (\"ShortDownArrow;\", (8595, 0)),\n        (\"rarrsim;\", (10612, 0)),\n        (\"Xopf;\", (120143, 0)),\n        (\"cross\", (0, 0)),\n        (\"DownTeeArr\", (0, 0)),\n        (\"Otild\", (0, 0)),\n        (\"Jop\", (0, 0)),\n        (\"NotGreaterFullEqu\", (0, 0)),\n        (\"bbr\", (0, 0)),\n        (\"biguplu\", (0, 0)),\n        (\"uop\", (0, 0)),\n        (\"Thin\", (0, 0)),\n        (\"ov\", (0, 0)),\n        (\"boxuR;\", (9560, 0)),\n        (\"nRightarrow;\", (8655, 0)),\n        (\"Iacute\", (205, 0)),\n        (\"reali\", (0, 0)),\n        (\"cupcup\", (0, 0)),\n        (\"LongRightAr\", (0, 0)),\n        (\"nleftr\", (0, 0)),\n        (\"clubsui\", (0, 0)),\n        (\"andan\", (0, 0)),\n        (\"ycy;\", (1099, 0)),\n        (\"nvinfin\", (0, 0)),\n        (\"Ac\", (0, 0)),\n        (\"longmapsto;\", (10236, 0)),\n        (\"RightDoubleBracket;\", (10215, 0)),\n        (\"blacksqua\", (0, 0)),\n        (\"DoubleContour\", (0, 0)),\n        (\"isins\", (0, 0)),\n        (\"varsupsetne\", (0, 0)),\n        (\"LeftUpVect\", (0, 0)),\n        (\"nearr\", (0, 0)),\n        (\"Lle\", (0, 0)),\n        (\"Dscr;\", (119967, 0)),\n        (\"SucceedsSlan\", (0, 0)),\n        (\"Ass\", (0, 0)),\n        (\"sime\", (0, 0)),\n        (\"popf\", (0, 0)),\n        (\"LJcy;\", (1033, 0)),\n        (\"backeps\", (0, 0)),\n        (\"disin\", (0, 0)),\n        (\"ReverseEq\", (0, 0)),\n        (\"LeftAngleBr\", (0, 0)),\n        (\"UnderB\", (0, 0)),\n        (\"fallingdots\", (0, 0)),\n        (\"Verba\", (0, 0)),\n        (\"nrArr;\", (8655, 0)),\n        (\"Unio\", (0, 0)),\n        (\"Vc\", (0, 0)),\n        (\"female;\", (9792, 0)),\n        (\"topcir\", (0, 0)),\n        (\"NotSquareSubs\", (0, 0)),\n        (\"intl\", (0, 0)),\n        (\"her\", (0, 0)),\n        (\"prsi\", (0, 0)),\n        (\"downdownarr\", (0, 0)),\n        (\"Plus\", (0, 0)),\n        (\"elsd\", (0, 0)),\n        (\"lvertne\", (0, 0)),\n        (\"ccaron\", (0, 0)),\n        (\"lang\", (0, 0)),\n        (\"loar\", (0, 0)),\n        (\"LessS\", (0, 0)),\n        (\"LeftRigh\", (0, 0)),\n        (\"eqslantg\", (0, 0)),\n        (\"zwn\", (0, 0)),\n        (\"nsimeq\", (0, 0)),\n        (\"urcro\", (0, 0)),\n        (\"CHcy\", (0, 0)),\n        (\"Lapl\", (0, 0)),\n        (\"leqsl\", (0, 0)),\n        (\"LeftDownTeeVect\", (0, 0)),\n        (\"shortparalle\", (0, 0)),\n        (\"nvHar\", (0, 0)),\n        (\"Different\", (0, 0)),\n        (\"scE;\", (10932, 0)),\n        (\"Su\", (0, 0)),\n        (\"rcar\", (0, 0)),\n        (\"utri;\", (9653, 0)),\n        (\"UpTe\", (0, 0)),\n        (\"GreaterTilde;\", (8819, 0)),\n        (\"isin;\", (8712, 0)),\n        (\"eur\", (0, 0)),\n        (\"darr;\", (8595, 0)),\n        (\"longleftright\", (0, 0)),\n        (\"euro\", (0, 0)),\n        (\"NotDoubleVerticalBa\", (0, 0)),\n        (\"orslope\", (0, 0)),\n        (\"Icy;\", (1048, 0)),\n        (\"af;\", (8289, 0)),\n        (\"blacktriangleright;\", (9656, 0)),\n        (\"rsa\", (0, 0)),\n        (\"lE\", (0, 0)),\n        (\"Longleftrighta\", (0, 0)),\n        (\"esdot;\", (8784, 0)),\n        (\"lmi\", (0, 0)),\n        (\"backprime;\", (8245, 0)),\n        (\"NotSuperse\", (0, 0)),\n        (\"curlyeqsucc\", (0, 0)),\n        (\"dwangle;\", (10662, 0)),\n        (\"uacute;\", (250, 0)),\n        (\"Longleftr\", (0, 0)),\n        (\"DotDo\", (0, 0)),\n        (\"Hstrok\", (0, 0)),\n        (\"thick\", (0, 0)),\n        (\"Longright\", (0, 0)),\n        (\"NotHumpDown\", (0, 0)),\n        (\"TH\", (0, 0)),\n        (\"lbrkslu;\", (10637, 0)),\n        (\"gvn\", (0, 0)),\n        (\"imagl\", (0, 0)),\n        (\"Proporti\", (0, 0)),\n        (\"sup\", (0, 0)),\n        (\"EmptyVerySmal\", (0, 0)),\n        (\"npr;\", (8832, 0)),\n        (\"circeq;\", (8791, 0)),\n        (\"suphs\", (0, 0)),\n        (\"angle;\", (8736, 0)),\n        (\"rAtai\", (0, 0)),\n        (\"rop\", (0, 0)),\n        (\"NegativeM\", (0, 0)),\n        (\"Longle\", (0, 0)),\n        (\"Invisibl\", (0, 0)),\n        (\"angza\", (0, 0)),\n        (\"bigu\", (0, 0)),\n        (\"NotHumpEq\", (0, 0)),\n        (\"DoubleLongLeftRightArrow\", (0, 0)),\n        (\"VDash;\", (8875, 0)),\n        (\"nGg;\", (8921, 824)),\n        (\"Gre\", (0, 0)),\n        (\"cempty\", (0, 0)),\n        (\"NegativeThick\", (0, 0)),\n        (\"leftl\", (0, 0)),\n        (\"Ucirc\", (219, 0)),\n        (\"tr\", (0, 0)),\n        (\"easte\", (0, 0)),\n        (\"lo\", (0, 0)),\n        (\"COPY\", (169, 0)),\n        (\"Poi\", (0, 0)),\n        (\"Congruen\", (0, 0)),\n        (\"smepa\", (0, 0)),\n        (\"rfi\", (0, 0)),\n        (\"eplus;\", (10865, 0)),\n        (\"LeftArrowRightArro\", (0, 0)),\n        (\"CounterClockwiseCo\", (0, 0)),\n        (\"frac34;\", (190, 0)),\n        (\"bopf;\", (120147, 0)),\n        (\"rightleftha\", (0, 0)),\n        (\"blacktriangledow\", (0, 0)),\n        (\"xutri;\", (9651, 0)),\n        (\"eqvp\", (0, 0)),\n        (\"Rho\", (0, 0)),\n        (\"profa\", (0, 0)),\n        (\"circleda\", (0, 0)),\n        (\"frac58\", (0, 0)),\n        (\"prsim;\", (8830, 0)),\n        (\"scsim;\", (8831, 0)),\n        (\"leftarrowta\", (0, 0)),\n        (\"LeftUpDown\", (0, 0)),\n        (\"eqco\", (0, 0)),\n        (\"NestedGreaterGreater\", (0, 0)),\n        (\"nwarhk;\", (10531, 0)),\n        (\"epsilo\", (0, 0)),\n        (\"Eg\", (0, 0)),\n        (\"dtdo\", (0, 0)),\n        (\"es\", (0, 0)),\n        (\"uwangl\", (0, 0)),\n        (\"zwj;\", (8205, 0)),\n        (\"LeftVec\", (0, 0)),\n        (\"succnap\", (0, 0)),\n        (\"iec\", (0, 0)),\n        (\"softc\", (0, 0)),\n        (\"topfo\", (0, 0)),\n        (\"vf\", (0, 0)),\n        (\"Hilbert\", (0, 0)),\n        (\"pro\", (0, 0)),\n        (\"gs\", (0, 0)),\n        (\"ReverseEquili\", (0, 0)),\n        (\"Wscr;\", (119986, 0)),\n        (\"DownLeftRigh\", (0, 0)),\n        (\"LeftRightAr\", (0, 0)),\n        (\"rmoustac\", (0, 0)),\n        (\"nprec\", (0, 0)),\n        (\"Trip\", (0, 0)),\n        (\"circlearrowright;\", (8635, 0)),\n        (\"SucceedsS\", (0, 0)),\n        (\"NoBr\", (0, 0)),\n        (\"xod\", (0, 0)),\n        (\"DoubleDot\", (0, 0)),\n        (\"mapstou\", (0, 0)),\n        (\"ncap;\", (10819, 0)),\n        (\"Diacri\", (0, 0)),\n        (\"subset;\", (8834, 0)),\n        (\"YA\", (0, 0)),\n        (\"Sigm\", (0, 0)),\n        (\"gtrarr;\", (10616, 0)),\n        (\"DoubleLongRigh\", (0, 0)),\n        (\"Beta;\", (914, 0)),\n        (\"gtrarr\", (0, 0)),\n        (\"nsup;\", (8837, 0)),\n        (\"LeftTeeVect\", (0, 0)),\n        (\"plank\", (0, 0)),\n        (\"omid\", (0, 0)),\n        (\"DownRightVectorB\", (0, 0)),\n        (\"lmoustach\", (0, 0)),\n        (\"OpenCu\", (0, 0)),\n        (\"Lt\", (0, 0)),\n        (\"gtreqqless;\", (10892, 0)),\n        (\"twohea\", (0, 0)),\n        (\"ni\", (0, 0)),\n        (\"laemp\", (0, 0)),\n        (\"lhblk;\", (9604, 0)),\n        (\"Ud\", (0, 0)),\n        (\"PrecedesS\", (0, 0)),\n        (\"MediumSpace\", (0, 0)),\n        (\"varnot\", (0, 0)),\n        (\"divonx\", (0, 0)),\n        (\"bar\", (0, 0)),\n        (\"RightUpTeeV\", (0, 0)),\n        (\"bigst\", (0, 0)),\n        (\"ExponentialE\", (0, 0)),\n        (\"rightthre\", (0, 0)),\n        (\"prod\", (0, 0)),\n        (\"npa\", (0, 0)),\n        (\"ufr;\", (120114, 0)),\n        (\"preccurl\", (0, 0)),\n        (\"oi\", (0, 0)),\n        (\"sf\", (0, 0)),\n        (\"IOc\", (0, 0)),\n        (\"loplu\", (0, 0)),\n        (\"Uo\", (0, 0)),\n        (\"rharu;\", (8640, 0)),\n        (\"LessG\", (0, 0)),\n        (\"doteqd\", (0, 0)),\n        (\"chc\", (0, 0)),\n        (\"Ubreve;\", (364, 0)),\n        (\"ris\", (0, 0)),\n        (\"nGtv\", (0, 0)),\n        (\"boxdr\", (0, 0)),\n        (\"rarrp\", (0, 0)),\n        (\"eco\", (0, 0)),\n        (\"hamil\", (0, 0)),\n        (\"ord;\", (10845, 0)),\n        (\"wedb\", (0, 0)),\n        (\"nsucc;\", (8833, 0)),\n        (\"zcy;\", (1079, 0)),\n        (\"NotLef\", (0, 0)),\n        (\"Ocy\", (0, 0)),\n        (\"Intersection\", (0, 0)),\n        (\"Ntilde;\", (209, 0)),\n        (\"vartriangleri\", (0, 0)),\n        (\"uuar\", (0, 0)),\n        (\"suphsol;\", (10185, 0)),\n        (\"verbar\", (0, 0)),\n        (\"exponentia\", (0, 0)),\n        (\"eop\", (0, 0)),\n        (\"boxU\", (0, 0)),\n        (\"twoheadlef\", (0, 0)),\n        (\"dotmin\", (0, 0)),\n        (\"rho\", (0, 0)),\n        (\"Ubreve\", (0, 0)),\n        (\"Jfr;\", (120077, 0)),\n        (\"LessGreate\", (0, 0)),\n        (\"Rced\", (0, 0)),\n        (\"vBar;\", (10984, 0)),\n        (\"Longleftarro\", (0, 0)),\n        (\"wsc\", (0, 0)),\n        (\"yen\", (165, 0)),\n        (\"NotGreaterFul\", (0, 0)),\n        (\"gcirc\", (0, 0)),\n        (\"qpri\", (0, 0)),\n        (\"napo\", (0, 0)),\n        (\"Aacu\", (0, 0)),\n        (\"UpDow\", (0, 0)),\n        (\"Assign;\", (8788, 0)),\n        (\"Chi\", (0, 0)),\n        (\"blank;\", (9251, 0)),\n        (\"VerticalSep\", (0, 0)),\n        (\"vars\", (0, 0)),\n        (\"SuchTh\", (0, 0)),\n        (\"NotSucceedsS\", (0, 0)),\n        (\"Ced\", (0, 0)),\n        (\"NotSquareS\", (0, 0)),\n        (\"LowerR\", (0, 0)),\n        (\"DoubleRight\", (0, 0)),\n        (\"NotDoub\", (0, 0)),\n        (\"subrar\", (0, 0)),\n        (\"boxpl\", (0, 0)),\n        (\"ogon\", (0, 0)),\n        (\"lescc\", (0, 0)),\n        (\"capan\", (0, 0)),\n        (\"egrave\", (232, 0)),\n        (\"VerticalBa\", (0, 0)),\n        (\"ltr\", (0, 0)),\n        (\"Fourie\", (0, 0)),\n        (\"Precedes;\", (8826, 0)),\n        (\"rarr\", (0, 0)),\n        (\"cuv\", (0, 0)),\n        (\"ct\", (0, 0)),\n        (\"Longleftrig\", (0, 0)),\n        (\"VDash\", (0, 0)),\n        (\"nsimeq;\", (8772, 0)),\n        (\"natural\", (0, 0)),\n        (\"TildeFullEqua\", (0, 0)),\n        (\"Updo\", (0, 0)),\n        (\"hamilt\", (0, 0)),\n        (\"OpenCur\", (0, 0)),\n        (\"Ve\", (0, 0)),\n        (\"Cdot;\", (266, 0)),\n        (\"updow\", (0, 0)),\n        (\"nleftarrow\", (0, 0)),\n        (\"jsercy\", (0, 0)),\n        (\"upharpoonr\", (0, 0)),\n        (\"ang;\", (8736, 0)),\n        (\"blacktriangledown;\", (9662, 0)),\n        (\"Im;\", (8465, 0)),\n        (\"curlyeq\", (0, 0)),\n        (\"cularrp\", (0, 0)),\n        (\"lrcor\", (0, 0)),\n        (\"comp\", (0, 0)),\n        (\"sstarf;\", (8902, 0)),\n        (\"apid;\", (8779, 0)),\n        (\"curvearrowlef\", (0, 0)),\n        (\"GreaterFull\", (0, 0)),\n        (\"xr\", (0, 0)),\n        (\"SupersetEqual\", (0, 0)),\n        (\"Ph\", (0, 0)),\n        (\"rightsquigarrow\", (0, 0)),\n        (\"divideonti\", (0, 0)),\n        (\"euml\", (235, 0)),\n        (\"Kappa;\", (922, 0)),\n        (\"npre\", (0, 0)),\n        (\"njcy;\", (1114, 0)),\n        (\"xla\", (0, 0)),\n        (\"blacktriangl\", (0, 0)),\n        (\"RightDownT\", (0, 0)),\n        (\"ReverseEle\", (0, 0)),\n        (\"DoubleLongRi\", (0, 0)),\n        (\"wreath;\", (8768, 0)),\n        (\"race\", (0, 0)),\n        (\"NotSquareSu\", (0, 0)),\n        (\"nbsp\", (160, 0)),\n        (\"ZeroWidt\", (0, 0)),\n        (\"wedg\", (0, 0)),\n        (\"he\", (0, 0)),\n        (\"UpperRightAr\", (0, 0)),\n        (\"xcirc;\", (9711, 0)),\n        (\"ges;\", (10878, 0)),\n        (\"trian\", (0, 0)),\n        (\"nsucceq;\", (10928, 824)),\n        (\"j\", (0, 0)),\n        (\"Cayl\", (0, 0)),\n        (\"Xsc\", (0, 0)),\n        (\"circle\", (0, 0)),\n        (\"yo\", (0, 0)),\n        (\"rcedil;\", (343, 0)),\n        (\"notn\", (0, 0)),\n        (\"NotCup\", (0, 0)),\n        (\"cirmid\", (0, 0)),\n        (\"o\", (0, 0)),\n        (\"UpperR\", (0, 0)),\n        (\"smallsetmin\", (0, 0)),\n        (\"boxvh;\", (9532, 0)),\n        (\"boxhU;\", (9576, 0)),\n        (\"ForA\", (0, 0)),\n        (\"RightDoub\", (0, 0)),\n        (\"nvHarr;\", (10500, 0)),\n        (\"Kcedil;\", (310, 0)),\n        (\"mdash;\", (8212, 0)),\n        (\"LeftUpTee\", (0, 0)),\n        (\"prnsi\", (0, 0)),\n        (\"rarrbf\", (0, 0)),\n        (\"thickapp\", (0, 0)),\n        (\"simg;\", (10910, 0)),\n        (\"Low\", (0, 0)),\n        (\"oast\", (0, 0)),\n        (\"rppoli\", (0, 0)),\n        (\"CloseCurlyDoubleQuote\", (0, 0)),\n        (\"RE\", (0, 0)),\n        (\"rbrk\", (0, 0)),\n        (\"Gop\", (0, 0)),\n        (\"epsi\", (0, 0)),\n        (\"RightU\", (0, 0)),\n        (\"aring;\", (229, 0)),\n        (\"eps\", (0, 0)),\n        (\"amalg;\", (10815, 0)),\n        (\"SquareInterse\", (0, 0)),\n        (\"Omic\", (0, 0)),\n        (\"bigo\", (0, 0)),\n        (\"rightleftharpoons\", (0, 0)),\n        (\"uog\", (0, 0)),\n        (\"ShortUpAr\", (0, 0)),\n        (\"Ropf;\", (8477, 0)),\n        (\"UpperLeft\", (0, 0)),\n        (\"downarrow\", (0, 0)),\n        (\"succsi\", (0, 0)),\n        (\"otime\", (0, 0)),\n        (\"Til\", (0, 0)),\n        (\"suphsub;\", (10967, 0)),\n        (\"llhard\", (0, 0)),\n        (\"Lop\", (0, 0)),\n        (\"ShortLeftA\", (0, 0)),\n        (\"NotPrecede\", (0, 0)),\n        (\"Gscr\", (0, 0)),\n        (\"NotD\", (0, 0)),\n        (\"boxminus\", (0, 0)),\n        (\"qi\", (0, 0)),\n        (\"iiint;\", (8749, 0)),\n        (\"NotEqualTild\", (0, 0)),\n        (\"Phi;\", (934, 0)),\n        (\"Clockw\", (0, 0)),\n        (\"cudar\", (0, 0)),\n        (\"Inte\", (0, 0)),\n        (\"midcir;\", (10992, 0)),\n        (\"UpE\", (0, 0)),\n        (\"lbar\", (0, 0)),\n        (\"ZeroWidthSpa\", (0, 0)),\n        (\"Zdot\", (0, 0)),\n        (\"lbrk\", (0, 0)),\n        (\"ReverseUpEquilibri\", (0, 0)),\n        (\"Capital\", (0, 0)),\n        (\"nhpa\", (0, 0)),\n        (\"precns\", (0, 0)),\n        (\"NotSquareSubset;\", (8847, 824)),\n        (\"Hi\", (0, 0)),\n        (\"eacute;\", (233, 0)),\n        (\"smile\", (0, 0)),\n        (\"RightUpTeeVect\", (0, 0)),\n        (\"pfr;\", (120109, 0)),\n        (\"Ncy\", (0, 0)),\n        (\"opa\", (0, 0)),\n        (\"xo\", (0, 0)),\n        (\"ntriangler\", (0, 0)),\n        (\"lotim\", (0, 0)),\n        (\"Element;\", (8712, 0)),\n        (\"Mcy;\", (1052, 0)),\n        (\"vdash;\", (8866, 0)),\n        (\"ExponentialE;\", (8519, 0)),\n        (\"vA\", (0, 0)),\n        (\"precnappro\", (0, 0)),\n        (\"Cci\", (0, 0)),\n        (\"ome\", (0, 0)),\n        (\"blk12\", (0, 0)),\n        (\"yf\", (0, 0)),\n        (\"plust\", (0, 0)),\n        (\"LeftDoubleBr\", (0, 0)),\n        (\"angrtv\", (0, 0)),\n        (\"cupor\", (0, 0)),\n        (\"gvnE\", (0, 0)),\n        (\"LessSlan\", (0, 0)),\n        (\"triangle\", (0, 0)),\n        (\"Lsh;\", (8624, 0)),\n        (\"ecir;\", (8790, 0)),\n        (\"NotPrecedes;\", (8832, 0)),\n        (\"Y\", (0, 0)),\n        (\"edo\", (0, 0)),\n        (\"PlusMin\", (0, 0)),\n        (\"DoubleLongL\", (0, 0)),\n        (\"racu\", (0, 0)),\n        (\"SHCH\", (0, 0)),\n        (\"Rrightar\", (0, 0)),\n        (\"u\", (0, 0)),\n        (\"cur\", (0, 0)),\n        (\"Copr\", (0, 0)),\n        (\"llh\", (0, 0)),\n        (\"NotCupC\", (0, 0)),\n        (\"Vee\", (0, 0)),\n        (\"lsquor\", (0, 0)),\n        (\"sop\", (0, 0)),\n        (\"nese\", (0, 0)),\n        (\"shar\", (0, 0)),\n        (\"hc\", (0, 0)),\n        (\"har\", (0, 0)),\n        (\"RuleDe\", (0, 0)),\n        (\"RightVec\", (0, 0)),\n        (\"bbrktb\", (0, 0)),\n        (\"boxDR;\", (9556, 0)),\n        (\"Lfr\", (0, 0)),\n        (\"Zfr;\", (8488, 0)),\n        (\"it\", (0, 0)),\n        (\"expectation;\", (8496, 0)),\n        (\"Lstro\", (0, 0)),\n        (\"sol;\", (47, 0)),\n        (\"ShortLef\", (0, 0)),\n        (\"tel\", (0, 0)),\n        (\"mul\", (0, 0)),\n        (\"uac\", (0, 0)),\n        (\"dblac;\", (733, 0)),\n        (\"Esim\", (0, 0)),\n        (\"nappr\", (0, 0)),\n        (\"ulcorn;\", (8988, 0)),\n        (\"lotimes;\", (10804, 0)),\n        (\"SucceedsEq\", (0, 0)),\n        (\"nti\", (0, 0)),\n        (\"ffl\", (0, 0)),\n        (\"beth;\", (8502, 0)),\n        (\"circledas\", (0, 0)),\n        (\"nVda\", (0, 0)),\n        (\"udh\", (0, 0)),\n        (\"ET\", (0, 0)),\n        (\"luru\", (0, 0)),\n        (\"fp\", (0, 0)),\n        (\"simne\", (0, 0)),\n        (\"NotCongruent;\", (8802, 0)),\n        (\"less\", (0, 0)),\n        (\"thetav;\", (977, 0)),\n        (\"lopar;\", (10629, 0)),\n        (\"zeetrf;\", (8488, 0)),\n        (\"uwang\", (0, 0)),\n        (\"nearhk;\", (10532, 0)),\n        (\"rect\", (0, 0)),\n        (\"IJlig;\", (306, 0)),\n        (\"mscr\", (0, 0)),\n        (\"crarr;\", (8629, 0)),\n        (\"vartriangler\", (0, 0)),\n        (\"tcy\", (0, 0)),\n        (\"varpr\", (0, 0)),\n        (\"InvisibleTimes;\", (8290, 0)),\n        (\"urtri;\", (9721, 0)),\n        (\"Hci\", (0, 0)),\n        (\"UpEq\", (0, 0)),\n        (\"LeftVectorB\", (0, 0)),\n        (\"rmoustache;\", (9137, 0)),\n        (\"ngeqsla\", (0, 0)),\n        (\"NotEqual;\", (8800, 0)),\n        (\"imac\", (0, 0)),\n        (\"quater\", (0, 0)),\n        (\"Tf\", (0, 0)),\n        (\"nvge\", (0, 0)),\n        (\"LeftUpTeeV\", (0, 0)),\n        (\"fallingd\", (0, 0)),\n        (\"Zs\", (0, 0)),\n        (\"Fouriertr\", (0, 0)),\n        (\"lessdot\", (0, 0)),\n        (\"Ec\", (0, 0)),\n        (\"nsce;\", (10928, 824)),\n        (\"tcaron;\", (357, 0)),\n        (\"seAr\", (0, 0)),\n        (\"agra\", (0, 0)),\n        (\"GreaterGreater\", (0, 0)),\n        (\"ug\", (0, 0)),\n        (\"NotSucceedsTilde\", (0, 0)),\n        (\"UpAr\", (0, 0)),\n        (\"hopf;\", (120153, 0)),\n        (\"NotLessSl\", (0, 0)),\n        (\"iinfin;\", (10716, 0)),\n        (\"dlcro\", (0, 0)),\n        (\"bet\", (0, 0)),\n        (\"cir;\", (9675, 0)),\n        (\"iacute\", (237, 0)),\n        (\"gtl\", (0, 0)),\n        (\"olcross;\", (10683, 0)),\n        (\"Non\", (0, 0)),\n        (\"impe\", (0, 0)),\n        (\"Exponential\", (0, 0)),\n        (\"VeryThinSpace\", (0, 0)),\n        (\"CloseCurlyD\", (0, 0)),\n        (\"ef\", (0, 0)),\n        (\"Conin\", (0, 0)),\n        (\"za\", (0, 0)),\n        (\"DoubleLongLeftArrow;\", (10232, 0)),\n        (\"dsol\", (0, 0)),\n        (\"ra\", (0, 0)),\n        (\"hellip;\", (8230, 0)),\n        (\"loz;\", (9674, 0)),\n        (\"Cayleys\", (0, 0)),\n        (\"RightDownTeeVe\", (0, 0)),\n        (\"Si\", (0, 0)),\n        (\"ohbar;\", (10677, 0)),\n        (\"U\", (0, 0)),\n        (\"trit\", (0, 0)),\n        (\"pl\", (0, 0)),\n        (\"timesd\", (0, 0)),\n        (\"nless;\", (8814, 0)),\n        (\"sqsupseteq;\", (8850, 0)),\n        (\"Vda\", (0, 0)),\n        (\"SquareSupersetEqual\", (0, 0)),\n        (\"ShortDownArrow\", (0, 0)),\n        (\"Edo\", (0, 0)),\n        (\"DownRightTeeVector;\", (10591, 0)),\n        (\"CounterClockwiseContourInteg\", (0, 0)),\n        (\"lap;\", (10885, 0)),\n        (\"SquareSuperset\", (0, 0)),\n        (\"Lower\", (0, 0)),\n        (\"check\", (0, 0)),\n        (\"Ca\", (0, 0)),\n        (\"looparrowright;\", (8620, 0)),\n        (\"CapitalDif\", (0, 0)),\n        (\"ncongdot\", (0, 0)),\n        (\"ub\", (0, 0)),\n        (\"nwa\", (0, 0)),\n        (\"Mellintr\", (0, 0)),\n        (\"elinters\", (0, 0)),\n        (\"lessappr\", (0, 0)),\n        (\"perm\", (0, 0)),\n        (\"Succeed\", (0, 0)),\n        (\"odsold;\", (10684, 0)),\n        (\"Ep\", (0, 0)),\n        (\"DZc\", (0, 0)),\n        (\"wei\", (0, 0)),\n        (\"Cong\", (0, 0)),\n        (\"preccurlye\", (0, 0)),\n        (\"nparallel;\", (8742, 0)),\n        (\"NotLeftTriangleBar;\", (10703, 824)),\n        (\"Pfr;\", (120083, 0)),\n        (\"GreaterGreater;\", (10914, 0)),\n        (\"Odblac\", (0, 0)),\n        (\"xd\", (0, 0)),\n        (\"puncsp\", (0, 0)),\n        (\"ntrianglelef\", (0, 0)),\n        (\"gtcc;\", (10919, 0)),\n        (\"scnE\", (0, 0)),\n        (\"osc\", (0, 0)),\n        (\"rAarr\", (0, 0)),\n        (\"boxdr;\", (9484, 0)),\n        (\"rarrsi\", (0, 0)),\n        (\"Sacute\", (0, 0)),\n        (\"NegativeThinSpace\", (0, 0)),\n        (\"Nega\", (0, 0)),\n        (\"LeftArrowRightArrow;\", (8646, 0)),\n        (\"ecaron;\", (283, 0)),\n        (\"Les\", (0, 0)),\n        (\"sim;\", (8764, 0)),\n        (\"bot;\", (8869, 0)),\n        (\"ShortRightArr\", (0, 0)),\n        (\"blacktrianglerigh\", (0, 0)),\n        (\"zsc\", (0, 0)),\n        (\"expone\", (0, 0)),\n        (\"NotLessL\", (0, 0)),\n        (\"ors\", (0, 0)),\n        (\"bNot;\", (10989, 0)),\n        (\"Upper\", (0, 0)),\n        (\"Le\", (0, 0)),\n        (\"gtrapprox\", (0, 0)),\n        (\"tprime\", (0, 0)),\n        (\"veeb\", (0, 0)),\n        (\"nvinf\", (0, 0)),\n        (\"ffi\", (0, 0)),\n        (\"Dagger\", (0, 0)),\n        (\"Kscr\", (0, 0)),\n        (\"vartr\", (0, 0)),\n        (\"smeparsl\", (0, 0)),\n        (\"star\", (0, 0)),\n        (\"rightsqu\", (0, 0)),\n        (\"die;\", (168, 0)),\n        (\"Pop\", (0, 0)),\n        (\"divon\", (0, 0)),\n        (\"nle;\", (8816, 0)),\n        (\"larrsi\", (0, 0)),\n        (\"nequ\", (0, 0)),\n        (\"rightleftarrows\", (0, 0)),\n        (\"q\", (0, 0)),\n        (\"Abreve;\", (258, 0)),\n        (\"dop\", (0, 0)),\n        (\"longlefta\", (0, 0)),\n        (\"LeftRi\", (0, 0)),\n        (\"bulle\", (0, 0)),\n        (\"nvrtri\", (0, 0)),\n        (\"Mopf;\", (120132, 0)),\n        (\"hcirc;\", (293, 0)),\n        (\"incar\", (0, 0)),\n        (\"RightTrian\", (0, 0)),\n        (\"precne\", (0, 0)),\n        (\"target;\", (8982, 0)),\n        (\"Ocirc;\", (212, 0)),\n        (\"ama\", (0, 0)),\n        (\"prcue\", (0, 0)),\n        (\"uHar\", (0, 0)),\n        (\"IJ\", (0, 0)),\n        (\"lsimg;\", (10895, 0)),\n        (\"simeq;\", (8771, 0)),\n        (\"TS\", (0, 0)),\n        (\"solbar\", (0, 0)),\n        (\"rarrsim\", (0, 0)),\n        (\"asym\", (0, 0)),\n        (\"ggg;\", (8921, 0)),\n        (\"raempty\", (0, 0)),\n        (\"hookrightarr\", (0, 0)),\n        (\"bow\", (0, 0)),\n        (\"CircleMinu\", (0, 0)),\n        (\"nshortpara\", (0, 0)),\n        (\"nrightar\", (0, 0)),\n        (\"straigh\", (0, 0)),\n        (\"DoubleLeftRightArrow;\", (8660, 0)),\n        (\"gesdo\", (0, 0)),\n        (\"bbrkt\", (0, 0)),\n        (\"DoubleRightTee;\", (8872, 0)),\n        (\"rrar\", (0, 0)),\n        (\"SquareUnion;\", (8852, 0)),\n        (\"NotGreaterGre\", (0, 0)),\n        (\"sqcap;\", (8851, 0)),\n        (\"DotEqua\", (0, 0)),\n        (\"RightArr\", (0, 0)),\n        (\"Ju\", (0, 0)),\n        (\"sqsupseteq\", (0, 0)),\n        (\"ltrPa\", (0, 0)),\n        (\"NotSquareSuper\", (0, 0)),\n        (\"orv;\", (10843, 0)),\n        (\"varsigma\", (0, 0)),\n        (\"andslop\", (0, 0)),\n        (\"nwarrow;\", (8598, 0)),\n        (\"CloseCurl\", (0, 0)),\n        (\"copf\", (0, 0)),\n        (\"UpDown\", (0, 0)),\n        (\"bk\", (0, 0)),\n        (\"Pro\", (0, 0)),\n        (\"NegativeVeryThinSpace\", (0, 0)),\n        (\"tripl\", (0, 0)),\n        (\"frac14\", (188, 0)),\n        (\"Lambd\", (0, 0)),\n        (\"Jcirc;\", (308, 0)),\n        (\"npo\", (0, 0)),\n        (\"yfr\", (0, 0)),\n        (\"DoubleU\", (0, 0)),\n        (\"mstp\", (0, 0)),\n        (\"Rightarr\", (0, 0)),\n        (\"que\", (0, 0)),\n        (\"divide\", (247, 0)),\n        (\"Cced\", (0, 0)),\n        (\"bNo\", (0, 0)),\n        (\"swnwar\", (0, 0)),\n        (\"dlcor\", (0, 0)),\n        (\"time\", (0, 0)),\n        (\"thk\", (0, 0)),\n        (\"ltcir\", (0, 0)),\n        (\"sup3\", (179, 0)),\n        (\"Ncaron\", (0, 0)),\n        (\"Therefore;\", (8756, 0)),\n        (\"CloseCurlyQuo\", (0, 0)),\n        (\"NotSubset;\", (8834, 8402)),\n        (\"ruluhar\", (0, 0)),\n        (\"blk1\", (0, 0)),\n        (\"lcub\", (0, 0)),\n        (\"period;\", (46, 0)),\n        (\"vzigz\", (0, 0)),\n        (\"tos\", (0, 0)),\n        (\"nwn\", (0, 0)),\n        (\"Id\", (0, 0)),\n        (\"ddots\", (0, 0)),\n        (\"eqvpa\", (0, 0)),\n        (\"intprod\", (0, 0)),\n        (\"scna\", (0, 0)),\n        (\"Medium\", (0, 0)),\n        (\"ffr\", (0, 0)),\n        (\"ii;\", (8520, 0)),\n        (\"CounterClockwiseCont\", (0, 0)),\n        (\"boxur;\", (9492, 0)),\n        (\"colo\", (0, 0)),\n        (\"trianglerig\", (0, 0)),\n        (\"latai\", (0, 0)),\n        (\"IEc\", (0, 0)),\n        (\"awco\", (0, 0)),\n        (\"rightharpoondown\", (0, 0)),\n        (\"shortmid\", (0, 0)),\n        (\"LeftUpTeeVecto\", (0, 0)),\n        (\"Longleftrigh\", (0, 0)),\n        (\"Tcar\", (0, 0)),\n        (\"LeftUpDo\", (0, 0)),\n        (\"checkmark\", (0, 0)),\n        (\"Rarr;\", (8608, 0)),\n        (\"isindot;\", (8949, 0)),\n        (\"Rac\", (0, 0)),\n        (\"solba\", (0, 0)),\n        (\"dda\", (0, 0)),\n        (\"sc\", (0, 0)),\n        (\"infin;\", (8734, 0)),\n        (\"npr\", (0, 0)),\n        (\"prnE\", (0, 0)),\n        (\"NotRightT\", (0, 0)),\n        (\"NegativeMediumSpace;\", (8203, 0)),\n        (\"alpha;\", (945, 0)),\n        (\"Ccaro\", (0, 0)),\n        (\"NotTildeTilde;\", (8777, 0)),\n        (\"rca\", (0, 0)),\n        (\"geqslant;\", (10878, 0)),\n        (\"bsolh\", (0, 0)),\n        (\"mapstodo\", (0, 0)),\n        (\"NotLessGrea\", (0, 0)),\n        (\"RightAngleBr\", (0, 0)),\n        (\"middo\", (0, 0)),\n        (\"lcaron;\", (318, 0)),\n        (\"supedo\", (0, 0)),\n        (\"iogon\", (0, 0)),\n        (\"GreaterTilde\", (0, 0)),\n        (\"PrecedesSlant\", (0, 0)),\n        (\"HA\", (0, 0)),\n        (\"leftrighta\", (0, 0)),\n        (\"boxdl\", (0, 0)),\n        (\"NotN\", (0, 0)),\n        (\"LeftVectorBa\", (0, 0)),\n        (\"Cacute;\", (262, 0)),\n        (\"ae\", (0, 0)),\n        (\"suped\", (0, 0)),\n        (\"infi\", (0, 0)),\n        (\"Esi\", (0, 0)),\n        (\"gnapprox\", (0, 0)),\n        (\"uha\", (0, 0)),\n        (\"Br\", (0, 0)),\n        (\"divideontimes\", (0, 0)),\n        (\"heartsui\", (0, 0)),\n        (\"Dc\", (0, 0)),\n        (\"boxvr\", (0, 0)),\n        (\"EmptyS\", (0, 0)),\n        (\"cirscir;\", (10690, 0)),\n        (\"egsd\", (0, 0)),\n        (\"hookleft\", (0, 0)),\n        (\"nvr\", (0, 0)),\n        (\"lne\", (0, 0)),\n        (\"ati\", (0, 0)),\n        (\"NotTildeEqual\", (0, 0)),\n        (\"NotSucceeds\", (0, 0)),\n        (\"LeftDownVector\", (0, 0)),\n        (\"Ffr;\", (120073, 0)),\n        (\"Sfr;\", (120086, 0)),\n        (\"eng;\", (331, 0)),\n        (\"lurdshar;\", (10570, 0)),\n        (\"NotVer\", (0, 0)),\n        (\"frac78\", (0, 0)),\n        (\"LeftUpTeeVector\", (0, 0)),\n        (\"longleftrightarro\", (0, 0)),\n        (\"nleftarr\", (0, 0)),\n        (\"Thick\", (0, 0)),\n        (\"Llefta\", (0, 0)),\n        (\"VerticalSepa\", (0, 0)),\n        (\"Sq\", (0, 0)),\n        (\"TRADE;\", (8482, 0)),\n        (\"Diamon\", (0, 0)),\n        (\"ell;\", (8467, 0)),\n        (\"Cop\", (0, 0)),\n        (\"Zfr\", (0, 0)),\n        (\"succsim;\", (8831, 0)),\n        (\"NonBrea\", (0, 0)),\n        (\"Rcaron;\", (344, 0)),\n        (\"rth\", (0, 0)),\n        (\"nparalle\", (0, 0)),\n        (\"Wcirc;\", (372, 0)),\n        (\"jukcy\", (0, 0)),\n        (\"dwang\", (0, 0)),\n        (\"SuchTha\", (0, 0)),\n        (\"varsubset\", (0, 0)),\n        (\"Vfr;\", (120089, 0)),\n        (\"nsubse\", (0, 0)),\n        (\"hop\", (0, 0)),\n        (\"multimap\", (0, 0)),\n        (\"nvd\", (0, 0)),\n        (\"NotLeftTri\", (0, 0)),\n        (\"curvearrowl\", (0, 0)),\n        (\"tilde\", (0, 0)),\n        (\"zacu\", (0, 0)),\n        (\"zcy\", (0, 0)),\n        (\"PrecedesTilde\", (0, 0)),\n        (\"DoubleLeftR\", (0, 0)),\n        (\"Larr;\", (8606, 0)),\n        (\"Ss\", (0, 0)),\n        (\"zacut\", (0, 0)),\n        (\"Poincarepla\", (0, 0)),\n        (\"urcorn;\", (8989, 0)),\n        (\"boxUl\", (0, 0)),\n        (\"Rc\", (0, 0)),\n        (\"lbarr\", (0, 0)),\n        (\"vartriangleright\", (0, 0)),\n        (\"eqcolon\", (0, 0)),\n        (\"CapitalDiffe\", (0, 0)),\n        (\"subsetneqq;\", (10955, 0)),\n        (\"Dcaro\", (0, 0)),\n        (\"ldsh;\", (8626, 0)),\n        (\"ccup\", (0, 0)),\n        (\"CircleTimes;\", (8855, 0)),\n        (\"coprod;\", (8720, 0)),\n        (\"RightDownVec\", (0, 0)),\n        (\"SquareSup\", (0, 0)),\n        (\"nprc\", (0, 0)),\n        (\"sr\", (0, 0)),\n        (\"rea\", (0, 0)),\n        (\"LeftUpTeeVector;\", (10592, 0)),\n        (\"midci\", (0, 0)),\n        (\"upl\", (0, 0)),\n        (\"DoubleContourIntegral;\", (8751, 0)),\n        (\"RightDownVectorBa\", (0, 0)),\n        (\"Zcy\", (0, 0)),\n        (\"NotSquareSupersetE\", (0, 0)),\n        (\"UpA\", (0, 0)),\n        (\"circlearro\", (0, 0)),\n        (\"gescc;\", (10921, 0)),\n        (\"dtrif;\", (9662, 0)),\n        (\"Ig\", (0, 0)),\n        (\"NotGreaterSlantEqual;\", (10878, 824)),\n        (\"die\", (0, 0)),\n        (\"NotSupersetE\", (0, 0)),\n        (\"dollar\", (0, 0)),\n        (\"tritime;\", (10811, 0)),\n        (\"digamma\", (0, 0)),\n        (\"CapitalDifferen\", (0, 0)),\n        (\"ffili\", (0, 0)),\n        (\"scedil;\", (351, 0)),\n        (\"delt\", (0, 0)),\n        (\"sqsupe\", (0, 0)),\n        (\"nc\", (0, 0)),\n        (\"NotSucceedsEqu\", (0, 0)),\n        (\"NoBreak;\", (8288, 0)),\n        (\"NegativeVeryThinSp\", (0, 0)),\n        (\"ShortLeftArr\", (0, 0)),\n        (\"SOF\", (0, 0)),\n        (\"egr\", (0, 0)),\n        (\"CHc\", (0, 0)),\n        (\"NestedLessLess\", (0, 0)),\n        (\"leftr\", (0, 0)),\n        (\"SucceedsTilde\", (0, 0)),\n        (\"Square\", (0, 0)),\n        (\"Oo\", (0, 0)),\n        (\"d\", (0, 0)),\n        (\"varsupsetneqq\", (0, 0)),\n        (\"varsi\", (0, 0)),\n        (\"nlE;\", (8806, 824)),\n        (\"Lm\", (0, 0)),\n        (\"rtriltri;\", (10702, 0)),\n        (\"dfisht;\", (10623, 0)),\n        (\"DoubleRightTee\", (0, 0)),\n        (\"ltcc\", (0, 0)),\n        (\"triti\", (0, 0)),\n        (\"loa\", (0, 0)),\n        (\"Dscr\", (0, 0)),\n        (\"rtriltr\", (0, 0)),\n        (\"nRightarr\", (0, 0)),\n        (\"ngsi\", (0, 0)),\n        (\"curlyeqsucc;\", (8927, 0)),\n        (\"horbar;\", (8213, 0)),\n        (\"Kcy;\", (1050, 0)),\n        (\"LeftUpVectorBar\", (0, 0)),\n        (\"DoubleVerticalB\", (0, 0)),\n        (\"subdot\", (0, 0)),\n        (\"fro\", (0, 0)),\n        (\"ThinSpac\", (0, 0)),\n        (\"Ograve\", (210, 0)),\n        (\"lti\", (0, 0)),\n        (\"copy;\", (169, 0)),\n        (\"cro\", (0, 0)),\n        (\"DoubleVertic\", (0, 0)),\n        (\"prnsim;\", (8936, 0)),\n        (\"kj\", (0, 0)),\n        (\"lsqu\", (0, 0)),\n        (\"Igrave;\", (204, 0)),\n        (\"DoubleRightT\", (0, 0)),\n        (\"Alpha;\", (913, 0)),\n        (\"Lan\", (0, 0)),\n        (\"llcorner\", (0, 0)),\n        (\"risingdotseq\", (0, 0)),\n        (\"olcro\", (0, 0)),\n        (\"MinusPlu\", (0, 0)),\n        (\"gtdot\", (0, 0)),\n        (\"bsolhs\", (0, 0)),\n        (\"hb\", (0, 0)),\n        (\"hkswarow;\", (10534, 0)),\n        (\"dbkaro\", (0, 0)),\n        (\"SquareSubsetEqu\", (0, 0)),\n        (\"lmous\", (0, 0)),\n        (\"AM\", (0, 0)),\n        (\"tpri\", (0, 0)),\n        (\"ofr\", (0, 0)),\n        (\"ZHcy;\", (1046, 0)),\n        (\"equiv\", (0, 0)),\n        (\"EmptyVe\", (0, 0)),\n        (\"eqslantless;\", (10901, 0)),\n        (\"upharpoonrigh\", (0, 0)),\n        (\"eng\", (0, 0)),\n        (\"Lo\", (0, 0)),\n        (\"Invisi\", (0, 0)),\n        (\"larrhk\", (0, 0)),\n        (\"nbumpe;\", (8783, 824)),\n        (\"nshortparalle\", (0, 0)),\n        (\"lsaquo;\", (8249, 0)),\n        (\"nLeftrig\", (0, 0)),\n        (\"omi\", (0, 0)),\n        (\"lu\", (0, 0)),\n        (\"Cedi\", (0, 0)),\n        (\"bnot;\", (8976, 0)),\n        (\"Dca\", (0, 0)),\n        (\"xcap;\", (8898, 0)),\n        (\"ca\", (0, 0)),\n        (\"fpa\", (0, 0)),\n        (\"UpDownArro\", (0, 0)),\n        (\"NotTildeFullEqual;\", (8775, 0)),\n        (\"Pa\", (0, 0)),\n        (\"iiint\", (0, 0)),\n        (\"plankv\", (0, 0)),\n        (\"curr\", (0, 0)),\n        (\"shc\", (0, 0)),\n        (\"At\", (0, 0)),\n        (\"plusmn\", (177, 0)),\n        (\"lates\", (0, 0)),\n        (\"cent;\", (162, 0)),\n        (\"dbka\", (0, 0)),\n        (\"Sum\", (0, 0)),\n        (\"NotCo\", (0, 0)),\n        (\"lurdsh\", (0, 0)),\n        (\"nhAr\", (0, 0)),\n        (\"UnderBa\", (0, 0)),\n        (\"vsubn\", (0, 0)),\n        (\"rdsh;\", (8627, 0)),\n        (\"leftth\", (0, 0)),\n        (\"SubsetEqual\", (0, 0)),\n        (\"EqualTilde;\", (8770, 0)),\n        (\"lnE;\", (8808, 0)),\n        (\"dou\", (0, 0)),\n        (\"telre\", (0, 0)),\n        (\"DownArrowB\", (0, 0)),\n        (\"nsccu\", (0, 0)),\n        (\"Colon;\", (8759, 0)),\n        (\"bac\", (0, 0)),\n        (\"UpperRi\", (0, 0)),\n        (\"longleftrigh\", (0, 0)),\n        (\"Eta;\", (919, 0)),\n        (\"NotNestedGre\", (0, 0)),\n        (\"Nopf\", (0, 0)),\n        (\"Upar\", (0, 0)),\n        (\"circleddas\", (0, 0)),\n        (\"rcaron;\", (345, 0)),\n        (\"ApplyF\", (0, 0)),\n        (\"djcy;\", (1106, 0)),\n        (\"succnsi\", (0, 0)),\n        (\"xra\", (0, 0)),\n        (\"frac3\", (0, 0)),\n        (\"succneq\", (0, 0)),\n        (\"eqsla\", (0, 0)),\n        (\"NotNestedG\", (0, 0)),\n        (\"upsi;\", (965, 0)),\n        (\"CounterClockwiseContourIntegr\", (0, 0)),\n        (\"subdo\", (0, 0)),\n        (\"Leftright\", (0, 0)),\n        (\"GreaterEqua\", (0, 0)),\n        (\"Lsh\", (0, 0)),\n        (\"itilde\", (0, 0)),\n        (\"SmallCircle;\", (8728, 0)),\n        (\"diamond\", (0, 0)),\n        (\"ApplyFunction;\", (8289, 0)),\n        (\"iiota;\", (8489, 0)),\n        (\"upharpo\", (0, 0)),\n        (\"ContourIntegral\", (0, 0)),\n        (\"ffilig;\", (64259, 0)),\n        (\"NotEqualTi\", (0, 0)),\n        (\"gvertneq\", (0, 0)),\n        (\"NotPre\", (0, 0)),\n        (\"fflig\", (0, 0)),\n        (\"varsubsetneq;\", (8842, 65024)),\n        (\"NotSquareSup\", (0, 0)),\n        (\"models\", (0, 0)),\n        (\"nLefta\", (0, 0)),\n        (\"drbkarow\", (0, 0)),\n        (\"DoubleUpDownArr\", (0, 0)),\n        (\"xcirc\", (0, 0)),\n        (\"empty\", (0, 0)),\n        (\"CounterClockw\", (0, 0)),\n        (\"quatint;\", (10774, 0)),\n        (\"LeftDou\", (0, 0)),\n        (\"LeftTeeVecto\", (0, 0)),\n        (\"dotsquare;\", (8865, 0)),\n        (\"bernou\", (0, 0)),\n        (\"Omicro\", (0, 0)),\n        (\"colone\", (0, 0)),\n        (\"xh\", (0, 0)),\n        (\"varnothin\", (0, 0)),\n        (\"pound;\", (163, 0)),\n        (\"gtc\", (0, 0)),\n        (\"LowerLeftA\", (0, 0)),\n        (\"xoplu\", (0, 0)),\n        (\"geqsla\", (0, 0)),\n        (\"uogo\", (0, 0)),\n        (\"epar\", (0, 0)),\n        (\"cacut\", (0, 0)),\n        (\"apos\", (0, 0)),\n        (\"xdtri;\", (9661, 0)),\n        (\"CupCap\", (0, 0)),\n        (\"iti\", (0, 0)),\n        (\"Breve\", (0, 0)),\n        (\"utilde\", (0, 0)),\n        (\"Ycirc\", (0, 0)),\n        (\"Rcy;\", (1056, 0)),\n        (\"NotSubse\", (0, 0)),\n        (\"napE;\", (10864, 824)),\n        (\"lat\", (0, 0)),\n        (\"UpDownArrow;\", (8597, 0)),\n        (\"pluse\", (0, 0)),\n        (\"ShortDow\", (0, 0)),\n        (\"OverBracke\", (0, 0)),\n        (\"vprop\", (0, 0)),\n        (\"flt\", (0, 0)),\n        (\"Rf\", (0, 0)),\n        (\"lbr\", (0, 0)),\n        (\"DoubleRightTe\", (0, 0)),\n        (\"conint\", (0, 0)),\n        (\"SucceedsSlantEqual;\", (8829, 0)),\n        (\"DownArrow;\", (8595, 0)),\n        (\"LessGreat\", (0, 0)),\n        (\"Ru\", (0, 0)),\n        (\"exis\", (0, 0)),\n        (\"csub;\", (10959, 0)),\n        (\"lcaron\", (0, 0)),\n        (\"ntrianglel\", (0, 0)),\n        (\"ip\", (0, 0)),\n        (\"Aopf;\", (120120, 0)),\n        (\"Phi\", (0, 0)),\n        (\"TildeTild\", (0, 0)),\n        (\"rightright\", (0, 0)),\n        (\"ffr;\", (120099, 0)),\n        (\"ograve\", (242, 0)),\n        (\"cacute;\", (263, 0)),\n        (\"NotVert\", (0, 0)),\n        (\"scedi\", (0, 0)),\n        (\"succcurlyeq\", (0, 0)),\n        (\"Bs\", (0, 0)),\n        (\"weierp\", (0, 0)),\n        (\"lesss\", (0, 0)),\n        (\"backc\", (0, 0)),\n        (\"rpar;\", (41, 0)),\n        (\"LeftFloor\", (0, 0)),\n        (\"yic\", (0, 0)),\n        (\"Omacr;\", (332, 0)),\n        (\"nabla;\", (8711, 0)),\n        (\"gne;\", (10888, 0)),\n        (\"nvDas\", (0, 0)),\n        (\"reg;\", (174, 0)),\n        (\"CounterClockwiseContourI\", (0, 0)),\n        (\"geqsl\", (0, 0)),\n        (\"lobrk;\", (10214, 0)),\n        (\"oslas\", (0, 0)),\n        (\"Ds\", (0, 0)),\n        (\"Odbla\", (0, 0)),\n        (\"bigstar\", (0, 0)),\n        (\"olc\", (0, 0)),\n        (\"perte\", (0, 0)),\n        (\"dotp\", (0, 0)),\n        (\"DoubleUpArro\", (0, 0)),\n        (\"gtrdot;\", (8919, 0)),\n        (\"Jscr;\", (119973, 0)),\n        (\"tcedil\", (0, 0)),\n        (\"Mel\", (0, 0)),\n        (\"gtrapprox;\", (10886, 0)),\n        (\"dotmi\", (0, 0)),\n        (\"harrw\", (0, 0)),\n        (\"ntg\", (0, 0)),\n        (\"EmptySmall\", (0, 0)),\n        (\"CapitalD\", (0, 0)),\n        (\"cudarr\", (0, 0)),\n        (\"lvert\", (0, 0)),\n        (\"subdot;\", (10941, 0)),\n        (\"sup3;\", (179, 0)),\n        (\"minu\", (0, 0)),\n        (\"yicy\", (0, 0)),\n        (\"boxVr;\", (9567, 0)),\n        (\"Ncar\", (0, 0)),\n        (\"otild\", (0, 0)),\n        (\"RightTriangl\", (0, 0)),\n        (\"UpperRightArrow\", (0, 0)),\n        (\"subedo\", (0, 0)),\n        (\"dr\", (0, 0)),\n        (\"GreaterFullEqual;\", (8807, 0)),\n        (\"RightAngleBrack\", (0, 0)),\n        (\"we\", (0, 0)),\n        (\"DiacriticalGrave\", (0, 0)),\n        (\"Oscr;\", (119978, 0)),\n        (\"zigrarr;\", (8669, 0)),\n        (\"Eci\", (0, 0)),\n        (\"LeftTriangleBar\", (0, 0)),\n        (\"lozf\", (0, 0)),\n        (\"Ns\", (0, 0)),\n        (\"omeg\", (0, 0)),\n        (\"sime;\", (8771, 0)),\n        (\"gtrless;\", (8823, 0)),\n        (\"Cen\", (0, 0)),\n        (\"Ia\", (0, 0)),\n        (\"mnplu\", (0, 0)),\n        (\"lae\", (0, 0)),\n        (\"primes;\", (8473, 0)),\n        (\"acd\", (0, 0)),\n        (\"NotNeste\", (0, 0)),\n        (\"nhArr\", (0, 0)),\n        (\"ltcir;\", (10873, 0)),\n        (\"thinsp;\", (8201, 0)),\n        (\"lt\", (60, 0)),\n        (\"ApplyFunct\", (0, 0)),\n        (\"nsubseteq;\", (8840, 0)),\n        (\"lesssim;\", (8818, 0)),\n        (\"dstro\", (0, 0)),\n        (\"Tab\", (0, 0)),\n        (\"circlearrowle\", (0, 0)),\n        (\"LessLes\", (0, 0)),\n        (\"Squa\", (0, 0)),\n        (\"Topf\", (0, 0)),\n        (\"eqvpars\", (0, 0)),\n        (\"UnderBrac\", (0, 0)),\n        (\"quaterni\", (0, 0)),\n        (\"curlye\", (0, 0)),\n        (\"dagg\", (0, 0)),\n        (\"profalar;\", (9006, 0)),\n        (\"frac15;\", (8533, 0)),\n        (\"Longrightarrow\", (0, 0)),\n        (\"bigsqcup;\", (10758, 0)),\n        (\"Uppe\", (0, 0)),\n        (\"GreaterSlan\", (0, 0)),\n        (\"Lleftar\", (0, 0)),\n        (\"trpe\", (0, 0)),\n        (\"SucceedsEqual;\", (10928, 0)),\n        (\"NegativeMediumSpace\", (0, 0)),\n        (\"wedba\", (0, 0)),\n        (\"leftle\", (0, 0)),\n        (\"RightVector\", (0, 0)),\n        (\"bsol;\", (92, 0)),\n        (\"Acy\", (0, 0)),\n        (\"dzigrarr;\", (10239, 0)),\n        (\"double\", (0, 0)),\n        (\"SquareIn\", (0, 0)),\n        (\"emsp\", (0, 0)),\n        (\"thetasym;\", (977, 0)),\n        (\"Xop\", (0, 0)),\n        (\"cwi\", (0, 0)),\n        (\"Mcy\", (0, 0)),\n        (\"ltcc;\", (10918, 0)),\n        (\"vsubne;\", (8842, 65024)),\n        (\"cfr;\", (120096, 0)),\n        (\"thorn;\", (254, 0)),\n        (\"Lar\", (0, 0)),\n        (\"fllig;\", (64258, 0)),\n        (\"foral\", (0, 0)),\n        (\"boxvh\", (0, 0)),\n        (\"boxdl;\", (9488, 0)),\n        (\"DoubleContourInt\", (0, 0)),\n        (\"GJcy;\", (1027, 0)),\n        (\"shchcy\", (0, 0)),\n        (\"Uopf\", (0, 0)),\n        (\"ze\", (0, 0)),\n        (\"at\", (0, 0)),\n        (\"model\", (0, 0)),\n        (\"uharl\", (0, 0)),\n        (\"prec\", (0, 0)),\n        (\"UnderParenth\", (0, 0)),\n        (\"NotSucceedsSlantEqual\", (0, 0)),\n        (\"curve\", (0, 0)),\n        (\"rnmi\", (0, 0)),\n        (\"ClockwiseCon\", (0, 0)),\n        (\"Rar\", (0, 0)),\n        (\"nsubs\", (0, 0)),\n        (\"sccu\", (0, 0)),\n        (\"SucceedsSla\", (0, 0)),\n        (\"atild\", (0, 0)),\n        (\"ddotse\", (0, 0)),\n        (\"curarrm;\", (10556, 0)),\n        (\"LeftDoubleB\", (0, 0)),\n        (\"exponenti\", (0, 0)),\n        (\"apid\", (0, 0)),\n        (\"awconint;\", (8755, 0)),\n        (\"te\", (0, 0)),\n        (\"ult\", (0, 0)),\n        (\"LessT\", (0, 0)),\n        (\"uarr\", (0, 0)),\n        (\"Jfr\", (0, 0)),\n        (\"radic\", (0, 0)),\n        (\"NotLeftTriang\", (0, 0)),\n        (\"intprod;\", (10812, 0)),\n        (\"xf\", (0, 0)),\n        (\"GreaterSlantEq\", (0, 0)),\n        (\"ngeqq;\", (8807, 824)),\n        (\"prcue;\", (8828, 0)),\n        (\"bigwedg\", (0, 0)),\n        (\"dH\", (0, 0)),\n        (\"gesdotol;\", (10884, 0)),\n        (\"ShortDownA\", (0, 0)),\n        (\"div;\", (247, 0)),\n        (\"dfi\", (0, 0)),\n        (\"larrt\", (0, 0)),\n        (\"varrho\", (0, 0)),\n        (\"NotTildeFullE\", (0, 0)),\n        (\"intlarhk;\", (10775, 0)),\n        (\"upsi\", (0, 0)),\n        (\"dcaro\", (0, 0)),\n        (\"Gfr\", (0, 0)),\n        (\"nequiv\", (0, 0)),\n        (\"lobr\", (0, 0)),\n        (\"Euml;\", (203, 0)),\n        (\"NotCongrue\", (0, 0)),\n        (\"nG\", (0, 0)),\n        (\"vzi\", (0, 0)),\n        (\"NegativeMediumSpa\", (0, 0)),\n        (\"Plu\", (0, 0)),\n        (\"Ccaron\", (0, 0)),\n        (\"nj\", (0, 0)),\n        (\"roarr;\", (8702, 0)),\n        (\"rtril\", (0, 0)),\n        (\"nwnear\", (0, 0)),\n        (\"hksear\", (0, 0)),\n        (\"ssmile;\", (8995, 0)),\n        (\"numero\", (0, 0)),\n        (\"Kapp\", (0, 0)),\n        (\"parsim;\", (10995, 0)),\n        (\"ccupssm\", (0, 0)),\n        (\"AE\", (0, 0)),\n        (\"Nc\", (0, 0)),\n        (\"Supe\", (0, 0)),\n        (\"angrt\", (0, 0)),\n        (\"RightTriangleEq\", (0, 0)),\n        (\"DoubleLongLeftR\", (0, 0)),\n        (\"lcedi\", (0, 0)),\n        (\"in\", (0, 0)),\n        (\"rightri\", (0, 0)),\n        (\"RightFl\", (0, 0)),\n        (\"LessEqualGreater;\", (8922, 0)),\n        (\"upsih;\", (978, 0)),\n        (\"frac38\", (0, 0)),\n        (\"EmptyVeryS\", (0, 0)),\n        (\"hook\", (0, 0)),\n        (\"blk3\", (0, 0)),\n        (\"longrightarrow;\", (10230, 0)),\n        (\"NotLessGreat\", (0, 0)),\n        (\"RightArrow;\", (8594, 0)),\n        (\"EqualTilde\", (0, 0)),\n        (\"Par\", (0, 0)),\n        (\"rcaro\", (0, 0)),\n        (\"sqcups\", (0, 0)),\n        (\"comma\", (0, 0)),\n        (\"cirm\", (0, 0)),\n        (\"InvisibleCom\", (0, 0)),\n        (\"dblac\", (0, 0)),\n        (\"PrecedesSla\", (0, 0)),\n        (\"NotLe\", (0, 0)),\n        (\"xotime\", (0, 0)),\n        (\"Vdash;\", (8873, 0)),\n        (\"HumpDownHu\", (0, 0)),\n        (\"lf\", (0, 0)),\n        (\"sbq\", (0, 0)),\n        (\"succeq\", (0, 0)),\n        (\"DownLeftVector;\", (8637, 0)),\n        (\"gvertne\", (0, 0)),\n        (\"NegativeMedium\", (0, 0)),\n        (\"lesdot\", (0, 0)),\n        (\"expo\", (0, 0)),\n        (\"nldr;\", (8229, 0)),\n        (\"So\", (0, 0)),\n        (\"lobrk\", (0, 0)),\n        (\"chec\", (0, 0)),\n        (\"RightUpTe\", (0, 0)),\n        (\"xhA\", (0, 0)),\n        (\"ntrianglelefteq\", (0, 0)),\n        (\"GreaterFullE\", (0, 0)),\n        (\"SHC\", (0, 0)),\n        (\"Fouriert\", (0, 0)),\n        (\"str\", (0, 0)),\n        (\"IJli\", (0, 0)),\n        (\"imath;\", (305, 0)),\n        (\"lmoustache;\", (9136, 0)),\n        (\"minusd\", (0, 0)),\n        (\"uogon;\", (371, 0)),\n        (\"erarr;\", (10609, 0)),\n        (\"Cup\", (0, 0)),\n        (\"and\", (0, 0)),\n        (\"dbkarow;\", (10511, 0)),\n        (\"cularr\", (0, 0)),\n        (\"NJ\", (0, 0)),\n        (\"succcurlyeq;\", (8829, 0)),\n        (\"drcr\", (0, 0)),\n        (\"nlarr\", (0, 0)),\n        (\"PlusMinu\", (0, 0)),\n        (\"nacute\", (0, 0)),\n        (\"SHcy;\", (1064, 0)),\n        (\"SupersetEqual;\", (8839, 0)),\n        (\"Lleftarrow;\", (8666, 0)),\n        (\"DoubleL\", (0, 0)),\n        (\"Ecaro\", (0, 0)),\n        (\"uh\", (0, 0)),\n        (\"oast;\", (8859, 0)),\n        (\"IJl\", (0, 0)),\n        (\"sup2;\", (178, 0)),\n        (\"curvearrowleft\", (0, 0)),\n        (\"vscr;\", (120011, 0)),\n        (\"equest\", (0, 0)),\n        (\"RightVect\", (0, 0)),\n        (\"varsubsetneq\", (0, 0)),\n        (\"Yci\", (0, 0)),\n        (\"UnderPare\", (0, 0)),\n        (\"lot\", (0, 0)),\n        (\"triplu\", (0, 0)),\n        (\"Oslash;\", (216, 0)),\n        (\"Down\", (0, 0)),\n        (\"RightTeeVecto\", (0, 0)),\n        (\"dh\", (0, 0)),\n        (\"supl\", (0, 0)),\n        (\"nisd\", (0, 0)),\n        (\"nacu\", (0, 0)),\n        (\"xrArr\", (0, 0)),\n        (\"vart\", (0, 0)),\n        (\"ntri\", (0, 0)),\n        (\"frac1\", (0, 0)),\n        (\"bsi\", (0, 0)),\n        (\"ya\", (0, 0)),\n        (\"DoubleLongLeft\", (0, 0)),\n        (\"Icirc;\", (206, 0)),\n        (\"notindot;\", (8949, 824)),\n        (\"two\", (0, 0)),\n        (\"twohe\", (0, 0)),\n        (\"SupersetEqu\", (0, 0)),\n        (\"gacu\", (0, 0)),\n        (\"leftrightsquigarrow\", (0, 0)),\n        (\"ratail\", (0, 0)),\n        (\"UnionPl\", (0, 0)),\n        (\"bemp\", (0, 0)),\n        (\"notni;\", (8716, 0)),\n        (\"hellip\", (0, 0)),\n        (\"pun\", (0, 0)),\n        (\"DoubleLongLeftRightA\", (0, 0)),\n        (\"eqslantgtr\", (0, 0)),\n        (\"n\", (0, 0)),\n        (\"longmapsto\", (0, 0)),\n        (\"longrightarro\", (0, 0)),\n        (\"NotReve\", (0, 0)),\n        (\"brvbar;\", (166, 0)),\n        (\"Gt;\", (8811, 0)),\n        (\"tcedil;\", (355, 0)),\n        (\"RightFloo\", (0, 0)),\n        (\"Sup\", (0, 0)),\n        (\"Ugr\", (0, 0)),\n        (\"Esc\", (0, 0)),\n        (\"circledR;\", (174, 0)),\n        (\"hksw\", (0, 0)),\n        (\"Diacr\", (0, 0)),\n        (\"RightAngle\", (0, 0)),\n        (\"precap\", (0, 0)),\n        (\"topbot;\", (9014, 0)),\n        (\"oe\", (0, 0)),\n        (\"NotReverseEl\", (0, 0)),\n        (\"supset\", (0, 0)),\n        (\"lesg;\", (8922, 65024)),\n        (\"EmptySmallSquare\", (0, 0)),\n        (\"isc\", (0, 0)),\n        (\"tosa;\", (10537, 0)),\n        (\"EmptyV\", (0, 0)),\n        (\"yucy\", (0, 0)),\n        (\"NotRightTriangleEqual\", (0, 0)),\n        (\"InvisibleComma\", (0, 0)),\n        (\"OverParen\", (0, 0)),\n        (\"ltques\", (0, 0)),\n        (\"Otimes\", (0, 0)),\n        (\"inf\", (0, 0)),\n        (\"prime\", (0, 0)),\n        (\"dempt\", (0, 0)),\n        (\"Tau;\", (932, 0)),\n        (\"simrar\", (0, 0)),\n        (\"FilledSma\", (0, 0)),\n        (\"ia\", (0, 0)),\n        (\"qo\", (0, 0)),\n        (\"minus;\", (8722, 0)),\n        (\"NotSquareSuperse\", (0, 0)),\n        (\"gbreve\", (0, 0)),\n        (\"thickapprox;\", (8776, 0)),\n        (\"ultr\", (0, 0)),\n        (\"simeq\", (0, 0)),\n        (\"Exponen\", (0, 0)),\n        (\"nsp\", (0, 0)),\n        (\"Iopf;\", (120128, 0)),\n        (\"ocy;\", (1086, 0)),\n        (\"subed\", (0, 0)),\n        (\"drcrop;\", (8972, 0)),\n        (\"twoheadl\", (0, 0)),\n        (\"vo\", (0, 0)),\n        (\"LeftDownVe\", (0, 0)),\n        (\"Acy;\", (1040, 0)),\n        (\"Nested\", (0, 0)),\n        (\"Fc\", (0, 0)),\n        (\"Eac\", (0, 0)),\n        (\"nfr\", (0, 0)),\n        (\"subsetneq;\", (8842, 0)),\n        (\"nearr;\", (8599, 0)),\n        (\"DownLeftVecto\", (0, 0)),\n        (\"Gopf\", (0, 0)),\n        (\"thinsp\", (0, 0)),\n        (\"DownTeeA\", (0, 0)),\n        (\"Ofr;\", (120082, 0)),\n        (\"nvlt\", (0, 0)),\n        (\"circleddash\", (0, 0)),\n        (\"ldr\", (0, 0)),\n        (\"aleph\", (0, 0)),\n        (\"doub\", (0, 0)),\n        (\"nac\", (0, 0)),\n        (\"Zscr\", (0, 0)),\n        (\"LeftCei\", (0, 0)),\n        (\"LeftArrowR\", (0, 0)),\n        (\"NotGreaterGrea\", (0, 0)),\n        (\"rangl\", (0, 0)),\n        (\"NotReverseEleme\", (0, 0)),\n        (\"puncsp;\", (8200, 0)),\n        (\"lArr;\", (8656, 0)),\n        (\"hookrightarro\", (0, 0)),\n        (\"CenterDot\", (0, 0)),\n        (\"LowerLeftArrow;\", (8601, 0)),\n        (\"bsem\", (0, 0)),\n        (\"zigrarr\", (0, 0)),\n        (\"ecol\", (0, 0)),\n        (\"rA\", (0, 0)),\n        (\"xhar\", (0, 0)),\n        (\"PrecedesEq\", (0, 0)),\n        (\"Escr\", (0, 0)),\n        (\"uhblk\", (0, 0)),\n        (\"subsetn\", (0, 0)),\n        (\"ApplyFun\", (0, 0)),\n        (\"eacu\", (0, 0)),\n        (\"rightrightar\", (0, 0)),\n        (\"nda\", (0, 0)),\n        (\"GreaterTil\", (0, 0)),\n        (\"DownArrowBa\", (0, 0)),\n        (\"centerd\", (0, 0)),\n        (\"kc\", (0, 0)),\n        (\"lltri\", (0, 0)),\n        (\"DoubleUpArrow;\", (8657, 0)),\n        (\"Zcar\", (0, 0)),\n        (\"tau;\", (964, 0)),\n        (\"angmsdae\", (0, 0)),\n        (\"cupca\", (0, 0)),\n        (\"Invis\", (0, 0)),\n        (\"raquo\", (187, 0)),\n        (\"SucceedsTi\", (0, 0)),\n        (\"LessFullEqual;\", (8806, 0)),\n        (\"sqsu\", (0, 0)),\n        (\"equest;\", (8799, 0)),\n        (\"nleqsl\", (0, 0)),\n        (\"raem\", (0, 0)),\n        (\"Double\", (0, 0)),\n        (\"horba\", (0, 0)),\n        (\"NotCon\", (0, 0)),\n        (\"lE;\", (8806, 0)),\n        (\"Dcy\", (0, 0)),\n        (\"gra\", (0, 0)),\n        (\"simgE\", (0, 0)),\n        (\"semi\", (0, 0)),\n        (\"mic\", (0, 0)),\n        (\"CenterDot;\", (183, 0)),\n        (\"ha\", (0, 0)),\n        (\"setminus;\", (8726, 0)),\n        (\"dotplus\", (0, 0)),\n        (\"suc\", (0, 0)),\n        (\"varpro\", (0, 0)),\n        (\"gsime;\", (10894, 0)),\n        (\"Sum;\", (8721, 0)),\n        (\"iin\", (0, 0)),\n        (\"nbs\", (0, 0)),\n        (\"nvrArr;\", (10499, 0)),\n        (\"ldrdha\", (0, 0)),\n        (\"OpenCurlyDoubleQu\", (0, 0)),\n        (\"ncu\", (0, 0)),\n        (\"dHa\", (0, 0)),\n        (\"boxv\", (0, 0)),\n        (\"brev\", (0, 0)),\n        (\"Tcy;\", (1058, 0)),\n        (\"Oslas\", (0, 0)),\n        (\"PrecedesSlantEqua\", (0, 0)),\n        (\"DiacriticalTilde;\", (732, 0)),\n        (\"Zcaron\", (0, 0)),\n        (\"yucy;\", (1102, 0)),\n        (\"dd;\", (8518, 0)),\n        (\"harr;\", (8596, 0)),\n        (\"DoubleRigh\", (0, 0)),\n        (\"looparrowri\", (0, 0)),\n        (\"orslope;\", (10839, 0)),\n        (\"RuleDelayed\", (0, 0)),\n        (\"xrar\", (0, 0)),\n        (\"acy\", (0, 0)),\n        (\"FilledS\", (0, 0)),\n        (\"DoubleLeftRig\", (0, 0)),\n        (\"varepsil\", (0, 0)),\n        (\"RightDow\", (0, 0)),\n        (\"Updownarrow\", (0, 0)),\n        (\"nha\", (0, 0)),\n        (\"oslash;\", (248, 0)),\n        (\"Cayleys;\", (8493, 0)),\n        (\"iiii\", (0, 0)),\n        (\"subplus\", (0, 0)),\n        (\"cuwed;\", (8911, 0)),\n        (\"NotReverseElem\", (0, 0)),\n        (\"suphsu\", (0, 0)),\n        (\"vang\", (0, 0)),\n        (\"ClockwiseContourI\", (0, 0)),\n        (\"Vd\", (0, 0)),\n        (\"fe\", (0, 0)),\n        (\"Leftarrow;\", (8656, 0)),\n        (\"NotR\", (0, 0)),\n        (\"cra\", (0, 0)),\n        (\"NotNestedLessL\", (0, 0)),\n        (\"rsqb\", (0, 0)),\n        (\"TripleDo\", (0, 0)),\n        (\"gesd\", (0, 0)),\n        (\"Longri\", (0, 0)),\n        (\"block;\", (9608, 0)),\n        (\"NestedGreater\", (0, 0)),\n        (\"RightArrowBa\", (0, 0)),\n        (\"KJc\", (0, 0)),\n        (\"LeftTeeVector;\", (10586, 0)),\n        (\"NotVerticalBar;\", (8740, 0)),\n        (\"GreaterG\", (0, 0)),\n        (\"LeftDown\", (0, 0)),\n        (\"Eum\", (0, 0)),\n        (\"Wop\", (0, 0)),\n        (\"bpri\", (0, 0)),\n        (\"br\", (0, 0)),\n        (\"profsurf\", (0, 0)),\n        (\"rharu\", (0, 0)),\n        (\"SquareU\", (0, 0)),\n        (\"strns\", (0, 0)),\n        (\"boxdR;\", (9554, 0)),\n        (\"larrh\", (0, 0)),\n        (\"TripleDot\", (0, 0)),\n        (\"FilledVerySmallSq\", (0, 0)),\n        (\"scpoli\", (0, 0)),\n        (\"YUcy\", (0, 0)),\n        (\"xrAr\", (0, 0)),\n        (\"Qfr;\", (120084, 0)),\n        (\"NewLine;\", (10, 0)),\n        (\"angmsdac;\", (10666, 0)),\n        (\"nsucce\", (0, 0)),\n        (\"wcirc;\", (373, 0)),\n        (\"dem\", (0, 0)),\n        (\"van\", (0, 0)),\n        (\"NotSquareSupersetEqu\", (0, 0)),\n        (\"Bop\", (0, 0)),\n        (\"Exponent\", (0, 0)),\n        (\"mapstolef\", (0, 0)),\n        (\"prap\", (0, 0)),\n        (\"squf\", (0, 0)),\n        (\"DoubleRi\", (0, 0)),\n        (\"origo\", (0, 0)),\n        (\"plussi\", (0, 0)),\n        (\"Longrig\", (0, 0)),\n        (\"twoheadleftarro\", (0, 0)),\n        (\"Uar\", (0, 0)),\n        (\"Cce\", (0, 0)),\n        (\"Parti\", (0, 0)),\n        (\"drbkar\", (0, 0)),\n        (\"SH\", (0, 0)),\n        (\"nsubset\", (0, 0)),\n        (\"semi;\", (59, 0)),\n        (\"supsim\", (0, 0)),\n        (\"YU\", (0, 0)),\n        (\"igrave\", (236, 0)),\n        (\"Aogo\", (0, 0)),\n        (\"HumpDownH\", (0, 0)),\n        (\"DownRightVectorBar\", (0, 0)),\n        (\"ga\", (0, 0)),\n        (\"geq;\", (8805, 0)),\n        (\"Tau\", (0, 0)),\n        (\"ratio\", (0, 0)),\n        (\"DownRight\", (0, 0)),\n        (\"aci\", (0, 0)),\n        (\"NestedGreaterGreater;\", (8811, 0)),\n        (\"gv\", (0, 0)),\n        (\"Mi\", (0, 0)),\n        (\"Bcy;\", (1041, 0)),\n        (\"Tcaron\", (0, 0)),\n        (\"boxv;\", (9474, 0)),\n        (\"ua\", (0, 0)),\n        (\"LeftDownVecto\", (0, 0)),\n        (\"plusb\", (0, 0)),\n        (\"NotSucceedsT\", (0, 0)),\n        (\"LongLe\", (0, 0)),\n        (\"RightDou\", (0, 0)),\n        (\"bsolhsu\", (0, 0)),\n        (\"cong;\", (8773, 0)),\n        (\"rsqu\", (0, 0)),\n        (\"rfisht\", (0, 0)),\n        (\"app\", (0, 0)),\n        (\"ClockwiseContourIntegral\", (0, 0)),\n        (\"ale\", (0, 0)),\n        (\"eques\", (0, 0)),\n        (\"RightTeeVector\", (0, 0)),\n        (\"leftarro\", (0, 0)),\n        (\"ysc\", (0, 0)),\n        (\"ne\", (0, 0)),\n        (\"Backsla\", (0, 0)),\n        (\"hkswarow\", (0, 0)),\n        (\"excl;\", (33, 0)),\n        (\"nges\", (0, 0)),\n        (\"Dar\", (0, 0)),\n        (\"NotSucceedsSla\", (0, 0)),\n        (\"Ub\", (0, 0)),\n        (\"igra\", (0, 0)),\n        (\"VeryT\", (0, 0)),\n        (\"ntilde\", (241, 0)),\n        (\"copr\", (0, 0)),\n        (\"Lce\", (0, 0)),\n        (\"swnwar;\", (10538, 0)),\n        (\"ecaron\", (0, 0)),\n        (\"bumpeq;\", (8783, 0)),\n        (\"rightsqui\", (0, 0)),\n        (\"bnequiv\", (0, 0)),\n        (\"lhar\", (0, 0)),\n        (\"RightTee;\", (8866, 0)),\n        (\"FilledVer\", (0, 0)),\n        (\"ens\", (0, 0)),\n        (\"leftrightar\", (0, 0)),\n        (\"RightDownV\", (0, 0)),\n        (\"NotRe\", (0, 0)),\n        (\"bowti\", (0, 0)),\n        (\"falling\", (0, 0)),\n        (\"HilbertSp\", (0, 0)),\n        (\"LeftTri\", (0, 0)),\n        (\"gnsi\", (0, 0)),\n        (\"lgE;\", (10897, 0)),\n        (\"ThinS\", (0, 0)),\n        (\"gtdo\", (0, 0)),\n        (\"gacut\", (0, 0)),\n        (\"oro\", (0, 0)),\n        (\"Produc\", (0, 0)),\n        (\"emsp14;\", (8197, 0)),\n        (\"gcy\", (0, 0)),\n        (\"SuchThat;\", (8715, 0)),\n        (\"tstro\", (0, 0)),\n        (\"lesdotor\", (0, 0)),\n        (\"bbrktbrk\", (0, 0)),\n        (\"NotDoubleV\", (0, 0)),\n        (\"Kcedil\", (0, 0)),\n        (\"lessdot;\", (8918, 0)),\n        (\"cirE\", (0, 0)),\n        (\"DiacriticalGra\", (0, 0)),\n        (\"lAta\", (0, 0)),\n        (\"grave;\", (96, 0)),\n        (\"bigc\", (0, 0)),\n        (\"DoubleDownArro\", (0, 0)),\n        (\"elsdot\", (0, 0)),\n        (\"NotSub\", (0, 0)),\n        (\"DoubleVerti\", (0, 0)),\n        (\"VerticalBar\", (0, 0)),\n        (\"Sigma;\", (931, 0)),\n        (\"Ag\", (0, 0)),\n        (\"Fille\", (0, 0)),\n        (\"glE;\", (10898, 0)),\n        (\"lbrac\", (0, 0)),\n        (\"pitchfork\", (0, 0)),\n        (\"doublebarwed\", (0, 0)),\n        (\"num;\", (35, 0)),\n        (\"Uacute;\", (218, 0)),\n        (\"Zf\", (0, 0)),\n        (\"boxhu;\", (9524, 0)),\n        (\"ld\", (0, 0)),\n        (\"SuchT\", (0, 0)),\n        (\"LongRig\", (0, 0)),\n        (\"LowerLeft\", (0, 0)),\n        (\"veee\", (0, 0)),\n        (\"muma\", (0, 0)),\n        (\"thka\", (0, 0)),\n        (\"Ogra\", (0, 0)),\n        (\"SquareSu\", (0, 0)),\n        (\"compleme\", (0, 0)),\n        (\"Jukcy;\", (1028, 0)),\n        (\"Di\", (0, 0)),\n        (\"blk\", (0, 0)),\n        (\"zigra\", (0, 0)),\n        (\"lneq\", (0, 0)),\n        (\"gtquest;\", (10876, 0)),\n        (\"LeftArrowB\", (0, 0)),\n        (\"UpArro\", (0, 0)),\n        (\"succna\", (0, 0)),\n        (\"pluscir;\", (10786, 0)),\n        (\"sfr;\", (120112, 0)),\n        (\"vartriangle\", (0, 0)),\n        (\"Leftrightarrow\", (0, 0)),\n        (\"RightTria\", (0, 0)),\n        (\"upharpoonright;\", (8638, 0)),\n        (\"LeftUpVecto\", (0, 0)),\n        (\"TSc\", (0, 0)),\n        (\"colon;\", (58, 0)),\n        (\"DownLeftRightVe\", (0, 0)),\n        (\"Do\", (0, 0)),\n        (\"DoubleRightArrow;\", (8658, 0)),\n        (\"bump\", (0, 0)),\n        (\"cuvee;\", (8910, 0)),\n        (\"Ycirc;\", (374, 0)),\n        (\"lca\", (0, 0)),\n        (\"Revers\", (0, 0)),\n        (\"tdo\", (0, 0)),\n        (\"gtci\", (0, 0)),\n        (\"mDDot;\", (8762, 0)),\n        (\"nrightarrow;\", (8603, 0)),\n        (\"laqu\", (0, 0)),\n        (\"rpa\", (0, 0)),\n        (\"ned\", (0, 0)),\n        (\"NotCongr\", (0, 0)),\n        (\"Kap\", (0, 0)),\n        (\"eopf;\", (120150, 0)),\n        (\"num\", (0, 0)),\n        (\"plusdo;\", (8724, 0)),\n        (\"hookr\", (0, 0)),\n        (\"egs;\", (10902, 0)),\n        (\"varno\", (0, 0)),\n        (\"Downar\", (0, 0)),\n        (\"boxDr\", (0, 0)),\n        (\"lesseqqgtr;\", (10891, 0)),\n        (\"vl\", (0, 0)),\n        (\"uHa\", (0, 0)),\n        (\"osol;\", (8856, 0)),\n        (\"scaron\", (0, 0)),\n        (\"Ccedil\", (199, 0)),\n        (\"El\", (0, 0)),\n        (\"Coprod\", (0, 0)),\n        (\"divideontim\", (0, 0)),\n        (\"Nt\", (0, 0)),\n        (\"ss\", (0, 0)),\n        (\"lthree\", (0, 0)),\n        (\"utrif\", (0, 0)),\n        (\"RightTeeAr\", (0, 0)),\n        (\"SucceedsEqual\", (0, 0)),\n        (\"rotimes\", (0, 0)),\n        (\"gn\", (0, 0)),\n        (\"eogon\", (0, 0)),\n        (\"boxd\", (0, 0)),\n        (\"nLtv;\", (8810, 824)),\n        (\"nRigh\", (0, 0)),\n        (\"ShortRig\", (0, 0)),\n        (\"curlyeqs\", (0, 0)),\n        (\"Otime\", (0, 0)),\n        (\"UpD\", (0, 0)),\n        (\"theta;\", (952, 0)),\n        (\"Fouri\", (0, 0)),\n        (\"EmptySmallSquare;\", (9723, 0)),\n        (\"lpar;\", (40, 0)),\n        (\"lowb\", (0, 0)),\n        (\"SquareSuperse\", (0, 0)),\n        (\"Jf\", (0, 0)),\n        (\"gnappr\", (0, 0)),\n        (\"sear\", (0, 0)),\n        (\"NotLessEqua\", (0, 0)),\n        (\"DiacriticalDo\", (0, 0)),\n        (\"gtd\", (0, 0)),\n        (\"bowtie;\", (8904, 0)),\n        (\"precna\", (0, 0)),\n        (\"nprcue\", (0, 0)),\n        (\"Aring\", (197, 0)),\n        (\"Vb\", (0, 0)),\n        (\"ThickS\", (0, 0)),\n        (\"Lc\", (0, 0)),\n        (\"DiacriticalTild\", (0, 0)),\n        (\"TildeFullEqual\", (0, 0)),\n        (\"wc\", (0, 0)),\n        (\"Ff\", (0, 0)),\n        (\"dc\", (0, 0)),\n        (\"NotExists;\", (8708, 0)),\n        (\"atilde;\", (227, 0)),\n        (\"doteq;\", (8784, 0)),\n        (\"nvs\", (0, 0)),\n        (\"lbrack;\", (91, 0)),\n        (\"biguplus\", (0, 0)),\n        (\"hyphen\", (0, 0)),\n        (\"Scy\", (0, 0)),\n        (\"lsime\", (0, 0)),\n        (\"tb\", (0, 0)),\n        (\"intla\", (0, 0)),\n        (\"dst\", (0, 0)),\n        (\"back\", (0, 0)),\n        (\"DownBre\", (0, 0)),\n        (\"smile;\", (8995, 0)),\n        (\"ugra\", (0, 0)),\n        (\"Lced\", (0, 0)),\n        (\"H\", (0, 0)),\n        (\"urt\", (0, 0)),\n        (\"NotNest\", (0, 0)),\n        (\"precs\", (0, 0)),\n        (\"smallsetmi\", (0, 0)),\n        (\"DownRightTeeVec\", (0, 0)),\n        (\"Rrighta\", (0, 0)),\n        (\"Ycy;\", (1067, 0)),\n        (\"Oti\", (0, 0)),\n        (\"Xi;\", (926, 0)),\n        (\"leftarrow;\", (8592, 0)),\n        (\"ZH\", (0, 0)),\n        (\"permi\", (0, 0)),\n        (\"NotLessSlant\", (0, 0)),\n        (\"nopf\", (0, 0)),\n        (\"timesb\", (0, 0)),\n        (\"Zer\", (0, 0)),\n        (\"cupbrcap\", (0, 0)),\n        (\"LowerRi\", (0, 0)),\n        (\"late\", (0, 0)),\n        (\"InvisibleComma;\", (8291, 0)),\n        (\"eDD\", (0, 0)),\n        (\"softcy;\", (1100, 0)),\n        (\"nvrtrie;\", (8885, 8402)),\n        (\"xw\", (0, 0)),\n        (\"Tripl\", (0, 0)),\n        (\"rcub;\", (125, 0)),\n        (\"cudarrl\", (0, 0)),\n        (\"DoubleDownArrow;\", (8659, 0)),\n        (\"lag\", (0, 0)),\n        (\"ltlar\", (0, 0)),\n        (\"NoBre\", (0, 0)),\n        (\"Ecaron\", (0, 0)),\n        (\"lessapp\", (0, 0)),\n        (\"submu\", (0, 0)),\n        (\"wedbar\", (0, 0)),\n        (\"NestedGreaterG\", (0, 0)),\n        (\"RightDownVe\", (0, 0)),\n        (\"cu\", (0, 0)),\n        (\"hksearo\", (0, 0)),\n        (\"bigup\", (0, 0)),\n        (\"omic\", (0, 0)),\n        (\"aacut\", (0, 0)),\n        (\"notniva;\", (8716, 0)),\n        (\"dale\", (0, 0)),\n        (\"capbrcu\", (0, 0)),\n        (\"NotGreaterSlantEqu\", (0, 0)),\n        (\"atilde\", (227, 0)),\n        (\"wrea\", (0, 0)),\n        (\"imagp\", (0, 0)),\n        (\"Prec\", (0, 0)),\n        (\"otim\", (0, 0)),\n        (\"Nacute;\", (323, 0)),\n        (\"lesseqg\", (0, 0)),\n        (\"k\", (0, 0)),\n        (\"mod\", (0, 0)),\n        (\"Lleft\", (0, 0)),\n        (\"LessLess;\", (10913, 0)),\n        (\"pre;\", (10927, 0)),\n        (\"blk14;\", (9617, 0)),\n        (\"chcy;\", (1095, 0)),\n        (\"Integra\", (0, 0)),\n        (\"NotGreaterL\", (0, 0)),\n        (\"downa\", (0, 0)),\n        (\"gf\", (0, 0)),\n        (\"conint;\", (8750, 0)),\n        (\"thickap\", (0, 0)),\n        (\"vsubnE\", (0, 0)),\n        (\"boxuR\", (0, 0)),\n        (\"GreaterF\", (0, 0)),\n        (\"ETH\", (208, 0)),\n        (\"ced\", (0, 0)),\n        (\"gtcir\", (0, 0)),\n        (\"DoubleUpD\", (0, 0)),\n        (\"ulcorner\", (0, 0)),\n        (\"UpEqu\", (0, 0)),\n        (\"digamma;\", (989, 0)),\n        (\"rightsquigar\", (0, 0)),\n        (\"berno\", (0, 0)),\n        (\"divideo\", (0, 0)),\n        (\"digam\", (0, 0)),\n        (\"scir\", (0, 0)),\n        (\"exponent\", (0, 0)),\n        (\"apacir\", (0, 0)),\n        (\"i\", (0, 0)),\n        (\"LongLeftRightArrow\", (0, 0)),\n        (\"ngeqs\", (0, 0)),\n        (\"Cloc\", (0, 0)),\n        (\"pf\", (0, 0)),\n        (\"compfn\", (0, 0)),\n        (\"LeftTriangleEqual;\", (8884, 0)),\n        (\"wreath\", (0, 0)),\n        (\"boxVl\", (0, 0)),\n        (\"congdot\", (0, 0)),\n        (\"lstro\", (0, 0)),\n        (\"nopf;\", (120159, 0)),\n        (\"yacut\", (0, 0)),\n        (\"triplus\", (0, 0)),\n        (\"mapstol\", (0, 0)),\n        (\"Intersect\", (0, 0)),\n        (\"DiacriticalTi\", (0, 0)),\n        (\"utr\", (0, 0)),\n        (\"Omi\", (0, 0)),\n        (\"plussim;\", (10790, 0)),\n        (\"aopf;\", (120146, 0)),\n        (\"Oacute;\", (211, 0)),\n        (\"uplus\", (0, 0)),\n        (\"Tilde\", (0, 0)),\n        (\"ctd\", (0, 0)),\n        (\"div\", (0, 0)),\n        (\"gamm\", (0, 0)),\n        (\"NotHumpD\", (0, 0)),\n        (\"SquareS\", (0, 0)),\n        (\"ulcorner;\", (8988, 0)),\n        (\"succnapprox\", (0, 0)),\n        (\"shcy;\", (1096, 0)),\n        (\"MediumSpace;\", (8287, 0)),\n        (\"LeftTriangleEqual\", (0, 0)),\n        (\"iukcy\", (0, 0)),\n        (\"RightUpVector;\", (8638, 0)),\n        (\"bigodot;\", (10752, 0)),\n        (\"c\", (0, 0)),\n        (\"UpArrowDownArr\", (0, 0)),\n        (\"NotGreaterEqua\", (0, 0)),\n        (\"itild\", (0, 0)),\n        (\"Vopf;\", (120141, 0)),\n        (\"lvnE\", (0, 0)),\n        (\"lmoust;\", (9136, 0)),\n        (\"lotimes\", (0, 0)),\n        (\"numsp\", (0, 0)),\n        (\"sfr\", (0, 0)),\n        (\"subsetne\", (0, 0)),\n        (\"chi\", (0, 0)),\n        (\"boxVL;\", (9571, 0)),\n        (\"NotHump\", (0, 0)),\n        (\"ShortRightArro\", (0, 0)),\n        (\"xs\", (0, 0)),\n        (\"squa\", (0, 0)),\n        (\"Rarr\", (0, 0)),\n        (\"cirscir\", (0, 0)),\n        (\"intercal;\", (8890, 0)),\n        (\"UpTeeArr\", (0, 0)),\n        (\"Barwed\", (0, 0)),\n        (\"nsupset\", (0, 0)),\n        (\"Omeg\", (0, 0)),\n        (\"NewLine\", (0, 0)),\n        (\"LeftUpVector;\", (8639, 0)),\n        (\"Xfr;\", (120091, 0)),\n        (\"Tstr\", (0, 0)),\n        (\"nparallel\", (0, 0)),\n        (\"succapprox;\", (10936, 0)),\n        (\"subsub;\", (10965, 0)),\n        (\"lvertn\", (0, 0)),\n        (\"simgE;\", (10912, 0)),\n        (\"qsc\", (0, 0)),\n        (\"emacr;\", (275, 0)),\n        (\"LongL\", (0, 0)),\n        (\"longleftrightarrow\", (0, 0)),\n        (\"boxp\", (0, 0)),\n        (\"nesi\", (0, 0)),\n        (\"zf\", (0, 0)),\n        (\"Long\", (0, 0)),\n        (\"downharpoonlef\", (0, 0)),\n        (\"icy\", (0, 0)),\n        (\"LeftC\", (0, 0)),\n        (\"upupa\", (0, 0)),\n        (\"NotRigh\", (0, 0)),\n        (\"LeftFloor;\", (8970, 0)),\n        (\"Succe\", (0, 0)),\n        (\"box\", (0, 0)),\n        (\"cedi\", (0, 0)),\n        (\"PartialD;\", (8706, 0)),\n        (\"ora\", (0, 0)),\n        (\"UpArrowDownA\", (0, 0)),\n        (\"rmoustach\", (0, 0)),\n        (\"bNot\", (0, 0)),\n        (\"varp\", (0, 0)),\n        (\"lmido\", (0, 0)),\n        (\"Oacut\", (0, 0)),\n        (\"rig\", (0, 0)),\n        (\"vartri\", (0, 0)),\n        (\"odb\", (0, 0)),\n        (\"searr\", (0, 0)),\n        (\"xsqcu\", (0, 0)),\n        (\"SucceedsTild\", (0, 0)),\n        (\"sect;\", (167, 0)),\n        (\"tpr\", (0, 0)),\n        (\"gtreqq\", (0, 0)),\n        (\"Ab\", (0, 0)),\n        (\"isin\", (0, 0)),\n        (\"ntriang\", (0, 0)),\n        (\"leftharpoond\", (0, 0)),\n        (\"shy;\", (173, 0)),\n        (\"par\", (0, 0)),\n        (\"NotSubsetEqu\", (0, 0)),\n        (\"prcu\", (0, 0)),\n        (\"thet\", (0, 0)),\n        (\"UpTeeArro\", (0, 0)),\n        (\"kopf\", (0, 0)),\n        (\"LeftUpDow\", (0, 0)),\n        (\"cupbrcap;\", (10824, 0)),\n        (\"xlArr\", (0, 0)),\n        (\"Darr;\", (8609, 0)),\n        (\"DoubleVerticalBar;\", (8741, 0)),\n        (\"eqcir\", (0, 0)),\n        (\"qscr;\", (120006, 0)),\n        (\"looparrowleft\", (0, 0)),\n        (\"ltlarr;\", (10614, 0)),\n        (\"robr\", (0, 0)),\n        (\"cdot\", (0, 0)),\n        (\"integers\", (0, 0)),\n        (\"Iac\", (0, 0)),\n        (\"micr\", (0, 0)),\n        (\"LeftArrowRightAr\", (0, 0)),\n        (\"supn\", (0, 0)),\n        (\"RightDoubleBracket\", (0, 0)),\n        (\"olarr\", (0, 0)),\n        (\"larrs\", (0, 0)),\n        (\"utri\", (0, 0)),\n        (\"imped;\", (437, 0)),\n        (\"FilledVerySmal\", (0, 0)),\n        (\"leftrightharpoo\", (0, 0)),\n        (\"xrarr;\", (10230, 0)),\n        (\"olcros\", (0, 0)),\n        (\"sqcup\", (0, 0)),\n        (\"hercon;\", (8889, 0)),\n        (\"Em\", (0, 0)),\n        (\"prnsim\", (0, 0)),\n        (\"Nac\", (0, 0)),\n        (\"varrh\", (0, 0)),\n        (\"sfrown\", (0, 0)),\n        (\"dArr\", (0, 0)),\n        (\"longleftrightarrow;\", (10231, 0)),\n        (\"DownLeftTeeVector\", (0, 0)),\n        (\"NotSquareSub\", (0, 0)),\n        (\"NegativeVer\", (0, 0)),\n        (\"egsdot\", (0, 0)),\n        (\"rightrightarrows;\", (8649, 0)),\n        (\"sups\", (0, 0)),\n        (\"DownArrowBar;\", (10515, 0)),\n        (\"drc\", (0, 0)),\n        (\"nsube;\", (8840, 0)),\n        (\"fparti\", (0, 0)),\n        (\"mumap;\", (8888, 0)),\n        (\"Gdo\", (0, 0)),\n        (\"car\", (0, 0)),\n        (\"rotim\", (0, 0)),\n        (\"tilde;\", (732, 0)),\n        (\"sqc\", (0, 0)),\n        (\"yicy;\", (1111, 0)),\n        (\"nvHarr\", (0, 0)),\n        (\"Diam\", (0, 0)),\n        (\"ncar\", (0, 0)),\n        (\"lpar\", (0, 0)),\n        (\"Hc\", (0, 0)),\n        (\"Expo\", (0, 0)),\n        (\"Dagg\", (0, 0)),\n        (\"varsub\", (0, 0)),\n        (\"Sced\", (0, 0)),\n        (\"frac12\", (189, 0)),\n        (\"no\", (0, 0)),\n        (\"npart;\", (8706, 824)),\n        (\"lAar\", (0, 0)),\n        (\"bpr\", (0, 0)),\n        (\"oS;\", (9416, 0)),\n        (\"pru\", (0, 0)),\n        (\"harr\", (0, 0)),\n        (\"Gr\", (0, 0)),\n        (\"Cir\", (0, 0)),\n        (\"DJcy;\", (1026, 0)),\n        (\"zhcy;\", (1078, 0)),\n        (\"rightarrow\", (0, 0)),\n        (\"VerticalS\", (0, 0)),\n        (\"qop\", (0, 0)),\n        (\"ReverseEquilibrium\", (0, 0)),\n        (\"Vo\", (0, 0)),\n        (\"urcrop;\", (8974, 0)),\n        (\"TildeEqual;\", (8771, 0)),\n        (\"kcedil\", (0, 0)),\n        (\"Et\", (0, 0)),\n        (\"nLeftright\", (0, 0)),\n        (\"ReverseUpEquilib\", (0, 0)),\n        (\"tshcy\", (0, 0)),\n        (\"Uparr\", (0, 0)),\n        (\"angmsdae;\", (10668, 0)),\n        (\"Sqr\", (0, 0)),\n        (\"DownRi\", (0, 0)),\n        (\"Eta\", (0, 0)),\n        (\"succap\", (0, 0)),\n        (\"hyphe\", (0, 0)),\n        (\"Jsercy;\", (1032, 0)),\n        (\"GreaterEqualLess;\", (8923, 0)),\n        (\"ij\", (0, 0)),\n        (\"squarf;\", (9642, 0)),\n        (\"GreaterGre\", (0, 0)),\n        (\"OElig;\", (338, 0)),\n        (\"urcorne\", (0, 0)),\n        (\"LeftArr\", (0, 0)),\n        (\"Ecar\", (0, 0)),\n        (\"nles;\", (10877, 824)),\n        (\"pri\", (0, 0)),\n        (\"lessg\", (0, 0)),\n        (\"rbar\", (0, 0)),\n        (\"LessSl\", (0, 0)),\n        (\"md\", (0, 0)),\n        (\"DownBreve\", (0, 0)),\n        (\"succcurly\", (0, 0)),\n        (\"ncup\", (0, 0)),\n        (\"UnionP\", (0, 0)),\n        (\"HumpDownHump\", (0, 0)),\n        (\"sqcaps\", (0, 0)),\n        (\"NotNestedGreaterGre\", (0, 0)),\n        (\"triang\", (0, 0)),\n        (\"eqcol\", (0, 0)),\n        (\"oum\", (0, 0)),\n        (\"lbbrk;\", (10098, 0)),\n        (\"nsupsete\", (0, 0)),\n        (\"Icy\", (0, 0)),\n        (\"EN\", (0, 0)),\n        (\"nvltri\", (0, 0)),\n        (\"Uop\", (0, 0)),\n        (\"inte\", (0, 0)),\n        (\"darr\", (0, 0)),\n        (\"LeftArro\", (0, 0)),\n        (\"Diff\", (0, 0)),\n        (\"Empty\", (0, 0)),\n        (\"rangd;\", (10642, 0)),\n        (\"ln\", (0, 0)),\n        (\"Acir\", (0, 0)),\n        (\"Theta\", (0, 0)),\n        (\"Bscr;\", (8492, 0)),\n        (\"vfr;\", (120115, 0)),\n        (\"shortpara\", (0, 0)),\n        (\"curlywe\", (0, 0)),\n        (\"rarra\", (0, 0)),\n        (\"bigtriangledow\", (0, 0)),\n        (\"triminus;\", (10810, 0)),\n        (\"utdo\", (0, 0)),\n        (\"sme\", (0, 0)),\n        (\"LeftCeili\", (0, 0)),\n        (\"xcu\", (0, 0)),\n        (\"ge\", (0, 0)),\n        (\"smashp;\", (10803, 0)),\n        (\"dsc\", (0, 0)),\n        (\"twoheadleft\", (0, 0)),\n        (\"urtri\", (0, 0)),\n        (\"horb\", (0, 0)),\n        (\"upharpoonlef\", (0, 0)),\n        (\"lessdo\", (0, 0)),\n        (\"curvearrowrig\", (0, 0)),\n        (\"Ap\", (0, 0)),\n        (\"trad\", (0, 0)),\n        (\"LeftDownTeeVec\", (0, 0)),\n        (\"np\", (0, 0)),\n        (\"cirsci\", (0, 0)),\n        (\"prur\", (0, 0)),\n        (\"cirfnint\", (0, 0)),\n        (\"nbump;\", (8782, 824)),\n        (\"UpArrowD\", (0, 0)),\n        (\"GreaterFul\", (0, 0)),\n        (\"ntil\", (0, 0)),\n        (\"DoubleDow\", (0, 0)),\n        (\"Lst\", (0, 0)),\n        (\"GreaterEqual;\", (8805, 0)),\n        (\"mld\", (0, 0)),\n        (\"gtreql\", (0, 0)),\n        (\"thetas\", (0, 0)),\n        (\"Hopf\", (0, 0)),\n        (\"rrarr;\", (8649, 0)),\n        (\"napid\", (0, 0)),\n        (\"glj;\", (10916, 0)),\n        (\"nLeftarrow;\", (8653, 0)),\n        (\"emptyset;\", (8709, 0)),\n        (\"NotEqualTilde;\", (8770, 824)),\n        (\"angmsdad;\", (10667, 0)),\n        (\"njc\", (0, 0)),\n        (\"NotPrecedesSlantE\", (0, 0)),\n        (\"vrtri;\", (8883, 0)),\n        (\"Ws\", (0, 0)),\n        (\"prnap;\", (10937, 0)),\n        (\"nhArr;\", (8654, 0)),\n        (\"cuep\", (0, 0)),\n        (\"Cedill\", (0, 0)),\n        (\"Wopf;\", (120142, 0)),\n        (\"sigm\", (0, 0)),\n        (\"leftrightsq\", (0, 0)),\n        (\"nvlArr;\", (10498, 0)),\n        (\"jukcy;\", (1108, 0)),\n        (\"Gc\", (0, 0)),\n        (\"leftharpoondo\", (0, 0)),\n        (\"DoubleLeftA\", (0, 0)),\n        (\"Bum\", (0, 0)),\n        (\"Omicr\", (0, 0)),\n        (\"Uf\", (0, 0)),\n        (\"rdc\", (0, 0)),\n        (\"DownT\", (0, 0)),\n        (\"ropa\", (0, 0)),\n        (\"DoubleLong\", (0, 0)),\n        (\"Lmido\", (0, 0)),\n        (\"Bernoull\", (0, 0)),\n        (\"NotLeftTriangl\", (0, 0)),\n        (\"NotRightTriangleEqua\", (0, 0)),\n        (\"lparlt;\", (10643, 0)),\n        (\"HumpE\", (0, 0)),\n        (\"Becaus\", (0, 0)),\n        (\"female\", (0, 0)),\n        (\"Wed\", (0, 0)),\n        (\"LessGreater\", (0, 0)),\n        (\"LessE\", (0, 0)),\n        (\"phiv\", (0, 0)),\n        (\"LongLeftRightAr\", (0, 0)),\n        (\"\", (0, 0)),\n        (\"Gt\", (0, 0)),\n        (\"nsqsup\", (0, 0)),\n        (\"gr\", (0, 0)),\n        (\"ape\", (0, 0)),\n        (\"dagger\", (0, 0)),\n        (\"lrarr;\", (8646, 0)),\n        (\"Otimes;\", (10807, 0)),\n        (\"topbot\", (0, 0)),\n        (\"RightAngleB\", (0, 0)),\n        (\"precapprox\", (0, 0)),\n        (\"TSHcy;\", (1035, 0)),\n        (\"HorizontalLine\", (0, 0)),\n        (\"KJ\", (0, 0)),\n        (\"rightrightarr\", (0, 0)),\n        (\"rightrightarrows\", (0, 0)),\n        (\"bigcu\", (0, 0)),\n        (\"nVDa\", (0, 0)),\n        (\"RightVectorB\", (0, 0)),\n        (\"Rever\", (0, 0)),\n        (\"curvearrowle\", (0, 0)),\n        (\"vsubne\", (0, 0)),\n        (\"RightArro\", (0, 0)),\n        (\"gesle\", (0, 0)),\n        (\"Rcedi\", (0, 0)),\n        (\"gdot\", (0, 0)),\n        (\"GreaterL\", (0, 0)),\n        (\"Odblac;\", (336, 0)),\n        (\"NegativeVeryThinSpa\", (0, 0)),\n        (\"abre\", (0, 0)),\n        (\"backcong\", (0, 0)),\n        (\"Vbar\", (0, 0)),\n        (\"dotsq\", (0, 0)),\n        (\"mcomma\", (0, 0)),\n        (\"NotTil\", (0, 0)),\n        (\"NotVerticalBar\", (0, 0)),\n        (\"opar;\", (10679, 0)),\n        (\"rarrbfs\", (0, 0)),\n        (\"Lstrok\", (0, 0)),\n        (\"zfr;\", (120119, 0)),\n        (\"nrtrie;\", (8941, 0)),\n        (\"prof\", (0, 0)),\n        (\"odbl\", (0, 0)),\n        (\"UpArrowDo\", (0, 0)),\n        (\"UpEquili\", (0, 0)),\n        (\"uA\", (0, 0)),\n        (\"Mfr;\", (120080, 0)),\n        (\"lesseqq\", (0, 0)),\n        (\"Ur\", (0, 0)),\n        (\"supedot\", (0, 0)),\n        (\"mldr;\", (8230, 0)),\n        (\"succs\", (0, 0)),\n        (\"congdo\", (0, 0)),\n        (\"pr\", (0, 0)),\n        (\"LeftUpTeeVect\", (0, 0)),\n        (\"cularrp;\", (10557, 0)),\n        (\"lh\", (0, 0)),\n        (\"supplus;\", (10944, 0)),\n        (\"NotNestedGreater\", (0, 0)),\n        (\"leftrights\", (0, 0)),\n        (\"asc\", (0, 0)),\n        (\"Efr;\", (120072, 0)),\n        (\"utdot\", (0, 0)),\n        (\"omicron\", (0, 0)),\n        (\"YIcy;\", (1031, 0)),\n        (\"supsup;\", (10966, 0)),\n        (\"rfis\", (0, 0)),\n        (\"andd;\", (10844, 0)),\n        (\"nrAr\", (0, 0)),\n        (\"nwarro\", (0, 0)),\n        (\"eli\", (0, 0)),\n        (\"gacute;\", (501, 0)),\n        (\"NonBreakingSpace;\", (160, 0)),\n        (\"NotReverseEle\", (0, 0)),\n        (\"uf\", (0, 0)),\n        (\"nshortm\", (0, 0)),\n        (\"ltim\", (0, 0)),\n        (\"angr\", (0, 0)),\n        (\"uplus;\", (8846, 0)),\n        (\"part\", (0, 0)),\n        (\"RightArrowB\", (0, 0)),\n        (\"DoubleUpDownAr\", (0, 0)),\n        (\"LessL\", (0, 0)),\n        (\"Poincareplane;\", (8460, 0)),\n        (\"RightDoubleBrack\", (0, 0)),\n        (\"LeftA\", (0, 0)),\n        (\"ngeqslant;\", (10878, 824)),\n        (\"FilledSmallSq\", (0, 0)),\n        (\"uar\", (0, 0)),\n        (\"dharr\", (0, 0)),\n        (\"rf\", (0, 0)),\n        (\"MinusPlus;\", (8723, 0)),\n        (\"leftthree\", (0, 0)),\n        (\"NotGreaterSla\", (0, 0)),\n        (\"circlearrowrig\", (0, 0)),\n        (\"DoubleRig\", (0, 0)),\n        (\"cupcu\", (0, 0)),\n        (\"lparlt\", (0, 0)),\n        (\"bdq\", (0, 0)),\n        (\"Go\", (0, 0)),\n        (\"xi;\", (958, 0)),\n        (\"Lscr\", (0, 0)),\n        (\"ubreve\", (0, 0)),\n        (\"checkmar\", (0, 0)),\n        (\"LeftDoubleBra\", (0, 0)),\n        (\"NestedLes\", (0, 0)),\n        (\"rec\", (0, 0)),\n        (\"rlha\", (0, 0)),\n        (\"msc\", (0, 0)),\n        (\"CounterClockwiseCon\", (0, 0)),\n        (\"supsete\", (0, 0)),\n        (\"boxDl;\", (9558, 0)),\n        (\"hkswa\", (0, 0)),\n        (\"vDash;\", (8872, 0)),\n        (\"xca\", (0, 0)),\n        (\"DownLeftRi\", (0, 0)),\n        (\"seswa\", (0, 0)),\n        (\"mDDot\", (0, 0)),\n        (\"ubre\", (0, 0)),\n        (\"RightDownTeeVector\", (0, 0)),\n        (\"Gamma;\", (915, 0)),\n        (\"Wsc\", (0, 0)),\n        (\"Ofr\", (0, 0)),\n        (\"blacktriangledo\", (0, 0)),\n        (\"triangledo\", (0, 0)),\n        (\"lnapp\", (0, 0)),\n        (\"upuparrows;\", (8648, 0)),\n        (\"Kop\", (0, 0)),\n        (\"PrecedesTil\", (0, 0)),\n        (\"circledcirc\", (0, 0)),\n        (\"RightTriangle;\", (8883, 0)),\n        (\"copf;\", (120148, 0)),\n        (\"dar\", (0, 0)),\n        (\"sb\", (0, 0)),\n        (\"lvn\", (0, 0)),\n        (\"eqslantles\", (0, 0)),\n        (\"hkswaro\", (0, 0)),\n        (\"eDDo\", (0, 0)),\n        (\"CenterDo\", (0, 0)),\n        (\"LeftAngleB\", (0, 0)),\n        (\"in;\", (8712, 0)),\n        (\"LessEq\", (0, 0)),\n        (\"gnappro\", (0, 0)),\n        (\"LeftD\", (0, 0)),\n        (\"rad\", (0, 0)),\n        (\"Hscr;\", (8459, 0)),\n        (\"Circ\", (0, 0)),\n        (\"curlywedge\", (0, 0)),\n        (\"smalls\", (0, 0)),\n        (\"racut\", (0, 0)),\n        (\"loz\", (0, 0)),\n        (\"xhArr\", (0, 0)),\n        (\"DoubleUpDownArro\", (0, 0)),\n        (\"gtrless\", (0, 0)),\n        (\"DoubleLeftRightA\", (0, 0)),\n        (\"ZeroWi\", (0, 0)),\n        (\"Yfr;\", (120092, 0)),\n        (\"inodot\", (0, 0)),\n        (\"nshortparallel\", (0, 0)),\n        (\"curren\", (164, 0)),\n        (\"Uu\", (0, 0)),\n        (\"Lopf;\", (120131, 0)),\n        (\"Um\", (0, 0)),\n        (\"Del\", (0, 0)),\n        (\"langd;\", (10641, 0)),\n        (\"frac35;\", (8535, 0)),\n        (\"capdot\", (0, 0)),\n        (\"Dstro\", (0, 0)),\n        (\"smi\", (0, 0)),\n        (\"thetasym\", (0, 0)),\n        (\"szlig;\", (223, 0)),\n        (\"rtrif;\", (9656, 0)),\n        (\"NotLessSlan\", (0, 0)),\n        (\"ups\", (0, 0)),\n        (\"becaus\", (0, 0)),\n        (\"bbrktbrk;\", (9142, 0)),\n        (\"NegativeThickSpac\", (0, 0)),\n        (\"rarrh\", (0, 0)),\n        (\"Leftr\", (0, 0)),\n        (\"xoti\", (0, 0)),\n        (\"Union;\", (8899, 0)),\n        (\"ema\", (0, 0)),\n        (\"RightArrowBar\", (0, 0)),\n        (\"rced\", (0, 0)),\n        (\"hea\", (0, 0)),\n        (\"NotNestedLessLes\", (0, 0)),\n        (\"ltimes\", (0, 0)),\n        (\"itil\", (0, 0)),\n        (\"nsube\", (0, 0)),\n        (\"jsc\", (0, 0)),\n        (\"Cross\", (0, 0)),\n        (\"sdotb;\", (8865, 0)),\n        (\"NotDoubleVertical\", (0, 0)),\n        (\"NotVertic\", (0, 0)),\n        (\"drbkaro\", (0, 0)),\n        (\"sqsup\", (0, 0)),\n        (\"Zeta;\", (918, 0)),\n        (\"supsetneq\", (0, 0)),\n        (\"UpArrowDow\", (0, 0)),\n        (\"eqci\", (0, 0)),\n        (\"uti\", (0, 0)),\n        (\"UpTeeA\", (0, 0)),\n        (\"varpropto;\", (8733, 0)),\n        (\"NotTildeFullEqua\", (0, 0)),\n        (\"Dot\", (0, 0)),\n        (\"gver\", (0, 0)),\n        (\"cong\", (0, 0)),\n        (\"measuredangle;\", (8737, 0)),\n        (\"FilledSmal\", (0, 0)),\n        (\"zeet\", (0, 0)),\n        (\"rdquo\", (0, 0)),\n        (\"Proportion;\", (8759, 0)),\n        (\"ldquor\", (0, 0)),\n        (\"Lcaron;\", (317, 0)),\n        (\"ldsh\", (0, 0)),\n        (\"rarrfs\", (0, 0)),\n        (\"PlusMi\", (0, 0)),\n        (\"omicr\", (0, 0)),\n        (\"RoundImplies;\", (10608, 0)),\n        (\"UpDownAr\", (0, 0)),\n        (\"lrcorner\", (0, 0)),\n        (\"roplus\", (0, 0)),\n        (\"uma\", (0, 0)),\n        (\"bigod\", (0, 0)),\n        (\"gap\", (0, 0)),\n        (\"NotSup\", (0, 0)),\n        (\"LeftAn\", (0, 0)),\n        (\"Oc\", (0, 0)),\n        (\"sdotb\", (0, 0)),\n        (\"barwed\", (0, 0)),\n        (\"lnappr\", (0, 0)),\n        (\"fora\", (0, 0)),\n        (\"Kfr;\", (120078, 0)),\n        (\"rightharpoo\", (0, 0)),\n        (\"Therefor\", (0, 0)),\n        (\"au\", (0, 0)),\n        (\"daleth\", (0, 0)),\n        (\"leftrightsquigarr\", (0, 0)),\n        (\"subsetneq\", (0, 0)),\n        (\"iexcl;\", (161, 0)),\n        (\"NegativeVery\", (0, 0)),\n        (\"plusd\", (0, 0)),\n        (\"qprime;\", (8279, 0)),\n        (\"subra\", (0, 0)),\n        (\"hst\", (0, 0)),\n        (\"vr\", (0, 0)),\n        (\"parall\", (0, 0)),\n        (\"Eu\", (0, 0)),\n        (\"TSH\", (0, 0)),\n        (\"trip\", (0, 0)),\n        (\"ssmil\", (0, 0)),\n        (\"cue\", (0, 0)),\n        (\"tint\", (0, 0)),\n        (\"eqsim;\", (8770, 0)),\n        (\"Ucirc;\", (219, 0)),\n        (\"tdot\", (0, 0)),\n        (\"lnsim\", (0, 0)),\n        (\"Wopf\", (0, 0)),\n        (\"NotLeftTriangleB\", (0, 0)),\n        (\"Imagi\", (0, 0)),\n        (\"backpri\", (0, 0)),\n        (\"sube\", (0, 0)),\n        (\"bigcir\", (0, 0)),\n        (\"ngtr\", (0, 0)),\n        (\"mode\", (0, 0)),\n        (\"am\", (0, 0)),\n        (\"trisb;\", (10701, 0)),\n        (\"DoubleLongLeftAr\", (0, 0)),\n        (\"rationals\", (0, 0)),\n        (\"GreaterLe\", (0, 0)),\n        (\"capbrcup;\", (10825, 0)),\n        (\"NotLessSlantEq\", (0, 0)),\n        (\"Emp\", (0, 0)),\n        (\"InvisibleTime\", (0, 0)),\n        (\"ast;\", (42, 0)),\n        (\"therefore\", (0, 0)),\n        (\"Bac\", (0, 0)),\n        (\"LessGreater;\", (8822, 0)),\n        (\"Propor\", (0, 0)),\n        (\"Fopf;\", (120125, 0)),\n        (\"Eacute\", (201, 0)),\n        (\"rbrkslu\", (0, 0)),\n        (\"lowba\", (0, 0)),\n        (\"gg;\", (8811, 0)),\n        (\"Hac\", (0, 0)),\n        (\"ohb\", (0, 0)),\n        (\"lg\", (0, 0)),\n        (\"Longrigh\", (0, 0)),\n        (\"angmsdag\", (0, 0)),\n        (\"backsimeq\", (0, 0)),\n        (\"elinte\", (0, 0)),\n        (\"rdldhar\", (0, 0)),\n        (\"thicksim\", (0, 0)),\n        (\"udbla\", (0, 0)),\n        (\"malte\", (0, 0)),\n        (\"gbr\", (0, 0)),\n        (\"supp\", (0, 0)),\n        (\"Downa\", (0, 0)),\n        (\"NotTi\", (0, 0)),\n        (\"mo\", (0, 0)),\n        (\"ngeqslan\", (0, 0)),\n        (\"nshortparall\", (0, 0)),\n        (\"swArr\", (0, 0)),\n        (\"Ups\", (0, 0)),\n        (\"triangler\", (0, 0)),\n        (\"nRightarro\", (0, 0)),\n        (\"nu;\", (957, 0)),\n        (\"LessSla\", (0, 0)),\n        (\"cced\", (0, 0)),\n        (\"SucceedsTilde;\", (8831, 0)),\n        (\"gesdoto\", (0, 0)),\n        (\"Longlef\", (0, 0)),\n        (\"Egrave\", (200, 0)),\n        (\"ShortUpArro\", (0, 0)),\n        (\"duh\", (0, 0)),\n        (\"Therefore\", (0, 0)),\n        (\"blacktriangledown\", (0, 0)),\n        (\"nhar\", (0, 0)),\n        (\"Gsc\", (0, 0)),\n        (\"nleftrighta\", (0, 0)),\n        (\"csupe;\", (10962, 0)),\n        (\"nRig\", (0, 0)),\n        (\"ofc\", (0, 0)),\n        (\"gscr\", (0, 0)),\n        (\"set\", (0, 0)),\n        (\"RightUpVec\", (0, 0)),\n        (\"Vdashl\", (0, 0)),\n        (\"prod;\", (8719, 0)),\n        (\"Fil\", (0, 0)),\n        (\"jfr;\", (120103, 0)),\n        (\"sdote;\", (10854, 0)),\n        (\"nshortmi\", (0, 0)),\n        (\"naturals;\", (8469, 0)),\n        (\"Zo\", (0, 0)),\n        (\"rightarrowt\", (0, 0)),\n        (\"lozen\", (0, 0)),\n        (\"parsi\", (0, 0)),\n        (\"emptyv;\", (8709, 0)),\n        (\"Count\", (0, 0)),\n        (\"NotLessGreater\", (0, 0)),\n        (\"NotSquareSupersetEqua\", (0, 0)),\n        (\"angrt;\", (8735, 0)),\n        (\"epsil\", (0, 0)),\n        (\"crar\", (0, 0)),\n        (\"LeftCeilin\", (0, 0)),\n        (\"LeftArrowRight\", (0, 0)),\n        (\"Vdashl;\", (10982, 0)),\n        (\"iiota\", (0, 0)),\n        (\"LeftArrow\", (0, 0)),\n        (\"LowerRightArr\", (0, 0)),\n        (\"scirc\", (0, 0)),\n        (\"Hil\", (0, 0)),\n        (\"duar\", (0, 0)),\n        (\"Rightarrow;\", (8658, 0)),\n        (\"Mc\", (0, 0)),\n        (\"SucceedsSlantE\", (0, 0)),\n        (\"Af\", (0, 0)),\n        (\"ran\", (0, 0)),\n        (\"circlearrowr\", (0, 0)),\n        (\"natural;\", (9838, 0)),\n        (\"VerticalTilde\", (0, 0)),\n        (\"NotLessT\", (0, 0)),\n        (\"esim\", (0, 0)),\n        (\"td\", (0, 0)),\n        (\"boxminus;\", (8863, 0)),\n        (\"rightthreeti\", (0, 0)),\n        (\"tridot;\", (9708, 0)),\n        (\"gtreqle\", (0, 0)),\n        (\"LeftUpVector\", (0, 0)),\n        (\"boxvR\", (0, 0)),\n        (\"twoheadrigh\", (0, 0)),\n        (\"OverParenth\", (0, 0)),\n        (\"roarr\", (0, 0)),\n        (\"epsiv\", (0, 0)),\n        (\"There\", (0, 0)),\n        (\"rcy\", (0, 0)),\n        (\"tca\", (0, 0)),\n        (\"DoubleLongRight\", (0, 0)),\n        (\"Yacut\", (0, 0)),\n        (\"CirclePl\", (0, 0)),\n        (\"nLeftrigh\", (0, 0)),\n        (\"dscy\", (0, 0)),\n        (\"laempt\", (0, 0)),\n        (\"mnp\", (0, 0)),\n        (\"upup\", (0, 0)),\n        (\"isi\", (0, 0)),\n        (\"bbrktbr\", (0, 0)),\n        (\"NotPreced\", (0, 0)),\n        (\"NegativeThickS\", (0, 0)),\n        (\"supsetneqq\", (0, 0)),\n        (\"Lacute;\", (313, 0)),\n        (\"Euml\", (203, 0)),\n        (\"Egrave;\", (200, 0)),\n        (\"zwj\", (0, 0)),\n        (\"gnE;\", (8809, 0)),\n        (\"fcy\", (0, 0)),\n        (\"ape;\", (8778, 0)),\n        (\"demp\", (0, 0)),\n        (\"DownLeft\", (0, 0)),\n        (\"nbsp;\", (160, 0)),\n        (\"angs\", (0, 0)),\n        (\"ltri;\", (9667, 0)),\n        (\"natur\", (0, 0)),\n        (\"lessappro\", (0, 0)),\n        (\"frac5\", (0, 0)),\n        (\"FilledVerySmallSquare\", (0, 0)),\n        (\"qprime\", (0, 0)),\n        (\"aogon\", (0, 0)),\n        (\"wo\", (0, 0)),\n        (\"vArr;\", (8661, 0)),\n        (\"omicro\", (0, 0)),\n        (\"HilbertSpa\", (0, 0)),\n        (\"rightarrowtai\", (0, 0)),\n        (\"ifr\", (0, 0)),\n        (\"infintie\", (0, 0)),\n        (\"ti\", (0, 0)),\n        (\"Cscr\", (0, 0)),\n        (\"ot\", (0, 0)),\n        (\"dt\", (0, 0)),\n        (\"ecirc;\", (234, 0)),\n        (\"marker;\", (9646, 0)),\n        (\"NotPrecedesSlantEqua\", (0, 0)),\n        (\"oop\", (0, 0)),\n        (\"Or;\", (10836, 0)),\n        (\"le;\", (8804, 0)),\n        (\"puncs\", (0, 0)),\n        (\"timesbar;\", (10801, 0)),\n        (\"Cont\", (0, 0)),\n        (\"Ome\", (0, 0)),\n        (\"lvnE;\", (8808, 65024)),\n        (\"w\", (0, 0)),\n        (\"sigmav\", (0, 0)),\n        (\"colon\", (0, 0)),\n        (\"Zca\", (0, 0)),\n        (\"leftharpoondown;\", (8637, 0)),\n        (\"ic;\", (8291, 0)),\n        (\"Eca\", (0, 0)),\n        (\"Egrav\", (0, 0)),\n        (\"larrb;\", (8676, 0)),\n        (\"boxul;\", (9496, 0)),\n        (\"upuparro\", (0, 0)),\n        (\"Sopf;\", (120138, 0)),\n        (\"VerticalTil\", (0, 0)),\n        (\"eqs\", (0, 0)),\n        (\"DoubleDownArr\", (0, 0)),\n        (\"NotP\", (0, 0)),\n        (\"Fcy;\", (1060, 0)),\n        (\"bkaro\", (0, 0)),\n        (\"UnderBr\", (0, 0)),\n        (\"lt;\", (60, 0)),\n        (\"Nu;\", (925, 0)),\n        (\"ReverseElement\", (0, 0)),\n        (\"micro\", (181, 0)),\n        (\"Atild\", (0, 0)),\n        (\"exponen\", (0, 0)),\n        (\"egra\", (0, 0)),\n        (\"pluscir\", (0, 0)),\n        (\"perten\", (0, 0)),\n        (\"ShortLeftArro\", (0, 0)),\n        (\"LeftUpD\", (0, 0)),\n        (\"NotPrece\", (0, 0)),\n        (\"NotCongruent\", (0, 0)),\n        (\"NotLessTild\", (0, 0)),\n        (\"trianglelefteq\", (0, 0)),\n        (\"RightArrowLeftArrow\", (0, 0)),\n        (\"notinvb\", (0, 0)),\n        (\"DotEqu\", (0, 0)),\n        (\"NotRightTriangleEqual;\", (8941, 0)),\n        (\"Lf\", (0, 0)),\n        (\"Because;\", (8757, 0)),\n        (\"RightTeeArrow;\", (8614, 0)),\n        (\"NotLessTil\", (0, 0)),\n        (\"bumpe;\", (8783, 0)),\n        (\"ijlig;\", (307, 0)),\n        (\"Ysc\", (0, 0)),\n        (\"theref\", (0, 0)),\n        (\"supnE;\", (10956, 0)),\n        (\"DScy\", (0, 0)),\n        (\"Nop\", (0, 0)),\n        (\"Uogo\", (0, 0)),\n        (\"eqsi\", (0, 0)),\n        (\"CapitalDifferentia\", (0, 0)),\n        (\"laempty\", (0, 0)),\n        (\"Bernou\", (0, 0)),\n        (\"e\", (0, 0)),\n        (\"prE\", (0, 0)),\n        (\"zs\", (0, 0)),\n        (\"csupe\", (0, 0)),\n        (\"Ope\", (0, 0)),\n        (\"block\", (0, 0)),\n        (\"NotLeftTriangle;\", (8938, 0)),\n        (\"xopf\", (0, 0)),\n        (\"NotLessTilde;\", (8820, 0)),\n        (\"ls\", (0, 0)),\n        (\"intlarh\", (0, 0)),\n        (\"ulcrop\", (0, 0)),\n        (\"OverParenthes\", (0, 0)),\n        (\"triangled\", (0, 0)),\n        (\"Tscr\", (0, 0)),\n        (\"rightlef\", (0, 0)),\n        (\"SmallCir\", (0, 0)),\n        (\"LeftArrowRigh\", (0, 0)),\n        (\"sqca\", (0, 0)),\n        (\"cirsc\", (0, 0)),\n        (\"NotNes\", (0, 0)),\n        (\"odblac\", (0, 0)),\n        (\"the\", (0, 0)),\n        (\"boxbox;\", (10697, 0)),\n        (\"LeftAngleBracke\", (0, 0)),\n        (\"Col\", (0, 0)),\n        (\"Yscr;\", (119988, 0)),\n        (\"Ra\", (0, 0)),\n        (\"dzi\", (0, 0)),\n        (\"Bfr\", (0, 0)),\n        (\"nltri;\", (8938, 0)),\n        (\"Igr\", (0, 0)),\n        (\"TildeF\", (0, 0)),\n        (\"Squar\", (0, 0)),\n        (\"Sacut\", (0, 0)),\n        (\"divi\", (0, 0)),\n        (\"Capita\", (0, 0)),\n        (\"wscr;\", (120012, 0)),\n        (\"Wf\", (0, 0)),\n        (\"NotLessSlantEqua\", (0, 0)),\n        (\"dbl\", (0, 0)),\n        (\"rcei\", (0, 0)),\n        (\"rightleftarrow\", (0, 0)),\n        (\"gtrdot\", (0, 0)),\n        (\"gtquest\", (0, 0)),\n        (\"lstr\", (0, 0)),\n        (\"VerticalT\", (0, 0)),\n        (\"rhard\", (0, 0)),\n        (\"NotLessLess;\", (8810, 824)),\n        (\"cac\", (0, 0)),\n        (\"nfr;\", (120107, 0)),\n        (\"caron;\", (711, 0)),\n        (\"maltes\", (0, 0)),\n        (\"NewLi\", (0, 0)),\n        (\"rlhar;\", (8652, 0)),\n        (\"uparrow;\", (8593, 0)),\n        (\"CounterClockwiseContourIntegral\", (0, 0)),\n        (\"Apply\", (0, 0)),\n        (\"ncong;\", (8775, 0)),\n        (\"topbo\", (0, 0)),\n        (\"V\", (0, 0)),\n        (\"dtri\", (0, 0)),\n        (\"ubrev\", (0, 0)),\n        (\"ff\", (0, 0)),\n        (\"LeftDow\", (0, 0)),\n        (\"lfisht\", (0, 0)),\n        (\"emptyv\", (0, 0)),\n        (\"DiacriticalAcut\", (0, 0)),\n        (\"nrightarr\", (0, 0)),\n        (\"upharp\", (0, 0)),\n        (\"Ci\", (0, 0)),\n        (\"uc\", (0, 0)),\n        (\"awint;\", (10769, 0)),\n        (\"ci\", (0, 0)),\n        (\"scap;\", (10936, 0)),\n        (\"ope\", (0, 0)),\n        (\"oplu\", (0, 0)),\n        (\"Neg\", (0, 0)),\n        (\"LowerRightArro\", (0, 0)),\n        (\"SupersetE\", (0, 0)),\n        (\"Yopf;\", (120144, 0)),\n        (\"multi\", (0, 0)),\n        (\"Equilibrium\", (0, 0)),\n        (\"Less\", (0, 0)),\n        (\"NegativeThickSpa\", (0, 0)),\n        (\"sl\", (0, 0)),\n        (\"nshortmid;\", (8740, 0)),\n        (\"OverBar\", (0, 0)),\n        (\"NestedGreate\", (0, 0)),\n        (\"Ka\", (0, 0)),\n        (\"Oacute\", (211, 0)),\n        (\"prE;\", (10931, 0)),\n        (\"ReverseUpEquilibrium;\", (10607, 0)),\n        (\"Updownar\", (0, 0)),\n        (\"simplus;\", (10788, 0)),\n        (\"boxti\", (0, 0)),\n        (\"vsupn\", (0, 0)),\n        (\"FilledVerySmall\", (0, 0)),\n        (\"ol\", (0, 0)),\n        (\"marker\", (0, 0)),\n        (\"df\", (0, 0)),\n        (\"aelig;\", (230, 0)),\n        (\"longrightar\", (0, 0)),\n        (\"upsil\", (0, 0)),\n        (\"squarf\", (0, 0)),\n        (\"nVdash;\", (8878, 0)),\n        (\"do\", (0, 0)),\n        (\"Up\", (0, 0)),\n        (\"daleth;\", (8504, 0)),\n        (\"capd\", (0, 0)),\n        (\"isinv;\", (8712, 0)),\n        (\"NotNestedGreaterGreater;\", (10914, 824)),\n        (\"Tri\", (0, 0)),\n        (\"E\", (0, 0)),\n        (\"nLeftrightar\", (0, 0)),\n        (\"Medi\", (0, 0)),\n        (\"LessEqualGre\", (0, 0)),\n        (\"Rightarro\", (0, 0)),\n        (\"boxV;\", (9553, 0)),\n        (\"gvertneqq\", (0, 0)),\n        (\"ast\", (0, 0)),\n        (\"NotRight\", (0, 0)),\n        (\"asy\", (0, 0)),\n        (\"profal\", (0, 0)),\n        (\"go\", (0, 0)),\n        (\"Copf;\", (8450, 0)),\n        (\"nrighta\", (0, 0)),\n        (\"RightUpDo\", (0, 0)),\n        (\"notnivc;\", (8957, 0)),\n        (\"thic\", (0, 0)),\n        (\"Not\", (0, 0)),\n        (\"wedgeq\", (0, 0)),\n        (\"orderof\", (0, 0)),\n        (\"scnsim\", (0, 0)),\n        (\"Laplacetrf;\", (8466, 0)),\n        (\"subne;\", (8842, 0)),\n        (\"ffli\", (0, 0)),\n        (\"SquareInter\", (0, 0)),\n        (\"Vvd\", (0, 0)),\n        (\"lds\", (0, 0)),\n        (\"rarrc\", (0, 0)),\n        (\"NotLeftTriangleBa\", (0, 0)),\n        (\"Ber\", (0, 0)),\n        (\"Op\", (0, 0)),\n        (\"KH\", (0, 0)),\n        (\"lAt\", (0, 0)),\n        (\"therefor\", (0, 0)),\n        (\"eci\", (0, 0)),\n        (\"llhar\", (0, 0)),\n        (\"phm\", (0, 0)),\n        (\"gesdot;\", (10880, 0)),\n        (\"xni\", (0, 0)),\n        (\"nrigh\", (0, 0)),\n        (\"varsup\", (0, 0)),\n        (\"LessFullEqua\", (0, 0)),\n        (\"ReverseUpEquilibriu\", (0, 0)),\n        (\"boxhD\", (0, 0)),\n        (\"plus;\", (43, 0)),\n        (\"lowbar\", (0, 0)),\n        (\"Omega;\", (937, 0)),\n        (\"notindot\", (0, 0)),\n        (\"lat;\", (10923, 0)),\n        (\"leftrightsquigarro\", (0, 0)),\n        (\"Mopf\", (0, 0)),\n        (\"odso\", (0, 0)),\n        (\"srarr\", (0, 0)),\n        (\"ssmile\", (0, 0)),\n        (\"lrarr\", (0, 0)),\n        (\"emsp1\", (0, 0)),\n        (\"rr\", (0, 0)),\n        (\"measured\", (0, 0)),\n        (\"hoo\", (0, 0)),\n        (\"GreaterSlantEqual\", (0, 0)),\n        (\"ngeqslant\", (0, 0)),\n        (\"ndash;\", (8211, 0)),\n        (\"lns\", (0, 0)),\n        (\"shy\", (173, 0)),\n        (\"triminu\", (0, 0)),\n        (\"Oum\", (0, 0)),\n        (\"updownarr\", (0, 0)),\n        (\"lrt\", (0, 0)),\n        (\"ocir;\", (8858, 0)),\n        (\"DoubleVe\", (0, 0)),\n        (\"Gcedil;\", (290, 0)),\n        (\"nleft\", (0, 0)),\n        (\"gesc\", (0, 0)),\n        (\"bigwe\", (0, 0)),\n        (\"twoheadr\", (0, 0)),\n        (\"drbka\", (0, 0)),\n        (\"GreaterLess;\", (8823, 0)),\n        (\"NotDou\", (0, 0)),\n        (\"comp;\", (8705, 0)),\n        (\"Tcy\", (0, 0)),\n        (\"geq\", (0, 0)),\n        (\"Cconi\", (0, 0)),\n        (\"nsupse\", (0, 0)),\n        (\"LeftDownVectorBar\", (0, 0)),\n        (\"RightUpV\", (0, 0)),\n        (\"Eogon\", (0, 0)),\n        (\"suplarr\", (0, 0)),\n        (\"LeftRightArrow;\", (8596, 0)),\n        (\"topf;\", (120165, 0)),\n        (\"Zero\", (0, 0)),\n        (\"uharr;\", (8638, 0)),\n        (\"rar\", (0, 0)),\n        (\"longleftarr\", (0, 0)),\n        (\"OpenCurlyDoubleQuot\", (0, 0)),\n        (\"lmou\", (0, 0)),\n        (\"nleqslant;\", (10877, 824)),\n        (\"Vertical\", (0, 0)),\n        (\"boxdL\", (0, 0)),\n        (\"yopf\", (0, 0)),\n        (\"Congru\", (0, 0)),\n        (\"gesdot\", (0, 0)),\n        (\"boxDr;\", (9555, 0)),\n        (\"NotSqu\", (0, 0)),\n        (\"ntrianglerig\", (0, 0)),\n        (\"CloseCurlyDoubleQ\", (0, 0)),\n        (\"RightArrow\", (0, 0)),\n        (\"xut\", (0, 0)),\n        (\"ltla\", (0, 0)),\n        (\"Jc\", (0, 0)),\n        (\"zo\", (0, 0)),\n        (\"Racut\", (0, 0)),\n        (\"Jcy\", (0, 0)),\n        (\"EmptySm\", (0, 0)),\n        (\"eDot;\", (8785, 0)),\n        (\"trpezium;\", (9186, 0)),\n        (\"rdld\", (0, 0)),\n        (\"VerticalSeparato\", (0, 0)),\n        (\"ka\", (0, 0)),\n        (\"Sigma\", (0, 0)),\n        (\"RightTeeVector;\", (10587, 0)),\n        (\"xwed\", (0, 0)),\n        (\"DoubleUpDownArrow\", (0, 0)),\n        (\"CirclePlus;\", (8853, 0)),\n        (\"xopl\", (0, 0)),\n        (\"RightAng\", (0, 0)),\n        (\"bumpe\", (0, 0)),\n        (\"Chi;\", (935, 0)),\n        (\"rfish\", (0, 0)),\n        (\"nwarhk\", (0, 0)),\n        (\"fjli\", (0, 0)),\n        (\"rarrw;\", (8605, 0)),\n        (\"supseteqq\", (0, 0)),\n        (\"bsemi\", (0, 0)),\n        (\"DoubleRightArrow\", (0, 0)),\n        (\"robrk;\", (10215, 0)),\n        (\"cscr;\", (119992, 0)),\n        (\"boxvH\", (0, 0)),\n        (\"egrav\", (0, 0)),\n        (\"Yacu\", (0, 0)),\n        (\"roar\", (0, 0)),\n        (\"OpenCurlyQuote;\", (8216, 0)),\n        (\"Yop\", (0, 0)),\n        (\"subE\", (0, 0)),\n        (\"LeftRightVe\", (0, 0)),\n        (\"loo\", (0, 0)),\n        (\"rarrc;\", (10547, 0)),\n        (\"cupd\", (0, 0)),\n        (\"upu\", (0, 0)),\n        (\"xupl\", (0, 0)),\n        (\"rightthreetimes\", (0, 0)),\n        (\"KJcy;\", (1036, 0)),\n        (\"GreaterEqu\", (0, 0)),\n        (\"Med\", (0, 0)),\n        (\"NotSucc\", (0, 0)),\n        (\"bka\", (0, 0)),\n        (\"nrtri\", (0, 0)),\n        (\"qp\", (0, 0)),\n        (\"HilbertSpac\", (0, 0)),\n        (\"vp\", (0, 0)),\n        (\"cupo\", (0, 0)),\n        (\"Ufr;\", (120088, 0)),\n        (\"sub\", (0, 0)),\n        (\"rdldhar;\", (10601, 0)),\n        (\"otilde;\", (245, 0)),\n        (\"maltese\", (0, 0)),\n        (\"Scaron\", (0, 0)),\n        (\"Zacu\", (0, 0)),\n        (\"rbarr\", (0, 0)),\n        (\"bprim\", (0, 0)),\n        (\"loplus;\", (10797, 0)),\n        (\"tbrk\", (0, 0)),\n        (\"epsilon;\", (949, 0)),\n        (\"uml;\", (168, 0)),\n        (\"nparsl;\", (11005, 8421)),\n        (\"Nce\", (0, 0)),\n        (\"UpEquilibri\", (0, 0)),\n        (\"CounterCloc\", (0, 0)),\n        (\"leqq;\", (8806, 0)),\n        (\"SucceedsSlantEqu\", (0, 0)),\n        (\"sced\", (0, 0)),\n        (\"dotplus;\", (8724, 0)),\n        (\"REG\", (174, 0)),\n        (\"Omacr\", (0, 0)),\n        (\"trpeziu\", (0, 0)),\n        (\"LeftTee;\", (8867, 0)),\n        (\"UnderParent\", (0, 0)),\n        (\"UpperLeftArrow;\", (8598, 0)),\n        (\"DownArrowUpArrow;\", (8693, 0)),\n        (\"eD\", (0, 0)),\n        (\"lagra\", (0, 0)),\n        (\"spa\", (0, 0)),\n        (\"sscr;\", (120008, 0)),\n        (\"ETH;\", (208, 0)),\n        (\"rbarr;\", (10509, 0)),\n        (\"phiv;\", (981, 0)),\n        (\"Cedilla\", (0, 0)),\n        (\"andslope;\", (10840, 0)),\n        (\"slarr\", (0, 0)),\n        (\"angzarr;\", (9084, 0)),\n        (\"varthe\", (0, 0)),\n        (\"preccurly\", (0, 0)),\n        (\"triangledown\", (0, 0)),\n        (\"Sta\", (0, 0)),\n        (\"leftrightarrow\", (0, 0)),\n        (\"therefo\", (0, 0)),\n        (\"imagline\", (0, 0)),\n        (\"Udblac;\", (368, 0)),\n        (\"elint\", (0, 0)),\n        (\"uhb\", (0, 0)),\n        (\"NotSucceedsSlan\", (0, 0)),\n        (\"larrfs;\", (10525, 0)),\n        (\"Ze\", (0, 0)),\n        (\"varprop\", (0, 0)),\n        (\"varphi\", (0, 0)),\n        (\"lcaro\", (0, 0)),\n        (\"bre\", (0, 0)),\n        (\"dharr;\", (8642, 0)),\n        (\"Inters\", (0, 0)),\n        (\"ffllig;\", (64260, 0)),\n        (\"int\", (0, 0)),\n        (\"Implies\", (0, 0)),\n        (\"iecy\", (0, 0)),\n        (\"NotNestedGreaterGreater\", (0, 0)),\n        (\"csube;\", (10961, 0)),\n        (\"DDotrah\", (0, 0)),\n        (\"blacktriangleright\", (0, 0)),\n        (\"rsquo\", (0, 0)),\n        (\"Qscr;\", (119980, 0)),\n        (\"RightFloor;\", (8971, 0)),\n        (\"NotCupCap\", (0, 0)),\n        (\"bs\", (0, 0)),\n        (\"FilledVe\", (0, 0)),\n        (\"straig\", (0, 0)),\n        (\"ecaro\", (0, 0)),\n        (\"NotT\", (0, 0)),\n        (\"langle\", (0, 0)),\n        (\"Ga\", (0, 0)),\n        (\"kf\", (0, 0)),\n        (\"Wcirc\", (0, 0)),\n        (\"boxvL;\", (9569, 0)),\n        (\"qin\", (0, 0)),\n        (\"hercon\", (0, 0)),\n        (\"NotLessGre\", (0, 0)),\n        (\"LeftR\", (0, 0)),\n        (\"VerticalSepar\", (0, 0)),\n        (\"NegativeThinSp\", (0, 0)),\n        (\"Greate\", (0, 0)),\n        (\"jcirc;\", (309, 0)),\n        (\"ldquo\", (0, 0)),\n        (\"uphar\", (0, 0)),\n        (\"lambda\", (0, 0)),\n        (\"neArr\", (0, 0)),\n        (\"lbarr;\", (10508, 0)),\n        (\"downharpoonright\", (0, 0)),\n        (\"Lcaro\", (0, 0)),\n        (\"SquareUn\", (0, 0)),\n        (\"lp\", (0, 0)),\n        (\"varsupset\", (0, 0)),\n        (\"fr\", (0, 0)),\n        (\"ncong\", (0, 0)),\n        (\"Dcy;\", (1044, 0)),\n        (\"DownA\", (0, 0)),\n        (\"DiacriticalTilde\", (0, 0)),\n        (\"ReverseEquil\", (0, 0)),\n        (\"NotSucceedsSlantEqual;\", (8929, 0)),\n        (\"eqcolo\", (0, 0)),\n        (\"DoubleContourIntegr\", (0, 0)),\n        (\"HumpD\", (0, 0)),\n        (\"questeq\", (0, 0)),\n        (\"cem\", (0, 0)),\n        (\"Dashv\", (0, 0)),\n        (\"parallel\", (0, 0)),\n        (\"rightleftharpoon\", (0, 0)),\n        (\"ClockwiseConto\", (0, 0)),\n        (\"NotPrecedesEqu\", (0, 0)),\n        (\"DownLeftTee\", (0, 0)),\n        (\"OverBrack\", (0, 0)),\n        (\"NotEleme\", (0, 0)),\n        (\"nf\", (0, 0)),\n        (\"Hu\", (0, 0)),\n        (\"intc\", (0, 0)),\n        (\"Jser\", (0, 0)),\n        (\"circledS;\", (9416, 0)),\n        (\"Gamm\", (0, 0)),\n        (\"iqu\", (0, 0)),\n        (\"Oacu\", (0, 0)),\n        (\"divonx;\", (8903, 0)),\n        (\"lessapprox;\", (10885, 0)),\n        (\"orar\", (0, 0)),\n        (\"TildeFull\", (0, 0)),\n        (\"ShortLeftArrow;\", (8592, 0)),\n        (\"ie\", (0, 0)),\n        (\"NotRig\", (0, 0)),\n        (\"Pscr;\", (119979, 0)),\n        (\"oso\", (0, 0)),\n        (\"alef\", (0, 0)),\n        (\"pou\", (0, 0)),\n        (\"NotRightTriangle;\", (8939, 0)),\n        (\"prnap\", (0, 0)),\n        (\"da\", (0, 0)),\n        (\"RightArrowLeftA\", (0, 0)),\n        (\"utild\", (0, 0)),\n        (\"ReverseEl\", (0, 0)),\n        (\"scE\", (0, 0)),\n        (\"duhar\", (0, 0)),\n        (\"Ycir\", (0, 0)),\n        (\"NotSquareSubsetEqua\", (0, 0)),\n        (\"LongLeftRightArr\", (0, 0)),\n        (\"ShortD\", (0, 0)),\n        (\"male;\", (9794, 0)),\n        (\"sta\", (0, 0)),\n        (\"lharul;\", (10602, 0)),\n        (\"dscr;\", (119993, 0)),\n        (\"VerticalLine;\", (124, 0)),\n        (\"RightDouble\", (0, 0)),\n        (\"NotRightTriangleE\", (0, 0)),\n        (\"Close\", (0, 0)),\n        (\"perio\", (0, 0)),\n        (\"subsub\", (0, 0)),\n        (\"iu\", (0, 0)),\n        (\"gtreqqles\", (0, 0)),\n        (\"Leftrighta\", (0, 0)),\n        (\"caret;\", (8257, 0)),\n        (\"smallsetm\", (0, 0)),\n        (\"coprod\", (0, 0)),\n        (\"ipr\", (0, 0)),\n        (\"ta\", (0, 0)),\n        (\"Hcirc;\", (292, 0)),\n        (\"rfr\", (0, 0)),\n        (\"downharpoo\", (0, 0)),\n        (\"Uc\", (0, 0)),\n        (\"NotSupers\", (0, 0)),\n        (\"xfr\", (0, 0)),\n        (\"xfr;\", (120117, 0)),\n        (\"downharpoonrig\", (0, 0)),\n        (\"tced\", (0, 0)),\n        (\"barwed;\", (8965, 0)),\n        (\"lfis\", (0, 0)),\n        (\"comple\", (0, 0)),\n        (\"CounterClockwiseContourIn\", (0, 0)),\n        (\"gsiml\", (0, 0)),\n        (\"scpolint\", (0, 0)),\n        (\"NotGreaterSlantEqua\", (0, 0)),\n        (\"OpenCurlyDou\", (0, 0)),\n        (\"Nti\", (0, 0)),\n        (\"lstrok\", (0, 0)),\n        (\"NotTildeEqual;\", (8772, 0)),\n        (\"rightleftarro\", (0, 0)),\n        (\"plussim\", (0, 0)),\n        (\"subsi\", (0, 0)),\n        (\"SupersetEq\", (0, 0)),\n        (\"egrave;\", (232, 0)),\n        (\"risingdots\", (0, 0)),\n        (\"DifferentialD;\", (8518, 0)),\n        (\"omin\", (0, 0)),\n        (\"righ\", (0, 0)),\n        (\"succne\", (0, 0)),\n        (\"DoubleR\", (0, 0)),\n        (\"ratio;\", (8758, 0)),\n        (\"sca\", (0, 0)),\n        (\"NotLessEqu\", (0, 0)),\n        (\"NestedLessLes\", (0, 0)),\n        (\"LeftRightVector;\", (10574, 0)),\n        (\"ldq\", (0, 0)),\n        (\"gsime\", (0, 0)),\n        (\"f\", (0, 0)),\n        (\"zca\", (0, 0)),\n        (\"downdown\", (0, 0)),\n        (\"DownLeftV\", (0, 0)),\n        (\"supne\", (0, 0)),\n        (\"ni;\", (8715, 0)),\n        (\"Jukc\", (0, 0)),\n        (\"Acirc;\", (194, 0)),\n        (\"bnequ\", (0, 0)),\n        (\"LeftTriangleEqua\", (0, 0)),\n        (\"LongR\", (0, 0)),\n        (\"Racute\", (0, 0)),\n        (\"triplus;\", (10809, 0)),\n        (\"NonBreakingSpa\", (0, 0)),\n        (\"sq\", (0, 0)),\n        (\"triangleri\", (0, 0)),\n        (\"nis\", (0, 0)),\n        (\"Doubl\", (0, 0)),\n        (\"nsqsub\", (0, 0)),\n        (\"longle\", (0, 0)),\n        (\"nlsim;\", (8820, 0)),\n        (\"cfr\", (0, 0)),\n        (\"AElig;\", (198, 0)),\n        (\"LeftVectorBar;\", (10578, 0)),\n        (\"tprime;\", (8244, 0)),\n        (\"nmid\", (0, 0)),\n        (\"LeftFl\", (0, 0)),\n        (\"NotGreaterEqual\", (0, 0)),\n        (\"DownTe\", (0, 0)),\n        (\"Ubr\", (0, 0)),\n        (\"ascr\", (0, 0)),\n        (\"esdot\", (0, 0)),\n        (\"ropar;\", (10630, 0)),\n        (\"LowerRightArrow;\", (8600, 0)),\n        (\"sube;\", (8838, 0)),\n        (\"mumap\", (0, 0)),\n        (\"nca\", (0, 0)),\n        (\"ShortUpA\", (0, 0)),\n        (\"RightUpTeeVecto\", (0, 0)),\n        (\"dow\", (0, 0)),\n        (\"vartria\", (0, 0)),\n        (\"NotDoubleVerticalB\", (0, 0)),\n        (\"LeftDo\", (0, 0)),\n        (\"xn\", (0, 0)),\n        (\"ws\", (0, 0)),\n        (\"yi\", (0, 0)),\n        (\"luruh\", (0, 0)),\n        (\"heartsuit;\", (9829, 0)),\n        (\"olt\", (0, 0)),\n        (\"NestedLessL\", (0, 0)),\n        (\"NotReverseE\", (0, 0)),\n        (\"REG;\", (174, 0)),\n        (\"sqs\", (0, 0)),\n        (\"geqslan\", (0, 0)),\n        (\"precnapp\", (0, 0)),\n        (\"FilledVery\", (0, 0)),\n        (\"bigot\", (0, 0)),\n        (\"rAt\", (0, 0)),\n        (\"leftrighthar\", (0, 0)),\n        (\"gesdoto;\", (10882, 0)),\n        (\"LeftUpVectorB\", (0, 0)),\n        (\"Pscr\", (0, 0)),\n        (\"umacr\", (0, 0)),\n        (\"rati\", (0, 0)),\n        (\"Pfr\", (0, 0)),\n        (\"capand;\", (10820, 0)),\n        (\"thicks\", (0, 0)),\n        (\"varka\", (0, 0)),\n        (\"Mf\", (0, 0)),\n        (\"subplu\", (0, 0)),\n        (\"gtreqql\", (0, 0)),\n        (\"dd\", (0, 0)),\n        (\"complexes\", (0, 0)),\n        (\"ubr\", (0, 0)),\n        (\"xrarr\", (0, 0)),\n        (\"phmmat;\", (8499, 0)),\n        (\"UpArrowBar\", (0, 0)),\n        (\"subsetneqq\", (0, 0)),\n        (\"nparsl\", (0, 0)),\n        (\"raquo;\", (187, 0)),\n        (\"Uarr;\", (8607, 0)),\n        (\"homth\", (0, 0)),\n        (\"uuarr\", (0, 0)),\n        (\"Supset\", (0, 0)),\n        (\"triangleq;\", (8796, 0)),\n        (\"tscr\", (0, 0)),\n        (\"DownBr\", (0, 0)),\n        (\"LessGre\", (0, 0)),\n        (\"NotDo\", (0, 0)),\n        (\"OpenCurlyDoubleQuo\", (0, 0)),\n        (\"Fcy\", (0, 0)),\n        (\"eparsl\", (0, 0)),\n        (\"Escr;\", (8496, 0)),\n        (\"bottom;\", (8869, 0)),\n        (\"Fsc\", (0, 0)),\n        (\"curlyw\", (0, 0)),\n        (\"ShortU\", (0, 0)),\n        (\"NestedL\", (0, 0)),\n        (\"hookrigh\", (0, 0)),\n        (\"sdot;\", (8901, 0)),\n        (\"gtrdo\", (0, 0)),\n        (\"DoubleLeftTe\", (0, 0)),\n        (\"iacute;\", (237, 0)),\n        (\"leftright\", (0, 0)),\n        (\"NotPrecedesSlan\", (0, 0)),\n        (\"Omega\", (0, 0)),\n        (\"ovba\", (0, 0)),\n        (\"sstar\", (0, 0)),\n        (\"ohm;\", (937, 0)),\n        (\"Lambda\", (0, 0)),\n        (\"nleq\", (0, 0)),\n        (\"ges\", (0, 0)),\n        (\"LeftAngleBrack\", (0, 0)),\n        (\"gsim\", (0, 0)),\n        (\"NotTilde\", (0, 0)),\n        (\"nvDash;\", (8877, 0)),\n        (\"CounterClockwiseC\", (0, 0)),\n        (\"lne;\", (10887, 0)),\n        (\"NotCongruen\", (0, 0)),\n        (\"twoheadrightarro\", (0, 0)),\n        (\"re\", (0, 0)),\n        (\"curv\", (0, 0)),\n        (\"reals\", (0, 0)),\n        (\"epsi;\", (949, 0)),\n        (\"Dopf\", (0, 0)),\n        (\"mu\", (0, 0)),\n        (\"NotSquareSubse\", (0, 0)),\n        (\"boxmin\", (0, 0)),\n        (\"succeq;\", (10928, 0)),\n        (\"rcaron\", (0, 0)),\n        (\"longright\", (0, 0)),\n        (\"tdot;\", (8411, 0)),\n        (\"be\", (0, 0)),\n        (\"cupcup;\", (10826, 0)),\n        (\"pitch\", (0, 0)),\n        (\"jse\", (0, 0)),\n        (\"backep\", (0, 0)),\n        (\"yacu\", (0, 0)),\n        (\"gjcy\", (0, 0)),\n        (\"sqsubset;\", (8847, 0)),\n        (\"risingdot\", (0, 0)),\n        (\"NestedGrea\", (0, 0)),\n        (\"mnpl\", (0, 0)),\n        (\"LeftUpTeeVe\", (0, 0)),\n        (\"ands\", (0, 0)),\n        (\"topci\", (0, 0)),\n        (\"nrarrc\", (0, 0)),\n        (\"propto;\", (8733, 0)),\n        (\"curlyeqprec\", (0, 0)),\n        (\"ll;\", (8810, 0)),\n        (\"xodot\", (0, 0)),\n        (\"maltese;\", (10016, 0)),\n        (\"diamond;\", (8900, 0)),\n        (\"nRightar\", (0, 0)),\n        (\"C\", (0, 0)),\n        (\"xm\", (0, 0)),\n        (\"uuml\", (252, 0)),\n        (\"risi\", (0, 0)),\n        (\"Da\", (0, 0)),\n        (\"gnapp\", (0, 0)),\n        (\"npar\", (0, 0)),\n        (\"NotElement;\", (8713, 0)),\n        (\"IEcy;\", (1045, 0)),\n        (\"curvearr\", (0, 0)),\n        (\"FilledVeryS\", (0, 0)),\n        (\"hard\", (0, 0)),\n        (\"diam\", (0, 0)),\n        (\"Yum\", (0, 0)),\n        (\"Tcaron;\", (356, 0)),\n        (\"Igrav\", (0, 0)),\n        (\"nexis\", (0, 0)),\n        (\"NegativeMediu\", (0, 0)),\n        (\"otimes\", (0, 0)),\n        (\"wop\", (0, 0)),\n        (\"trianglel\", (0, 0)),\n        (\"bscr;\", (119991, 0)),\n        (\"oline;\", (8254, 0)),\n        (\"Coprodu\", (0, 0)),\n        (\"plusaci\", (0, 0)),\n        (\"lrar\", (0, 0)),\n        (\"Center\", (0, 0)),\n        (\"fno\", (0, 0)),\n        (\"nsh\", (0, 0)),\n        (\"Ouml;\", (214, 0)),\n        (\"nced\", (0, 0)),\n        (\"NotSuper\", (0, 0)),\n        (\"cd\", (0, 0)),\n        (\"longrightarr\", (0, 0)),\n        (\"supdsu\", (0, 0)),\n        (\"nvlt;\", (60, 8402)),\n        (\"Eacu\", (0, 0)),\n        (\"expect\", (0, 0)),\n        (\"Am\", (0, 0)),\n        (\"InvisibleTim\", (0, 0)),\n        (\"midcir\", (0, 0)),\n        (\"setminu\", (0, 0)),\n        (\"larrpl\", (0, 0)),\n        (\"larrpl;\", (10553, 0)),\n        (\"roang\", (0, 0)),\n        (\"App\", (0, 0)),\n        (\"NotGreaterTil\", (0, 0)),\n        (\"rbrks\", (0, 0)),\n        (\"VeryThinSpa\", (0, 0)),\n        (\"lthre\", (0, 0)),\n        (\"rla\", (0, 0)),\n        (\"lsaqu\", (0, 0)),\n        (\"NotGreaterSl\", (0, 0)),\n        (\"angmsdaa;\", (10664, 0)),\n        (\"NotSquar\", (0, 0)),\n        (\"LeftAr\", (0, 0)),\n        (\"us\", (0, 0)),\n        (\"ecar\", (0, 0)),\n        (\"Diffe\", (0, 0)),\n        (\"gneq;\", (10888, 0)),\n        (\"esd\", (0, 0)),\n        (\"DoubleUpDow\", (0, 0)),\n        (\"varphi;\", (981, 0)),\n        (\"ntgl\", (0, 0)),\n        (\"Imac\", (0, 0)),\n        (\"til\", (0, 0)),\n        (\"frasl;\", (8260, 0)),\n        (\"caps;\", (8745, 65024)),\n        (\"Uacu\", (0, 0)),\n        (\"models;\", (8871, 0)),\n        (\"RoundIm\", (0, 0)),\n        (\"Otil\", (0, 0)),\n        (\"Barv;\", (10983, 0)),\n        (\"lBarr;\", (10510, 0)),\n        (\"Rightar\", (0, 0)),\n        (\"clubsuit;\", (9827, 0)),\n        (\"minusd;\", (8760, 0)),\n        (\"rmousta\", (0, 0)),\n        (\"bsime;\", (8909, 0)),\n        (\"TildeTilde;\", (8776, 0)),\n        (\"acut\", (0, 0)),\n        (\"NotGreaterEqual;\", (8817, 0)),\n        (\"gcir\", (0, 0)),\n        (\"subedot;\", (10947, 0)),\n        (\"Epsi\", (0, 0)),\n        (\"rightarrowtail;\", (8611, 0)),\n        (\"quatin\", (0, 0)),\n        (\"boxDl\", (0, 0)),\n        (\"hookri\", (0, 0)),\n        (\"circledci\", (0, 0)),\n        (\"HumpDownHum\", (0, 0)),\n        (\"nvle;\", (8804, 8402)),\n        (\"longleftrighta\", (0, 0)),\n        (\"measuredangl\", (0, 0)),\n        (\"dA\", (0, 0)),\n        (\"circledS\", (0, 0)),\n        (\"iecy;\", (1077, 0)),\n        (\"qint\", (0, 0)),\n        (\"SmallCi\", (0, 0)),\n        (\"rcy;\", (1088, 0)),\n        (\"period\", (0, 0)),\n        (\"Ug\", (0, 0)),\n        (\"measur\", (0, 0)),\n        (\"umacr;\", (363, 0)),\n        (\"is\", (0, 0)),\n        (\"backsi\", (0, 0)),\n        (\"SmallC\", (0, 0)),\n        (\"auml\", (228, 0)),\n        (\"bigoplus;\", (10753, 0)),\n        (\"drcorn\", (0, 0)),\n        (\"ShortUpArrow;\", (8593, 0)),\n        (\"rppolin\", (0, 0)),\n        (\"Counte\", (0, 0)),\n        (\"DownRightTe\", (0, 0)),\n        (\"eplu\", (0, 0)),\n        (\"boxVh\", (0, 0)),\n        (\"vBar\", (0, 0)),\n        (\"perp;\", (8869, 0)),\n        (\"Lcedil\", (0, 0)),\n        (\"downharpoonri\", (0, 0)),\n        (\"rdqu\", (0, 0)),\n        (\"ContourInteg\", (0, 0)),\n        (\"ecirc\", (234, 0)),\n        (\"dotsqu\", (0, 0)),\n        (\"mstpos\", (0, 0)),\n        (\"CloseCurlyDouble\", (0, 0)),\n        (\"Delta\", (0, 0)),\n        (\"llc\", (0, 0)),\n        (\"NotSquareSubsetEqual\", (0, 0)),\n        (\"Umacr\", (0, 0)),\n        (\"LeftDownVectorB\", (0, 0)),\n        (\"Ncedil\", (0, 0)),\n        (\"trimi\", (0, 0)),\n        (\"andsl\", (0, 0)),\n        (\"rAarr;\", (8667, 0)),\n        (\"seA\", (0, 0)),\n        (\"Small\", (0, 0)),\n        (\"Vcy\", (0, 0)),\n        (\"coloneq;\", (8788, 0)),\n        (\"Verbar\", (0, 0)),\n        (\"rdca\", (0, 0)),\n        (\"SmallCircle\", (0, 0)),\n        (\"ye\", (0, 0)),\n        (\"bl\", (0, 0)),\n        (\"pho\", (0, 0)),\n        (\"amacr;\", (257, 0)),\n        (\"MinusPlus\", (0, 0)),\n        (\"lbrace\", (0, 0)),\n        (\"Sub;\", (8912, 0)),\n        (\"nlArr\", (0, 0)),\n        (\"zigr\", (0, 0)),\n        (\"Lap\", (0, 0)),\n        (\"Poinc\", (0, 0)),\n        (\"longr\", (0, 0)),\n        (\"DiacriticalDou\", (0, 0)),\n        (\"Bf\", (0, 0)),\n        (\"ltrif;\", (9666, 0)),\n        (\"varthet\", (0, 0)),\n        (\"thin\", (0, 0)),\n        (\"NotLeftTriangleBar\", (0, 0)),\n        (\"ogr\", (0, 0)),\n        (\"LessGr\", (0, 0)),\n        (\"complex\", (0, 0)),\n        (\"VerticalTilde;\", (8768, 0)),\n        (\"half;\", (189, 0)),\n        (\"NotSubsetEqual\", (0, 0)),\n        (\"frac58;\", (8541, 0)),\n        (\"napid;\", (8779, 824)),\n        (\"Gb\", (0, 0)),\n        (\"rbrksld;\", (10638, 0)),\n        (\"nL\", (0, 0)),\n        (\"rrarr\", (0, 0)),\n        (\"vBa\", (0, 0)),\n        (\"NotGreaterFu\", (0, 0)),\n        (\"DownLeftRightVect\", (0, 0)),\n        (\"circl\", (0, 0)),\n        (\"xsqc\", (0, 0)),\n        (\"harrw;\", (8621, 0)),\n        (\"PrecedesSlantEqu\", (0, 0)),\n        (\"ar\", (0, 0)),\n        (\"TildeFu\", (0, 0)),\n        (\"triangleleft;\", (9667, 0)),\n        (\"Superse\", (0, 0)),\n        (\"ltri\", (0, 0)),\n        (\"Ugrav\", (0, 0)),\n        (\"mopf;\", (120158, 0)),\n        (\"fallingdo\", (0, 0)),\n        (\"Gcir\", (0, 0)),\n        (\"zscr\", (0, 0)),\n        (\"iopf;\", (120154, 0)),\n        (\"ltrPar\", (0, 0)),\n        (\"bigtriangleup;\", (9651, 0)),\n        (\"setminus\", (0, 0)),\n        (\"yum\", (0, 0)),\n        (\"ration\", (0, 0)),\n        (\"rhar\", (0, 0)),\n        (\"Partial\", (0, 0)),\n        (\"updowna\", (0, 0)),\n        (\"UnderBracket;\", (9141, 0)),\n        (\"topb\", (0, 0)),\n        (\"Iukcy;\", (1030, 0)),\n        (\"asympe\", (0, 0)),\n        (\"notin;\", (8713, 0)),\n        (\"scsi\", (0, 0)),\n        (\"UnderParenthesis\", (0, 0)),\n        (\"cudarrr;\", (10549, 0)),\n        (\"bo\", (0, 0)),\n        (\"tc\", (0, 0)),\n        (\"urcr\", (0, 0)),\n        (\"gfr\", (0, 0)),\n        (\"NotNestedLess\", (0, 0)),\n        (\"xrA\", (0, 0)),\n        (\"wr\", (0, 0)),\n        (\"nequiv;\", (8802, 0)),\n        (\"NonBreakingSpac\", (0, 0)),\n        (\"bempty\", (0, 0)),\n        (\"ogo\", (0, 0)),\n        (\"Assig\", (0, 0)),\n        (\"Sce\", (0, 0)),\n        (\"plustw\", (0, 0)),\n        (\"lrco\", (0, 0)),\n        (\"NotLeftTr\", (0, 0)),\n        (\"tfr;\", (120113, 0)),\n        (\"subsup\", (0, 0)),\n        (\"kop\", (0, 0)),\n        (\"phon\", (0, 0)),\n        (\"doublebar\", (0, 0)),\n        (\"oror;\", (10838, 0)),\n        (\"veeba\", (0, 0)),\n        (\"Itilde\", (0, 0)),\n        (\"xlAr\", (0, 0)),\n        (\"kced\", (0, 0)),\n        (\"ShortDown\", (0, 0)),\n        (\"rd\", (0, 0)),\n        (\"NoBreak\", (0, 0)),\n        (\"NotTildeEqu\", (0, 0)),\n        (\"caron\", (0, 0)),\n        (\"expectatio\", (0, 0)),\n        (\"UnderParenthes\", (0, 0)),\n        (\"Backslas\", (0, 0)),\n        (\"Ccon\", (0, 0)),\n        (\"varepsilon\", (0, 0)),\n        (\"YUcy;\", (1070, 0)),\n        (\"urcor\", (0, 0)),\n        (\"MinusPl\", (0, 0)),\n        (\"CircleTime\", (0, 0)),\n        (\"SquareSub\", (0, 0)),\n        (\"Ucy;\", (1059, 0)),\n        (\"hopf\", (0, 0)),\n        (\"NotDouble\", (0, 0)),\n        (\"Dagger;\", (8225, 0)),\n        (\"leqq\", (0, 0)),\n        (\"Fo\", (0, 0)),\n        (\"srarr;\", (8594, 0)),\n        (\"NegativeVe\", (0, 0)),\n        (\"operp\", (0, 0)),\n        (\"RightTriangleE\", (0, 0)),\n        (\"ccaro\", (0, 0)),\n        (\"NotVerticalBa\", (0, 0)),\n        (\"profs\", (0, 0)),\n        (\"PrecedesSlantE\", (0, 0)),\n        (\"UnderParenthe\", (0, 0)),\n        (\"tstr\", (0, 0)),\n        (\"NotRightTriangleBa\", (0, 0)),\n        (\"ccupssm;\", (10832, 0)),\n        (\"vartriangleleft;\", (8882, 0)),\n        (\"eqslant\", (0, 0)),\n        (\"flat\", (0, 0)),\n        (\"eqslantless\", (0, 0)),\n        (\"nvrtrie\", (0, 0)),\n        (\"mea\", (0, 0)),\n        (\"DoubleCo\", (0, 0)),\n        (\"twoheadleftar\", (0, 0)),\n        (\"uw\", (0, 0)),\n        (\"RightDoubleBracke\", (0, 0)),\n        (\"ShortUpArrow\", (0, 0)),\n        (\"rbrack\", (0, 0)),\n        (\"lrm\", (0, 0)),\n        (\"LeftTeeV\", (0, 0)),\n        (\"GreaterGreat\", (0, 0)),\n        (\"nvi\", (0, 0)),\n        (\"RightUpVecto\", (0, 0)),\n        (\"ntrianglerighte\", (0, 0)),\n        (\"Osla\", (0, 0)),\n        (\"Rang;\", (10219, 0)),\n        (\"thicksi\", (0, 0)),\n        (\"Squ\", (0, 0)),\n        (\"nwnea\", (0, 0)),\n        (\"Sqrt;\", (8730, 0)),\n        (\"nvDash\", (0, 0)),\n        (\"Differen\", (0, 0)),\n        (\"harrci\", (0, 0)),\n        (\"oa\", (0, 0)),\n        (\"aacute;\", (225, 0)),\n        (\"rdl\", (0, 0)),\n        (\"qfr;\", (120110, 0)),\n        (\"tint;\", (8749, 0)),\n        (\"NotRightTriangleB\", (0, 0)),\n        (\"bN\", (0, 0)),\n        (\"napos;\", (329, 0)),\n        (\"lfr\", (0, 0)),\n        (\"Zcy;\", (1047, 0)),\n        (\"smallsetminus\", (0, 0)),\n        (\"supm\", (0, 0)),\n        (\"plusm\", (0, 0)),\n        (\"downharp\", (0, 0)),\n        (\"LeftDownVect\", (0, 0)),\n        (\"nap;\", (8777, 0)),\n        (\"Diacritical\", (0, 0)),\n        (\"leftrightharpoon\", (0, 0)),\n        (\"Coproduct\", (0, 0)),\n        (\"duha\", (0, 0)),\n        (\"Hump\", (0, 0)),\n        (\"isinsv;\", (8947, 0)),\n        (\"hardcy;\", (1098, 0)),\n        (\"oacut\", (0, 0)),\n        (\"blackloze\", (0, 0)),\n        (\"xwe\", (0, 0)),\n        (\"sup1;\", (185, 0)),\n        (\"DiacriticalAc\", (0, 0)),\n        (\"left\", (0, 0)),\n        (\"Oa\", (0, 0)),\n        (\"udha\", (0, 0)),\n        (\"nge\", (0, 0)),\n        (\"Coproduc\", (0, 0)),\n        (\"hyphen;\", (8208, 0)),\n        (\"RightTriangleBa\", (0, 0)),\n        (\"intlar\", (0, 0)),\n        (\"Zdot;\", (379, 0)),\n        (\"DiacriticalDoubleAcut\", (0, 0)),\n        (\"ShortR\", (0, 0)),\n        (\"bkarow\", (0, 0)),\n        (\"th\", (0, 0)),\n        (\"lar\", (0, 0)),\n        (\"cud\", (0, 0)),\n        (\"ne;\", (8800, 0)),\n        (\"RightAn\", (0, 0)),\n        (\"vD\", (0, 0)),\n        (\"downharpoonleft\", (0, 0)),\n        (\"pitchfo\", (0, 0)),\n        (\"lozenge\", (0, 0)),\n        (\"mn\", (0, 0)),\n        (\"Z\", (0, 0)),\n        (\"expectat\", (0, 0)),\n        (\"Horizon\", (0, 0)),\n        (\"Tcedil;\", (354, 0)),\n        (\"trid\", (0, 0)),\n        (\"NotLessLe\", (0, 0)),\n        (\"prim\", (0, 0)),\n        (\"ReverseEqu\", (0, 0)),\n        (\"Utilde;\", (360, 0)),\n        (\"omacr\", (0, 0)),\n        (\"mapstodow\", (0, 0)),\n        (\"cemptyv\", (0, 0)),\n        (\"UpArrow\", (0, 0)),\n        (\"qf\", (0, 0)),\n        (\"J\", (0, 0)),\n        (\"diamon\", (0, 0)),\n        (\"HorizontalLi\", (0, 0)),\n        (\"Sqrt\", (0, 0)),\n        (\"kap\", (0, 0)),\n        (\"CloseCurlyQ\", (0, 0)),\n        (\"EqualTil\", (0, 0)),\n        (\"fallingdotse\", (0, 0)),\n        (\"gE\", (0, 0)),\n        (\"sqsubset\", (0, 0)),\n        (\"FilledVerySmallSqua\", (0, 0)),\n        (\"UpperRightA\", (0, 0)),\n        (\"NotVerti\", (0, 0)),\n        (\"ntlg\", (0, 0)),\n        (\"pm\", (0, 0)),\n        (\"DiacriticalDouble\", (0, 0)),\n        (\"NotTildeFu\", (0, 0)),\n        (\"xharr;\", (10231, 0)),\n        (\"leqslant\", (0, 0)),\n        (\"DZ\", (0, 0)),\n        (\"twoheadleftarrow;\", (8606, 0)),\n        (\"Ic\", (0, 0)),\n        (\"DownR\", (0, 0)),\n        (\"realpar\", (0, 0)),\n        (\"Neste\", (0, 0)),\n        (\"nvltrie;\", (8884, 8402)),\n        (\"lcedil;\", (316, 0)),\n        (\"lur\", (0, 0)),\n        (\"NotSucceedsEqua\", (0, 0)),\n        (\"gtrle\", (0, 0)),\n        (\"qu\", (0, 0)),\n        (\"RightTriangleEqu\", (0, 0)),\n        (\"ReverseEqui\", (0, 0)),\n        (\"Gcedi\", (0, 0)),\n        (\"chi;\", (967, 0)),\n        (\"thorn\", (254, 0)),\n        (\"iinfi\", (0, 0)),\n        (\"midc\", (0, 0)),\n        (\"HilbertSpace\", (0, 0)),\n        (\"lnappro\", (0, 0)),\n        (\"cy\", (0, 0)),\n        (\"marke\", (0, 0)),\n        (\"lrtri;\", (8895, 0)),\n        (\"smashp\", (0, 0)),\n        (\"RightUpVectorBar\", (0, 0)),\n        (\"ngt\", (0, 0)),\n        (\"jcirc\", (0, 0)),\n        (\"Epsilo\", (0, 0)),\n        (\"GreaterTi\", (0, 0)),\n        (\"oacute;\", (243, 0)),\n        (\"tritime\", (0, 0)),\n        (\"iogo\", (0, 0)),\n        (\"looparrowr\", (0, 0)),\n        (\"Lac\", (0, 0)),\n        (\"vsupnE\", (0, 0)),\n        (\"cura\", (0, 0)),\n        (\"circ;\", (710, 0)),\n        (\"dzcy\", (0, 0)),\n        (\"napprox;\", (8777, 0)),\n        (\"ncongdot;\", (10861, 824)),\n        (\"DoubleLeftRightAr\", (0, 0)),\n        (\"Vertic\", (0, 0)),\n        (\"npart\", (0, 0)),\n        (\"triminus\", (0, 0)),\n        (\"egsdot;\", (10904, 0)),\n        (\"hfr\", (0, 0)),\n        (\"longleftri\", (0, 0)),\n        (\"rsquor\", (0, 0)),\n        (\"DownLeftTeeVec\", (0, 0)),\n        (\"zdot\", (0, 0)),\n        (\"SHCHcy\", (0, 0)),\n        (\"Intersec\", (0, 0)),\n        (\"An\", (0, 0)),\n        (\"ccirc;\", (265, 0)),\n        (\"swarro\", (0, 0)),\n        (\"quest\", (0, 0)),\n        (\"frac35\", (0, 0)),\n        (\"PrecedesSlantEqual\", (0, 0)),\n        (\"sbquo;\", (8218, 0)),\n        (\"imacr;\", (299, 0)),\n        (\"twoheadleftarr\", (0, 0)),\n        (\"leftthreetimes\", (0, 0)),\n        (\"sigma;\", (963, 0)),\n        (\"boxh\", (0, 0)),\n        (\"SquareSuperset;\", (8848, 0)),\n        (\"eqsl\", (0, 0)),\n        (\"circeq\", (0, 0)),\n        (\"lesseqgt\", (0, 0)),\n        (\"ufis\", (0, 0)),\n        (\"nsubseteqq\", (0, 0)),\n        (\"veebar\", (0, 0)),\n        (\"bigotimes;\", (10754, 0)),\n        (\"brvb\", (0, 0)),\n        (\"LeftTeeArrow;\", (8612, 0)),\n        (\"barw\", (0, 0)),\n        (\"rAtail\", (0, 0)),\n        (\"DownBrev\", (0, 0)),\n        (\"fo\", (0, 0)),\n        (\"Exists;\", (8707, 0)),\n        (\"equals;\", (61, 0)),\n        (\"upha\", (0, 0)),\n        (\"Proport\", (0, 0)),\n        (\"vel\", (0, 0)),\n        (\"subp\", (0, 0)),\n        (\"Gf\", (0, 0)),\n        (\"hoarr\", (0, 0)),\n        (\"thksim\", (0, 0)),\n        (\"atil\", (0, 0)),\n        (\"nleqslant\", (0, 0)),\n        (\"mscr;\", (120002, 0)),\n        (\"lsime;\", (10893, 0)),\n        (\"Hstr\", (0, 0)),\n        (\"yfr;\", (120118, 0)),\n        (\"UpArrowBa\", (0, 0)),\n        (\"filig\", (0, 0)),\n        (\"DoubleLeftRight\", (0, 0)),\n        (\"gci\", (0, 0)),\n        (\"dbkarow\", (0, 0)),\n        (\"lEg\", (0, 0)),\n        (\"bprime\", (0, 0)),\n        (\"nearrow\", (0, 0)),\n        (\"HumpEq\", (0, 0)),\n        (\"forkv;\", (10969, 0)),\n        (\"Igra\", (0, 0)),\n        (\"Bet\", (0, 0)),\n        (\"RightArrowLeft\", (0, 0)),\n        (\"RightDownTeeVector;\", (10589, 0)),\n        (\"CO\", (0, 0)),\n        (\"rarrtl\", (0, 0)),\n        (\"CapitalDi\", (0, 0)),\n        (\"TripleD\", (0, 0)),\n        (\"xcup;\", (8899, 0)),\n        (\"sci\", (0, 0)),\n        (\"Short\", (0, 0)),\n        (\"bdquo\", (0, 0)),\n        (\"zcar\", (0, 0)),\n        (\"RightCeiling;\", (8969, 0)),\n        (\"lcei\", (0, 0)),\n        (\"ijl\", (0, 0)),\n        (\"dlcorn;\", (8990, 0)),\n        (\"circlea\", (0, 0)),\n        (\"risingd\", (0, 0)),\n        (\"Cd\", (0, 0)),\n        (\"Rsc\", (0, 0)),\n        (\"NotPrecedesSlantEqu\", (0, 0)),\n        (\"thi\", (0, 0)),\n        (\"efD\", (0, 0)),\n        (\"LessEqualGr\", (0, 0)),\n        (\"Dstrok;\", (272, 0)),\n        (\"Iogo\", (0, 0)),\n        (\"Hacek\", (0, 0)),\n        (\"blacktri\", (0, 0)),\n        (\"Integral;\", (8747, 0)),\n        (\"lessgtr;\", (8822, 0)),\n        (\"notinE;\", (8953, 824)),\n        (\"xci\", (0, 0)),\n        (\"LeftT\", (0, 0)),\n        (\"esdo\", (0, 0)),\n        (\"GreaterSlant\", (0, 0)),\n        (\"NotGreaterTild\", (0, 0)),\n        (\"DoubleLeftRightArrow\", (0, 0)),\n        (\"nLeftarrow\", (0, 0)),\n        (\"supsub\", (0, 0)),\n        (\"Uti\", (0, 0)),\n        (\"Longleftarr\", (0, 0)),\n        (\"hear\", (0, 0)),\n        (\"bigw\", (0, 0)),\n        (\"Sm\", (0, 0)),\n        (\"Hscr\", (0, 0)),\n        (\"iexc\", (0, 0)),\n        (\"Tfr;\", (120087, 0)),\n        (\"rac\", (0, 0)),\n        (\"supsi\", (0, 0)),\n        (\"cirfnint;\", (10768, 0)),\n        (\"lefta\", (0, 0)),\n        (\"lla\", (0, 0)),\n        (\"qopf;\", (120162, 0)),\n        (\"les;\", (10877, 0)),\n        (\"EmptyVerySmallSqua\", (0, 0)),\n        (\"NotDoubleVerticalBar;\", (8742, 0)),\n        (\"barvee\", (0, 0)),\n        (\"ccups;\", (10828, 0)),\n        (\"PartialD\", (0, 0)),\n        (\"telrec\", (0, 0)),\n        (\"boxVh;\", (9579, 0)),\n        (\"VeryTh\", (0, 0)),\n        (\"NotVertical\", (0, 0)),\n        (\"ShortDownAr\", (0, 0)),\n        (\"supsub;\", (10964, 0)),\n        (\"blacklozeng\", (0, 0)),\n        (\"nRightarrow\", (0, 0)),\n        (\"Osc\", (0, 0)),\n        (\"rbbrk\", (0, 0)),\n        (\"iii\", (0, 0)),\n        (\"Uscr;\", (119984, 0)),\n        (\"RightVector;\", (8640, 0)),\n        (\"geqs\", (0, 0)),\n        (\"Agra\", (0, 0)),\n        (\"FilledSm\", (0, 0)),\n        (\"rArr\", (0, 0)),\n        (\"Equal;\", (10869, 0)),\n        (\"NotSupersetEq\", (0, 0)),\n        (\"capcap\", (0, 0)),\n        (\"ntild\", (0, 0)),\n        (\"rtim\", (0, 0)),\n        (\"nvda\", (0, 0)),\n        (\"NestedLess\", (0, 0)),\n        (\"lnsim;\", (8934, 0)),\n        (\"ulcro\", (0, 0)),\n        (\"oscr;\", (8500, 0)),\n        (\"tcaron\", (0, 0)),\n        (\"CloseCurlyDoubl\", (0, 0)),\n        (\"sqcu\", (0, 0)),\n        (\"olcir;\", (10686, 0)),\n        (\"And\", (0, 0)),\n        (\"or;\", (8744, 0)),\n        (\"Scir\", (0, 0)),\n        (\"Leftrightarr\", (0, 0)),\n        (\"NotLessSlantEqu\", (0, 0)),\n        (\"Ecy;\", (1069, 0)),\n        (\"rti\", (0, 0)),\n        (\"gt\", (62, 0)),\n        (\"boxHu;\", (9575, 0)),\n        (\"napp\", (0, 0)),\n        (\"ocy\", (0, 0)),\n        (\"DDot\", (0, 0)),\n        (\"ques\", (0, 0)),\n        (\"ltdot\", (0, 0)),\n        (\"EqualTild\", (0, 0)),\n        (\"nleftrightarrow\", (0, 0)),\n        (\"twohead\", (0, 0)),\n        (\"Scirc;\", (348, 0)),\n        (\"fpar\", (0, 0)),\n        (\"UpArrowDownArrow;\", (8645, 0)),\n        (\"Aog\", (0, 0)),\n        (\"point\", (0, 0)),\n        (\"leftar\", (0, 0)),\n        (\"lbbrk\", (0, 0)),\n        (\"DoubleRightArr\", (0, 0)),\n        (\"CounterClockwiseContour\", (0, 0)),\n        (\"ldrdh\", (0, 0)),\n        (\"NotEqualTil\", (0, 0)),\n        (\"Sf\", (0, 0)),\n        (\"uci\", (0, 0)),\n        (\"rsc\", (0, 0)),\n        (\"Popf\", (0, 0)),\n        (\"NotSubsetEqual;\", (8840, 0)),\n        (\"swnwa\", (0, 0)),\n        (\"fop\", (0, 0)),\n        (\"ThickSpa\", (0, 0)),\n        (\"luruhar;\", (10598, 0)),\n        (\"nsim\", (0, 0)),\n        (\"po\", (0, 0)),\n        (\"Bumpeq;\", (8782, 0)),\n        (\"vare\", (0, 0)),\n        (\"gtre\", (0, 0)),\n        (\"downhar\", (0, 0)),\n        (\"Oopf\", (0, 0)),\n        (\"blacktriangled\", (0, 0)),\n        (\"UpTeeArrow\", (0, 0)),\n        (\"cuwe\", (0, 0)),\n        (\"oror\", (0, 0)),\n        (\"Exponentia\", (0, 0)),\n        (\"zacute\", (0, 0)),\n        (\"RightDo\", (0, 0)),\n        (\"gtreqless\", (0, 0)),\n        (\"Dif\", (0, 0)),\n        (\"Qo\", (0, 0)),\n        (\"vc\", (0, 0)),\n        (\"trp\", (0, 0)),\n        (\"nsqsube;\", (8930, 0)),\n        (\"downdownarrows;\", (8650, 0)),\n        (\"rt\", (0, 0)),\n        (\"CircleMin\", (0, 0)),\n        (\"Invi\", (0, 0)),\n        (\"so\", (0, 0)),\n        (\"rightl\", (0, 0)),\n        (\"boxHD\", (0, 0)),\n        (\"Upsilon;\", (933, 0)),\n        (\"omega\", (0, 0)),\n        (\"beth\", (0, 0)),\n        (\"mcomma;\", (10793, 0)),\n        (\"lac\", (0, 0)),\n        (\"rArr;\", (8658, 0)),\n        (\"alph\", (0, 0)),\n        (\"cupdot\", (0, 0)),\n        (\"bloc\", (0, 0)),\n        (\"mc\", (0, 0)),\n        (\"Lsc\", (0, 0)),\n        (\"ce\", (0, 0)),\n        (\"LessEqualGreate\", (0, 0)),\n        (\"imagpa\", (0, 0)),\n        (\"dotminus\", (0, 0)),\n        (\"tria\", (0, 0)),\n        (\"LeftCeiling;\", (8968, 0)),\n        (\"ccu\", (0, 0)),\n        (\"shortmid;\", (8739, 0)),\n        (\"mark\", (0, 0)),\n        (\"trianglelefte\", (0, 0)),\n        (\"qs\", (0, 0)),\n        (\"trianglelef\", (0, 0)),\n        (\"mal\", (0, 0)),\n        (\"Righta\", (0, 0)),\n        (\"checkmark;\", (10003, 0)),\n        (\"xsc\", (0, 0)),\n        (\"ksc\", (0, 0)),\n        (\"leftharp\", (0, 0)),\n        (\"ReverseEleme\", (0, 0)),\n        (\"fil\", (0, 0)),\n        (\"incare\", (0, 0)),\n        (\"angst;\", (197, 0)),\n        (\"NotGreaterGreate\", (0, 0)),\n        (\"varph\", (0, 0)),\n        (\"GreaterFullEq\", (0, 0)),\n        (\"NotSubsetE\", (0, 0)),\n        (\"tild\", (0, 0)),\n        (\"ClockwiseContourInte\", (0, 0)),\n        (\"LowerRigh\", (0, 0)),\n        (\"Greater\", (0, 0)),\n        (\"dfr\", (0, 0)),\n        (\"subE;\", (10949, 0)),\n        (\"rx\", (0, 0)),\n        (\"RightDoubleB\", (0, 0)),\n        (\"Alpha\", (0, 0)),\n        (\"blk12;\", (9618, 0)),\n        (\"DotEqual;\", (8784, 0)),\n        (\"LeftUp\", (0, 0)),\n        (\"NotPrecedesEqua\", (0, 0)),\n        (\"Nu\", (0, 0)),\n        (\"UnderPa\", (0, 0)),\n        (\"vzigza\", (0, 0)),\n        (\"nexists;\", (8708, 0)),\n        (\"leftarr\", (0, 0)),\n        (\"lesg\", (0, 0)),\n        (\"DoubleD\", (0, 0)),\n        (\"beta\", (0, 0)),\n        (\"LeftDownVectorBar;\", (10585, 0)),\n        (\"va\", (0, 0)),\n        (\"Longrightar\", (0, 0)),\n        (\"cuve\", (0, 0)),\n        (\"bot\", (0, 0)),\n        (\"bottom\", (0, 0)),\n        (\"Fou\", (0, 0)),\n        (\"blacksquare\", (0, 0)),\n        (\"SucceedsT\", (0, 0)),\n        (\"Nced\", (0, 0)),\n        (\"uscr;\", (120010, 0)),\n        (\"ddarr;\", (8650, 0)),\n        (\"gtreqless;\", (8923, 0)),\n        (\"congdot;\", (10861, 0)),\n        (\"deg;\", (176, 0)),\n        (\"ffil\", (0, 0)),\n        (\"gcy;\", (1075, 0)),\n        (\"xl\", (0, 0)),\n        (\"lan\", (0, 0)),\n        (\"le\", (0, 0)),\n        (\"NotTildeEq\", (0, 0)),\n        (\"ium\", (0, 0)),\n        (\"utrif;\", (9652, 0)),\n        (\"gj\", (0, 0)),\n        (\"CenterD\", (0, 0)),\n        (\"precneqq;\", (10933, 0)),\n        (\"Imagin\", (0, 0)),\n        (\"mult\", (0, 0)),\n        (\"rightth\", (0, 0)),\n        (\"NotPrecedes\", (0, 0)),\n        (\"boxur\", (0, 0)),\n        (\"Uparrow\", (0, 0)),\n        (\"pfr\", (0, 0)),\n        (\"ubrc\", (0, 0)),\n        (\"ang\", (0, 0)),\n        (\"NotEqua\", (0, 0)),\n        (\"UpDownArr\", (0, 0)),\n        (\"TildeFullEq\", (0, 0)),\n        (\"Hcirc\", (0, 0)),\n        (\"CloseCurlyDoubleQuote;\", (8221, 0)),\n        (\"Poincar\", (0, 0)),\n        (\"smallse\", (0, 0)),\n        (\"simp\", (0, 0)),\n        (\"leqsla\", (0, 0)),\n        (\"Rrig\", (0, 0)),\n        (\"uo\", (0, 0)),\n        (\"east\", (0, 0)),\n        (\"IOcy;\", (1025, 0)),\n        (\"LeftTeeAr\", (0, 0)),\n        (\"rarrhk\", (0, 0)),\n        (\"UpperLef\", (0, 0)),\n        (\"mum\", (0, 0)),\n        (\"gtque\", (0, 0)),\n        (\"DownLeftTeeVecto\", (0, 0)),\n        (\"Supset;\", (8913, 0)),\n        (\"NotHumpEqua\", (0, 0)),\n        (\"rightrighta\", (0, 0)),\n        (\"abreve\", (0, 0)),\n        (\"Lapla\", (0, 0)),\n        (\"bigsta\", (0, 0)),\n        (\"ell\", (0, 0)),\n        (\"RightCeilin\", (0, 0)),\n        (\"Longleftrightarr\", (0, 0)),\n        (\"rightsquigarr\", (0, 0)),\n        (\"iquest\", (191, 0)),\n        (\"UpT\", (0, 0)),\n        (\"supsup\", (0, 0)),\n        (\"ZeroW\", (0, 0)),\n        (\"shcy\", (0, 0)),\n        (\"mda\", (0, 0)),\n        (\"SucceedsSlantEqua\", (0, 0)),\n        (\"ncy;\", (1085, 0)),\n        (\"scs\", (0, 0)),\n        (\"SquareInters\", (0, 0)),\n        (\"rharul\", (0, 0)),\n        (\"Verti\", (0, 0)),\n        (\"updown\", (0, 0)),\n        (\"lstrok;\", (322, 0)),\n        (\"vartheta\", (0, 0)),\n        (\"nls\", (0, 0)),\n        (\"setmn\", (0, 0)),\n        (\"supE\", (0, 0)),\n        (\"bigop\", (0, 0)),\n        (\"DoubleLongLeftRightArrow;\", (10234, 0)),\n        (\"Vdash\", (0, 0)),\n        (\"dtrif\", (0, 0)),\n        (\"lozf;\", (10731, 0)),\n        (\"odash;\", (8861, 0)),\n        (\"larrtl;\", (8610, 0)),\n        (\"ClockwiseCont\", (0, 0)),\n        (\"Assi\", (0, 0)),\n        (\"udbl\", (0, 0)),\n        (\"Imagina\", (0, 0)),\n        (\"nleftrig\", (0, 0)),\n        (\"acE;\", (8766, 819)),\n        (\"gneqq;\", (8809, 0)),\n        (\"and;\", (8743, 0)),\n        (\"downharpoonright;\", (8642, 0)),\n        (\"diamondsuit\", (0, 0)),\n        (\"bigoplus\", (0, 0)),\n        (\"oint;\", (8750, 0)),\n        (\"cirfn\", (0, 0)),\n        (\"nleftrightarro\", (0, 0)),\n        (\"vellip;\", (8942, 0)),\n        (\"LessFullEq\", (0, 0)),\n        (\"blacktriangler\", (0, 0)),\n        (\"DiacriticalA\", (0, 0)),\n        (\"VDa\", (0, 0)),\n        (\"leftharpoonup;\", (8636, 0)),\n        (\"Na\", (0, 0)),\n        (\"VerticalLin\", (0, 0)),\n        (\"iscr;\", (119998, 0)),\n        (\"ndas\", (0, 0)),\n        (\"lnsi\", (0, 0)),\n        (\"langl\", (0, 0)),\n        (\"sext;\", (10038, 0)),\n        (\"DownRightVectorBar;\", (10583, 0)),\n        (\"ldrd\", (0, 0)),\n        (\"Zcaro\", (0, 0)),\n        (\"Cedilla;\", (184, 0)),\n        (\"NotGreaterE\", (0, 0)),\n        (\"Zacute\", (0, 0)),\n        (\"telr\", (0, 0)),\n        (\"xhAr\", (0, 0)),\n        (\"NotTildeFul\", (0, 0)),\n        (\"ContourI\", (0, 0)),\n        (\"varkappa\", (0, 0)),\n        (\"uArr;\", (8657, 0)),\n        (\"OpenCurlyDoubleQ\", (0, 0)),\n        (\"triangledown;\", (9663, 0)),\n        (\"ucy;\", (1091, 0)),\n        (\"scy;\", (1089, 0)),\n        (\"NotLessLess\", (0, 0)),\n        (\"tst\", (0, 0)),\n        (\"eDo\", (0, 0)),\n        (\"Ov\", (0, 0)),\n        (\"twixt\", (0, 0)),\n        (\"Poincareplane\", (0, 0)),\n        (\"frac7\", (0, 0)),\n        (\"xutri\", (0, 0)),\n        (\"boxh;\", (9472, 0)),\n        (\"lessapprox\", (0, 0)),\n        (\"eqslantgtr;\", (10902, 0)),\n        (\"ovb\", (0, 0)),\n        (\"intp\", (0, 0)),\n        (\"fc\", (0, 0)),\n        (\"topfork;\", (10970, 0)),\n        (\"nLeftrightarrow\", (0, 0)),\n        (\"hfr;\", (120101, 0)),\n        (\"lfloo\", (0, 0)),\n        (\"nsq\", (0, 0)),\n        (\"arin\", (0, 0)),\n        (\"plusc\", (0, 0)),\n        (\"nvH\", (0, 0)),\n        (\"preca\", (0, 0)),\n        (\"wedge\", (0, 0)),\n        (\"LeftDownTeeVector\", (0, 0)),\n        (\"GreaterGreate\", (0, 0)),\n        (\"quaternions\", (0, 0)),\n        (\"multim\", (0, 0)),\n        (\"lesse\", (0, 0)),\n        (\"r\", (0, 0)),\n        (\"thicka\", (0, 0)),\n        (\"LongLeftR\", (0, 0)),\n        (\"NotH\", (0, 0)),\n        (\"qscr\", (0, 0)),\n        (\"NotNestedL\", (0, 0)),\n        (\"Vv\", (0, 0)),\n        (\"dwangle\", (0, 0)),\n        (\"supmu\", (0, 0)),\n        (\"NotNestedLes\", (0, 0)),\n        (\"Ubrcy\", (0, 0)),\n        (\"percn\", (0, 0)),\n        (\"Uopf;\", (120140, 0)),\n        (\"cuwed\", (0, 0)),\n        (\"submult;\", (10945, 0)),\n        (\"nleftrightarr\", (0, 0)),\n        (\"vsubnE;\", (10955, 65024)),\n        (\"nlt\", (0, 0)),\n        (\"NegativeThinSpace;\", (8203, 0)),\n        (\"hk\", (0, 0)),\n        (\"DoubleDownA\", (0, 0)),\n        (\"Gd\", (0, 0)),\n        (\"blac\", (0, 0)),\n        (\"ng\", (0, 0)),\n        (\"LeftRightVecto\", (0, 0)),\n        (\"gamma;\", (947, 0)),\n        (\"bern\", (0, 0)),\n        (\"zcaron\", (0, 0)),\n        (\"gtrsi\", (0, 0)),\n        (\"Differ\", (0, 0)),\n        (\"swnw\", (0, 0)),\n        (\"divideon\", (0, 0)),\n        (\"SucceedsSlantEq\", (0, 0)),\n        (\"leftarrowt\", (0, 0)),\n        (\"Ver\", (0, 0)),\n        (\"Vee;\", (8897, 0)),\n        (\"Edot\", (0, 0)),\n        (\"ioc\", (0, 0)),\n        (\"nvgt\", (0, 0)),\n        (\"small\", (0, 0)),\n        (\"Melli\", (0, 0)),\n        (\"timesbar\", (0, 0)),\n        (\"curvearro\", (0, 0)),\n        (\"OpenCurlyQuote\", (0, 0)),\n        (\"jscr;\", (119999, 0)),\n        (\"equivDD;\", (10872, 0)),\n        (\"sbqu\", (0, 0)),\n        (\"longleftrightar\", (0, 0)),\n        (\"vark\", (0, 0)),\n        (\"vnsu\", (0, 0)),\n        (\"tprim\", (0, 0)),\n        (\"LessTi\", (0, 0)),\n        (\"Vfr\", (0, 0)),\n        (\"lrcorner;\", (8991, 0)),\n        (\"Scedil\", (0, 0)),\n        (\"hookrightar\", (0, 0)),\n        (\"circledcirc;\", (8858, 0)),\n        (\"hstrok\", (0, 0)),\n        (\"gtcc\", (0, 0)),\n        (\"blacksqu\", (0, 0)),\n        (\"FilledSmallSqu\", (0, 0)),\n        (\"pertenk\", (0, 0)),\n        (\"nsmi\", (0, 0)),\n        (\"omega;\", (969, 0)),\n        (\"Product;\", (8719, 0)),\n        (\"Omac\", (0, 0)),\n        (\"LeftDownTe\", (0, 0)),\n        (\"EqualTi\", (0, 0)),\n        (\"ohm\", (0, 0)),\n        (\"midast\", (0, 0)),\n        (\"curlywedge;\", (8911, 0)),\n        (\"complement;\", (8705, 0)),\n        (\"rtimes\", (0, 0)),\n        (\"Lcy\", (0, 0)),\n        (\"nldr\", (0, 0)),\n        (\"bigtriangledown;\", (9661, 0)),\n        (\"RightTriangleEqual\", (0, 0)),\n        (\"nedo\", (0, 0)),\n        (\"otimesas\", (0, 0)),\n        (\"Gfr;\", (120074, 0)),\n        (\"db\", (0, 0)),\n        (\"Odb\", (0, 0)),\n        (\"Copro\", (0, 0)),\n        (\"Cfr\", (0, 0)),\n        (\"leftrightsqui\", (0, 0)),\n        (\"ys\", (0, 0)),\n        (\"betw\", (0, 0)),\n        (\"DiacriticalGrave;\", (96, 0)),\n        (\"LeftRightVect\", (0, 0)),\n        (\"St\", (0, 0)),\n        (\"TildeFullEqu\", (0, 0)),\n        (\"rightharpoonup\", (0, 0)),\n        (\"Ifr\", (0, 0)),\n        (\"zhcy\", (0, 0)),\n        (\"rangle\", (0, 0)),\n        (\"Zsc\", (0, 0)),\n        (\"pluse;\", (10866, 0)),\n        (\"Subs\", (0, 0)),\n        (\"LeftUpDownVecto\", (0, 0)),\n        (\"CircleDot\", (0, 0)),\n        (\"Yc\", (0, 0)),\n        (\"backepsilon\", (0, 0)),\n        (\"vz\", (0, 0)),\n        (\"ReverseEquilib\", (0, 0)),\n        (\"CapitalDiff\", (0, 0)),\n        (\"varrho;\", (1009, 0)),\n        (\"lurdsha\", (0, 0)),\n        (\"gnap;\", (10890, 0)),\n        (\"if\", (0, 0)),\n        (\"rarrlp\", (0, 0)),\n        (\"gac\", (0, 0)),\n        (\"xodo\", (0, 0)),\n        (\"righth\", (0, 0)),\n        (\"NotSquareSupersetEqual;\", (8931, 0)),\n        (\"RightDownTeeVecto\", (0, 0)),\n        (\"Ove\", (0, 0)),\n        (\"dHar\", (0, 0)),\n        (\"New\", (0, 0)),\n        (\"Open\", (0, 0)),\n        (\"precnsim;\", (8936, 0)),\n        (\"CounterClockwiseContourIntegra\", (0, 0)),\n        (\"rightleftharpoo\", (0, 0)),\n        (\"Odbl\", (0, 0)),\n        (\"gtlPa\", (0, 0)),\n        (\"backcon\", (0, 0)),\n        (\"sqsup;\", (8848, 0)),\n        (\"mopf\", (0, 0)),\n        (\"kscr;\", (120000, 0)),\n        (\"nharr;\", (8622, 0)),\n        (\"Ima\", (0, 0)),\n        (\"TildeTilde\", (0, 0)),\n        (\"Conint\", (0, 0)),\n        (\"DownArrowUpArro\", (0, 0)),\n        (\"circlear\", (0, 0)),\n        (\"UpDownArrow\", (0, 0)),\n        (\"because\", (0, 0)),\n        (\"udarr;\", (8645, 0)),\n        (\"tcy;\", (1090, 0)),\n        (\"Fs\", (0, 0)),\n        (\"boxuL;\", (9563, 0)),\n        (\"Ls\", (0, 0)),\n        (\"af\", (0, 0)),\n        (\"Ko\", (0, 0)),\n        (\"jscr\", (0, 0)),\n        (\"Dopf;\", (120123, 0)),\n        (\"cscr\", (0, 0)),\n        (\"ldca\", (0, 0)),\n        (\"Poincareplan\", (0, 0)),\n        (\"igrav\", (0, 0)),\n        (\"nrightarro\", (0, 0)),\n        (\"sho\", (0, 0)),\n        (\"kappa\", (0, 0)),\n        (\"bemptyv;\", (10672, 0)),\n        (\"sigmaf;\", (962, 0)),\n        (\"era\", (0, 0)),\n        (\"pitchfor\", (0, 0)),\n        (\"Ubrcy;\", (1038, 0)),\n        (\"expectation\", (0, 0)),\n        (\"Arin\", (0, 0)),\n        (\"mac\", (0, 0)),\n        (\"Longleftright\", (0, 0)),\n        (\"lurdshar\", (0, 0)),\n        (\"cedil;\", (184, 0)),\n        (\"lsh;\", (8624, 0)),\n        (\"nrArr\", (0, 0)),\n        (\"rightlefth\", (0, 0)),\n        (\"supdot\", (0, 0)),\n        (\"NotGreaterLess;\", (8825, 0)),\n        (\"NegativeMedi\", (0, 0)),\n        (\"LeftAngleBrac\", (0, 0)),\n        (\"Ncedi\", (0, 0)),\n        (\"amac\", (0, 0)),\n        (\"diamondsui\", (0, 0)),\n        (\"Emacr;\", (274, 0)),\n        (\"NegativeThic\", (0, 0)),\n        (\"ggg\", (0, 0)),\n        (\"imacr\", (0, 0)),\n        (\"lesges\", (0, 0)),\n        (\"Agrave\", (192, 0)),\n        (\"Vop\", (0, 0)),\n        (\"forkv\", (0, 0)),\n        (\"uharl;\", (8639, 0)),\n        (\"rightarrowtail\", (0, 0)),\n        (\"hamilt;\", (8459, 0)),\n        (\"rmou\", (0, 0)),\n        (\"leqslan\", (0, 0)),\n        (\"rds\", (0, 0)),\n        (\"ccir\", (0, 0)),\n        (\"cwint\", (0, 0)),\n        (\"shortp\", (0, 0)),\n        (\"sung\", (0, 0)),\n        (\"TRAD\", (0, 0)),\n        (\"NotSqua\", (0, 0)),\n        (\"DownLef\", (0, 0)),\n        (\"aog\", (0, 0)),\n        (\"VeryThinSp\", (0, 0)),\n        (\"ShortLeftAr\", (0, 0)),\n        (\"divid\", (0, 0)),\n        (\"integ\", (0, 0)),\n        (\"UpperLeftArro\", (0, 0)),\n        (\"frac45;\", (8536, 0)),\n        (\"UpperRightArrow;\", (8599, 0)),\n        (\"hksea\", (0, 0)),\n        (\"notinva\", (0, 0)),\n        (\"NotEqu\", (0, 0)),\n        (\"fnof;\", (402, 0)),\n        (\"blk34;\", (9619, 0)),\n        (\"infint\", (0, 0)),\n        (\"nltri\", (0, 0)),\n        (\"RightAngleBra\", (0, 0)),\n        (\"HilbertSpace;\", (8459, 0)),\n        (\"Upsi\", (0, 0)),\n        (\"rightharpoon\", (0, 0)),\n        (\"curl\", (0, 0)),\n        (\"DownTeeArro\", (0, 0)),\n        (\"rho;\", (961, 0)),\n        (\"suphsol\", (0, 0)),\n        (\"alp\", (0, 0)),\n        (\"nleqslan\", (0, 0)),\n        (\"ring\", (0, 0)),\n        (\"bumpeq\", (0, 0)),\n        (\"Vs\", (0, 0)),\n        (\"LeftTrian\", (0, 0)),\n        (\"curren;\", (164, 0)),\n        (\"rarrpl\", (0, 0)),\n        (\"longma\", (0, 0)),\n        (\"DJcy\", (0, 0)),\n        (\"Ncaron;\", (327, 0)),\n        (\"Zopf\", (0, 0)),\n        (\"UnderBrace;\", (9183, 0)),\n        (\"Poincare\", (0, 0)),\n        (\"gsim;\", (8819, 0)),\n        (\"ENG\", (0, 0)),\n        (\"uuml;\", (252, 0)),\n        (\"NotHumpDo\", (0, 0)),\n        (\"NotLeftTriangleEqual;\", (8940, 0)),\n        (\"phone;\", (9742, 0)),\n        (\"Breve;\", (728, 0)),\n        (\"leqslant;\", (10877, 0)),\n        (\"LeftTriang\", (0, 0)),\n        (\"leftrigh\", (0, 0)),\n        (\"Rou\", (0, 0)),\n        (\"el\", (0, 0)),\n        (\"NotLeftTriangleEqual\", (0, 0)),\n        (\"et\", (0, 0)),\n        (\"Leftrigh\", (0, 0)),\n        (\"igr\", (0, 0)),\n        (\"eqslantgt\", (0, 0)),\n        (\"bigoti\", (0, 0)),\n        (\"tcedi\", (0, 0)),\n        (\"ReverseEquilibrium;\", (8651, 0)),\n        (\"minus\", (0, 0)),\n        (\"profalar\", (0, 0)),\n        (\"F\", (0, 0)),\n        (\"rsaq\", (0, 0)),\n        (\"ngeq;\", (8817, 0)),\n        (\"nwAr\", (0, 0)),\n        (\"nsmid;\", (8740, 0)),\n        (\"esc\", (0, 0)),\n        (\"angmsdag;\", (10670, 0)),\n        (\"s\", (0, 0)),\n        (\"ds\", (0, 0)),\n        (\"rmoustache\", (0, 0)),\n        (\"LongLeftAr\", (0, 0)),\n        (\"zopf;\", (120171, 0)),\n        (\"RightDoubleBrac\", (0, 0)),\n        (\"ddot\", (0, 0)),\n        (\"cupbr\", (0, 0)),\n        (\"DoubleLongLeftRig\", (0, 0)),\n        (\"NotGreaterEqu\", (0, 0)),\n        (\"ms\", (0, 0)),\n        (\"NotSupe\", (0, 0)),\n        (\"ForAll;\", (8704, 0)),\n        (\"Gci\", (0, 0)),\n        (\"Filled\", (0, 0)),\n        (\"fili\", (0, 0)),\n        (\"ofcir\", (0, 0)),\n        (\"DownArrowBar\", (0, 0)),\n        (\"ShortUp\", (0, 0)),\n        (\"Lleftarrow\", (0, 0)),\n        (\"lHar;\", (10594, 0)),\n        (\"upuparrows\", (0, 0)),\n        (\"LeftRig\", (0, 0)),\n        (\"conin\", (0, 0)),\n        (\"nume\", (0, 0)),\n        (\"rsquo;\", (8217, 0)),\n        (\"ucirc;\", (251, 0)),\n        (\"urcorn\", (0, 0)),\n        (\"Ran\", (0, 0)),\n        (\"nequi\", (0, 0)),\n        (\"radic;\", (8730, 0)),\n        (\"DiacriticalGr\", (0, 0)),\n        (\"tshcy;\", (1115, 0)),\n        (\"ber\", (0, 0)),\n        (\"Xopf\", (0, 0)),\n        (\"Horizont\", (0, 0)),\n        (\"coni\", (0, 0)),\n        (\"smte;\", (10924, 0)),\n        (\"DiacriticalDot;\", (729, 0)),\n        (\"rarrtl;\", (8611, 0)),\n        (\"scaron;\", (353, 0)),\n        (\"pit\", (0, 0)),\n        (\"DifferentialD\", (0, 0)),\n        (\"RightFlo\", (0, 0)),\n        (\"In\", (0, 0)),\n        (\"GreaterT\", (0, 0)),\n        (\"vrtri\", (0, 0)),\n        (\"swarrow;\", (8601, 0)),\n        (\"subplus;\", (10943, 0)),\n        (\"rotime\", (0, 0)),\n        (\"downdownarro\", (0, 0)),\n        (\"dcy\", (0, 0)),\n        (\"plusac\", (0, 0)),\n        (\"UpArrowDownArro\", (0, 0)),\n        (\"propt\", (0, 0)),\n        (\"kappa;\", (954, 0)),\n        (\"shor\", (0, 0)),\n        (\"NotTildeTilde\", (0, 0)),\n        (\"kgre\", (0, 0)),\n        (\"lbrks\", (0, 0)),\n        (\"LeftDoubleBracket;\", (10214, 0)),\n        (\"dlc\", (0, 0)),\n        (\"boxvl;\", (9508, 0)),\n        (\"starf;\", (9733, 0)),\n        (\"Tab;\", (9, 0)),\n        (\"efDo\", (0, 0)),\n        (\"nmid;\", (8740, 0)),\n        (\"cacu\", (0, 0)),\n        (\"CloseCurlyDo\", (0, 0)),\n        (\"ltque\", (0, 0)),\n        (\"Cs\", (0, 0)),\n        (\"NotEq\", (0, 0)),\n        (\"Epsil\", (0, 0)),\n        (\"nsqs\", (0, 0)),\n        (\"Abreve\", (0, 0)),\n        (\"ldrusha\", (0, 0)),\n        (\"oline\", (0, 0)),\n        (\"SquareSubsetEq\", (0, 0)),\n        (\"apos;\", (39, 0)),\n        (\"longm\", (0, 0)),\n        (\"notinvc;\", (8950, 0)),\n        (\"NotRightTriangleEq\", (0, 0)),\n        (\"vartriangleleft\", (0, 0)),\n        (\"leqs\", (0, 0)),\n        (\"Upp\", (0, 0)),\n        (\"tim\", (0, 0)),\n        (\"prns\", (0, 0)),\n        (\"NestedGreat\", (0, 0)),\n        (\"Lmi\", (0, 0)),\n        (\"OpenCurl\", (0, 0)),\n        (\"UnderParenthesi\", (0, 0)),\n        (\"bi\", (0, 0)),\n        (\"gtrapp\", (0, 0)),\n        (\"Cdot\", (0, 0)),\n        (\"gEl;\", (10892, 0)),\n        (\"Upa\", (0, 0)),\n        (\"dash\", (0, 0)),\n        (\"DoubleLongLeftArrow\", (0, 0)),\n        (\"rppolint;\", (10770, 0)),\n        (\"blacktr\", (0, 0)),\n        (\"bcon\", (0, 0)),\n        (\"sun\", (0, 0)),\n        (\"RightUpTee\", (0, 0)),\n        (\"KJcy\", (0, 0)),\n        (\"hybull;\", (8259, 0)),\n        (\"simdo\", (0, 0)),\n        (\"bigsqcup\", (0, 0)),\n        (\"leftharpoondown\", (0, 0)),\n        (\"NotSq\", (0, 0)),\n        (\"longleftarrow\", (0, 0)),\n        (\"supseteqq;\", (10950, 0)),\n        (\"NotNestedGreat\", (0, 0)),\n        (\"nsub;\", (8836, 0)),\n        (\"dstrok;\", (273, 0)),\n        (\"mh\", (0, 0)),\n        (\"eDot\", (0, 0)),\n        (\"Jopf\", (0, 0)),\n        (\"jci\", (0, 0)),\n        (\"nspar\", (0, 0)),\n        (\"notnivb\", (0, 0)),\n        (\"subrarr\", (0, 0)),\n        (\"lsaq\", (0, 0)),\n        (\"rfloor\", (0, 0)),\n        (\"ntria\", (0, 0)),\n        (\"Cdo\", (0, 0)),\n        (\"not\", (172, 0)),\n        (\"Omicron\", (0, 0)),\n        (\"Ugrave\", (217, 0)),\n        (\"NotSquareSupers\", (0, 0)),\n        (\"top;\", (8868, 0)),\n        (\"Rrigh\", (0, 0)),\n        (\"DoubleConto\", (0, 0)),\n        (\"lcy\", (0, 0)),\n        (\"SquareSubsetE\", (0, 0)),\n        (\"scirc;\", (349, 0)),\n        (\"Differenti\", (0, 0)),\n        (\"beta;\", (946, 0)),\n        (\"NotHumpDow\", (0, 0)),\n        (\"yopf;\", (120170, 0)),\n        (\"RightUp\", (0, 0)),\n        (\"urcrop\", (0, 0)),\n        (\"lozenge;\", (9674, 0)),\n        (\"interc\", (0, 0)),\n        (\"fflig;\", (64256, 0)),\n        (\"trie;\", (8796, 0)),\n        (\"lhard;\", (8637, 0)),\n        (\"imped\", (0, 0)),\n        (\"prime;\", (8242, 0)),\n        (\"Uacut\", (0, 0)),\n        (\"NotE\", (0, 0)),\n        (\"Hum\", (0, 0)),\n        (\"NegativeT\", (0, 0)),\n        (\"boxUr;\", (9561, 0)),\n        (\"Impl\", (0, 0)),\n        (\"gd\", (0, 0)),\n        (\"nappro\", (0, 0)),\n        (\"Nsc\", (0, 0)),\n        (\"Subset;\", (8912, 0)),\n        (\"nleftarro\", (0, 0)),\n        (\"leftleftar\", (0, 0)),\n        (\"Ccar\", (0, 0)),\n        (\"Laplace\", (0, 0)),\n        (\"DoubleUpAr\", (0, 0)),\n        (\"lmid\", (0, 0)),\n        (\"Barv\", (0, 0)),\n        (\"THORN\", (222, 0)),\n        (\"infintie;\", (10717, 0)),\n        (\"mlc\", (0, 0)),\n        (\"Abr\", (0, 0)),\n        (\"Lef\", (0, 0)),\n        (\"downharpoonrigh\", (0, 0)),\n        (\"bigvee\", (0, 0)),\n        (\"fjlig;\", (102, 106)),\n        (\"Iscr\", (0, 0)),\n        (\"NotLeft\", (0, 0)),\n        (\"GreaterFullEqual\", (0, 0)),\n        (\"YI\", (0, 0)),\n        (\"NotPrecedesSlantEqual\", (0, 0)),\n        (\"seswar\", (0, 0)),\n        (\"Eps\", (0, 0)),\n        (\"FilledV\", (0, 0)),\n        (\"Integr\", (0, 0)),\n        (\"zeetr\", (0, 0)),\n        (\"subsim\", (0, 0)),\n        (\"ntriangleright\", (0, 0)),\n        (\"doteqdo\", (0, 0)),\n        (\"RightVectorBa\", (0, 0)),\n        (\"jmath\", (0, 0)),\n        (\"an\", (0, 0)),\n        (\"NotSquareSubset\", (0, 0)),\n        (\"nhpar;\", (10994, 0)),\n        (\"nLeftarr\", (0, 0)),\n        (\"vareps\", (0, 0)),\n        (\"frasl\", (0, 0)),\n        (\"CircleP\", (0, 0)),\n        (\"Empt\", (0, 0)),\n        (\"LeftAngleBracket\", (0, 0)),\n        (\"ec\", (0, 0)),\n        (\"perc\", (0, 0)),\n        (\"cent\", (162, 0)),\n        (\"rbrksld\", (0, 0)),\n        (\"Uarr\", (0, 0)),\n        (\"Integ\", (0, 0)),\n        (\"Ffr\", (0, 0)),\n        (\"Dow\", (0, 0)),\n        (\"Ncy;\", (1053, 0)),\n        (\"oac\", (0, 0)),\n        (\"Jci\", (0, 0)),\n        (\"z\", (0, 0)),\n        (\"intlarhk\", (0, 0)),\n        (\"psc\", (0, 0)),\n        (\"Sca\", (0, 0)),\n        (\"THOR\", (0, 0)),\n        (\"ogon;\", (731, 0)),\n        (\"EmptySma\", (0, 0)),\n        (\"ratail;\", (10522, 0)),\n        (\"roplu\", (0, 0)),\n        (\"loplus\", (0, 0)),\n        (\"subseteq;\", (8838, 0)),\n        (\"bsolb\", (0, 0)),\n        (\"subsete\", (0, 0)),\n        (\"notnivb;\", (8958, 0)),\n        (\"lopl\", (0, 0)),\n        (\"Inv\", (0, 0)),\n        (\"gop\", (0, 0)),\n        (\"NotC\", (0, 0)),\n        (\"Es\", (0, 0)),\n        (\"Over\", (0, 0)),\n        (\"Downarrow;\", (8659, 0)),\n        (\"bigtriangle\", (0, 0)),\n        (\"varpropto\", (0, 0)),\n        (\"nltrie;\", (8940, 0)),\n        (\"vellip\", (0, 0)),\n        (\"supsetneq;\", (8843, 0)),\n        (\"LJcy\", (0, 0)),\n        (\"homtht;\", (8763, 0)),\n        (\"Equilibr\", (0, 0)),\n        (\"NotNestedGreaterGrea\", (0, 0)),\n        (\"en\", (0, 0)),\n        (\"LeftFloo\", (0, 0)),\n        (\"cross;\", (10007, 0)),\n        (\"Vertica\", (0, 0)),\n        (\"biguplus;\", (10756, 0)),\n        (\"plu\", (0, 0)),\n        (\"RightUpTeeVe\", (0, 0)),\n        (\"rbb\", (0, 0)),\n        (\"nLeftr\", (0, 0)),\n        (\"Ele\", (0, 0)),\n        (\"gtreqqle\", (0, 0)),\n        (\"straightphi\", (0, 0)),\n        (\"longleftarro\", (0, 0)),\n        (\"lrcorne\", (0, 0)),\n        (\"ropar\", (0, 0)),\n        (\"kcedi\", (0, 0)),\n        (\"Wedg\", (0, 0)),\n        (\"hardcy\", (0, 0)),\n        (\"Rright\", (0, 0)),\n        (\"maps\", (0, 0)),\n        (\"nLl\", (0, 0)),\n        (\"realine;\", (8475, 0)),\n        (\"dcar\", (0, 0)),\n        (\"ddagger;\", (8225, 0)),\n        (\"lhblk\", (0, 0)),\n        (\"LeftTeeVec\", (0, 0)),\n        (\"Qopf\", (0, 0)),\n        (\"Mell\", (0, 0)),\n        (\"lr\", (0, 0)),\n        (\"twixt;\", (8812, 0)),\n        (\"lbrace;\", (123, 0)),\n        (\"csube\", (0, 0)),\n        (\"oacu\", (0, 0)),\n        (\"rarrpl;\", (10565, 0)),\n        (\"Aop\", (0, 0)),\n        (\"frow\", (0, 0)),\n        (\"simlE\", (0, 0)),\n        (\"DownRightVe\", (0, 0)),\n        (\"ClockwiseContourIntegr\", (0, 0)),\n        (\"LeftArrowRightA\", (0, 0)),\n        (\"supsim;\", (10952, 0)),\n        (\"boxHD;\", (9574, 0)),\n        (\"DownLeftTeeV\", (0, 0)),\n        (\"Proportional;\", (8733, 0)),\n        (\"CloseCurlyQuot\", (0, 0)),\n        (\"iuk\", (0, 0)),\n        (\"isindo\", (0, 0)),\n        (\"boxplus;\", (8862, 0)),\n        (\"Dou\", (0, 0)),\n        (\"diams;\", (9830, 0)),\n        (\"swa\", (0, 0)),\n        (\"compfn;\", (8728, 0)),\n        (\"eogo\", (0, 0)),\n        (\"LessEqu\", (0, 0)),\n        (\"UpArrowDown\", (0, 0)),\n        (\"rm\", (0, 0)),\n        (\"lnap;\", (10889, 0)),\n        (\"SOFTcy\", (0, 0)),\n        (\"curvearrowright\", (0, 0)),\n        (\"nld\", (0, 0)),\n        (\"dhar\", (0, 0)),\n        (\"GreaterFullEqua\", (0, 0)),\n        (\"long\", (0, 0)),\n        (\"integer\", (0, 0)),\n        (\"succneqq\", (0, 0)),\n        (\"SOFTcy;\", (1068, 0)),\n        (\"fallingdot\", (0, 0)),\n        (\"Such\", (0, 0)),\n        (\"eca\", (0, 0)),\n        (\"Produ\", (0, 0)),\n        (\"wr;\", (8768, 0)),\n        (\"SHCHcy;\", (1065, 0)),\n        (\"subsim;\", (10951, 0)),\n        (\"tris\", (0, 0)),\n        (\"UpTee\", (0, 0)),\n        (\"DownRightTeeVect\", (0, 0)),\n        (\"No\", (0, 0)),\n        (\"compl\", (0, 0)),\n        (\"NotDoubleVertic\", (0, 0)),\n        (\"nvge;\", (8805, 8402)),\n        (\"psi;\", (968, 0)),\n        (\"cci\", (0, 0)),\n        (\"x\", (0, 0)),\n        (\"rtrie\", (0, 0)),\n        (\"Udb\", (0, 0)),\n        (\"ZeroWidthSpace;\", (8203, 0)),\n        (\"nRight\", (0, 0)),\n        (\"hookrig\", (0, 0)),\n        (\"esim;\", (8770, 0)),\n        (\"Ugra\", (0, 0)),\n        (\"target\", (0, 0)),\n        (\"Gs\", (0, 0)),\n        (\"emsp;\", (8195, 0)),\n        (\"llarr;\", (8647, 0)),\n        (\"che\", (0, 0)),\n        (\"Implie\", (0, 0)),\n        (\"NotLessLes\", (0, 0)),\n        (\"RightUpDownVecto\", (0, 0)),\n        (\"nwarh\", (0, 0)),\n        (\"vs\", (0, 0)),\n        (\"lap\", (0, 0)),\n        (\"awint\", (0, 0)),\n        (\"omacr;\", (333, 0)),\n        (\"si\", (0, 0)),\n        (\"jfr\", (0, 0)),\n        (\"leftrightsquigarrow;\", (8621, 0)),\n        (\"RightDownTeeVec\", (0, 0)),\n        (\"sung;\", (9834, 0)),\n        (\"mstpo\", (0, 0)),\n        (\"dlcr\", (0, 0)),\n        (\"LowerRightAr\", (0, 0)),\n        (\"bb\", (0, 0)),\n        (\"ham\", (0, 0)),\n        (\"smas\", (0, 0)),\n        (\"nwA\", (0, 0)),\n        (\"cemp\", (0, 0)),\n        (\"LongLeftArrow\", (0, 0)),\n        (\"lesseqgtr\", (0, 0)),\n        (\"imof\", (0, 0)),\n        (\"between;\", (8812, 0)),\n        (\"NotPrecedesEq\", (0, 0)),\n        (\"nrA\", (0, 0)),\n        (\"UpperRig\", (0, 0)),\n        (\"CircleMinus\", (0, 0)),\n        (\"boxUl;\", (9564, 0)),\n        (\"mapst\", (0, 0)),\n        (\"KHc\", (0, 0)),\n        (\"SquareSupersetEqu\", (0, 0)),\n        (\"precnapprox\", (0, 0)),\n        (\"Eacute;\", (201, 0)),\n        (\"zacute;\", (378, 0)),\n        (\"Longrighta\", (0, 0)),\n        (\"nsccue;\", (8929, 0)),\n        (\"caro\", (0, 0)),\n        (\"NotGreaterTilde\", (0, 0)),\n        (\"jser\", (0, 0)),\n        (\"beps\", (0, 0)),\n        (\"Negati\", (0, 0)),\n        (\"ShortRightArrow;\", (8594, 0)),\n        (\"nLeftar\", (0, 0)),\n        (\"GreaterE\", (0, 0)),\n        (\"leftrig\", (0, 0)),\n        (\"LessSlantEq\", (0, 0)),\n        (\"ldrus\", (0, 0)),\n        (\"chcy\", (0, 0)),\n        (\"xdt\", (0, 0)),\n        (\"Gdot\", (0, 0)),\n        (\"blackloz\", (0, 0)),\n        (\"DoubleLeftRi\", (0, 0)),\n        (\"Sup;\", (8913, 0)),\n        (\"NotSu\", (0, 0)),\n        (\"Zeta\", (0, 0)),\n        (\"dcaron;\", (271, 0)),\n        (\"udb\", (0, 0)),\n        (\"leftleftarrow\", (0, 0)),\n        (\"Copf\", (0, 0)),\n        (\"NotSucceed\", (0, 0)),\n        (\"DotDot\", (0, 0)),\n        (\"NotVerticalB\", (0, 0)),\n        (\"Vvdash;\", (8874, 0)),\n        (\"trianglerighteq;\", (8885, 0)),\n        (\"szli\", (0, 0)),\n        (\"ntriangleright;\", (8939, 0)),\n        (\"short\", (0, 0)),\n        (\"mop\", (0, 0)),\n        (\"leftrightarrows;\", (8646, 0)),\n        (\"ufi\", (0, 0)),\n        (\"ReverseUpEquilibr\", (0, 0)),\n        (\"Gamma\", (0, 0)),\n        (\"NotLeftT\", (0, 0)),\n        (\"flat;\", (9837, 0)),\n        (\"Pre\", (0, 0)),\n        (\"looparrowright\", (0, 0)),\n        (\"glj\", (0, 0)),\n        (\"boxdL;\", (9557, 0)),\n        (\"ThickSp\", (0, 0)),\n        (\"shortparallel;\", (8741, 0)),\n        (\"dtdot\", (0, 0)),\n        (\"sfrow\", (0, 0)),\n        (\"UpperRightArr\", (0, 0)),\n        (\"suphsub\", (0, 0)),\n        (\"Gcy\", (0, 0)),\n        (\"otilde\", (245, 0)),\n        (\"ldrushar;\", (10571, 0)),\n        (\"nsmid\", (0, 0)),\n        (\"HumpEqual;\", (8783, 0)),\n        (\"THO\", (0, 0)),\n        (\"ReverseUpEquilibrium\", (0, 0)),\n        (\"nVD\", (0, 0)),\n        (\"CircleT\", (0, 0)),\n        (\"Tcaro\", (0, 0)),\n        (\"VerticalBar;\", (8739, 0)),\n        (\"LeftTriangle;\", (8882, 0)),\n        (\"divideont\", (0, 0)),\n        (\"Updown\", (0, 0)),\n        (\"Rcar\", (0, 0)),\n        (\"Dop\", (0, 0)),\n        (\"cues\", (0, 0)),\n        (\"odas\", (0, 0)),\n        (\"Rul\", (0, 0)),\n        (\"UnderParenthesis;\", (9181, 0)),\n        (\"checkm\", (0, 0)),\n        (\"OpenCurlyQuo\", (0, 0)),\n        (\"RoundImpl\", (0, 0)),\n        (\"Bar\", (0, 0)),\n        (\"OpenCurlyDoubleQuote\", (0, 0)),\n        (\"Cscr;\", (119966, 0)),\n        (\"sqsub;\", (8847, 0)),\n        (\"hsla\", (0, 0)),\n        (\"orderof;\", (8500, 0)),\n        (\"mfr\", (0, 0)),\n        (\"ldca;\", (10550, 0)),\n        (\"Jcir\", (0, 0)),\n        (\"yop\", (0, 0)),\n        (\"DoubleContourI\", (0, 0)),\n        (\"Uacute\", (218, 0)),\n        (\"ll\", (0, 0)),\n        (\"DoubleV\", (0, 0)),\n        (\"diams\", (0, 0)),\n        (\"vsu\", (0, 0)),\n        (\"csc\", (0, 0)),\n        (\"backco\", (0, 0)),\n        (\"orarr;\", (8635, 0)),\n        (\"dig\", (0, 0)),\n        (\"hksearow;\", (10533, 0)),\n        (\"nvlArr\", (0, 0)),\n        (\"NotNestedGreate\", (0, 0)),\n        (\"demptyv\", (0, 0)),\n        (\"Vvdas\", (0, 0)),\n        (\"boxUr\", (0, 0)),\n        (\"Th\", (0, 0)),\n        (\"circlearrowrigh\", (0, 0)),\n        (\"Hor\", (0, 0)),\n        (\"CirclePlu\", (0, 0)),\n        (\"jopf\", (0, 0)),\n        (\"DDotr\", (0, 0)),\n        (\"rAa\", (0, 0)),\n        (\"circled\", (0, 0)),\n        (\"pointin\", (0, 0)),\n        (\"varsubsetn\", (0, 0)),\n        (\"lfish\", (0, 0)),\n        (\"DownRightV\", (0, 0)),\n        (\"varsupsetneqq;\", (10956, 65024)),\n        (\"drcorn;\", (8991, 0)),\n        (\"integers;\", (8484, 0)),\n        (\"NotSquareSubsetE\", (0, 0)),\n        (\"UpArrow;\", (8593, 0)),\n        (\"lver\", (0, 0)),\n        (\"iiin\", (0, 0)),\n        (\"NotGreaterGr\", (0, 0)),\n        (\"gnap\", (0, 0)),\n        (\"measuredang\", (0, 0)),\n        (\"bott\", (0, 0)),\n        (\"aacu\", (0, 0)),\n        (\"xnis;\", (8955, 0)),\n        (\"planck\", (0, 0)),\n        (\"Uogon\", (0, 0)),\n        (\"Xi\", (0, 0)),\n        (\"dlco\", (0, 0)),\n        (\"Longleftrightar\", (0, 0)),\n        (\"Equilibri\", (0, 0)),\n        (\"Iog\", (0, 0)),\n        (\"cce\", (0, 0)),\n        (\"smt\", (0, 0)),\n        (\"DownRightTeeVector\", (0, 0)),\n        (\"zwnj\", (0, 0)),\n        (\"iacut\", (0, 0)),\n        (\"Longr\", (0, 0)),\n        (\"DownLeftRightVecto\", (0, 0)),\n        (\"Bcy\", (0, 0)),\n        (\"wedge;\", (8743, 0)),\n        (\"wci\", (0, 0)),\n        (\"dzig\", (0, 0)),\n        (\"xvee\", (0, 0)),\n        (\"UnderBra\", (0, 0)),\n        (\"ccirc\", (0, 0)),\n        (\"Elemen\", (0, 0)),\n        (\"ltd\", (0, 0)),\n        (\"lesssi\", (0, 0)),\n        (\"ngE;\", (8807, 824)),\n        (\"lbrksl\", (0, 0)),\n        (\"CounterClockwis\", (0, 0)),\n        (\"dotm\", (0, 0)),\n        (\"NegativeThickSpace;\", (8203, 0)),\n        (\"Bernoullis\", (0, 0)),\n        (\"CounterClock\", (0, 0)),\n        (\"CounterCl\", (0, 0)),\n        (\"Und\", (0, 0)),\n        (\"eu\", (0, 0)),\n        (\"wed\", (0, 0)),\n        (\"bsc\", (0, 0)),\n        (\"Uarroc\", (0, 0)),\n        (\"dwan\", (0, 0)),\n        (\"hooklef\", (0, 0)),\n        (\"InvisibleTi\", (0, 0)),\n        (\"kcy;\", (1082, 0)),\n        (\"Star\", (0, 0)),\n        (\"kappav\", (0, 0)),\n        (\"eth;\", (240, 0)),\n        (\"DiacriticalAcute;\", (180, 0)),\n        (\"acirc\", (226, 0)),\n        (\"HARDcy\", (0, 0)),\n        (\"NotPrecedesE\", (0, 0)),\n        (\"bowt\", (0, 0)),\n        (\"abr\", (0, 0)),\n        (\"loop\", (0, 0)),\n        (\"upharpoonle\", (0, 0)),\n        (\"bigsqcu\", (0, 0)),\n        (\"pi\", (0, 0)),\n        (\"rn\", (0, 0)),\n        (\"boxvr;\", (9500, 0)),\n        (\"angms\", (0, 0)),\n        (\"blacktria\", (0, 0)),\n        (\"LongRi\", (0, 0)),\n        (\"LeftF\", (0, 0)),\n        (\"Ch\", (0, 0)),\n        (\"UpDo\", (0, 0)),\n        (\"Aacute\", (193, 0)),\n        (\"eqslantle\", (0, 0)),\n        (\"dlcrop\", (0, 0)),\n        (\"emptyse\", (0, 0)),\n        (\"al\", (0, 0)),\n        (\"EmptyVerySmall\", (0, 0)),\n        (\"DownLeftRightV\", (0, 0)),\n        (\"sa\", (0, 0)),\n        (\"ver\", (0, 0)),\n        (\"preccurlyeq;\", (8828, 0)),\n        (\"Congrue\", (0, 0)),\n        (\"Hat;\", (94, 0)),\n        (\"nesim;\", (8770, 824)),\n        (\"coloneq\", (0, 0)),\n        (\"Alp\", (0, 0)),\n        (\"boxuL\", (0, 0)),\n        (\"smep\", (0, 0)),\n        (\"LowerLeftArr\", (0, 0)),\n        (\"nges;\", (10878, 824)),\n        (\"primes\", (0, 0)),\n        (\"hookleftar\", (0, 0)),\n        (\"ClockwiseContourIntegral;\", (8754, 0)),\n        (\"roplus;\", (10798, 0)),\n        (\"ntriangle\", (0, 0)),\n        (\"xwedge\", (0, 0)),\n        (\"rights\", (0, 0)),\n        (\"lmousta\", (0, 0)),\n        (\"Auml\", (196, 0)),\n        (\"RightDoubleBr\", (0, 0)),\n        (\"circledda\", (0, 0)),\n        (\"Cacu\", (0, 0)),\n        (\"uacu\", (0, 0)),\n        (\"precappro\", (0, 0)),\n        (\"targ\", (0, 0)),\n        (\"sqcup;\", (8852, 0)),\n        (\"Aacut\", (0, 0)),\n        (\"vzigzag\", (0, 0)),\n        (\"strai\", (0, 0)),\n        (\"LeftTriangleB\", (0, 0)),\n        (\"NotLessGreate\", (0, 0)),\n        (\"Po\", (0, 0)),\n        (\"cirfnin\", (0, 0)),\n        (\"nshor\", (0, 0)),\n        (\"bp\", (0, 0)),\n        (\"ograve;\", (242, 0)),\n        (\"ugrav\", (0, 0)),\n        (\"hkswar\", (0, 0)),\n        (\"tf\", (0, 0)),\n        (\"dstrok\", (0, 0)),\n        (\"rarrf\", (0, 0)),\n        (\"oelig\", (0, 0)),\n        (\"Dstrok\", (0, 0)),\n        (\"gam\", (0, 0)),\n        (\"sqsubse\", (0, 0)),\n        (\"Jsc\", (0, 0)),\n        (\"Supers\", (0, 0)),\n        (\"kappav;\", (1008, 0)),\n        (\"curar\", (0, 0)),\n        (\"ino\", (0, 0)),\n        (\"angrtvb\", (0, 0)),\n        (\"os\", (0, 0)),\n        (\"lbb\", (0, 0)),\n        (\"frac16\", (0, 0)),\n        (\"gtdot;\", (8919, 0)),\n        (\"Kopf;\", (120130, 0)),\n        (\"prurel;\", (8880, 0)),\n        (\"THORN;\", (222, 0)),\n        (\"TildeTi\", (0, 0)),\n        (\"lBar\", (0, 0)),\n        (\"blacktriangleleft\", (0, 0)),\n        (\"dlcrop;\", (8973, 0)),\n        (\"CounterClockwise\", (0, 0)),\n        (\"isinv\", (0, 0)),\n        (\"Proportion\", (0, 0)),\n        (\"DownRightVectorBa\", (0, 0)),\n        (\"mp;\", (8723, 0)),\n        (\"varn\", (0, 0)),\n        (\"LessSlantEqua\", (0, 0)),\n        (\"mco\", (0, 0)),\n        (\"Jse\", (0, 0)),\n        (\"rthre\", (0, 0)),\n        (\"Udbla\", (0, 0)),\n        (\"NegativeThickSp\", (0, 0)),\n        (\"LongLeftRigh\", (0, 0)),\n        (\"Theta;\", (920, 0)),\n        (\"wscr\", (0, 0)),\n        (\"SquareSuper\", (0, 0)),\n        (\"nap\", (0, 0)),\n        (\"gtqu\", (0, 0)),\n        (\"doublebarwe\", (0, 0)),\n        (\"ssetm\", (0, 0)),\n        (\"longrighta\", (0, 0)),\n        (\"PrecedesT\", (0, 0)),\n        (\"lop\", (0, 0)),\n        (\"Itilde;\", (296, 0)),\n        (\"sup2\", (178, 0)),\n        (\"RuleD\", (0, 0)),\n        (\"Fouriertrf\", (0, 0)),\n        (\"flli\", (0, 0)),\n        (\"multima\", (0, 0)),\n        (\"Delta;\", (916, 0)),\n        (\"DoubleLon\", (0, 0)),\n        (\"rBarr\", (0, 0)),\n        (\"smal\", (0, 0)),\n        (\"DownLeftVect\", (0, 0)),\n        (\"Rfr;\", (8476, 0)),\n        (\"LeftU\", (0, 0)),\n        (\"helli\", (0, 0)),\n        (\"Gammad;\", (988, 0)),\n        (\"righthar\", (0, 0)),\n        (\"nsce\", (0, 0)),\n        (\"spar\", (0, 0)),\n        (\"nGt;\", (8811, 8402)),\n        (\"ud\", (0, 0)),\n        (\"varpi\", (0, 0)),\n        (\"Og\", (0, 0)),\n        (\"Leftarr\", (0, 0)),\n        (\"Mediu\", (0, 0)),\n        (\"plusmn;\", (177, 0)),\n        (\"RightTriangle\", (0, 0)),\n        (\"ncon\", (0, 0)),\n        (\"Nca\", (0, 0)),\n        (\"napE\", (0, 0)),\n        (\"succneqq;\", (10934, 0)),\n        (\"Ubrc\", (0, 0)),\n        (\"divide;\", (247, 0)),\n        (\"kg\", (0, 0)),\n        (\"topcir;\", (10993, 0)),\n        (\"LeftDownTee\", (0, 0)),\n        (\"NegativeVeryTh\", (0, 0)),\n        (\"fema\", (0, 0)),\n        (\"frac15\", (0, 0)),\n        (\"scn\", (0, 0)),\n        (\"RightTeeVe\", (0, 0)),\n        (\"blackl\", (0, 0)),\n        (\"Shor\", (0, 0)),\n        (\"DoubleLeftArrow;\", (8656, 0)),\n        (\"Rr\", (0, 0)),\n        (\"ngeqq\", (0, 0)),\n        (\"Uarrocir;\", (10569, 0)),\n        (\"NotRev\", (0, 0)),\n        (\"NotDoubleVerti\", (0, 0)),\n        (\"Lcar\", (0, 0)),\n        (\"LeftTeeArr\", (0, 0)),\n        (\"supsu\", (0, 0)),\n        (\"PrecedesTi\", (0, 0)),\n        (\"oci\", (0, 0)),\n        (\"angm\", (0, 0)),\n        (\"fsc\", (0, 0)),\n        (\"complem\", (0, 0)),\n        (\"straightphi;\", (981, 0)),\n        (\"sqsupe;\", (8850, 0)),\n        (\"LongRightArrow;\", (10230, 0)),\n        (\"dbla\", (0, 0)),\n        (\"Psi;\", (936, 0)),\n        (\"drbk\", (0, 0)),\n        (\"ring;\", (730, 0)),\n        (\"leftleftarrows;\", (8647, 0)),\n        (\"ntrianglerighteq;\", (8941, 0)),\n        (\"updownarro\", (0, 0)),\n        (\"hsl\", (0, 0)),\n        (\"ClockwiseCo\", (0, 0)),\n        (\"imath\", (0, 0)),\n        (\"LeftTeeA\", (0, 0)),\n        (\"hstro\", (0, 0)),\n        (\"NotHum\", (0, 0)),\n        (\"Re;\", (8476, 0)),\n        (\"ycir\", (0, 0)),\n        (\"subsu\", (0, 0)),\n        (\"wre\", (0, 0)),\n        (\"cwconint\", (0, 0)),\n        (\"NotSucceedsTild\", (0, 0)),\n        (\"ntrian\", (0, 0)),\n        (\"lHar\", (0, 0)),\n        (\"Prime\", (0, 0)),\n        (\"SmallCircl\", (0, 0)),\n        (\"Backsl\", (0, 0)),\n        (\"euml;\", (235, 0)),\n        (\"ntl\", (0, 0)),\n        (\"Fop\", (0, 0)),\n        (\"lcy;\", (1083, 0)),\n        (\"doublebarw\", (0, 0)),\n        (\"Oac\", (0, 0)),\n        (\"zdot;\", (380, 0)),\n        (\"ReverseUpEqu\", (0, 0)),\n        (\"ucir\", (0, 0)),\n        (\"Interse\", (0, 0)),\n        (\"Otilde;\", (213, 0)),\n        (\"rflo\", (0, 0)),\n        (\"LeftVectorBar\", (0, 0)),\n        (\"gtrsim\", (0, 0)),\n        (\"subn\", (0, 0)),\n        (\"spar;\", (8741, 0)),\n        (\"Tc\", (0, 0)),\n        (\"UpArr\", (0, 0)),\n        (\"Ccir\", (0, 0)),\n        (\"RightAngleBracket\", (0, 0)),\n        (\"udarr\", (0, 0)),\n        (\"uwan\", (0, 0)),\n        (\"club\", (0, 0)),\n        (\"lopf;\", (120157, 0)),\n        (\"xharr\", (0, 0)),\n        (\"xma\", (0, 0)),\n        (\"ltci\", (0, 0)),\n        (\"nw\", (0, 0)),\n        (\"FilledVerySm\", (0, 0)),\n        (\"hs\", (0, 0)),\n        (\"UpperLeftArrow\", (0, 0)),\n        (\"NotSuperset\", (0, 0)),\n        (\"SHCHc\", (0, 0)),\n        (\"Rscr\", (0, 0)),\n        (\"FilledVerySma\", (0, 0)),\n        (\"trimin\", (0, 0)),\n        (\"uring;\", (367, 0)),\n        (\"lAtai\", (0, 0)),\n        (\"Equilib\", (0, 0)),\n        (\"varpropt\", (0, 0)),\n        (\"inod\", (0, 0)),\n        (\"Longrightarrow;\", (10233, 0)),\n        (\"Yf\", (0, 0)),\n        (\"Bo\", (0, 0)),\n        (\"Round\", (0, 0)),\n        (\"capb\", (0, 0)),\n        (\"ecir\", (0, 0)),\n        (\"NotHumpDownHump\", (0, 0)),\n        (\"curarrm\", (0, 0)),\n        (\"Aac\", (0, 0)),\n        (\"lthree;\", (8907, 0)),\n        (\"olcir\", (0, 0)),\n        (\"Intersection;\", (8898, 0)),\n    ],\n};\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","src","api","auth.rs"],"content":"//! User authentication and management API endpoints\n//!\n//! Provides endpoints for login, registration, profile management,\n//! admin user management, and initial setup.\n\nuse actix_web::{delete, get, post, put, web, HttpRequest, HttpResponse, Responder, Result};\nuse deadpool_postgres::Pool;\nuse log::{error, info, warn};\nuse rand::distributions::Alphanumeric;\nuse rand::Rng;\nuse uuid::Uuid;\n\nuse crate::auth::{\n    extract_token, generate_token, hash_password, validate_password, validate_username,\n    verify_password, verify_token, AuthContext,\n};\nuse crate::db::DatabaseService;\nuse crate::models::{\n    AdminCreateUserRequest, AdminUpdateUserRequest, ApiResponse, ChangePasswordRequest,\n    ConfirmRecoveryCodesRequest, CreateInventoryShareRequest, CreateUserAccessGrantRequest,\n    ErrorResponse, InitialSetupRequest, LoginRequest, LoginResponse, PermissionSource,\n    RecoveryCodeUsedResponse, RecoveryCodesResponse, RecoveryCodesStatus, SetupStatusResponse,\n    TransferOwnershipRequest, TransferOwnershipResponse, UpdateInventoryShareRequest,\n    UpdateProfileRequest, UpdateUserSettingsRequest, UseRecoveryCodeRequest, UserResponse,\n};\n\n// ==================== Helper Functions ====================\n\n/// Extract and verify auth context from request\npub async fn get_auth_context_from_request(\n    req: &HttpRequest,\n    pool: &Pool,\n) -> Result<AuthContext, HttpResponse> {\n    let Some(token) = extract_token(req) else {\n        return Err(HttpResponse::Unauthorized().json(ErrorResponse {\n            success: false,\n            error: \"No authentication token provided\".to_string(),\n            message: Some(\"Please log in to access this resource\".to_string()),\n        }));\n    };\n\n    let claims = match verify_token(&token) {\n        Ok(c) => c,\n        Err(e) => {\n            return Err(HttpResponse::Unauthorized().json(ErrorResponse {\n                success: false,\n                error: format!(\"Invalid token: {e}\"),\n                message: Some(\"Please log in again\".to_string()),\n            }));\n        },\n    };\n\n    let Ok(auth_ctx) = AuthContext::from_claims(&claims) else {\n        return Err(HttpResponse::Unauthorized().json(ErrorResponse {\n            success: false,\n            error: \"Invalid user ID in token\".to_string(),\n            message: Some(\"Please log in again\".to_string()),\n        }));\n    };\n\n    // Verify user still exists and is active\n    let db_service = DatabaseService::new(pool.clone());\n    match db_service.get_user_by_id(auth_ctx.user_id).await {\n        Ok(Some(user)) => {\n            if !user.is_active {\n                return Err(HttpResponse::Forbidden().json(ErrorResponse {\n                    success: false,\n                    error: \"Account is deactivated\".to_string(),\n                    message: Some(\n                        \"Your account has been deactivated. Contact an administrator.\".to_string(),\n                    ),\n                }));\n            }\n        },\n        Ok(None) => {\n            return Err(HttpResponse::Unauthorized().json(ErrorResponse {\n                success: false,\n                error: \"User not found\".to_string(),\n                message: Some(\"Please log in again\".to_string()),\n            }));\n        },\n        Err(e) => {\n            error!(\"Database error verifying user: {}\", e);\n            return Err(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Database error\".to_string(),\n                message: Some(\"Unable to verify user\".to_string()),\n            }));\n        },\n    }\n\n    Ok(auth_ctx)\n}\n\n/// Require admin privileges\npub async fn require_admin(req: &HttpRequest, pool: &Pool) -> Result<AuthContext, HttpResponse> {\n    let auth_ctx = get_auth_context_from_request(req, pool).await?;\n\n    if !auth_ctx.is_admin {\n        return Err(HttpResponse::Forbidden().json(ErrorResponse {\n            success: false,\n            error: \"Admin privileges required\".to_string(),\n            message: Some(\"You don't have permission to access this resource\".to_string()),\n        }));\n    }\n\n    Ok(auth_ctx)\n}\n\n// ==================== Public Endpoints ====================\n\n/// Check if initial setup is needed (no users exist)\n#[get(\"/auth/setup/status\")]\npub async fn get_setup_status(pool: web::Data<Pool>) -> Result<impl Responder> {\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_user_count().await {\n        Ok(count) => Ok(HttpResponse::Ok().json(ApiResponse {\n            success: true,\n            data: Some(SetupStatusResponse {\n                needs_setup: count == 0,\n                user_count: count,\n            }),\n            message: None,\n            error: None,\n        })),\n        Err(e) => {\n            error!(\"Error checking setup status: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to check setup status\".to_string()),\n            }))\n        },\n    }\n}\n\n/// Initial setup - create first admin user (only works when no users exist)\n#[post(\"/auth/setup\")]\npub async fn initial_setup(\n    pool: web::Data<Pool>,\n    req: web::Json<InitialSetupRequest>,\n) -> Result<impl Responder> {\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Verify no users exist\n    match db_service.get_user_count().await {\n        Ok(count) if count > 0 => {\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Setup already completed\".to_string(),\n                message: Some(\"An admin user already exists\".to_string()),\n            }));\n        },\n        Err(e) => {\n            error!(\"Error checking user count: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to check setup status\".to_string()),\n            }));\n        },\n        _ => {},\n    }\n\n    // Validate input\n    if let Err(msg) = validate_username(&req.username) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: msg.to_string(),\n            message: Some(\"Invalid username\".to_string()),\n        }));\n    }\n    if let Err(msg) = validate_password(&req.password) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: msg.to_string(),\n            message: Some(\"Invalid password\".to_string()),\n        }));\n    }\n\n    // Hash password\n    let password_hash = match hash_password(req.password.clone()).await {\n        Ok(hash) => hash,\n        Err(e) => {\n            error!(\"Error hashing password: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to hash password\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Create admin user\n    let user = match db_service\n        .create_user(\n            &req.username,\n            &req.full_name,\n            &password_hash,\n            true, // is_admin\n            true, // is_active\n        )\n        .await\n    {\n        Ok(u) => u,\n        Err(e) => {\n            error!(\"Error creating admin user: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: format!(\"Failed to create user: {e}\"),\n                message: None,\n            }));\n        },\n    };\n\n    // Create default settings for user\n    if let Err(e) = db_service.create_user_settings(user.id).await {\n        warn!(\"Failed to create user settings: {}\", e);\n    }\n\n    // Generate token\n    let token = match generate_token(&user) {\n        Ok(t) => t,\n        Err(e) => {\n            error!(\"Error generating token: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to generate token\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    info!(\n        \"Initial setup completed - created admin user: {}\",\n        user.username\n    );\n\n    Ok(HttpResponse::Created().json(ApiResponse {\n        success: true,\n        data: Some(LoginResponse {\n            token,\n            user: user.into(),\n        }),\n        message: Some(\"Setup completed successfully\".to_string()),\n        error: None,\n    }))\n}\n\n/// User login\n#[post(\"/auth/login\")]\npub async fn login(pool: web::Data<Pool>, req: web::Json<LoginRequest>) -> Result<impl Responder> {\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Find user by username\n    let user = match db_service.get_user_by_username(&req.username).await {\n        Ok(Some(u)) => u,\n        Ok(None) => {\n            // Don't reveal whether username exists\n            return Ok(HttpResponse::Unauthorized().json(ErrorResponse {\n                success: false,\n                error: \"Invalid credentials\".to_string(),\n                message: Some(\"Username or password is incorrect\".to_string()),\n            }));\n        },\n        Err(e) => {\n            error!(\"Database error during login: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Database error\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Check if user is active\n    if !user.is_active {\n        return Ok(HttpResponse::Forbidden().json(ErrorResponse {\n            success: false,\n            error: \"Account deactivated\".to_string(),\n            message: Some(\n                \"Your account has been deactivated. Contact an administrator.\".to_string(),\n            ),\n        }));\n    }\n\n    // Verify password\n    let password_valid =\n        match verify_password(req.password.clone(), user.password_hash.clone()).await {\n            Ok(valid) => valid,\n            Err(e) => {\n                error!(\"Error verifying password: {}\", e);\n                return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                    success: false,\n                    error: \"Password verification failed\".to_string(),\n                    message: None,\n                }));\n            },\n        };\n\n    if !password_valid {\n        return Ok(HttpResponse::Unauthorized().json(ErrorResponse {\n            success: false,\n            error: \"Invalid credentials\".to_string(),\n            message: Some(\"Username or password is incorrect\".to_string()),\n        }));\n    }\n\n    // Generate token\n    let token = match generate_token(&user) {\n        Ok(t) => t,\n        Err(e) => {\n            error!(\"Error generating token: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to generate token\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    info!(\"User logged in: {}\", user.username);\n\n    Ok(HttpResponse::Ok().json(ApiResponse {\n        success: true,\n        data: Some(LoginResponse {\n            token,\n            user: user.into(),\n        }),\n        message: Some(\"Login successful\".to_string()),\n        error: None,\n    }))\n}\n\n/// Register new user (public registration after initial setup)\n#[post(\"/auth/register\")]\npub async fn register(\n    pool: web::Data<Pool>,\n    req: web::Json<crate::models::CreateUserRequest>,\n) -> Result<impl Responder> {\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Check that at least one user exists (initial setup has been done)\n    match db_service.get_user_count().await {\n        Ok(0) => {\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Initial setup required\".to_string(),\n                message: Some(\n                    \"Please complete the initial setup before registering users\".to_string(),\n                ),\n            }));\n        },\n        Err(e) => {\n            error!(\"Database error checking user count: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Database error\".to_string(),\n                message: None,\n            }));\n        },\n        _ => {},\n    }\n\n    // Validate username\n    if let Err(msg) = validate_username(&req.username) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: msg.to_string(),\n            message: Some(\"Invalid username\".to_string()),\n        }));\n    }\n\n    // Validate password\n    if let Err(msg) = validate_password(&req.password) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: msg.to_string(),\n            message: Some(\"Invalid password\".to_string()),\n        }));\n    }\n\n    // Check if username already exists\n    if let Ok(Some(_)) = db_service.get_user_by_username(&req.username).await {\n        return Ok(HttpResponse::Conflict().json(ErrorResponse {\n            success: false,\n            error: \"Username already taken\".to_string(),\n            message: Some(\"Please choose a different username\".to_string()),\n        }));\n    }\n\n    // Hash password\n    let password_hash = match hash_password(req.password.clone()).await {\n        Ok(hash) => hash,\n        Err(e) => {\n            error!(\"Error hashing password: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to process password\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Create user (non-admin, active)\n    let user = match db_service\n        .create_user(\n            &req.username,\n            &req.full_name,\n            &password_hash,\n            false, // not admin\n            true,  // active\n        )\n        .await\n    {\n        Ok(u) => u,\n        Err(e) => {\n            error!(\"Error creating user: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to create account\".to_string()),\n            }));\n        },\n    };\n\n    // Create default settings for the user\n    if let Err(e) = db_service.create_user_settings(user.id).await {\n        warn!(\n            \"Failed to create user settings for {}: {}\",\n            user.username, e\n        );\n    }\n\n    // Generate token for immediate login\n    let token = match generate_token(&user) {\n        Ok(t) => t,\n        Err(e) => {\n            error!(\"Error generating token: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Account created but login failed\".to_string(),\n                message: Some(\"Please log in manually\".to_string()),\n            }));\n        },\n    };\n\n    info!(\"New user registered: {}\", user.username);\n\n    Ok(HttpResponse::Created().json(ApiResponse {\n        success: true,\n        data: Some(LoginResponse {\n            token,\n            user: user.into(),\n        }),\n        message: Some(\"Registration successful\".to_string()),\n        error: None,\n    }))\n}\n\n// ==================== Authenticated User Endpoints ====================\n\n/// Get current user's profile\n#[get(\"/auth/me\")]\npub async fn get_current_user(pool: web::Data<Pool>, req: HttpRequest) -> Result<impl Responder> {\n    let auth_ctx = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(ctx) => ctx,\n        Err(response) => return Ok(response),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_user_by_id(auth_ctx.user_id).await {\n        Ok(Some(user)) => Ok(HttpResponse::Ok().json(ApiResponse {\n            success: true,\n            data: Some(UserResponse::from(user)),\n            message: None,\n            error: None,\n        })),\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"User not found\".to_string(),\n            message: None,\n        })),\n        Err(e) => {\n            error!(\"Error getting user profile: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Update current user's profile\n#[put(\"/auth/me\")]\npub async fn update_current_user(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    body: web::Json<UpdateProfileRequest>,\n) -> Result<impl Responder> {\n    let auth_ctx = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(ctx) => ctx,\n        Err(response) => return Ok(response),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .update_user_profile(auth_ctx.user_id, body.full_name.as_deref())\n        .await\n    {\n        Ok(Some(user)) => {\n            info!(\"User {} updated their profile\", auth_ctx.username);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(UserResponse::from(user)),\n                message: Some(\"Profile updated successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"User not found\".to_string(),\n            message: None,\n        })),\n        Err(e) => {\n            error!(\"Error updating user profile: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Change current user's password\n#[put(\"/auth/password\")]\npub async fn change_password(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    body: web::Json<ChangePasswordRequest>,\n) -> Result<impl Responder> {\n    let auth_ctx = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(ctx) => ctx,\n        Err(response) => return Ok(response),\n    };\n\n    // Validate new password\n    if let Err(msg) = validate_password(&body.new_password) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: msg.to_string(),\n            message: Some(\"Invalid new password\".to_string()),\n        }));\n    }\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Get user to verify current password\n    let user = match db_service.get_user_by_id(auth_ctx.user_id).await {\n        Ok(Some(u)) => u,\n        Ok(None) => {\n            return Ok(HttpResponse::NotFound().json(ErrorResponse {\n                success: false,\n                error: \"User not found\".to_string(),\n                message: None,\n            }));\n        },\n        Err(e) => {\n            error!(\"Error getting user: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Database error\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Verify current password\n    let password_valid =\n        match verify_password(body.current_password.clone(), user.password_hash).await {\n            Ok(valid) => valid,\n            Err(e) => {\n                error!(\"Error verifying password: {}\", e);\n                return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                    success: false,\n                    error: \"Password verification failed\".to_string(),\n                    message: None,\n                }));\n            },\n        };\n\n    if !password_valid {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Current password is incorrect\".to_string(),\n            message: None,\n        }));\n    }\n\n    // Hash new password\n    let password_hash = match hash_password(body.new_password.clone()).await {\n        Ok(hash) => hash,\n        Err(e) => {\n            error!(\"Error hashing password: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to hash password\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Update password\n    if let Err(e) = db_service\n        .update_user_password(auth_ctx.user_id, &password_hash)\n        .await\n    {\n        error!(\"Error updating password: {}\", e);\n        return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n            success: false,\n            error: \"Failed to update password\".to_string(),\n            message: None,\n        }));\n    }\n\n    info!(\"User {} changed their password\", auth_ctx.username);\n\n    Ok(HttpResponse::Ok().json(ApiResponse {\n        success: true,\n        data: None::<()>,\n        message: Some(\"Password changed successfully\".to_string()),\n        error: None,\n    }))\n}\n\n// ==================== User Settings Endpoints ====================\n\n/// Get current user's settings\n#[get(\"/auth/settings\")]\npub async fn get_user_settings(pool: web::Data<Pool>, req: HttpRequest) -> Result<impl Responder> {\n    let auth_ctx = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(ctx) => ctx,\n        Err(response) => return Ok(response),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .get_or_create_user_settings(auth_ctx.user_id)\n        .await\n    {\n        Ok(settings) => Ok(HttpResponse::Ok().json(ApiResponse {\n            success: true,\n            data: Some(settings),\n            message: None,\n            error: None,\n        })),\n        Err(e) => {\n            error!(\"Error getting user settings: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Update current user's settings\n#[put(\"/auth/settings\")]\npub async fn update_user_settings(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    body: web::Json<UpdateUserSettingsRequest>,\n) -> Result<impl Responder> {\n    let auth_ctx = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(ctx) => ctx,\n        Err(response) => return Ok(response),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Ensure settings exist\n    let _ = db_service\n        .get_or_create_user_settings(auth_ctx.user_id)\n        .await;\n\n    match db_service\n        .update_user_settings(auth_ctx.user_id, body.into_inner())\n        .await\n    {\n        Ok(Some(settings)) => Ok(HttpResponse::Ok().json(ApiResponse {\n            success: true,\n            data: Some(settings),\n            message: Some(\"Settings updated successfully\".to_string()),\n            error: None,\n        })),\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"Settings not found\".to_string(),\n            message: None,\n        })),\n        Err(e) => {\n            error!(\"Error updating user settings: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n// ==================== Admin User Management Endpoints ====================\n\n/// Get all users (admin only)\n#[get(\"/admin/users\")]\npub async fn admin_get_users(pool: web::Data<Pool>, req: HttpRequest) -> Result<impl Responder> {\n    let _auth_ctx = match require_admin(&req, pool.get_ref()).await {\n        Ok(ctx) => ctx,\n        Err(response) => return Ok(response),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_all_users().await {\n        Ok(users) => Ok(HttpResponse::Ok().json(ApiResponse {\n            success: true,\n            data: Some(users.clone()),\n            message: Some(format!(\"Retrieved {count} users\", count = users.len())),\n            error: None,\n        })),\n        Err(e) => {\n            error!(\"Error getting users: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Get a specific user (admin only)\n#[get(\"/admin/users/{id}\")]\npub async fn admin_get_user(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<Uuid>,\n) -> Result<impl Responder> {\n    let _auth_ctx = match require_admin(&req, pool.get_ref()).await {\n        Ok(ctx) => ctx,\n        Err(response) => return Ok(response),\n    };\n\n    let user_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_user_by_id(user_id).await {\n        Ok(Some(user)) => Ok(HttpResponse::Ok().json(ApiResponse {\n            success: true,\n            data: Some(UserResponse::from(user)),\n            message: None,\n            error: None,\n        })),\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"User not found\".to_string(),\n            message: None,\n        })),\n        Err(e) => {\n            error!(\"Error getting user: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Create a new user (admin only)\n#[post(\"/admin/users\")]\npub async fn admin_create_user(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    body: web::Json<AdminCreateUserRequest>,\n) -> Result<impl Responder> {\n    let _auth_ctx = match require_admin(&req, pool.get_ref()).await {\n        Ok(ctx) => ctx,\n        Err(response) => return Ok(response),\n    };\n\n    // Validate input\n    if let Err(msg) = validate_username(&body.username) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: msg.to_string(),\n            message: Some(\"Invalid username\".to_string()),\n        }));\n    }\n    if let Err(msg) = validate_password(&body.password) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: msg.to_string(),\n            message: Some(\"Invalid password\".to_string()),\n        }));\n    }\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Check if username already exists\n    if let Ok(Some(_)) = db_service.get_user_by_username(&body.username).await {\n        return Ok(HttpResponse::Conflict().json(ErrorResponse {\n            success: false,\n            error: \"Username already exists\".to_string(),\n            message: None,\n        }));\n    }\n\n    // Hash password\n    let password_hash = match hash_password(body.password.clone()).await {\n        Ok(hash) => hash,\n        Err(e) => {\n            error!(\"Error hashing password: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to hash password\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Create user\n    match db_service\n        .create_user(\n            &body.username,\n            &body.full_name,\n            &password_hash,\n            body.is_admin,\n            body.is_active,\n        )\n        .await\n    {\n        Ok(user) => {\n            // Create default settings\n            let _ = db_service.create_user_settings(user.id).await;\n\n            info!(\"Admin created new user: {}\", user.username);\n            Ok(HttpResponse::Created().json(ApiResponse {\n                success: true,\n                data: Some(UserResponse::from(user)),\n                message: Some(\"User created successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error creating user: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: format!(\"Failed to create user: {e}\"),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Update a user (admin only)\n#[put(\"/admin/users/{id}\")]\npub async fn admin_update_user(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<Uuid>,\n    body: web::Json<AdminUpdateUserRequest>,\n) -> Result<impl Responder> {\n    let auth_ctx = match require_admin(&req, pool.get_ref()).await {\n        Ok(ctx) => ctx,\n        Err(response) => return Ok(response),\n    };\n\n    let user_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Validate username if provided\n    if let Some(ref username) = body.username {\n        if let Err(msg) = validate_username(username) {\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: msg.to_string(),\n                message: Some(\"Invalid username\".to_string()),\n            }));\n        }\n    }\n\n    // Prevent admin from demoting themselves\n    if user_id == auth_ctx.user_id {\n        if let Some(false) = body.is_admin {\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Cannot remove your own admin privileges\".to_string(),\n                message: None,\n            }));\n        }\n        if let Some(false) = body.is_active {\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Cannot deactivate your own account\".to_string(),\n                message: None,\n            }));\n        }\n    }\n\n    // Protect last admin\n    if let Some(false) = body.is_admin {\n        let admin_count = db_service.count_admin_users().await.unwrap_or(0);\n        if admin_count <= 1 {\n            let target_user = db_service.get_user_by_id(user_id).await.ok().flatten();\n            if target_user.is_some_and(|u| u.is_admin) {\n                return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                    success: false,\n                    error: \"Cannot remove admin privileges from the last admin\".to_string(),\n                    message: None,\n                }));\n            }\n        }\n    }\n\n    match db_service\n        .admin_update_user(user_id, body.into_inner())\n        .await\n    {\n        Ok(Some(user)) => {\n            info!(\"Admin updated user: {}\", user.username);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(UserResponse::from(user)),\n                message: Some(\"User updated successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"User not found\".to_string(),\n            message: None,\n        })),\n        Err(e) => {\n            error!(\"Error updating user: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: format!(\"Failed to update user: {e}\"),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Delete a user (admin only)\n#[delete(\"/admin/users/{id}\")]\npub async fn admin_delete_user(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<Uuid>,\n) -> Result<impl Responder> {\n    let auth_ctx = match require_admin(&req, pool.get_ref()).await {\n        Ok(ctx) => ctx,\n        Err(response) => return Ok(response),\n    };\n\n    let user_id = path.into_inner();\n\n    // Prevent admin from deleting themselves\n    if user_id == auth_ctx.user_id {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Cannot delete your own account\".to_string(),\n            message: None,\n        }));\n    }\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Check if this is the last admin\n    let target_user = match db_service.get_user_by_id(user_id).await {\n        Ok(Some(u)) => u,\n        Ok(None) => {\n            return Ok(HttpResponse::NotFound().json(ErrorResponse {\n                success: false,\n                error: \"User not found\".to_string(),\n                message: None,\n            }));\n        },\n        Err(e) => {\n            error!(\"Error getting user: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Database error\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    if target_user.is_admin {\n        let admin_count = db_service.count_admin_users().await.unwrap_or(0);\n        if admin_count <= 1 {\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Cannot delete the last admin\".to_string(),\n                message: None,\n            }));\n        }\n    }\n\n    match db_service.delete_user(user_id).await {\n        Ok(true) => {\n            info!(\n                \"Admin deleted user: {} (ID: {})\",\n                target_user.username, user_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: None::<()>,\n                message: Some(\"User deleted successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(false) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"User not found\".to_string(),\n            message: None,\n        })),\n        Err(e) => {\n            error!(\"Error deleting user: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: format!(\"Failed to delete user: {e}\"),\n                message: None,\n            }))\n        },\n    }\n}\n\n// ==================== Inventory Sharing Endpoints ====================\n\n/// Get shares for an inventory\n#[get(\"/inventories/{id}/shares\")]\npub async fn get_inventory_shares(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<i32>,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let inventory_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Check if user has permission to view shares (must be owner or have All Access)\n    let effective_perms = match db_service\n        .get_effective_permissions(auth.user_id, inventory_id)\n        .await\n    {\n        Ok(p) => p,\n        Err(e) => {\n            error!(\"Error checking permission: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    if effective_perms.permission_source == PermissionSource::None {\n        return Ok(HttpResponse::Forbidden().json(ErrorResponse {\n            success: false,\n            error: \"Access denied\".to_string(),\n            message: Some(\"You don't have access to this inventory\".to_string()),\n        }));\n    }\n\n    if !effective_perms.can_manage_sharing && !auth.is_admin {\n        return Ok(HttpResponse::Forbidden().json(ErrorResponse {\n            success: false,\n            error: \"Insufficient permissions\".to_string(),\n            message: Some(\n                \"Only inventory owners or users with All Access can manage shares\".to_string(),\n            ),\n        }));\n    }\n\n    match db_service.get_inventory_shares(inventory_id).await {\n        Ok(shares) => {\n            info!(\n                \"Retrieved {} shares for inventory {}\",\n                shares.len(),\n                inventory_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(shares),\n                message: Some(\"Shares retrieved successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error retrieving shares: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Share an inventory with another user\n#[post(\"/inventories/{id}/shares\")]\npub async fn create_inventory_share(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<i32>,\n    body: web::Json<CreateInventoryShareRequest>,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let inventory_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Check if user has permission to share (must be owner or have All Access)\n    let effective_perms = match db_service\n        .get_effective_permissions(auth.user_id, inventory_id)\n        .await\n    {\n        Ok(p) => p,\n        Err(e) => {\n            error!(\"Error checking permission: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    if effective_perms.permission_source == PermissionSource::None {\n        return Ok(HttpResponse::Forbidden().json(ErrorResponse {\n            success: false,\n            error: \"Access denied\".to_string(),\n            message: Some(\"You don't have access to this inventory\".to_string()),\n        }));\n    }\n\n    if !effective_perms.can_manage_sharing && !auth.is_admin {\n        return Ok(HttpResponse::Forbidden().json(ErrorResponse {\n            success: false,\n            error: \"Insufficient permissions\".to_string(),\n            message: Some(\n                \"Only inventory owners or users with All Access can share this inventory\"\n                    .to_string(),\n            ),\n        }));\n    }\n\n    // Find the user to share with\n    let target_user = match db_service\n        .get_user_by_username(&body.shared_with_username)\n        .await\n    {\n        Ok(Some(u)) => u,\n        Ok(None) => {\n            return Ok(HttpResponse::NotFound().json(ErrorResponse {\n                success: false,\n                error: \"User not found\".to_string(),\n                message: Some(format!(\n                    \"No user found with username or email: {username}\",\n                    username = body.shared_with_username\n                )),\n            }));\n        },\n        Err(e) => {\n            error!(\"Error finding user: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Don't allow sharing with self\n    if target_user.id == auth.user_id {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Cannot share with yourself\".to_string(),\n            message: None,\n        }));\n    }\n\n    match db_service\n        .create_inventory_share(\n            inventory_id,\n            target_user.id,\n            auth.user_id,\n            body.permission_level,\n        )\n        .await\n    {\n        Ok(share) => {\n            info!(\n                \"User {} shared inventory {} with {} (permission: {:?})\",\n                auth.username, inventory_id, target_user.username, body.permission_level\n            );\n            Ok(HttpResponse::Created().json(ApiResponse {\n                success: true,\n                data: Some(share),\n                message: Some(format!(\n                    \"Inventory shared with {username}\",\n                    username = target_user.username\n                )),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            // Check for duplicate share\n            if e.to_string().contains(\"duplicate\") || e.to_string().contains(\"unique\") {\n                return Ok(HttpResponse::Conflict().json(ErrorResponse {\n                    success: false,\n                    error: \"Already shared\".to_string(),\n                    message: Some(format!(\n                        \"This inventory is already shared with {username}\",\n                        username = target_user.username\n                    )),\n                }));\n            }\n            error!(\"Error creating share: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Update share permission level\n#[put(\"/shares/{share_id}\")]\npub async fn update_inventory_share(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<Uuid>,\n    body: web::Json<UpdateInventoryShareRequest>,\n) -> Result<impl Responder> {\n    let _auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let share_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Update the share permission\n    match db_service\n        .update_inventory_share(share_id, body.permission_level)\n        .await\n    {\n        Ok(Some(share)) => {\n            info!(\n                \"Updated share {} permission to {:?}\",\n                share_id, body.permission_level\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(share),\n                message: Some(\"Share permission updated\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"Share not found\".to_string(),\n            message: None,\n        })),\n        Err(e) => {\n            error!(\"Error updating share: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Remove a share\n#[delete(\"/shares/{share_id}\")]\npub async fn delete_inventory_share(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<Uuid>,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let share_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.delete_inventory_share(share_id).await {\n        Ok(true) => {\n            info!(\"User {} deleted share {}\", auth.username, share_id);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: None::<()>,\n                message: Some(\"Share removed successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(false) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"Share not found\".to_string(),\n            message: None,\n        })),\n        Err(e) => {\n            error!(\"Error deleting share: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Get inventories accessible to the current user (owned + shared + all-access)\n#[get(\"/auth/inventories\")]\npub async fn get_my_inventories(pool: web::Data<Pool>, req: HttpRequest) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_accessible_inventories(auth.user_id).await {\n        Ok(inventories) => {\n            info!(\n                \"User {} retrieved {} accessible inventories\",\n                auth.username,\n                inventories.len()\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(inventories),\n                message: None,\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error retrieving inventories: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n// ==================== User Access Grant Endpoints (All Access Tier) ====================\n\n/// Get users who have All Access to my inventories (grants I've made)\n#[get(\"/auth/access-grants\")]\npub async fn get_my_access_grants(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .get_user_access_grants_by_grantor(auth.user_id)\n        .await\n    {\n        Ok(grants) => {\n            info!(\n                \"User {} retrieved {} access grants they've made\",\n                auth.username,\n                grants.len()\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(grants),\n                message: Some(\"Access grants retrieved successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error retrieving access grants: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Get users who have granted me All Access to their inventories\n#[get(\"/auth/access-grants/received\")]\npub async fn get_received_access_grants(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .get_user_access_grants_by_grantee(auth.user_id)\n        .await\n    {\n        Ok(grants) => {\n            info!(\n                \"User {} retrieved {} received access grants\",\n                auth.username,\n                grants.len()\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(grants),\n                message: Some(\"Received access grants retrieved successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error retrieving received access grants: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Grant All Access to another user (gives them access to all my inventories)\n#[post(\"/auth/access-grants\")]\npub async fn create_access_grant(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    body: web::Json<CreateUserAccessGrantRequest>,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Find the user to grant access to\n    let target_user = match db_service\n        .get_user_by_username(&body.grantee_username)\n        .await\n    {\n        Ok(Some(u)) => u,\n        Ok(None) => {\n            return Ok(HttpResponse::NotFound().json(ErrorResponse {\n                success: false,\n                error: \"User not found\".to_string(),\n                message: Some(format!(\n                    \"No user found with username or email: {username}\",\n                    username = body.grantee_username\n                )),\n            }));\n        },\n        Err(e) => {\n            error!(\"Error finding user: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Don't allow granting access to self\n    if target_user.id == auth.user_id {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Cannot grant access to yourself\".to_string(),\n            message: None,\n        }));\n    }\n\n    match db_service\n        .create_user_access_grant(auth.user_id, target_user.id)\n        .await\n    {\n        Ok(grant) => {\n            info!(\n                \"User {} granted All Access to {} for all their inventories\",\n                auth.username, target_user.username\n            );\n            Ok(HttpResponse::Created().json(ApiResponse {\n                success: true,\n                data: Some(grant),\n                message: Some(format!(\n                    \"{username} now has All Access to all your inventories\",\n                    username = target_user.username\n                )),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            // Check for duplicate grant\n            if e.to_string().contains(\"duplicate\") || e.to_string().contains(\"unique\") {\n                return Ok(HttpResponse::Conflict().json(ErrorResponse {\n                    success: false,\n                    error: \"Already granted\".to_string(),\n                    message: Some(format!(\n                        \"{username} already has All Access to your inventories\",\n                        username = target_user.username\n                    )),\n                }));\n            }\n            error!(\"Error creating access grant: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Revoke All Access grant (remove someone's access to all my inventories)\n#[delete(\"/auth/access-grants/{grant_id}\")]\npub async fn delete_access_grant(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<Uuid>,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let grant_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Verify the grant belongs to the current user (as grantor)\n    let grant = match db_service.get_user_access_grant_by_id(grant_id).await {\n        Ok(Some(g)) => g,\n        Ok(None) => {\n            return Ok(HttpResponse::NotFound().json(ErrorResponse {\n                success: false,\n                error: \"Access grant not found\".to_string(),\n                message: None,\n            }));\n        },\n        Err(e) => {\n            error!(\"Error finding access grant: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Only the grantor can revoke their own grants (or admin)\n    if grant.grantor_user_id != auth.user_id && !auth.is_admin {\n        return Ok(HttpResponse::Forbidden().json(ErrorResponse {\n            success: false,\n            error: \"Access denied\".to_string(),\n            message: Some(\"You can only revoke access grants you have made\".to_string()),\n        }));\n    }\n\n    match db_service.delete_user_access_grant(grant_id).await {\n        Ok(true) => {\n            info!(\"User {} revoked access grant {}\", auth.username, grant_id);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: None::<()>,\n                message: Some(\"All Access grant revoked successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(false) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"Access grant not found\".to_string(),\n            message: None,\n        })),\n        Err(e) => {\n            error!(\"Error deleting access grant: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Get effective permissions for current user on a specific inventory\n#[get(\"/inventories/{id}/permissions\")]\npub async fn get_inventory_permissions(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<i32>,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let inventory_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .get_effective_permissions(auth.user_id, inventory_id)\n        .await\n    {\n        Ok(permissions) => Ok(HttpResponse::Ok().json(ApiResponse {\n            success: true,\n            data: Some(permissions),\n            message: None,\n            error: None,\n        })),\n        Err(e) => {\n            error!(\"Error retrieving permissions: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n// ==================== Ownership Transfer ====================\n\n/// Transfer ownership of an inventory to another user\n/// This action is irreversible - the original owner loses all access\n#[post(\"/inventories/{id}/transfer-ownership\")]\npub async fn transfer_inventory_ownership(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<i32>,\n    body: web::Json<TransferOwnershipRequest>,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let inventory_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Get the inventory to verify ownership and get details\n    let inventory = match db_service.get_inventory_by_id(inventory_id).await {\n        Ok(Some(inv)) => inv,\n        Ok(None) => {\n            return Ok(HttpResponse::NotFound().json(ErrorResponse {\n                success: false,\n                error: \"Inventory not found\".to_string(),\n                message: None,\n            }));\n        },\n        Err(e) => {\n            error!(\"Error retrieving inventory: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Only the owner can transfer ownership (not even All Access users)\n    if inventory.user_id != Some(auth.user_id) {\n        return Ok(HttpResponse::Forbidden().json(ErrorResponse {\n            success: false,\n            error: \"Only the owner can transfer ownership of an inventory\".to_string(),\n            message: Some(\"You must be the owner to transfer this inventory\".to_string()),\n        }));\n    }\n\n    // Find the target user by username\n    let target_user = match db_service\n        .get_user_by_username(&body.new_owner_username)\n        .await\n    {\n        Ok(Some(user)) => user,\n        Ok(None) => {\n            return Ok(HttpResponse::NotFound().json(ErrorResponse {\n                success: false,\n                error: format!(\n                    \"User '{username}' not found\",\n                    username = body.new_owner_username\n                ),\n                message: None,\n            }));\n        },\n        Err(e) => {\n            error!(\"Error finding target user: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Cannot transfer to yourself\n    if target_user.id == auth.user_id {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Cannot transfer ownership to yourself\".to_string(),\n            message: None,\n        }));\n    }\n\n    // Check if target user is active\n    if !target_user.is_active {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Cannot transfer ownership to an inactive user\".to_string(),\n            message: None,\n        }));\n    }\n\n    // Get current user details for response\n    let current_user = match db_service.get_user_by_id(auth.user_id).await {\n        Ok(Some(user)) => user,\n        Ok(None) => {\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Current user not found\".to_string(),\n                message: None,\n            }));\n        },\n        Err(e) => {\n            error!(\"Error finding current user: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Perform the ownership transfer\n    match db_service\n        .transfer_inventory_ownership(inventory_id, auth.user_id, target_user.id)\n        .await\n    {\n        Ok((items_transferred, shares_removed)) => {\n            let target_full_name = target_user.full_name.clone();\n            let target_username = target_user.username.clone();\n            let inventory_name = inventory.name.clone();\n\n            info!(\n                \"User {} transferred ownership of inventory '{}' (ID: {}) to user {}\",\n                auth.user_id, inventory_name, inventory_id, target_username\n            );\n\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(TransferOwnershipResponse {\n                    inventory_id,\n                    inventory_name: inventory.name,\n                    previous_owner: UserResponse {\n                        id: current_user.id,\n                        username: current_user.username,\n                        full_name: current_user.full_name,\n                        is_admin: current_user.is_admin,\n                        is_active: current_user.is_active,\n                        created_at: current_user.created_at,\n                        updated_at: current_user.updated_at,\n                    },\n                    new_owner: UserResponse {\n                        id: target_user.id,\n                        username: target_user.username,\n                        full_name: target_user.full_name,\n                        is_admin: target_user.is_admin,\n                        is_active: target_user.is_active,\n                        created_at: target_user.created_at,\n                        updated_at: target_user.updated_at,\n                    },\n                    items_transferred,\n                    shares_removed,\n                }),\n                message: Some(format!(\n                    \"Ownership transferred successfully to {target_full_name}. {items_transferred} items transferred, {shares_removed} shares removed.\"\n                )),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error transferring ownership: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: format!(\"Failed to transfer ownership: {e}\"),\n                message: None,\n            }))\n        },\n    }\n}\n\n// ==================== Recovery Codes Endpoints ====================\n\n/// Generate 10 new recovery codes for the authenticated user\n/// Any existing codes are replaced\n#[post(\"/auth/recovery-codes/generate\")]\npub async fn generate_recovery_codes(\n    req: HttpRequest,\n    pool: web::Data<Pool>,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Generate 10 random recovery codes\n    let mut rng = rand::thread_rng();\n    let mut plain_codes: Vec<String> = Vec::with_capacity(10);\n    let mut code_hashes: Vec<String> = Vec::with_capacity(10);\n\n    for _ in 0..10 {\n        // Generate code in format: XXXX-XXXX-XXXX (12 alphanumeric chars with dashes)\n        let code: String = (&mut rng)\n            .sample_iter(&Alphanumeric)\n            .take(12)\n            .map(char::from)\n            .collect::<String>()\n            .to_uppercase();\n\n        // Format with dashes for readability\n        let formatted_code = format!(\"{}-{}-{}\", &code[0..4], &code[4..8], &code[8..12]);\n\n        // Hash the code for storage\n        let hash = match hash_password(formatted_code.clone()).await {\n            Ok(h) => h,\n            Err(e) => {\n                error!(\"Error hashing recovery code: {}\", e);\n                return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                    success: false,\n                    error: \"Failed to generate recovery codes\".to_string(),\n                    message: None,\n                }));\n            },\n        };\n\n        plain_codes.push(formatted_code);\n        code_hashes.push(hash);\n    }\n\n    // Store the hashed codes\n    if let Err(e) = db_service\n        .store_recovery_codes(auth.user_id, code_hashes)\n        .await\n    {\n        error!(\"Error storing recovery codes: {}\", e);\n        return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n            success: false,\n            error: \"Failed to store recovery codes\".to_string(),\n            message: None,\n        }));\n    }\n\n    info!(\"Generated 10 recovery codes for user {}\", auth.user_id);\n\n    Ok(HttpResponse::Ok().json(ApiResponse {\n        success: true,\n        data: Some(RecoveryCodesResponse {\n            codes: plain_codes,\n            generated_at: chrono::Utc::now(),\n            message: \"Save these codes in a safe place. Each code can only be used once. You won't be able to see these codes again!\".to_string(),\n        }),\n        message: Some(\"Recovery codes generated successfully\".to_string()),\n        error: None,\n    }))\n}\n\n/// Get the status of the user's recovery codes (not the codes themselves)\n#[get(\"/auth/recovery-codes/status\")]\npub async fn get_recovery_codes_status(\n    req: HttpRequest,\n    pool: web::Data<Pool>,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_recovery_codes_status(auth.user_id).await {\n        Ok((has_codes, confirmed, unused_count, generated_at)) => {\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(RecoveryCodesStatus {\n                    has_codes,\n                    codes_confirmed: confirmed,\n                    unused_count,\n                    generated_at,\n                }),\n                message: None,\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error getting recovery codes status: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to get recovery codes status\".to_string(),\n                message: None,\n            }))\n        },\n    }\n}\n\n/// Confirm that the user has saved their recovery codes\n#[post(\"/auth/recovery-codes/confirm\")]\npub async fn confirm_recovery_codes(\n    req: HttpRequest,\n    pool: web::Data<Pool>,\n    body: web::Json<ConfirmRecoveryCodesRequest>,\n) -> Result<impl Responder> {\n    let auth = match get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    if !body.confirmed {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"You must confirm that you have saved the codes\".to_string(),\n            message: Some(\"Please save your recovery codes before confirming\".to_string()),\n        }));\n    }\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Check if user has codes to confirm\n    match db_service\n        .get_unused_recovery_codes_count(auth.user_id)\n        .await\n    {\n        Ok(0) => {\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"No recovery codes to confirm\".to_string(),\n                message: Some(\"Please generate recovery codes first\".to_string()),\n            }));\n        },\n        Err(e) => {\n            error!(\"Error checking recovery codes: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to check recovery codes\".to_string(),\n                message: None,\n            }));\n        },\n        _ => {},\n    }\n\n    if let Err(e) = db_service.confirm_recovery_codes(auth.user_id).await {\n        error!(\"Error confirming recovery codes: {}\", e);\n        return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n            success: false,\n            error: \"Failed to confirm recovery codes\".to_string(),\n            message: None,\n        }));\n    }\n\n    info!(\n        \"User {} confirmed saving their recovery codes\",\n        auth.user_id\n    );\n\n    Ok(HttpResponse::Ok().json(ApiResponse::<()> {\n        success: true,\n        data: None,\n        message: Some(\n            \"Recovery codes confirmed. You can now use them to recover your account if needed.\"\n                .to_string(),\n        ),\n        error: None,\n    }))\n}\n\n/// Use a recovery code to reset password (no authentication required)\n#[post(\"/auth/recovery-codes/use\")]\npub async fn use_recovery_code(\n    pool: web::Data<Pool>,\n    body: web::Json<UseRecoveryCodeRequest>,\n) -> Result<impl Responder> {\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // Validate new password\n    if let Err(msg) = validate_password(&body.new_password) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: msg.to_string(),\n            message: Some(\"Invalid new password\".to_string()),\n        }));\n    }\n\n    // Find user by username\n    let user = match db_service.get_user_by_username(&body.username).await {\n        Ok(Some(u)) => u,\n        Ok(None) => {\n            // Don't reveal if user exists\n            warn!(\n                \"Recovery code attempt for non-existent user: {}\",\n                body.username\n            );\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Invalid username or recovery code\".to_string(),\n                message: None,\n            }));\n        },\n        Err(e) => {\n            error!(\"Error finding user: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An error occurred\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    if !user.is_active {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Invalid username or recovery code\".to_string(),\n            message: None,\n        }));\n    }\n\n    // Get unused recovery codes for this user\n    let codes = match db_service.get_unused_recovery_codes(user.id).await {\n        Ok(c) => c,\n        Err(e) => {\n            error!(\"Error getting recovery codes: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An error occurred\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    if codes.is_empty() {\n        // Don't reveal that user has no codes\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Invalid username or recovery code\".to_string(),\n            message: None,\n        }));\n    }\n\n    // Check each code to find a match\n    let mut matched_code_id: Option<Uuid> = None;\n    for (code_id, code_hash) in &codes {\n        if verify_password(body.recovery_code.clone(), code_hash.clone())\n            .await\n            .unwrap_or(false)\n        {\n            matched_code_id = Some(*code_id);\n            break;\n        }\n    }\n\n    let Some(code_id) = matched_code_id else {\n        warn!(\"Invalid recovery code attempt for user {}\", user.username);\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Invalid username or recovery code\".to_string(),\n            message: None,\n        }));\n    };\n\n    // Hash new password\n    let new_password_hash = match hash_password(body.new_password.clone()).await {\n        Ok(h) => h,\n        Err(e) => {\n            error!(\"Error hashing new password: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to reset password\".to_string(),\n                message: None,\n            }));\n        },\n    };\n\n    // Update password\n    if let Err(e) = db_service\n        .update_user_password(user.id, &new_password_hash)\n        .await\n    {\n        error!(\"Error updating password: {}\", e);\n        return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n            success: false,\n            error: \"Failed to reset password\".to_string(),\n            message: None,\n        }));\n    }\n\n    // Mark recovery code as used\n    if let Err(e) = db_service.mark_recovery_code_used(code_id).await {\n        error!(\"Error marking recovery code as used: {}\", e);\n        // Don't fail the request - password was already changed\n    }\n\n    // Get remaining codes count\n    let remaining = db_service\n        .get_unused_recovery_codes_count(user.id)\n        .await\n        .unwrap_or(0);\n\n    info!(\n        \"User {} reset password using recovery code. {} codes remaining.\",\n        user.username, remaining\n    );\n\n    Ok(HttpResponse::Ok().json(ApiResponse {\n        success: true,\n        data: Some(RecoveryCodeUsedResponse {\n            success: true,\n            message: \"Password reset successfully. You can now log in with your new password.\"\n                .to_string(),\n            remaining_codes: remaining,\n        }),\n        message: Some(format!(\n            \"Password reset successfully. You have {remaining} recovery codes remaining.\"\n        )),\n        error: None,\n    }))\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":948,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1011,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1020,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1061,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1065,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":0}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1074,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1080,"address":[],"length":0,"stats":{"Line":0}},{"line":1081,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1088,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1090,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[],"length":0,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1098,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":0}},{"line":1100,"address":[],"length":0,"stats":{"Line":0}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1106,"address":[],"length":0,"stats":{"Line":0}},{"line":1107,"address":[],"length":0,"stats":{"Line":0}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1109,"address":[],"length":0,"stats":{"Line":0}},{"line":1112,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1114,"address":[],"length":0,"stats":{"Line":0}},{"line":1115,"address":[],"length":0,"stats":{"Line":0}},{"line":1116,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[],"length":0,"stats":{"Line":0}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":0}},{"line":1132,"address":[],"length":0,"stats":{"Line":0}},{"line":1133,"address":[],"length":0,"stats":{"Line":0}},{"line":1136,"address":[],"length":0,"stats":{"Line":0}},{"line":1137,"address":[],"length":0,"stats":{"Line":0}},{"line":1140,"address":[],"length":0,"stats":{"Line":0}},{"line":1141,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1144,"address":[],"length":0,"stats":{"Line":0}},{"line":1145,"address":[],"length":0,"stats":{"Line":0}},{"line":1146,"address":[],"length":0,"stats":{"Line":0}},{"line":1147,"address":[],"length":0,"stats":{"Line":0}},{"line":1148,"address":[],"length":0,"stats":{"Line":0}},{"line":1149,"address":[],"length":0,"stats":{"Line":0}},{"line":1150,"address":[],"length":0,"stats":{"Line":0}},{"line":1155,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1158,"address":[],"length":0,"stats":{"Line":0}},{"line":1159,"address":[],"length":0,"stats":{"Line":0}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1167,"address":[],"length":0,"stats":{"Line":0}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1175,"address":[],"length":0,"stats":{"Line":0}},{"line":1176,"address":[],"length":0,"stats":{"Line":0}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1179,"address":[],"length":0,"stats":{"Line":0}},{"line":1181,"address":[],"length":0,"stats":{"Line":0}},{"line":1182,"address":[],"length":0,"stats":{"Line":0}},{"line":1183,"address":[],"length":0,"stats":{"Line":0}},{"line":1184,"address":[],"length":0,"stats":{"Line":0}},{"line":1185,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1190,"address":[],"length":0,"stats":{"Line":0}},{"line":1191,"address":[],"length":0,"stats":{"Line":0}},{"line":1192,"address":[],"length":0,"stats":{"Line":0}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[],"length":0,"stats":{"Line":0}},{"line":1195,"address":[],"length":0,"stats":{"Line":0}},{"line":1201,"address":[],"length":0,"stats":{"Line":0}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1203,"address":[],"length":0,"stats":{"Line":0}},{"line":1204,"address":[],"length":0,"stats":{"Line":0}},{"line":1205,"address":[],"length":0,"stats":{"Line":0}},{"line":1209,"address":[],"length":0,"stats":{"Line":0}},{"line":1210,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1212,"address":[],"length":0,"stats":{"Line":0}},{"line":1213,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1218,"address":[],"length":0,"stats":{"Line":0}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1220,"address":[],"length":0,"stats":{"Line":0}},{"line":1221,"address":[],"length":0,"stats":{"Line":0}},{"line":1223,"address":[],"length":0,"stats":{"Line":0}},{"line":1224,"address":[],"length":0,"stats":{"Line":0}},{"line":1225,"address":[],"length":0,"stats":{"Line":0}},{"line":1226,"address":[],"length":0,"stats":{"Line":0}},{"line":1227,"address":[],"length":0,"stats":{"Line":0}},{"line":1228,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[],"length":0,"stats":{"Line":0}},{"line":1233,"address":[],"length":0,"stats":{"Line":0}},{"line":1235,"address":[],"length":0,"stats":{"Line":0}},{"line":1236,"address":[],"length":0,"stats":{"Line":0}},{"line":1237,"address":[],"length":0,"stats":{"Line":0}},{"line":1238,"address":[],"length":0,"stats":{"Line":0}},{"line":1239,"address":[],"length":0,"stats":{"Line":0}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[],"length":0,"stats":{"Line":0}},{"line":1246,"address":[],"length":0,"stats":{"Line":0}},{"line":1247,"address":[],"length":0,"stats":{"Line":0}},{"line":1248,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1257,"address":[],"length":0,"stats":{"Line":0}},{"line":1263,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[],"length":0,"stats":{"Line":0}},{"line":1265,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[],"length":0,"stats":{"Line":0}},{"line":1269,"address":[],"length":0,"stats":{"Line":0}},{"line":1272,"address":[],"length":0,"stats":{"Line":0}},{"line":1273,"address":[],"length":0,"stats":{"Line":0}},{"line":1274,"address":[],"length":0,"stats":{"Line":0}},{"line":1276,"address":[],"length":0,"stats":{"Line":0}},{"line":1277,"address":[],"length":0,"stats":{"Line":0}},{"line":1278,"address":[],"length":0,"stats":{"Line":0}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1281,"address":[],"length":0,"stats":{"Line":0}},{"line":1282,"address":[],"length":0,"stats":{"Line":0}},{"line":1283,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1285,"address":[],"length":0,"stats":{"Line":0}},{"line":1288,"address":[],"length":0,"stats":{"Line":0}},{"line":1289,"address":[],"length":0,"stats":{"Line":0}},{"line":1290,"address":[],"length":0,"stats":{"Line":0}},{"line":1291,"address":[],"length":0,"stats":{"Line":0}},{"line":1293,"address":[],"length":0,"stats":{"Line":0}},{"line":1294,"address":[],"length":0,"stats":{"Line":0}},{"line":1295,"address":[],"length":0,"stats":{"Line":0}},{"line":1296,"address":[],"length":0,"stats":{"Line":0}},{"line":1297,"address":[],"length":0,"stats":{"Line":0}},{"line":1298,"address":[],"length":0,"stats":{"Line":0}},{"line":1306,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1312,"address":[],"length":0,"stats":{"Line":0}},{"line":1313,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":0}},{"line":1317,"address":[],"length":0,"stats":{"Line":0}},{"line":1319,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1323,"address":[],"length":0,"stats":{"Line":0}},{"line":1324,"address":[],"length":0,"stats":{"Line":0}},{"line":1325,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[],"length":0,"stats":{"Line":0}},{"line":1329,"address":[],"length":0,"stats":{"Line":0}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1332,"address":[],"length":0,"stats":{"Line":0}},{"line":1334,"address":[],"length":0,"stats":{"Line":0}},{"line":1335,"address":[],"length":0,"stats":{"Line":0}},{"line":1336,"address":[],"length":0,"stats":{"Line":0}},{"line":1337,"address":[],"length":0,"stats":{"Line":0}},{"line":1338,"address":[],"length":0,"stats":{"Line":0}},{"line":1339,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1348,"address":[],"length":0,"stats":{"Line":0}},{"line":1349,"address":[],"length":0,"stats":{"Line":0}},{"line":1350,"address":[],"length":0,"stats":{"Line":0}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1356,"address":[],"length":0,"stats":{"Line":0}},{"line":1357,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1362,"address":[],"length":0,"stats":{"Line":0}},{"line":1363,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":0}},{"line":1365,"address":[],"length":0,"stats":{"Line":0}},{"line":1366,"address":[],"length":0,"stats":{"Line":0}},{"line":1369,"address":[],"length":0,"stats":{"Line":0}},{"line":1370,"address":[],"length":0,"stats":{"Line":0}},{"line":1371,"address":[],"length":0,"stats":{"Line":0}},{"line":1372,"address":[],"length":0,"stats":{"Line":0}},{"line":1373,"address":[],"length":0,"stats":{"Line":0}},{"line":1374,"address":[],"length":0,"stats":{"Line":0}},{"line":1384,"address":[],"length":0,"stats":{"Line":0}},{"line":1388,"address":[],"length":0,"stats":{"Line":0}},{"line":1389,"address":[],"length":0,"stats":{"Line":0}},{"line":1390,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[],"length":0,"stats":{"Line":0}},{"line":1395,"address":[],"length":0,"stats":{"Line":0}},{"line":1396,"address":[],"length":0,"stats":{"Line":0}},{"line":1397,"address":[],"length":0,"stats":{"Line":0}},{"line":1399,"address":[],"length":0,"stats":{"Line":0}},{"line":1400,"address":[],"length":0,"stats":{"Line":0}},{"line":1401,"address":[],"length":0,"stats":{"Line":0}},{"line":1403,"address":[],"length":0,"stats":{"Line":0}},{"line":1405,"address":[],"length":0,"stats":{"Line":0}},{"line":1406,"address":[],"length":0,"stats":{"Line":0}},{"line":1407,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":0}},{"line":1409,"address":[],"length":0,"stats":{"Line":0}},{"line":1412,"address":[],"length":0,"stats":{"Line":0}},{"line":1413,"address":[],"length":0,"stats":{"Line":0}},{"line":1414,"address":[],"length":0,"stats":{"Line":0}},{"line":1415,"address":[],"length":0,"stats":{"Line":0}},{"line":1416,"address":[],"length":0,"stats":{"Line":0}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1425,"address":[],"length":0,"stats":{"Line":0}},{"line":1429,"address":[],"length":0,"stats":{"Line":0}},{"line":1430,"address":[],"length":0,"stats":{"Line":0}},{"line":1431,"address":[],"length":0,"stats":{"Line":0}},{"line":1434,"address":[],"length":0,"stats":{"Line":0}},{"line":1436,"address":[],"length":0,"stats":{"Line":0}},{"line":1437,"address":[],"length":0,"stats":{"Line":0}},{"line":1438,"address":[],"length":0,"stats":{"Line":0}},{"line":1440,"address":[],"length":0,"stats":{"Line":0}},{"line":1441,"address":[],"length":0,"stats":{"Line":0}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1444,"address":[],"length":0,"stats":{"Line":0}},{"line":1446,"address":[],"length":0,"stats":{"Line":0}},{"line":1447,"address":[],"length":0,"stats":{"Line":0}},{"line":1448,"address":[],"length":0,"stats":{"Line":0}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1450,"address":[],"length":0,"stats":{"Line":0}},{"line":1453,"address":[],"length":0,"stats":{"Line":0}},{"line":1454,"address":[],"length":0,"stats":{"Line":0}},{"line":1455,"address":[],"length":0,"stats":{"Line":0}},{"line":1456,"address":[],"length":0,"stats":{"Line":0}},{"line":1457,"address":[],"length":0,"stats":{"Line":0}},{"line":1458,"address":[],"length":0,"stats":{"Line":0}},{"line":1466,"address":[],"length":0,"stats":{"Line":0}},{"line":1471,"address":[],"length":0,"stats":{"Line":0}},{"line":1472,"address":[],"length":0,"stats":{"Line":0}},{"line":1473,"address":[],"length":0,"stats":{"Line":0}},{"line":1476,"address":[],"length":0,"stats":{"Line":0}},{"line":1479,"address":[],"length":0,"stats":{"Line":0}},{"line":1480,"address":[],"length":0,"stats":{"Line":0}},{"line":1481,"address":[],"length":0,"stats":{"Line":0}},{"line":1483,"address":[],"length":0,"stats":{"Line":0}},{"line":1485,"address":[],"length":0,"stats":{"Line":0}},{"line":1486,"address":[],"length":0,"stats":{"Line":0}},{"line":1487,"address":[],"length":0,"stats":{"Line":0}},{"line":1488,"address":[],"length":0,"stats":{"Line":0}},{"line":1489,"address":[],"length":0,"stats":{"Line":0}},{"line":1490,"address":[],"length":0,"stats":{"Line":0}},{"line":1494,"address":[],"length":0,"stats":{"Line":0}},{"line":1495,"address":[],"length":0,"stats":{"Line":0}},{"line":1496,"address":[],"length":0,"stats":{"Line":0}},{"line":1497,"address":[],"length":0,"stats":{"Line":0}},{"line":1498,"address":[],"length":0,"stats":{"Line":0}},{"line":1499,"address":[],"length":0,"stats":{"Line":0}},{"line":1505,"address":[],"length":0,"stats":{"Line":0}},{"line":1506,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1508,"address":[],"length":0,"stats":{"Line":0}},{"line":1509,"address":[],"length":0,"stats":{"Line":0}},{"line":1513,"address":[],"length":0,"stats":{"Line":0}},{"line":1514,"address":[],"length":0,"stats":{"Line":0}},{"line":1515,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":0}},{"line":1518,"address":[],"length":0,"stats":{"Line":0}},{"line":1519,"address":[],"length":0,"stats":{"Line":0}},{"line":1522,"address":[],"length":0,"stats":{"Line":0}},{"line":1523,"address":[],"length":0,"stats":{"Line":0}},{"line":1524,"address":[],"length":0,"stats":{"Line":0}},{"line":1525,"address":[],"length":0,"stats":{"Line":0}},{"line":1526,"address":[],"length":0,"stats":{"Line":0}},{"line":1527,"address":[],"length":0,"stats":{"Line":0}},{"line":1529,"address":[],"length":0,"stats":{"Line":0}},{"line":1532,"address":[],"length":0,"stats":{"Line":0}},{"line":1534,"address":[],"length":0,"stats":{"Line":0}},{"line":1535,"address":[],"length":0,"stats":{"Line":0}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1537,"address":[],"length":0,"stats":{"Line":0}},{"line":1538,"address":[],"length":0,"stats":{"Line":0}},{"line":1539,"address":[],"length":0,"stats":{"Line":0}},{"line":1540,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1545,"address":[],"length":0,"stats":{"Line":0}},{"line":1546,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":0}},{"line":1548,"address":[],"length":0,"stats":{"Line":0}},{"line":1556,"address":[],"length":0,"stats":{"Line":0}},{"line":1561,"address":[],"length":0,"stats":{"Line":0}},{"line":1562,"address":[],"length":0,"stats":{"Line":0}},{"line":1563,"address":[],"length":0,"stats":{"Line":0}},{"line":1566,"address":[],"length":0,"stats":{"Line":0}},{"line":1567,"address":[],"length":0,"stats":{"Line":0}},{"line":1570,"address":[],"length":0,"stats":{"Line":0}},{"line":1571,"address":[],"length":0,"stats":{"Line":0}},{"line":1573,"address":[],"length":0,"stats":{"Line":0}},{"line":1574,"address":[],"length":0,"stats":{"Line":0}},{"line":1575,"address":[],"length":0,"stats":{"Line":0}},{"line":1576,"address":[],"length":0,"stats":{"Line":0}},{"line":1579,"address":[],"length":0,"stats":{"Line":0}},{"line":1580,"address":[],"length":0,"stats":{"Line":0}},{"line":1581,"address":[],"length":0,"stats":{"Line":0}},{"line":1582,"address":[],"length":0,"stats":{"Line":0}},{"line":1583,"address":[],"length":0,"stats":{"Line":0}},{"line":1584,"address":[],"length":0,"stats":{"Line":0}},{"line":1590,"address":[],"length":0,"stats":{"Line":0}},{"line":1591,"address":[],"length":0,"stats":{"Line":0}},{"line":1592,"address":[],"length":0,"stats":{"Line":0}},{"line":1593,"address":[],"length":0,"stats":{"Line":0}},{"line":1594,"address":[],"length":0,"stats":{"Line":0}},{"line":1598,"address":[],"length":0,"stats":{"Line":0}},{"line":1600,"address":[],"length":0,"stats":{"Line":0}},{"line":1601,"address":[],"length":0,"stats":{"Line":0}},{"line":1602,"address":[],"length":0,"stats":{"Line":0}},{"line":1603,"address":[],"length":0,"stats":{"Line":0}},{"line":1604,"address":[],"length":0,"stats":{"Line":0}},{"line":1605,"address":[],"length":0,"stats":{"Line":0}},{"line":1608,"address":[],"length":0,"stats":{"Line":0}},{"line":1609,"address":[],"length":0,"stats":{"Line":0}},{"line":1610,"address":[],"length":0,"stats":{"Line":0}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1613,"address":[],"length":0,"stats":{"Line":0}},{"line":1614,"address":[],"length":0,"stats":{"Line":0}},{"line":1615,"address":[],"length":0,"stats":{"Line":0}},{"line":1616,"address":[],"length":0,"stats":{"Line":0}},{"line":1617,"address":[],"length":0,"stats":{"Line":0}},{"line":1618,"address":[],"length":0,"stats":{"Line":0}},{"line":1626,"address":[],"length":0,"stats":{"Line":0}},{"line":1631,"address":[],"length":0,"stats":{"Line":0}},{"line":1632,"address":[],"length":0,"stats":{"Line":0}},{"line":1633,"address":[],"length":0,"stats":{"Line":0}},{"line":1636,"address":[],"length":0,"stats":{"Line":0}},{"line":1637,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":0}},{"line":1640,"address":[],"length":0,"stats":{"Line":0}},{"line":1641,"address":[],"length":0,"stats":{"Line":0}},{"line":1643,"address":[],"length":0,"stats":{"Line":0}},{"line":1644,"address":[],"length":0,"stats":{"Line":0}},{"line":1645,"address":[],"length":0,"stats":{"Line":0}},{"line":1646,"address":[],"length":0,"stats":{"Line":0}},{"line":1647,"address":[],"length":0,"stats":{"Line":0}},{"line":1649,"address":[],"length":0,"stats":{"Line":0}},{"line":1650,"address":[],"length":0,"stats":{"Line":0}},{"line":1651,"address":[],"length":0,"stats":{"Line":0}},{"line":1652,"address":[],"length":0,"stats":{"Line":0}},{"line":1653,"address":[],"length":0,"stats":{"Line":0}},{"line":1654,"address":[],"length":0,"stats":{"Line":0}},{"line":1665,"address":[],"length":0,"stats":{"Line":0}},{"line":1671,"address":[],"length":0,"stats":{"Line":0}},{"line":1672,"address":[],"length":0,"stats":{"Line":0}},{"line":1673,"address":[],"length":0,"stats":{"Line":0}},{"line":1676,"address":[],"length":0,"stats":{"Line":0}},{"line":1677,"address":[],"length":0,"stats":{"Line":0}},{"line":1680,"address":[],"length":0,"stats":{"Line":0}},{"line":1681,"address":[],"length":0,"stats":{"Line":0}},{"line":1683,"address":[],"length":0,"stats":{"Line":0}},{"line":1684,"address":[],"length":0,"stats":{"Line":0}},{"line":1685,"address":[],"length":0,"stats":{"Line":0}},{"line":1686,"address":[],"length":0,"stats":{"Line":0}},{"line":1689,"address":[],"length":0,"stats":{"Line":0}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1691,"address":[],"length":0,"stats":{"Line":0}},{"line":1692,"address":[],"length":0,"stats":{"Line":0}},{"line":1693,"address":[],"length":0,"stats":{"Line":0}},{"line":1694,"address":[],"length":0,"stats":{"Line":0}},{"line":1700,"address":[],"length":0,"stats":{"Line":0}},{"line":1701,"address":[],"length":0,"stats":{"Line":0}},{"line":1702,"address":[],"length":0,"stats":{"Line":0}},{"line":1703,"address":[],"length":0,"stats":{"Line":0}},{"line":1704,"address":[],"length":0,"stats":{"Line":0}},{"line":1709,"address":[],"length":0,"stats":{"Line":0}},{"line":1710,"address":[],"length":0,"stats":{"Line":0}},{"line":1711,"address":[],"length":0,"stats":{"Line":0}},{"line":1713,"address":[],"length":0,"stats":{"Line":0}},{"line":1715,"address":[],"length":0,"stats":{"Line":0}},{"line":1716,"address":[],"length":0,"stats":{"Line":0}},{"line":1717,"address":[],"length":0,"stats":{"Line":0}},{"line":1718,"address":[],"length":0,"stats":{"Line":0}},{"line":1719,"address":[],"length":0,"stats":{"Line":0}},{"line":1721,"address":[],"length":0,"stats":{"Line":0}},{"line":1724,"address":[],"length":0,"stats":{"Line":0}},{"line":1725,"address":[],"length":0,"stats":{"Line":0}},{"line":1726,"address":[],"length":0,"stats":{"Line":0}},{"line":1727,"address":[],"length":0,"stats":{"Line":0}},{"line":1728,"address":[],"length":0,"stats":{"Line":0}},{"line":1729,"address":[],"length":0,"stats":{"Line":0}},{"line":1735,"address":[],"length":0,"stats":{"Line":0}},{"line":1736,"address":[],"length":0,"stats":{"Line":0}},{"line":1737,"address":[],"length":0,"stats":{"Line":0}},{"line":1738,"address":[],"length":0,"stats":{"Line":0}},{"line":1739,"address":[],"length":0,"stats":{"Line":0}},{"line":1744,"address":[],"length":0,"stats":{"Line":0}},{"line":1745,"address":[],"length":0,"stats":{"Line":0}},{"line":1746,"address":[],"length":0,"stats":{"Line":0}},{"line":1747,"address":[],"length":0,"stats":{"Line":0}},{"line":1748,"address":[],"length":0,"stats":{"Line":0}},{"line":1753,"address":[],"length":0,"stats":{"Line":0}},{"line":1754,"address":[],"length":0,"stats":{"Line":0}},{"line":1756,"address":[],"length":0,"stats":{"Line":0}},{"line":1757,"address":[],"length":0,"stats":{"Line":0}},{"line":1758,"address":[],"length":0,"stats":{"Line":0}},{"line":1759,"address":[],"length":0,"stats":{"Line":0}},{"line":1762,"address":[],"length":0,"stats":{"Line":0}},{"line":1763,"address":[],"length":0,"stats":{"Line":0}},{"line":1764,"address":[],"length":0,"stats":{"Line":0}},{"line":1765,"address":[],"length":0,"stats":{"Line":0}},{"line":1766,"address":[],"length":0,"stats":{"Line":0}},{"line":1767,"address":[],"length":0,"stats":{"Line":0}},{"line":1773,"address":[],"length":0,"stats":{"Line":0}},{"line":1774,"address":[],"length":0,"stats":{"Line":0}},{"line":1775,"address":[],"length":0,"stats":{"Line":0}},{"line":1777,"address":[],"length":0,"stats":{"Line":0}},{"line":1778,"address":[],"length":0,"stats":{"Line":0}},{"line":1779,"address":[],"length":0,"stats":{"Line":0}},{"line":1780,"address":[],"length":0,"stats":{"Line":0}},{"line":1782,"address":[],"length":0,"stats":{"Line":0}},{"line":1783,"address":[],"length":0,"stats":{"Line":0}},{"line":1787,"address":[],"length":0,"stats":{"Line":0}},{"line":1788,"address":[],"length":0,"stats":{"Line":0}},{"line":1789,"address":[],"length":0,"stats":{"Line":0}},{"line":1790,"address":[],"length":0,"stats":{"Line":0}},{"line":1791,"address":[],"length":0,"stats":{"Line":0}},{"line":1792,"address":[],"length":0,"stats":{"Line":0}},{"line":1793,"address":[],"length":0,"stats":{"Line":0}},{"line":1794,"address":[],"length":0,"stats":{"Line":0}},{"line":1795,"address":[],"length":0,"stats":{"Line":0}},{"line":1796,"address":[],"length":0,"stats":{"Line":0}},{"line":1797,"address":[],"length":0,"stats":{"Line":0}},{"line":1798,"address":[],"length":0,"stats":{"Line":0}},{"line":1799,"address":[],"length":0,"stats":{"Line":0}},{"line":1801,"address":[],"length":0,"stats":{"Line":0}},{"line":1802,"address":[],"length":0,"stats":{"Line":0}},{"line":1803,"address":[],"length":0,"stats":{"Line":0}},{"line":1804,"address":[],"length":0,"stats":{"Line":0}},{"line":1805,"address":[],"length":0,"stats":{"Line":0}},{"line":1806,"address":[],"length":0,"stats":{"Line":0}},{"line":1807,"address":[],"length":0,"stats":{"Line":0}},{"line":1808,"address":[],"length":0,"stats":{"Line":0}},{"line":1810,"address":[],"length":0,"stats":{"Line":0}},{"line":1811,"address":[],"length":0,"stats":{"Line":0}},{"line":1813,"address":[],"length":0,"stats":{"Line":0}},{"line":1814,"address":[],"length":0,"stats":{"Line":0}},{"line":1816,"address":[],"length":0,"stats":{"Line":0}},{"line":1819,"address":[],"length":0,"stats":{"Line":0}},{"line":1820,"address":[],"length":0,"stats":{"Line":0}},{"line":1821,"address":[],"length":0,"stats":{"Line":0}},{"line":1822,"address":[],"length":0,"stats":{"Line":0}},{"line":1823,"address":[],"length":0,"stats":{"Line":0}},{"line":1824,"address":[],"length":0,"stats":{"Line":0}},{"line":1835,"address":[],"length":0,"stats":{"Line":0}},{"line":1839,"address":[],"length":0,"stats":{"Line":0}},{"line":1840,"address":[],"length":0,"stats":{"Line":0}},{"line":1841,"address":[],"length":0,"stats":{"Line":0}},{"line":1844,"address":[],"length":0,"stats":{"Line":0}},{"line":1847,"address":[],"length":0,"stats":{"Line":0}},{"line":1848,"address":[],"length":0,"stats":{"Line":0}},{"line":1849,"address":[],"length":0,"stats":{"Line":0}},{"line":1851,"address":[],"length":0,"stats":{"Line":0}},{"line":1853,"address":[],"length":0,"stats":{"Line":0}},{"line":1854,"address":[],"length":0,"stats":{"Line":0}},{"line":1856,"address":[],"length":0,"stats":{"Line":0}},{"line":1861,"address":[],"length":0,"stats":{"Line":0}},{"line":1864,"address":[],"length":0,"stats":{"Line":0}},{"line":1865,"address":[],"length":0,"stats":{"Line":0}},{"line":1866,"address":[],"length":0,"stats":{"Line":0}},{"line":1867,"address":[],"length":0,"stats":{"Line":0}},{"line":1868,"address":[],"length":0,"stats":{"Line":0}},{"line":1869,"address":[],"length":0,"stats":{"Line":0}},{"line":1870,"address":[],"length":0,"stats":{"Line":0}},{"line":1871,"address":[],"length":0,"stats":{"Line":0}},{"line":1876,"address":[],"length":0,"stats":{"Line":0}},{"line":1877,"address":[],"length":0,"stats":{"Line":0}},{"line":1881,"address":[],"length":0,"stats":{"Line":0}},{"line":1882,"address":[],"length":0,"stats":{"Line":0}},{"line":1883,"address":[],"length":0,"stats":{"Line":0}},{"line":1885,"address":[],"length":0,"stats":{"Line":0}},{"line":1886,"address":[],"length":0,"stats":{"Line":0}},{"line":1887,"address":[],"length":0,"stats":{"Line":0}},{"line":1888,"address":[],"length":0,"stats":{"Line":0}},{"line":1889,"address":[],"length":0,"stats":{"Line":0}},{"line":1893,"address":[],"length":0,"stats":{"Line":0}},{"line":1895,"address":[],"length":0,"stats":{"Line":0}},{"line":1896,"address":[],"length":0,"stats":{"Line":0}},{"line":1897,"address":[],"length":0,"stats":{"Line":0}},{"line":1898,"address":[],"length":0,"stats":{"Line":0}},{"line":1899,"address":[],"length":0,"stats":{"Line":0}},{"line":1900,"address":[],"length":0,"stats":{"Line":0}},{"line":1902,"address":[],"length":0,"stats":{"Line":0}},{"line":1903,"address":[],"length":0,"stats":{"Line":0}},{"line":1909,"address":[],"length":0,"stats":{"Line":0}},{"line":1913,"address":[],"length":0,"stats":{"Line":0}},{"line":1914,"address":[],"length":0,"stats":{"Line":0}},{"line":1915,"address":[],"length":0,"stats":{"Line":0}},{"line":1918,"address":[],"length":0,"stats":{"Line":0}},{"line":1920,"address":[],"length":0,"stats":{"Line":0}},{"line":1921,"address":[],"length":0,"stats":{"Line":0}},{"line":1922,"address":[],"length":0,"stats":{"Line":0}},{"line":1923,"address":[],"length":0,"stats":{"Line":0}},{"line":1924,"address":[],"length":0,"stats":{"Line":0}},{"line":1925,"address":[],"length":0,"stats":{"Line":0}},{"line":1926,"address":[],"length":0,"stats":{"Line":0}},{"line":1927,"address":[],"length":0,"stats":{"Line":0}},{"line":1928,"address":[],"length":0,"stats":{"Line":0}},{"line":1930,"address":[],"length":0,"stats":{"Line":0}},{"line":1931,"address":[],"length":0,"stats":{"Line":0}},{"line":1934,"address":[],"length":0,"stats":{"Line":0}},{"line":1935,"address":[],"length":0,"stats":{"Line":0}},{"line":1936,"address":[],"length":0,"stats":{"Line":0}},{"line":1937,"address":[],"length":0,"stats":{"Line":0}},{"line":1938,"address":[],"length":0,"stats":{"Line":0}},{"line":1939,"address":[],"length":0,"stats":{"Line":0}},{"line":1947,"address":[],"length":0,"stats":{"Line":0}},{"line":1952,"address":[],"length":0,"stats":{"Line":0}},{"line":1953,"address":[],"length":0,"stats":{"Line":0}},{"line":1954,"address":[],"length":0,"stats":{"Line":0}},{"line":1957,"address":[],"length":0,"stats":{"Line":0}},{"line":1958,"address":[],"length":0,"stats":{"Line":0}},{"line":1959,"address":[],"length":0,"stats":{"Line":0}},{"line":1960,"address":[],"length":0,"stats":{"Line":0}},{"line":1961,"address":[],"length":0,"stats":{"Line":0}},{"line":1965,"address":[],"length":0,"stats":{"Line":0}},{"line":1968,"address":[],"length":0,"stats":{"Line":0}},{"line":1969,"address":[],"length":0,"stats":{"Line":0}},{"line":1970,"address":[],"length":0,"stats":{"Line":0}},{"line":1973,"address":[],"length":0,"stats":{"Line":0}},{"line":1974,"address":[],"length":0,"stats":{"Line":0}},{"line":1975,"address":[],"length":0,"stats":{"Line":0}},{"line":1976,"address":[],"length":0,"stats":{"Line":0}},{"line":1979,"address":[],"length":0,"stats":{"Line":0}},{"line":1980,"address":[],"length":0,"stats":{"Line":0}},{"line":1981,"address":[],"length":0,"stats":{"Line":0}},{"line":1982,"address":[],"length":0,"stats":{"Line":0}},{"line":1983,"address":[],"length":0,"stats":{"Line":0}},{"line":1984,"address":[],"length":0,"stats":{"Line":0}},{"line":1987,"address":[],"length":0,"stats":{"Line":0}},{"line":1990,"address":[],"length":0,"stats":{"Line":0}},{"line":1991,"address":[],"length":0,"stats":{"Line":0}},{"line":1992,"address":[],"length":0,"stats":{"Line":0}},{"line":1993,"address":[],"length":0,"stats":{"Line":0}},{"line":1994,"address":[],"length":0,"stats":{"Line":0}},{"line":1995,"address":[],"length":0,"stats":{"Line":0}},{"line":1999,"address":[],"length":0,"stats":{"Line":0}},{"line":2000,"address":[],"length":0,"stats":{"Line":0}},{"line":2004,"address":[],"length":0,"stats":{"Line":0}},{"line":2005,"address":[],"length":0,"stats":{"Line":0}},{"line":2006,"address":[],"length":0,"stats":{"Line":0}},{"line":2007,"address":[],"length":0,"stats":{"Line":0}},{"line":2008,"address":[],"length":0,"stats":{"Line":0}},{"line":2009,"address":[],"length":0,"stats":{"Line":0}},{"line":2011,"address":[],"length":0,"stats":{"Line":0}},{"line":2017,"address":[],"length":0,"stats":{"Line":0}},{"line":2021,"address":[],"length":0,"stats":{"Line":0}},{"line":2024,"address":[],"length":0,"stats":{"Line":0}},{"line":2025,"address":[],"length":0,"stats":{"Line":0}},{"line":2026,"address":[],"length":0,"stats":{"Line":0}},{"line":2027,"address":[],"length":0,"stats":{"Line":0}},{"line":2028,"address":[],"length":0,"stats":{"Line":0}},{"line":2033,"address":[],"length":0,"stats":{"Line":0}},{"line":2034,"address":[],"length":0,"stats":{"Line":0}},{"line":2037,"address":[],"length":0,"stats":{"Line":0}},{"line":2038,"address":[],"length":0,"stats":{"Line":0}},{"line":2039,"address":[],"length":0,"stats":{"Line":0}},{"line":2041,"address":[],"length":0,"stats":{"Line":0}},{"line":2042,"address":[],"length":0,"stats":{"Line":0}},{"line":2043,"address":[],"length":0,"stats":{"Line":0}},{"line":2044,"address":[],"length":0,"stats":{"Line":0}},{"line":2047,"address":[],"length":0,"stats":{"Line":0}},{"line":2048,"address":[],"length":0,"stats":{"Line":0}},{"line":2049,"address":[],"length":0,"stats":{"Line":0}},{"line":2050,"address":[],"length":0,"stats":{"Line":0}},{"line":2051,"address":[],"length":0,"stats":{"Line":0}},{"line":2052,"address":[],"length":0,"stats":{"Line":0}},{"line":2057,"address":[],"length":0,"stats":{"Line":0}},{"line":2058,"address":[],"length":0,"stats":{"Line":0}},{"line":2059,"address":[],"length":0,"stats":{"Line":0}},{"line":2060,"address":[],"length":0,"stats":{"Line":0}},{"line":2061,"address":[],"length":0,"stats":{"Line":0}},{"line":2066,"address":[],"length":0,"stats":{"Line":0}},{"line":2067,"address":[],"length":0,"stats":{"Line":0}},{"line":2068,"address":[],"length":0,"stats":{"Line":0}},{"line":2069,"address":[],"length":0,"stats":{"Line":0}},{"line":2070,"address":[],"length":0,"stats":{"Line":0}},{"line":2071,"address":[],"length":0,"stats":{"Line":0}},{"line":2072,"address":[],"length":0,"stats":{"Line":0}},{"line":2073,"address":[],"length":0,"stats":{"Line":0}},{"line":2078,"address":[],"length":0,"stats":{"Line":0}},{"line":2080,"address":[],"length":0,"stats":{"Line":0}},{"line":2081,"address":[],"length":0,"stats":{"Line":0}},{"line":2082,"address":[],"length":0,"stats":{"Line":0}},{"line":2083,"address":[],"length":0,"stats":{"Line":0}},{"line":2088,"address":[],"length":0,"stats":{"Line":0}},{"line":2089,"address":[],"length":0,"stats":{"Line":0}},{"line":2090,"address":[],"length":0,"stats":{"Line":0}},{"line":2091,"address":[],"length":0,"stats":{"Line":0}},{"line":2094,"address":[],"length":0,"stats":{"Line":0}},{"line":2095,"address":[],"length":0,"stats":{"Line":0}},{"line":2099,"address":[],"length":0,"stats":{"Line":0}},{"line":2100,"address":[],"length":0,"stats":{"Line":0}},{"line":2101,"address":[],"length":0,"stats":{"Line":0}},{"line":2102,"address":[],"length":0,"stats":{"Line":0}},{"line":2103,"address":[],"length":0,"stats":{"Line":0}},{"line":2104,"address":[],"length":0,"stats":{"Line":0}},{"line":2109,"address":[],"length":0,"stats":{"Line":0}},{"line":2110,"address":[],"length":0,"stats":{"Line":0}},{"line":2111,"address":[],"length":0,"stats":{"Line":0}},{"line":2112,"address":[],"length":0,"stats":{"Line":0}},{"line":2113,"address":[],"length":0,"stats":{"Line":0}},{"line":2114,"address":[],"length":0,"stats":{"Line":0}},{"line":2115,"address":[],"length":0,"stats":{"Line":0}},{"line":2116,"address":[],"length":0,"stats":{"Line":0}},{"line":2122,"address":[],"length":0,"stats":{"Line":0}},{"line":2123,"address":[],"length":0,"stats":{"Line":0}},{"line":2124,"address":[],"length":0,"stats":{"Line":0}},{"line":2126,"address":[],"length":0,"stats":{"Line":0}},{"line":2127,"address":[],"length":0,"stats":{"Line":0}},{"line":2128,"address":[],"length":0,"stats":{"Line":0}},{"line":2129,"address":[],"length":0,"stats":{"Line":0}},{"line":2130,"address":[],"length":0,"stats":{"Line":0}},{"line":2135,"address":[],"length":0,"stats":{"Line":0}},{"line":2136,"address":[],"length":0,"stats":{"Line":0}},{"line":2141,"address":[],"length":0,"stats":{"Line":0}},{"line":2142,"address":[],"length":0,"stats":{"Line":0}},{"line":2143,"address":[],"length":0,"stats":{"Line":0}},{"line":2146,"address":[],"length":0,"stats":{"Line":0}},{"line":2147,"address":[],"length":0,"stats":{"Line":0}},{"line":2151,"address":[],"length":0,"stats":{"Line":0}},{"line":2152,"address":[],"length":0,"stats":{"Line":0}},{"line":2153,"address":[],"length":0,"stats":{"Line":0}},{"line":2154,"address":[],"length":0,"stats":{"Line":0}},{"line":2155,"address":[],"length":0,"stats":{"Line":0}},{"line":2156,"address":[],"length":0,"stats":{"Line":0}},{"line":2157,"address":[],"length":0,"stats":{"Line":0}},{"line":2159,"address":[],"length":0,"stats":{"Line":0}},{"line":2160,"address":[],"length":0,"stats":{"Line":0}},{"line":2162,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1226},{"path":["C:","\\","Projects","home-registry","src","api","backup.rs"],"content":"//! Backup & Restore API endpoints\n//!\n//! Provides endpoints for creating, listing, downloading, uploading,\n//! restoring, and deleting database backups. All endpoints require\n//! admin authentication.\n\nuse actix_multipart::form::{tempfile::TempFile, MultipartForm};\nuse actix_web::{delete, get, post, web, HttpRequest, HttpResponse, Responder, Result};\nuse deadpool_postgres::Pool;\nuse log::{error, info};\nuse std::path::Path;\n\nuse crate::api::auth;\nuse crate::db::DatabaseService;\nuse crate::models::{ApiResponse, BackupData, BackupInfo, BackupMetadata, ErrorResponse};\n\n/// Directory where backup files are stored\nconst BACKUPS_DIR: &str = \"backups\";\n\n/// Multipart form for backup file upload\n#[derive(MultipartForm)]\nstruct BackupUploadForm {\n    #[multipart(limit = \"100MB\")]\n    file: TempFile,\n}\n\n// ==================== Helper Functions ====================\n\n/// Validate backup filename to prevent path traversal attacks\nfn validate_backup_filename(filename: &str) -> std::result::Result<(), String> {\n    if !Path::new(filename)\n        .extension()\n        .is_some_and(|ext| ext.eq_ignore_ascii_case(\"json\"))\n    {\n        return Err(\"Only .json backup files are allowed\".to_string());\n    }\n    if filename.contains('/') || filename.contains('\\\\') || filename.contains(\"..\") {\n        return Err(\"Invalid filename\".to_string());\n    }\n    if !filename.starts_with(\"home_registry_\") {\n        return Err(\"Invalid backup filename format\".to_string());\n    }\n    Ok(())\n}\n\n/// Format file size in human-readable format\n#[allow(clippy::cast_precision_loss)]\nfn format_file_size(bytes: u64) -> String {\n    const KB: u64 = 1024;\n    const MB: u64 = KB * 1024;\n    const GB: u64 = MB * 1024;\n\n    if bytes >= GB {\n        format!(\"{:.2} GB\", bytes as f64 / GB as f64)\n    } else if bytes >= MB {\n        format!(\"{:.2} MB\", bytes as f64 / MB as f64)\n    } else if bytes >= KB {\n        format!(\"{:.2} KB\", bytes as f64 / KB as f64)\n    } else {\n        format!(\"{bytes} B\")\n    }\n}\n\n/// Generate a timestamped backup filename\nfn generate_backup_filename(prefix: &str) -> String {\n    let timestamp = chrono::Utc::now().format(\"%Y.%m.%d.%H.%M.%S\").to_string();\n    format!(\"{prefix}_{timestamp}.json\")\n}\n\n/// Ensure the backups directory exists\nasync fn ensure_backups_dir() -> std::io::Result<()> {\n    tokio::fs::create_dir_all(BACKUPS_DIR).await\n}\n\n/// Create a backup file and return its info\nasync fn create_backup_file(\n    db_service: &DatabaseService,\n    filename_prefix: &str,\n) -> std::result::Result<BackupInfo, Box<dyn std::error::Error>> {\n    ensure_backups_dir().await?;\n\n    let filename = generate_backup_filename(filename_prefix);\n    let filepath = format!(\"{BACKUPS_DIR}/{filename}\");\n\n    // Export all database data\n    let db_content = db_service.export_all_data().await?;\n\n    // Create backup envelope with metadata\n    let backup_data = BackupData {\n        metadata: BackupMetadata {\n            version: \"1.0\".to_string(),\n            app_version: env!(\"CARGO_PKG_VERSION\").to_string(),\n            created_at: chrono::Utc::now().to_rfc3339(),\n            database_type: \"postgresql\".to_string(),\n            description: None,\n        },\n        data: db_content,\n    };\n\n    // Serialize to pretty JSON\n    let json_content = serde_json::to_string_pretty(&backup_data)?;\n    let file_size = json_content.len() as u64;\n\n    // Write to file\n    tokio::fs::write(&filepath, &json_content).await?;\n\n    info!(\n        \"Backup created: {} ({})\",\n        filename,\n        format_file_size(file_size)\n    );\n\n    Ok(BackupInfo {\n        name: filename,\n        date: backup_data.metadata.created_at,\n        size: format_file_size(file_size),\n    })\n}\n\n// ==================== API Handlers ====================\n\n/// Create a new backup of all database data\n///\n/// POST /api/backup/create\n/// Requires: Admin authentication\n#[post(\"/backup/create\")]\npub async fn create_backup(pool: web::Data<Pool>, req: HttpRequest) -> Result<impl Responder> {\n    let auth = match auth::require_admin(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match create_backup_file(&db_service, \"home_registry\").await {\n        Ok(backup_info) => {\n            info!(\n                \"Backup created by admin user {}: {}\",\n                auth.username, backup_info.name\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(backup_info),\n                message: Some(\"Backup created successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Failed to create backup: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to create backup\".to_string()),\n            }))\n        },\n    }\n}\n\n/// List all available backup files\n///\n/// GET /api/backup/list\n/// Requires: Admin authentication\n#[get(\"/backup/list\")]\npub async fn list_backups(pool: web::Data<Pool>, req: HttpRequest) -> Result<impl Responder> {\n    let auth = match auth::require_admin(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    // Ensure backups directory exists\n    if let Err(e) = ensure_backups_dir().await {\n        error!(\"Failed to create backups directory: {}\", e);\n        return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n            success: false,\n            error: \"An internal error occurred\".to_string(),\n            message: Some(\"Failed to access backups directory\".to_string()),\n        }));\n    }\n\n    // Read directory and collect backup file info\n    let mut backups: Vec<BackupInfo> = Vec::new();\n    let mut entries = match tokio::fs::read_dir(BACKUPS_DIR).await {\n        Ok(entries) => entries,\n        Err(e) => {\n            error!(\"Failed to read backups directory: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to read backups directory\".to_string()),\n            }));\n        },\n    };\n\n    while let Ok(Some(entry)) = entries.next_entry().await {\n        let path = entry.path();\n        if let Some(ext) = path.extension() {\n            if ext == \"json\" {\n                if let Ok(metadata) = entry.metadata().await {\n                    let name = entry.file_name().to_string_lossy().to_string();\n                    let date = metadata\n                        .modified()\n                        .map(|t| {\n                            let datetime: chrono::DateTime<chrono::Utc> = t.into();\n                            datetime.to_rfc3339()\n                        })\n                        .unwrap_or_default();\n                    let size = format_file_size(metadata.len());\n\n                    backups.push(BackupInfo { name, date, size });\n                }\n            }\n        }\n    }\n\n    // Sort by date, newest first\n    backups.sort_by(|a, b| b.date.cmp(&a.date));\n\n    let count = backups.len();\n    info!(\"Listed {} backups for admin user {}\", count, auth.username);\n\n    Ok(HttpResponse::Ok().json(ApiResponse {\n        success: true,\n        data: Some(backups),\n        message: Some(format!(\"Retrieved {count} backups\")),\n        error: None,\n    }))\n}\n\n/// Download a backup file\n///\n/// GET /api/backup/download/{filename}\n/// Requires: Admin authentication\n#[get(\"/backup/download/{filename}\")]\npub async fn download_backup(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<String>,\n) -> Result<impl Responder> {\n    let auth = match auth::require_admin(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let filename = path.into_inner();\n\n    // Validate filename to prevent path traversal\n    if let Err(e) = validate_backup_filename(&filename) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: e,\n            message: Some(\"Invalid backup filename\".to_string()),\n        }));\n    }\n\n    let filepath = format!(\"{BACKUPS_DIR}/{filename}\");\n\n    // Verify file exists\n    if !tokio::fs::try_exists(&filepath).await.unwrap_or(false) {\n        return Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"Backup file not found\".to_string(),\n            message: Some(format!(\"Backup '{filename}' does not exist\")),\n        }));\n    }\n\n    // Read file content\n    match tokio::fs::read(&filepath).await {\n        Ok(content) => {\n            info!(\n                \"Backup '{}' downloaded by admin user {}\",\n                filename, auth.username\n            );\n            Ok(HttpResponse::Ok()\n                .content_type(\"application/json\")\n                .insert_header((\n                    \"Content-Disposition\",\n                    format!(\"attachment; filename=\\\"{filename}\\\"\"),\n                ))\n                .body(content))\n        },\n        Err(e) => {\n            error!(\"Failed to read backup file '{}': {}\", filename, e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to read backup file\".to_string()),\n            }))\n        },\n    }\n}\n\n/// Upload a backup file\n///\n/// POST /api/backup/upload\n/// Requires: Admin authentication\n/// Accepts: multipart/form-data with a 'file' field containing a .json backup\n#[post(\"/backup/upload\")]\npub async fn upload_backup(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    MultipartForm(form): MultipartForm<BackupUploadForm>,\n) -> Result<impl Responder> {\n    let auth = match auth::require_admin(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    // Get the original filename\n    let original_filename = form\n        .file\n        .file_name\n        .as_deref()\n        .unwrap_or(\"unknown.json\")\n        .to_string();\n\n    // Validate file extension\n    if !Path::new(&original_filename)\n        .extension()\n        .is_some_and(|ext| ext.eq_ignore_ascii_case(\"json\"))\n    {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Only .json backup files are allowed\".to_string(),\n            message: Some(\"Please upload a valid JSON backup file\".to_string()),\n        }));\n    }\n\n    // Read the temp file content\n    let temp_path = form.file.file.path();\n    let content = match tokio::fs::read(temp_path).await {\n        Ok(c) => c,\n        Err(e) => {\n            error!(\"Failed to read uploaded file: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to process uploaded file\".to_string()),\n            }));\n        },\n    };\n\n    // Validate JSON structure\n    let backup_data: BackupData = match serde_json::from_slice(&content) {\n        Ok(data) => data,\n        Err(e) => {\n            error!(\"Invalid backup file format: {}\", e);\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Invalid backup file format\".to_string(),\n                message: Some(\"The uploaded file is not a valid Home Registry backup\".to_string()),\n            }));\n        },\n    };\n\n    // Validate backup version\n    if backup_data.metadata.version != \"1.0\" {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: format!(\n                \"Unsupported backup version: {}\",\n                backup_data.metadata.version\n            ),\n            message: Some(\"This backup version is not supported\".to_string()),\n        }));\n    }\n\n    // Ensure backups directory exists\n    if let Err(e) = ensure_backups_dir().await {\n        error!(\"Failed to create backups directory: {}\", e);\n        return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n            success: false,\n            error: \"An internal error occurred\".to_string(),\n            message: Some(\"Failed to save backup file\".to_string()),\n        }));\n    }\n\n    // Determine target filename  use the original name if valid, otherwise generate\n    let mut target_filename = if validate_backup_filename(&original_filename).is_ok() {\n        original_filename\n    } else {\n        generate_backup_filename(\"home_registry\")\n    };\n\n    // Avoid silently overwriting an existing backup file\n    let mut filepath = format!(\"{BACKUPS_DIR}/{target_filename}\");\n    if tokio::fs::try_exists(&filepath).await.unwrap_or(false) {\n        // Append a numeric suffix to make the filename unique\n        let stem = target_filename.trim_end_matches(\".json\");\n        for i in 1..=100 {\n            let candidate = format!(\"{stem}_{i}.json\");\n            let candidate_path = format!(\"{BACKUPS_DIR}/{candidate}\");\n            if !tokio::fs::try_exists(&candidate_path)\n                .await\n                .unwrap_or(false)\n            {\n                target_filename = candidate;\n                filepath = candidate_path;\n                break;\n            }\n        }\n    }\n\n    let file_size = content.len() as u64;\n\n    // Write to backups directory\n    if let Err(e) = tokio::fs::write(&filepath, &content).await {\n        error!(\"Failed to save uploaded backup: {}\", e);\n        return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n            success: false,\n            error: \"An internal error occurred\".to_string(),\n            message: Some(\"Failed to save backup file\".to_string()),\n        }));\n    }\n\n    info!(\n        \"Backup '{}' uploaded by admin user {} ({})\",\n        target_filename,\n        auth.username,\n        format_file_size(file_size)\n    );\n\n    Ok(HttpResponse::Ok().json(ApiResponse {\n        success: true,\n        data: Some(BackupInfo {\n            name: target_filename,\n            date: backup_data.metadata.created_at,\n            size: format_file_size(file_size),\n        }),\n        message: Some(\"Backup uploaded successfully\".to_string()),\n        error: None,\n    }))\n}\n\n/// Restore database from a backup file\n///\n/// POST /api/backup/restore/{filename}\n/// Requires: Admin authentication\n/// Creates an automatic backup before restoring (safety net)\n#[post(\"/backup/restore/{filename}\")]\npub async fn restore_backup(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<String>,\n) -> Result<impl Responder> {\n    let auth = match auth::require_admin(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let filename = path.into_inner();\n\n    // Validate filename\n    if let Err(e) = validate_backup_filename(&filename) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: e,\n            message: Some(\"Invalid backup filename\".to_string()),\n        }));\n    }\n\n    let filepath = format!(\"{BACKUPS_DIR}/{filename}\");\n\n    // Verify backup file exists\n    if !tokio::fs::try_exists(&filepath).await.unwrap_or(false) {\n        return Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"Backup file not found\".to_string(),\n            message: Some(format!(\"Backup '{filename}' does not exist\")),\n        }));\n    }\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    // AUTO-BACKUP: Create a backup before restoring (safety net)\n    let auto_backup_info = match create_backup_file(&db_service, \"home_registry_auto_pre_restore\")\n        .await\n    {\n        Ok(info) => {\n            info!(\"Auto-backup created before restore: {}\", info.name);\n            info\n        },\n        Err(e) => {\n            error!(\"Failed to create auto-backup before restore: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\n                    \"Failed to create safety backup before restore. Restore aborted.\".to_string(),\n                ),\n            }));\n        },\n    };\n\n    // Read and parse the backup file\n    let content = match tokio::fs::read(&filepath).await {\n        Ok(c) => c,\n        Err(e) => {\n            error!(\"Failed to read backup file '{}': {}\", filename, e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to read backup file\".to_string()),\n            }));\n        },\n    };\n\n    let backup_data: BackupData = match serde_json::from_slice(&content) {\n        Ok(data) => data,\n        Err(e) => {\n            error!(\"Invalid backup file format '{}': {}\", filename, e);\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Invalid backup file format\".to_string(),\n                message: Some(\"The backup file could not be parsed\".to_string()),\n            }));\n        },\n    };\n\n    // Validate backup version\n    if backup_data.metadata.version != \"1.0\" {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: format!(\n                \"Unsupported backup version: {}\",\n                backup_data.metadata.version\n            ),\n            message: Some(\"This backup version is not supported\".to_string()),\n        }));\n    }\n\n    // Perform the restore within a transaction\n    match db_service.import_all_data(&backup_data.data).await {\n        Ok(()) => {\n            info!(\n                \"Backup '{}' restored by admin user {}\",\n                filename, auth.username\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse::<()> {\n                success: true,\n                data: None,\n                message: Some(format!(\n                    \"Backup restored successfully. A pre-restore backup was created: {}\",\n                    auto_backup_info.name\n                )),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Failed to restore backup '{}': {}\", filename, e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(format!(\n                    \"Failed to restore backup. Your pre-restore backup is available: {}\",\n                    auto_backup_info.name\n                )),\n            }))\n        },\n    }\n}\n\n/// Delete a backup file\n///\n/// DELETE /api/backup/{filename}\n/// Requires: Admin authentication\n#[delete(\"/backup/{filename}\")]\npub async fn delete_backup(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    path: web::Path<String>,\n) -> Result<impl Responder> {\n    let auth = match auth::require_admin(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let filename = path.into_inner();\n\n    // Validate filename to prevent path traversal\n    if let Err(e) = validate_backup_filename(&filename) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: e,\n            message: Some(\"Invalid backup filename\".to_string()),\n        }));\n    }\n\n    let filepath = format!(\"{BACKUPS_DIR}/{filename}\");\n\n    // Verify file exists\n    if !tokio::fs::try_exists(&filepath).await.unwrap_or(false) {\n        return Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: \"Backup file not found\".to_string(),\n            message: Some(format!(\"Backup '{filename}' does not exist\")),\n        }));\n    }\n\n    // Delete the file\n    match tokio::fs::remove_file(&filepath).await {\n        Ok(()) => {\n            info!(\n                \"Backup '{}' deleted by admin user {}\",\n                filename, auth.username\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse::<()> {\n                success: true,\n                data: None,\n                message: Some(format!(\"Backup {filename} deleted successfully\")),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Failed to delete backup '{}': {}\", filename, e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to delete backup file\".to_string()),\n            }))\n        },\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":307},{"path":["C:","\\","Projects","home-registry","src","api","mod.rs"],"content":"pub mod auth;\npub mod backup;\n\nuse crate::db::DatabaseService;\nuse crate::models::{\n    ApiResponse, CreateInventoryRequest, CreateItemRequest, CreateOrganizerOptionRequest,\n    CreateOrganizerTypeRequest, ErrorResponse, ImageUploadResponse, InventoryReportData,\n    InventoryReportRequest, Item, ItemExportRow, SetItemOrganizerValuesRequest,\n    UpdateInventoryRequest, UpdateItemRequest, UpdateOrganizerOptionRequest,\n    UpdateOrganizerTypeRequest,\n};\nuse actix_multipart::form::{tempfile::TempFile, MultipartForm};\nuse actix_web::{delete, get, post, put, web, HttpRequest, HttpResponse, Responder, Result, Scope};\nuse deadpool_postgres::Pool;\nuse log::{error, info, warn};\nuse validator::Validate;\n\n/// Validates that data URIs in `image_url` start with `data:image/` to prevent arbitrary data storage.\nfn validate_image_url(image_url: Option<&str>) -> std::result::Result<(), String> {\n    if let Some(url) = image_url {\n        if url.starts_with(\"data:\") && !url.starts_with(\"data:image/\") {\n            return Err(\"Invalid image data URI: must start with 'data:image/'\".to_string());\n        }\n    }\n    Ok(())\n}\n\n#[get(\"/\")]\npub async fn index() -> impl Responder {\n    // Serve the static HTML file instead of embedded HTML\n    match std::fs::read_to_string(\"static/index.html\") {\n        Ok(content) => HttpResponse::Ok().content_type(\"text/html\").body(content),\n        Err(_) => HttpResponse::InternalServerError().body(\"Could not load index page\"),\n    }\n}\n\n#[get(\"/health\")]\npub async fn api_health() -> impl Responder {\n    HttpResponse::Ok().json(serde_json::json!({\n        \"status\": \"ok\",\n        \"message\": \"Home Inventory Manager is running\",\n        \"timestamp\": chrono::Utc::now()\n    }))\n}\n\n// Inventories API endpoints\n#[get(\"/inventories\")]\npub async fn get_inventories(pool: web::Data<Pool>, req: HttpRequest) -> Result<impl Responder> {\n    let auth = match auth::get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_accessible_inventories(auth.user_id).await {\n        Ok(inventories) => {\n            info!(\n                \"Successfully retrieved {} inventories for user {}\",\n                inventories.len(),\n                auth.username\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(inventories.clone()),\n                message: Some(format!(\n                    \"Retrieved {count} inventories\",\n                    count = inventories.len()\n                )),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error retrieving inventories: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to retrieve inventories\".to_string()),\n            }))\n        },\n    }\n}\n\n#[post(\"/inventories\")]\npub async fn create_inventory(\n    pool: web::Data<Pool>,\n    http_req: HttpRequest,\n    req: web::Json<CreateInventoryRequest>,\n) -> Result<impl Responder> {\n    let auth = match auth::get_auth_context_from_request(&http_req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    // Validate input before processing\n    if let Err(validation_errors) = req.validate() {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Validation failed\".to_string(),\n            message: Some(validation_errors.to_string()),\n        }));\n    }\n\n    // Reject data URIs that are not images\n    if let Err(msg) = validate_image_url(req.image_url.as_deref()) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Validation failed\".to_string(),\n            message: Some(msg),\n        }));\n    }\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .create_inventory(req.into_inner(), auth.user_id)\n        .await\n    {\n        Ok(inventory) => {\n            info!(\"Successfully created inventory: {}\", inventory.name);\n            Ok(HttpResponse::Created().json(ApiResponse {\n                success: true,\n                data: Some(inventory),\n                message: Some(\"Inventory created successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error creating inventory: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to create inventory\".to_string()),\n            }))\n        },\n    }\n}\n\n#[get(\"/inventories/{id}\")]\npub async fn get_inventory(pool: web::Data<Pool>, path: web::Path<i32>) -> Result<impl Responder> {\n    let inventory_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_inventory_by_id(inventory_id).await {\n        Ok(Some(inventory)) => {\n            info!(\"Successfully retrieved inventory with id: {}\", inventory_id);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(inventory),\n                message: Some(\"Inventory retrieved successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Inventory with id {inventory_id} not found\"),\n            message: Some(\"Inventory not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error retrieving inventory: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to retrieve inventory\".to_string()),\n            }))\n        },\n    }\n}\n\n#[get(\"/inventories/{id}/items\")]\npub async fn get_inventory_items(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n) -> Result<impl Responder> {\n    let inventory_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_items_by_inventory(inventory_id).await {\n        Ok(items) => {\n            info!(\n                \"Successfully retrieved {} items for inventory {}\",\n                items.len(),\n                inventory_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(items.clone()),\n                message: Some(format!(\"Retrieved {count} items\", count = items.len())),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\n                \"Error retrieving items for inventory {}: {}\",\n                inventory_id, e\n            );\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to retrieve inventory items\".to_string()),\n            }))\n        },\n    }\n}\n\n#[put(\"/inventories/{id}\")]\npub async fn update_inventory(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n    req: web::Json<UpdateInventoryRequest>,\n) -> Result<impl Responder> {\n    // Validate input before processing\n    if let Err(validation_errors) = req.validate() {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Validation failed\".to_string(),\n            message: Some(validation_errors.to_string()),\n        }));\n    }\n\n    // Reject data URIs that are not images\n    if let Err(msg) = validate_image_url(req.image_url.as_deref()) {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Validation failed\".to_string(),\n            message: Some(msg),\n        }));\n    }\n\n    let inventory_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .update_inventory(inventory_id, req.into_inner())\n        .await\n    {\n        Ok(Some(inventory)) => {\n            info!(\"Successfully updated inventory with id: {}\", inventory_id);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(inventory),\n                message: Some(\"Inventory updated successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Inventory with id {inventory_id} not found\"),\n            message: Some(\"Inventory not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error updating inventory: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to update inventory\".to_string()),\n            }))\n        },\n    }\n}\n\n#[delete(\"/inventories/{id}\")]\npub async fn delete_inventory(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n) -> Result<impl Responder> {\n    let inventory_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.delete_inventory(inventory_id).await {\n        Ok(true) => {\n            info!(\"Successfully deleted inventory with id: {}\", inventory_id);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(()),\n                message: Some(\"Inventory deleted successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(false) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Inventory with id {inventory_id} not found\"),\n            message: Some(\"Inventory not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error deleting inventory: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to delete inventory\".to_string()),\n            }))\n        },\n    }\n}\n\n// Items API endpoints\n#[get(\"/items\")]\npub async fn get_items(pool: web::Data<Pool>) -> Result<impl Responder> {\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_all_items().await {\n        Ok(items) => {\n            info!(\"Successfully retrieved {} items from database\", items.len());\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(items.clone()),\n                message: Some(format!(\"Retrieved {count} items\", count = items.len())),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error retrieving items: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to retrieve items\".to_string()),\n            }))\n        },\n    }\n}\n\n#[get(\"/items/{id}\")]\npub async fn get_item(pool: web::Data<Pool>, path: web::Path<i32>) -> Result<impl Responder> {\n    let item_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_item_by_id(item_id).await {\n        Ok(Some(item)) => {\n            info!(\"Successfully retrieved item with id: {}\", item_id);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(item),\n                message: Some(\"Item retrieved successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Item with id {item_id} not found\"),\n            message: Some(\"Item not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error retrieving item: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to retrieve item\".to_string()),\n            }))\n        },\n    }\n}\n\n#[post(\"/items\")]\npub async fn create_item(\n    pool: web::Data<Pool>,\n    req: web::Json<CreateItemRequest>,\n) -> Result<impl Responder> {\n    // Validate input before processing\n    if let Err(validation_errors) = req.validate() {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Validation failed\".to_string(),\n            message: Some(validation_errors.to_string()),\n        }));\n    }\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.create_item(req.into_inner()).await {\n        Ok(item) => {\n            info!(\"Successfully created item: {}\", item.name);\n            Ok(HttpResponse::Created().json(ApiResponse {\n                success: true,\n                data: Some(item),\n                message: Some(\"Item created successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error creating item: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to create item\".to_string()),\n            }))\n        },\n    }\n}\n\n#[put(\"/items/{id}\")]\npub async fn update_item(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n    req: web::Json<UpdateItemRequest>,\n) -> Result<impl Responder> {\n    // Validate input before processing\n    if let Err(validation_errors) = req.validate() {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Validation failed\".to_string(),\n            message: Some(validation_errors.to_string()),\n        }));\n    }\n\n    let item_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.update_item(item_id, req.into_inner()).await {\n        Ok(Some(item)) => {\n            info!(\"Successfully updated item with id: {}\", item_id);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(item),\n                message: Some(\"Item updated successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Item with id {item_id} not found\"),\n            message: Some(\"Item not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error updating item: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to update item\".to_string()),\n            }))\n        },\n    }\n}\n\n#[delete(\"/items/{id}\")]\npub async fn delete_item(pool: web::Data<Pool>, path: web::Path<i32>) -> Result<impl Responder> {\n    let item_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.delete_item(item_id).await {\n        Ok(true) => {\n            info!(\"Successfully deleted item with id: {}\", item_id);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(()),\n                message: Some(\"Item deleted successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(false) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Item with id {item_id} not found\"),\n            message: Some(\"Item not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error deleting item: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to delete item\".to_string()),\n            }))\n        },\n    }\n}\n\n#[get(\"/items/search/{query}\")]\npub async fn search_items(\n    pool: web::Data<Pool>,\n    path: web::Path<String>,\n) -> Result<impl Responder> {\n    let query = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.search_items(&query).await {\n        Ok(items) => {\n            info!(\n                \"Successfully searched items with query '{}', found {} results\",\n                query,\n                items.len()\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(items.clone()),\n                message: Some(format!(\n                    \"Found {count} items matching '{query}'\",\n                    count = items.len()\n                )),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error searching items: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to search items\".to_string()),\n            }))\n        },\n    }\n}\n\n// ==================== Organizer Type Endpoints ====================\n\n#[get(\"/inventories/{id}/organizers\")]\npub async fn get_inventory_organizers(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n) -> Result<impl Responder> {\n    let inventory_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .get_organizer_types_with_options_by_inventory(inventory_id)\n        .await\n    {\n        Ok(organizers) => {\n            info!(\n                \"Successfully retrieved {} organizers for inventory {}\",\n                organizers.len(),\n                inventory_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(organizers.clone()),\n                message: Some(format!(\n                    \"Retrieved {count} organizers\",\n                    count = organizers.len()\n                )),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error retrieving organizers: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to retrieve organizers\".to_string()),\n            }))\n        },\n    }\n}\n\n#[post(\"/inventories/{id}/organizers\")]\npub async fn create_organizer_type(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n    req: web::Json<CreateOrganizerTypeRequest>,\n) -> Result<impl Responder> {\n    let inventory_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .create_organizer_type(inventory_id, req.into_inner())\n        .await\n    {\n        Ok(organizer) => {\n            info!(\"Successfully created organizer type: {}\", organizer.name);\n            Ok(HttpResponse::Created().json(ApiResponse {\n                success: true,\n                data: Some(organizer),\n                message: Some(\"Organizer type created successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error creating organizer type: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to create organizer type\".to_string()),\n            }))\n        },\n    }\n}\n\n#[get(\"/organizers/{id}\")]\npub async fn get_organizer_type(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n) -> Result<impl Responder> {\n    let organizer_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_organizer_type_by_id(organizer_id).await {\n        Ok(Some(organizer)) => {\n            info!(\n                \"Successfully retrieved organizer type with id: {}\",\n                organizer_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(organizer),\n                message: Some(\"Organizer type retrieved successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Organizer type with id {organizer_id} not found\"),\n            message: Some(\"Organizer type not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error retrieving organizer type: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to retrieve organizer type\".to_string()),\n            }))\n        },\n    }\n}\n\n#[put(\"/organizers/{id}\")]\npub async fn update_organizer_type(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n    req: web::Json<UpdateOrganizerTypeRequest>,\n) -> Result<impl Responder> {\n    let organizer_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .update_organizer_type(organizer_id, req.into_inner())\n        .await\n    {\n        Ok(Some(organizer)) => {\n            info!(\n                \"Successfully updated organizer type with id: {}\",\n                organizer_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(organizer),\n                message: Some(\"Organizer type updated successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Organizer type with id {organizer_id} not found\"),\n            message: Some(\"Organizer type not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error updating organizer type: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to update organizer type\".to_string()),\n            }))\n        },\n    }\n}\n\n#[delete(\"/organizers/{id}\")]\npub async fn delete_organizer_type(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n) -> Result<impl Responder> {\n    let organizer_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.delete_organizer_type(organizer_id).await {\n        Ok(true) => {\n            info!(\n                \"Successfully deleted organizer type with id: {}\",\n                organizer_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(()),\n                message: Some(\"Organizer type deleted successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(false) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Organizer type with id {organizer_id} not found\"),\n            message: Some(\"Organizer type not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error deleting organizer type: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to delete organizer type\".to_string()),\n            }))\n        },\n    }\n}\n\n// ==================== Organizer Option Endpoints ====================\n\n#[get(\"/organizers/{id}/options\")]\npub async fn get_organizer_options(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n) -> Result<impl Responder> {\n    let organizer_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_organizer_options(organizer_id).await {\n        Ok(options) => {\n            info!(\n                \"Successfully retrieved {} options for organizer {}\",\n                options.len(),\n                organizer_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(options.clone()),\n                message: Some(format!(\"Retrieved {count} options\", count = options.len())),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error retrieving organizer options: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to retrieve organizer options\".to_string()),\n            }))\n        },\n    }\n}\n\n#[post(\"/organizers/{id}/options\")]\npub async fn create_organizer_option(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n    req: web::Json<CreateOrganizerOptionRequest>,\n) -> Result<impl Responder> {\n    let organizer_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .create_organizer_option(organizer_id, req.into_inner())\n        .await\n    {\n        Ok(option) => {\n            info!(\"Successfully created organizer option: {}\", option.name);\n            Ok(HttpResponse::Created().json(ApiResponse {\n                success: true,\n                data: Some(option),\n                message: Some(\"Organizer option created successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error creating organizer option: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to create organizer option\".to_string()),\n            }))\n        },\n    }\n}\n\n#[put(\"/organizer-options/{id}\")]\npub async fn update_organizer_option(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n    req: web::Json<UpdateOrganizerOptionRequest>,\n) -> Result<impl Responder> {\n    let option_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .update_organizer_option(option_id, req.into_inner())\n        .await\n    {\n        Ok(Some(option)) => {\n            info!(\n                \"Successfully updated organizer option with id: {}\",\n                option_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(option),\n                message: Some(\"Organizer option updated successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(None) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Organizer option with id {option_id} not found\"),\n            message: Some(\"Organizer option not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error updating organizer option: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to update organizer option\".to_string()),\n            }))\n        },\n    }\n}\n\n#[delete(\"/organizer-options/{id}\")]\npub async fn delete_organizer_option(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n) -> Result<impl Responder> {\n    let option_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.delete_organizer_option(option_id).await {\n        Ok(true) => {\n            info!(\n                \"Successfully deleted organizer option with id: {}\",\n                option_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(()),\n                message: Some(\"Organizer option deleted successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(false) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Organizer option with id {option_id} not found\"),\n            message: Some(\"Organizer option not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error deleting organizer option: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to delete organizer option\".to_string()),\n            }))\n        },\n    }\n}\n\n// ==================== Item Organizer Value Endpoints ====================\n\n#[get(\"/items/{id}/organizer-values\")]\npub async fn get_item_organizer_values(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n) -> Result<impl Responder> {\n    let item_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service.get_item_organizer_values(item_id).await {\n        Ok(values) => {\n            info!(\n                \"Successfully retrieved {} organizer values for item {}\",\n                values.len(),\n                item_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(values.clone()),\n                message: Some(format!(\n                    \"Retrieved {count} organizer values\",\n                    count = values.len()\n                )),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error retrieving item organizer values: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to retrieve item organizer values\".to_string()),\n            }))\n        },\n    }\n}\n\n#[put(\"/items/{id}/organizer-values\")]\npub async fn set_item_organizer_values(\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n    req: web::Json<SetItemOrganizerValuesRequest>,\n) -> Result<impl Responder> {\n    let item_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .set_item_organizer_values(item_id, req.into_inner().values)\n        .await\n    {\n        Ok(values) => {\n            info!(\n                \"Successfully set {} organizer values for item {}\",\n                values.len(),\n                item_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(values),\n                message: Some(\"Item organizer values updated successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error setting item organizer values: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to set item organizer values\".to_string()),\n            }))\n        },\n    }\n}\n\n#[delete(\"/items/{item_id}/organizer-values/{organizer_type_id}\")]\npub async fn delete_item_organizer_value(\n    pool: web::Data<Pool>,\n    path: web::Path<(i32, i32)>,\n) -> Result<impl Responder> {\n    let (item_id, organizer_type_id) = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .delete_item_organizer_value(item_id, organizer_type_id)\n        .await\n    {\n        Ok(true) => {\n            info!(\n                \"Successfully deleted organizer value for item {} type {}\",\n                item_id, organizer_type_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(()),\n                message: Some(\"Item organizer value deleted successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Ok(false) => Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Organizer value not found for item {item_id} type {organizer_type_id}\"),\n            message: Some(\"Item organizer value not found\".to_string()),\n        })),\n        Err(e) => {\n            error!(\"Error deleting item organizer value: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to delete item organizer value\".to_string()),\n            }))\n        },\n    }\n}\n\n// ==================== Image Upload/Delete Endpoints ====================\n\n/// Validate file magic bytes to determine actual image type.\n/// Returns the file extension if valid, or None if not a recognized image.\nfn detect_image_type(data: &[u8]) -> Option<&'static str> {\n    if data.len() < 4 {\n        return None;\n    }\n    // JPEG: starts with FF D8 FF\n    if data.len() >= 3 && data[0] == 0xFF && data[1] == 0xD8 && data[2] == 0xFF {\n        return Some(\"jpg\");\n    }\n    // PNG: starts with 89 50 4E 47 0D 0A 1A 0A\n    if data.len() >= 8 && data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47 {\n        return Some(\"png\");\n    }\n    // GIF: starts with GIF87a or GIF89a\n    if data.len() >= 6 && data[0] == 0x47 && data[1] == 0x49 && data[2] == 0x46 {\n        return Some(\"gif\");\n    }\n    // WebP: starts with RIFF....WEBP\n    if data.len() >= 12\n        && data[0] == 0x52\n        && data[1] == 0x49\n        && data[2] == 0x46\n        && data[3] == 0x46\n        && data[8] == 0x57\n        && data[9] == 0x45\n        && data[10] == 0x42\n        && data[11] == 0x50\n    {\n        return Some(\"webp\");\n    }\n    None\n}\n\n/// Validate that a filename is safe (no path traversal).\n/// Only allows alphanumeric chars, underscores, hyphens, a single dot, and an extension.\nfn is_safe_filename(filename: &str) -> bool {\n    if filename.contains(\"..\")\n        || filename.contains('/')\n        || filename.contains('\\\\')\n        || filename.is_empty()\n    {\n        return false;\n    }\n    // Must be: one or more [a-zA-Z0-9_-], then a dot, then one or more [a-zA-Z0-9]\n    filename\n        .bytes()\n        .all(|b| b.is_ascii_alphanumeric() || b == b'_' || b == b'-' || b == b'.')\n        && filename.chars().filter(|c| *c == '.').count() == 1\n        && !filename.starts_with('.')\n        && !filename.ends_with('.')\n}\n\nconst MAX_IMAGE_SIZE: usize = 5 * 1024 * 1024; // 5 MB\n\n/// Multipart form for image upload\n#[derive(MultipartForm)]\nstruct ImageUploadForm {\n    #[multipart(limit = \"5MB\")]\n    image: TempFile,\n}\n\n#[post(\"/images/upload\")]\npub async fn upload_image(\n    req: HttpRequest,\n    pool: web::Data<Pool>,\n    MultipartForm(form): MultipartForm<ImageUploadForm>,\n) -> Result<impl Responder> {\n    // Auth check\n    let _auth = match auth::get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    // Read the temp file contents\n    let file_data = match tokio::fs::read(form.image.file.path()).await {\n        Ok(data) => data,\n        Err(e) => {\n            error!(\"Failed to read uploaded temp file: {}\", e);\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Upload read error\".to_string(),\n                message: Some(format!(\"Failed to read upload data: {e}\")),\n            }));\n        },\n    };\n\n    // Check size limit\n    if file_data.len() > MAX_IMAGE_SIZE {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"File too large\".to_string(),\n            message: Some(format!(\n                \"Image must be under {} MB\",\n                MAX_IMAGE_SIZE / 1024 / 1024\n            )),\n        }));\n    }\n\n    if file_data.is_empty() {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"No image provided\".to_string(),\n            message: Some(\"Please include an 'image' field with file data\".to_string()),\n        }));\n    }\n\n    // Validate magic bytes\n    let Some(ext) = detect_image_type(&file_data) else {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Invalid image type\".to_string(),\n            message: Some(\"Only JPEG, PNG, GIF, and WebP images are allowed\".to_string()),\n        }));\n    };\n\n    // Generate unique filename: {uuid}_{timestamp}.{ext}\n    let timestamp = chrono::Utc::now().timestamp();\n    let unique_id = uuid::Uuid::new_v4().to_string().replace('-', \"\");\n    let filename = format!(\"{unique_id}_{timestamp}.{ext}\");\n\n    // Ensure uploads/img directory exists\n    let upload_dir = std::path::Path::new(\"uploads/img\");\n    if let Err(e) = tokio::fs::create_dir_all(upload_dir).await {\n        error!(\"Failed to create upload directory: {}\", e);\n        return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n            success: false,\n            error: \"Upload directory error\".to_string(),\n            message: Some(\"Failed to prepare upload directory\".to_string()),\n        }));\n    }\n\n    // Write file\n    let file_path = upload_dir.join(&filename);\n    if let Err(e) = tokio::fs::write(&file_path, &file_data).await {\n        error!(\"Failed to write uploaded image: {}\", e);\n        return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n            success: false,\n            error: \"File write error\".to_string(),\n            message: Some(\"Failed to save uploaded image\".to_string()),\n        }));\n    }\n\n    let url = format!(\"/uploads/img/{filename}\");\n    info!(\n        \"Image uploaded successfully: {} ({} bytes)\",\n        filename,\n        file_data.len()\n    );\n\n    Ok(HttpResponse::Ok().json(ApiResponse {\n        success: true,\n        data: Some(ImageUploadResponse {\n            url: url.clone(),\n            filename,\n        }),\n        message: Some(\"Image uploaded successfully\".to_string()),\n        error: None,\n    }))\n}\n\n#[delete(\"/images/{filename}\")]\npub async fn delete_image(\n    req: HttpRequest,\n    pool: web::Data<Pool>,\n    path: web::Path<String>,\n) -> Result<impl Responder> {\n    // Auth check\n    let _auth = match auth::get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let filename = path.into_inner();\n\n    // Validate filename to prevent path traversal\n    if !is_safe_filename(&filename) {\n        warn!(\n            \"Path traversal attempt detected in image delete: {}\",\n            filename\n        );\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Invalid filename\".to_string(),\n            message: Some(\"Filename contains invalid characters\".to_string()),\n        }));\n    }\n\n    let file_path = std::path::Path::new(\"uploads/img\").join(&filename);\n\n    if !file_path.exists() {\n        return Ok(HttpResponse::NotFound().json(ErrorResponse {\n            success: false,\n            error: format!(\"Image not found: {filename}\"),\n            message: Some(\"The specified image does not exist\".to_string()),\n        }));\n    }\n\n    if let Err(e) = tokio::fs::remove_file(&file_path).await {\n        error!(\"Failed to delete image {}: {}\", filename, e);\n        return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n            success: false,\n            error: \"File delete error\".to_string(),\n            message: Some(\"Failed to delete image file\".to_string()),\n        }));\n    }\n\n    info!(\"Image deleted successfully: {}\", filename);\n\n    Ok(HttpResponse::Ok().json(ApiResponse::<()> {\n        success: true,\n        data: None,\n        message: Some(\"Image deleted successfully\".to_string()),\n        error: None,\n    }))\n}\n\n#[get(\"/inventories/{id}/item-images\")]\npub async fn get_inventory_item_images(\n    req: HttpRequest,\n    pool: web::Data<Pool>,\n    path: web::Path<i32>,\n) -> Result<impl Responder> {\n    // Auth check  consistent with other inventory endpoints\n    let _auth = match auth::get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let inventory_id = path.into_inner();\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n\n    match db_service\n        .get_item_image_urls_by_inventory(inventory_id)\n        .await\n    {\n        Ok(image_map) => {\n            let count = image_map.len();\n            info!(\n                \"Retrieved {} item images for inventory {}\",\n                count, inventory_id\n            );\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(image_map),\n                message: Some(format!(\"Retrieved {count} item images\")),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\n                \"Error retrieving item images for inventory {}: {}\",\n                inventory_id, e\n            );\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"An internal error occurred\".to_string(),\n                message: Some(\"Failed to retrieve item images\".to_string()),\n            }))\n        },\n    }\n}\n\n// ==================== Inventory Reporting Endpoints ====================\n\n/// Formats a collection of items as CSV data.\n///\n/// Generates a CSV file with columns for all relevant item fields including\n/// inventory name, purchase information, and calculated total values.\n///\n/// # Arguments\n/// * `items` - Vector of items to export\n/// * `inventories` - Map of inventory IDs to names for lookup\n///\n/// # Returns\n/// * `Ok(Vec<u8>)` - UTF-8 encoded CSV data ready for HTTP response\n/// * `Err` - CSV serialization or I/O errors\nfn format_items_as_csv(\n    items: Vec<Item>,\n    inventories: &std::collections::HashMap<i32, String>,\n) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n    let mut writer = csv::Writer::from_writer(vec![]);\n\n    // Write header\n    writer.write_record([\n        \"ID\",\n        \"Inventory\",\n        \"Name\",\n        \"Description\",\n        \"Category\",\n        \"Location\",\n        \"Quantity\",\n        \"Purchase Price\",\n        \"Total Value\",\n        \"Purchase Date\",\n        \"Warranty Expiry\",\n        \"Created At\",\n    ])?;\n\n    // Write data rows\n    for item in items {\n        let inventory_name = inventories\n            .get(&item.inventory_id)\n            .map_or(\"Unknown\", std::string::String::as_str);\n\n        let total_value = item\n            .purchase_price\n            .and_then(|price| item.quantity.map(|qty| price * f64::from(qty)))\n            .map(|v| format!(\"{v:.2}\"))\n            .unwrap_or_default();\n\n        writer.serialize(ItemExportRow {\n            id: item.id.unwrap_or(0),\n            inventory_name: inventory_name.to_string(),\n            item_name: item.name,\n            description: item.description.unwrap_or_default(),\n            category: item.category.unwrap_or_default(),\n            location: item.location.unwrap_or_default(),\n            quantity: item.quantity.unwrap_or(0),\n            purchase_price: item\n                .purchase_price\n                .map(|p| format!(\"{p:.2}\"))\n                .unwrap_or_default(),\n            total_value,\n            purchase_date: item.purchase_date.unwrap_or_default(),\n            warranty_expiry: item.warranty_expiry.unwrap_or_default(),\n            created_at: item\n                .created_at\n                .map(|dt| dt.to_rfc3339())\n                .unwrap_or_default(),\n        })?;\n    }\n\n    writer.flush()?;\n    Ok(writer.into_inner()?)\n}\n\n#[get(\"/reports/inventory\")]\npub async fn get_inventory_report(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    query: web::Query<InventoryReportRequest>,\n) -> Result<impl Responder> {\n    // Get authenticated user context\n    let auth = match auth::get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let request = query.into_inner();\n\n    // Validate input\n    if let Err(validation_errors) = request.validate() {\n        return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n            success: false,\n            error: \"Validation failed\".to_string(),\n            message: Some(validation_errors.to_string()),\n        }));\n    }\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n    let format = request.format.as_deref().unwrap_or(\"json\");\n\n    // Validate date formats if provided\n    if let Some(ref date_str) = request.from_date {\n        if chrono::NaiveDate::parse_from_str(date_str, \"%Y-%m-%d\").is_err() {\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Invalid from_date format\".to_string(),\n                message: Some(\"Date must be in ISO 8601 format (YYYY-MM-DD)\".to_string()),\n            }));\n        }\n    }\n\n    if let Some(ref date_str) = request.to_date {\n        if chrono::NaiveDate::parse_from_str(date_str, \"%Y-%m-%d\").is_err() {\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Invalid to_date format\".to_string(),\n                message: Some(\"Date must be in ISO 8601 format (YYYY-MM-DD)\".to_string()),\n            }));\n        }\n    }\n\n    // Validate date range (from_date must not be after to_date)\n    if let (Some(ref from), Some(ref to)) = (&request.from_date, &request.to_date) {\n        if let (Ok(from_parsed), Ok(to_parsed)) = (\n            chrono::NaiveDate::parse_from_str(from, \"%Y-%m-%d\"),\n            chrono::NaiveDate::parse_from_str(to, \"%Y-%m-%d\"),\n        ) {\n            if to_parsed < from_parsed {\n                return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                    success: false,\n                    error: \"Invalid date range\".to_string(),\n                    message: Some(\"to_date cannot be before from_date\".to_string()),\n                }));\n            }\n        }\n    }\n\n    // Validate price range\n    if let (Some(min), Some(max)) = (request.min_price, request.max_price) {\n        if min > max {\n            return Ok(HttpResponse::BadRequest().json(ErrorResponse {\n                success: false,\n                error: \"Invalid price range\".to_string(),\n                message: Some(\"min_price cannot exceed max_price\".to_string()),\n            }));\n        }\n    }\n\n    // Check inventory access if specific inventory requested\n    if let Some(inv_id) = request.inventory_id {\n        match db_service\n            .check_inventory_access(auth.user_id, inv_id)\n            .await\n        {\n            Ok(false) => {\n                return Ok(HttpResponse::Forbidden().json(ErrorResponse {\n                    success: false,\n                    error: \"Access denied to this inventory\".to_string(),\n                    message: None,\n                }))\n            },\n            Err(e) => {\n                error!(\"Error checking inventory access: {}\", e);\n                return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                    success: false,\n                    error: \"An internal error occurred\".to_string(),\n                    message: None,\n                }));\n            },\n            _ => {},\n        }\n    }\n\n    // Fetch report data\n    let items = match db_service\n        .get_inventory_report_data(request.clone(), auth.user_id)\n        .await\n    {\n        Ok(items) => items,\n        Err(e) => {\n            error!(\"Error generating report: {}\", e);\n            return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to generate report\".to_string(),\n                message: Some(e.to_string()),\n            }));\n        },\n    };\n\n    // Handle format selection - CSV vs JSON export\n    if format == \"csv\" {\n        // Fetch inventory names for CSV export\n        let inventory_names = match db_service.get_accessible_inventories(auth.user_id).await {\n            Ok(inventories) => inventories\n                .into_iter()\n                .filter_map(|inv| inv.id.map(|id| (id, inv.name)))\n                .collect(),\n            Err(e) => {\n                error!(\"Error fetching inventories for CSV: {}\", e);\n                return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                    success: false,\n                    error: \"Failed to fetch inventory names\".to_string(),\n                    message: Some(e.to_string()),\n                }));\n            },\n        };\n\n        match format_items_as_csv(items, &inventory_names) {\n            Ok(csv_data) => {\n                let filename = format!(\n                    \"inventory-report-{}.csv\",\n                    chrono::Utc::now().format(\"%Y%m%d-%H%M%S\")\n                );\n\n                info!(\n                    \"Generated CSV report for user {}: {} bytes\",\n                    auth.username,\n                    csv_data.len()\n                );\n\n                Ok(HttpResponse::Ok()\n                    .content_type(\"text/csv; charset=utf-8\")\n                    .insert_header((\n                        \"Content-Disposition\",\n                        format!(\"attachment; filename=\\\"{filename}\\\"\"),\n                    ))\n                    .body(csv_data))\n            },\n            Err(e) => {\n                error!(\"Error formatting CSV for user {}: {}\", auth.username, e);\n                let error_msg = if e.to_string().contains(\"CSV\") {\n                    \"CSV serialization error\"\n                } else {\n                    \"Failed to format CSV\"\n                };\n                Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                    success: false,\n                    error: error_msg.to_string(),\n                    message: Some(format!(\"Could not generate CSV export: {e}\")),\n                }))\n            },\n        }\n    } else {\n        // Fetch additional data for complete report\n        let statistics = match db_service\n            .get_inventory_statistics(request.inventory_id, auth.user_id)\n            .await\n        {\n            Ok(stats) => stats,\n            Err(e) => {\n                error!(\"Error fetching statistics: {}\", e);\n                return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                    success: false,\n                    error: \"Failed to fetch statistics\".to_string(),\n                    message: Some(e.to_string()),\n                }));\n            },\n        };\n\n        let category_breakdown = match db_service\n            .get_category_breakdown(request.inventory_id, auth.user_id)\n            .await\n        {\n            Ok(breakdown) => breakdown,\n            Err(e) => {\n                error!(\"Error fetching category breakdown: {}\", e);\n                return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                    success: false,\n                    error: \"Failed to fetch category breakdown\".to_string(),\n                    message: Some(e.to_string()),\n                }));\n            },\n        };\n\n        let report_data = InventoryReportData {\n            statistics,\n            category_breakdown,\n            items,\n            generated_at: chrono::Utc::now(),\n            filters_applied: request,\n        };\n\n        info!(\"Generated JSON report for user {}\", auth.username);\n\n        Ok(HttpResponse::Ok().json(ApiResponse {\n            success: true,\n            data: Some(report_data),\n            message: Some(\"Report generated successfully\".to_string()),\n            error: None,\n        }))\n    }\n}\n\n#[get(\"/reports/inventory/statistics\")]\npub async fn get_inventory_statistics_endpoint(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    query: web::Query<InventoryReportRequest>,\n) -> Result<impl Responder> {\n    let auth = match auth::get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n    let request = query.into_inner();\n\n    // Check inventory access if specific inventory requested\n    if let Some(inv_id) = request.inventory_id {\n        match db_service\n            .check_inventory_access(auth.user_id, inv_id)\n            .await\n        {\n            Ok(false) => {\n                return Ok(HttpResponse::Forbidden().json(ErrorResponse {\n                    success: false,\n                    error: \"Access denied to this inventory\".to_string(),\n                    message: None,\n                }))\n            },\n            Err(e) => {\n                error!(\"Error checking inventory access: {}\", e);\n                return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                    success: false,\n                    error: \"An internal error occurred\".to_string(),\n                    message: None,\n                }));\n            },\n            _ => {},\n        }\n    }\n\n    match db_service\n        .get_inventory_statistics(request.inventory_id, auth.user_id)\n        .await\n    {\n        Ok(stats) => {\n            info!(\"Retrieved statistics for user {}\", auth.username);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(stats),\n                message: Some(\"Statistics retrieved successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error retrieving statistics: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to retrieve statistics\".to_string(),\n                message: Some(e.to_string()),\n            }))\n        },\n    }\n}\n\n#[get(\"/reports/inventory/categories\")]\npub async fn get_category_breakdown_endpoint(\n    pool: web::Data<Pool>,\n    req: HttpRequest,\n    query: web::Query<InventoryReportRequest>,\n) -> Result<impl Responder> {\n    let auth = match auth::get_auth_context_from_request(&req, pool.get_ref()).await {\n        Ok(a) => a,\n        Err(e) => return Ok(e),\n    };\n\n    let db_service = DatabaseService::new(pool.get_ref().clone());\n    let request = query.into_inner();\n\n    // Check inventory access if specific inventory requested\n    if let Some(inv_id) = request.inventory_id {\n        match db_service\n            .check_inventory_access(auth.user_id, inv_id)\n            .await\n        {\n            Ok(false) => {\n                return Ok(HttpResponse::Forbidden().json(ErrorResponse {\n                    success: false,\n                    error: \"Access denied to this inventory\".to_string(),\n                    message: None,\n                }))\n            },\n            Err(e) => {\n                error!(\"Error checking inventory access: {}\", e);\n                return Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                    success: false,\n                    error: \"An internal error occurred\".to_string(),\n                    message: None,\n                }));\n            },\n            _ => {},\n        }\n    }\n\n    match db_service\n        .get_category_breakdown(request.inventory_id, auth.user_id)\n        .await\n    {\n        Ok(breakdown) => {\n            info!(\"Retrieved category breakdown for user {}\", auth.username);\n            Ok(HttpResponse::Ok().json(ApiResponse {\n                success: true,\n                data: Some(breakdown),\n                message: Some(\"Category breakdown retrieved successfully\".to_string()),\n                error: None,\n            }))\n        },\n        Err(e) => {\n            error!(\"Error retrieving category breakdown: {}\", e);\n            Ok(HttpResponse::InternalServerError().json(ErrorResponse {\n                success: false,\n                error: \"Failed to retrieve category breakdown\".to_string(),\n                message: Some(e.to_string()),\n            }))\n        },\n    }\n}\n\n// API 404 handler - returns JSON instead of HTML\nasync fn api_not_found(req: HttpRequest) -> impl Responder {\n    log::warn!(\"API 404: {}\", req.uri());\n    HttpResponse::NotFound().json(ErrorResponse {\n        success: false,\n        error: \"Endpoint not found\".to_string(),\n        message: Some(format!(\n            \"The API endpoint {uri} does not exist\",\n            uri = req.uri()\n        )),\n    })\n}\n\n// Create scope with all API routes\npub fn api_scope() -> Scope {\n    web::scope(\"/api\")\n        .app_data(web::JsonConfig::default().limit(15_728_640))\n        .app_data(web::PayloadConfig::new(20 * 1024 * 1024))\n        .service(api_health)\n        // Auth routes (setup, login, profile, admin user management) - imported directly to avoid nested scope\n        .service(auth::get_setup_status)\n        .service(auth::initial_setup)\n        .service(auth::login)\n        .service(auth::register)\n        .service(auth::get_current_user)\n        .service(auth::update_current_user)\n        .service(auth::change_password)\n        // Recovery codes endpoints\n        .service(auth::generate_recovery_codes)\n        .service(auth::get_recovery_codes_status)\n        .service(auth::confirm_recovery_codes)\n        .service(auth::use_recovery_code)\n        .service(auth::get_user_settings)\n        .service(auth::update_user_settings)\n        .service(auth::get_my_inventories)\n        .service(auth::get_inventory_shares)\n        .service(auth::create_inventory_share)\n        .service(auth::update_inventory_share)\n        .service(auth::delete_inventory_share)\n        .service(auth::transfer_inventory_ownership)\n        .service(auth::get_inventory_permissions)\n        .service(auth::get_my_access_grants)\n        .service(auth::get_received_access_grants)\n        .service(auth::create_access_grant)\n        .service(auth::delete_access_grant)\n        .service(auth::admin_get_users)\n        .service(auth::admin_get_user)\n        .service(auth::admin_create_user)\n        .service(auth::admin_update_user)\n        .service(auth::admin_delete_user)\n        // Inventory routes\n        .service(get_inventories)\n        .service(create_inventory)\n        .service(get_inventory)\n        .service(get_inventory_items)\n        .service(get_inventory_organizers)\n        .service(create_organizer_type)\n        .service(update_inventory)\n        .service(delete_inventory)\n        // Item routes\n        .service(get_items)\n        .service(get_item)\n        .service(create_item)\n        .service(update_item)\n        .service(delete_item)\n        .service(search_items)\n        .service(get_item_organizer_values)\n        .service(set_item_organizer_values)\n        .service(delete_item_organizer_value)\n        // Organizer routes\n        .service(get_organizer_type)\n        .service(update_organizer_type)\n        .service(delete_organizer_type)\n        .service(get_organizer_options)\n        .service(create_organizer_option)\n        .service(update_organizer_option)\n        .service(delete_organizer_option)\n        // Image upload/delete routes\n        .service(upload_image)\n        .service(delete_image)\n        .service(get_inventory_item_images)\n        // Inventory reporting routes\n        .service(get_inventory_report)\n        .service(get_inventory_statistics_endpoint)\n        .service(get_category_breakdown_endpoint)\n        // Backup & Restore routes\n        .service(backup::create_backup)\n        .service(backup::list_backups)\n        .service(backup::download_backup)\n        .service(backup::upload_backup)\n        .service(backup::restore_backup)\n        .service(backup::delete_backup)\n        // Catch-all for non-existent API endpoints\n        .default_service(web::to(api_not_found))\n}\n\n// Alias for backward compatibility\n#[must_use]\npub fn init_routes() -> Scope {\n    api_scope()\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1029,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1054,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1061,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1065,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":0}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1080,"address":[],"length":0,"stats":{"Line":0}},{"line":1081,"address":[],"length":0,"stats":{"Line":0}},{"line":1086,"address":[],"length":0,"stats":{"Line":0}},{"line":1087,"address":[],"length":0,"stats":{"Line":0}},{"line":1088,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1090,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[],"length":0,"stats":{"Line":0}},{"line":1096,"address":[],"length":0,"stats":{"Line":0}},{"line":1097,"address":[],"length":0,"stats":{"Line":0}},{"line":1098,"address":[],"length":0,"stats":{"Line":0}},{"line":1100,"address":[],"length":0,"stats":{"Line":0}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1104,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1106,"address":[],"length":0,"stats":{"Line":0}},{"line":1107,"address":[],"length":0,"stats":{"Line":0}},{"line":1109,"address":[],"length":0,"stats":{"Line":0}},{"line":1110,"address":[],"length":0,"stats":{"Line":0}},{"line":1115,"address":[],"length":0,"stats":{"Line":0}},{"line":1121,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":0}},{"line":1123,"address":[],"length":0,"stats":{"Line":0}},{"line":1126,"address":[],"length":0,"stats":{"Line":0}},{"line":1129,"address":[],"length":0,"stats":{"Line":0}},{"line":1130,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1135,"address":[],"length":0,"stats":{"Line":0}},{"line":1136,"address":[],"length":0,"stats":{"Line":0}},{"line":1137,"address":[],"length":0,"stats":{"Line":0}},{"line":1141,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":0}},{"line":1144,"address":[],"length":0,"stats":{"Line":0}},{"line":1145,"address":[],"length":0,"stats":{"Line":0}},{"line":1146,"address":[],"length":0,"stats":{"Line":0}},{"line":1147,"address":[],"length":0,"stats":{"Line":0}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1152,"address":[],"length":0,"stats":{"Line":0}},{"line":1153,"address":[],"length":0,"stats":{"Line":0}},{"line":1154,"address":[],"length":0,"stats":{"Line":0}},{"line":1155,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":0}},{"line":1160,"address":[],"length":0,"stats":{"Line":0}},{"line":1162,"address":[],"length":0,"stats":{"Line":0}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1178,"address":[],"length":0,"stats":{"Line":0}},{"line":1179,"address":[],"length":0,"stats":{"Line":0}},{"line":1182,"address":[],"length":0,"stats":{"Line":0}},{"line":1183,"address":[],"length":0,"stats":{"Line":0}},{"line":1185,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1187,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1190,"address":[],"length":0,"stats":{"Line":0}},{"line":1191,"address":[],"length":0,"stats":{"Line":0}},{"line":1192,"address":[],"length":0,"stats":{"Line":0}},{"line":1195,"address":[],"length":0,"stats":{"Line":0}},{"line":1196,"address":[],"length":0,"stats":{"Line":0}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1198,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[],"length":0,"stats":{"Line":0}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1203,"address":[],"length":0,"stats":{"Line":0}},{"line":1204,"address":[],"length":0,"stats":{"Line":0}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1208,"address":[],"length":0,"stats":{"Line":0}},{"line":1209,"address":[],"length":0,"stats":{"Line":0}},{"line":1210,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[],"length":0,"stats":{"Line":0}},{"line":1234,"address":[],"length":0,"stats":{"Line":0}},{"line":1237,"address":[],"length":0,"stats":{"Line":0}},{"line":1238,"address":[],"length":0,"stats":{"Line":0}},{"line":1239,"address":[],"length":0,"stats":{"Line":0}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[],"length":0,"stats":{"Line":0}},{"line":1242,"address":[],"length":0,"stats":{"Line":0}},{"line":1243,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[],"length":0,"stats":{"Line":0}},{"line":1246,"address":[],"length":0,"stats":{"Line":0}},{"line":1247,"address":[],"length":0,"stats":{"Line":0}},{"line":1248,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1253,"address":[],"length":0,"stats":{"Line":0}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1259,"address":[],"length":0,"stats":{"Line":0}},{"line":1260,"address":[],"length":0,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[],"length":0,"stats":{"Line":0}},{"line":1265,"address":[],"length":0,"stats":{"Line":0}},{"line":1266,"address":[],"length":0,"stats":{"Line":0}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[],"length":0,"stats":{"Line":0}},{"line":1269,"address":[],"length":0,"stats":{"Line":0}},{"line":1270,"address":[],"length":0,"stats":{"Line":0}},{"line":1271,"address":[],"length":0,"stats":{"Line":0}},{"line":1272,"address":[],"length":0,"stats":{"Line":0}},{"line":1273,"address":[],"length":0,"stats":{"Line":0}},{"line":1274,"address":[],"length":0,"stats":{"Line":0}},{"line":1275,"address":[],"length":0,"stats":{"Line":0}},{"line":1276,"address":[],"length":0,"stats":{"Line":0}},{"line":1277,"address":[],"length":0,"stats":{"Line":0}},{"line":1278,"address":[],"length":0,"stats":{"Line":0}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1280,"address":[],"length":0,"stats":{"Line":0}},{"line":1281,"address":[],"length":0,"stats":{"Line":0}},{"line":1282,"address":[],"length":0,"stats":{"Line":0}},{"line":1286,"address":[],"length":0,"stats":{"Line":0}},{"line":1287,"address":[],"length":0,"stats":{"Line":0}},{"line":1291,"address":[],"length":0,"stats":{"Line":0}},{"line":1297,"address":[],"length":0,"stats":{"Line":0}},{"line":1298,"address":[],"length":0,"stats":{"Line":0}},{"line":1299,"address":[],"length":0,"stats":{"Line":0}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1305,"address":[],"length":0,"stats":{"Line":0}},{"line":1306,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":0}},{"line":1308,"address":[],"length":0,"stats":{"Line":0}},{"line":1309,"address":[],"length":0,"stats":{"Line":0}},{"line":1313,"address":[],"length":0,"stats":{"Line":0}},{"line":1314,"address":[],"length":0,"stats":{"Line":0}},{"line":1317,"address":[],"length":0,"stats":{"Line":0}},{"line":1318,"address":[],"length":0,"stats":{"Line":0}},{"line":1319,"address":[],"length":0,"stats":{"Line":0}},{"line":1320,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1327,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1329,"address":[],"length":0,"stats":{"Line":0}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1332,"address":[],"length":0,"stats":{"Line":0}},{"line":1338,"address":[],"length":0,"stats":{"Line":0}},{"line":1339,"address":[],"length":0,"stats":{"Line":0}},{"line":1340,"address":[],"length":0,"stats":{"Line":0}},{"line":1341,"address":[],"length":0,"stats":{"Line":0}},{"line":1343,"address":[],"length":0,"stats":{"Line":0}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1345,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1356,"address":[],"length":0,"stats":{"Line":0}},{"line":1357,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1365,"address":[],"length":0,"stats":{"Line":0}},{"line":1366,"address":[],"length":0,"stats":{"Line":0}},{"line":1367,"address":[],"length":0,"stats":{"Line":0}},{"line":1368,"address":[],"length":0,"stats":{"Line":0}},{"line":1371,"address":[],"length":0,"stats":{"Line":0}},{"line":1372,"address":[],"length":0,"stats":{"Line":0}},{"line":1373,"address":[],"length":0,"stats":{"Line":0}},{"line":1374,"address":[],"length":0,"stats":{"Line":0}},{"line":1377,"address":[],"length":0,"stats":{"Line":0}},{"line":1378,"address":[],"length":0,"stats":{"Line":0}},{"line":1379,"address":[],"length":0,"stats":{"Line":0}},{"line":1380,"address":[],"length":0,"stats":{"Line":0}},{"line":1381,"address":[],"length":0,"stats":{"Line":0}},{"line":1382,"address":[],"length":0,"stats":{"Line":0}},{"line":1385,"address":[],"length":0,"stats":{"Line":0}},{"line":1390,"address":[],"length":0,"stats":{"Line":0}},{"line":1391,"address":[],"length":0,"stats":{"Line":0}},{"line":1392,"address":[],"length":0,"stats":{"Line":0}},{"line":1394,"address":[],"length":0,"stats":{"Line":0}},{"line":1395,"address":[],"length":0,"stats":{"Line":0}},{"line":1396,"address":[],"length":0,"stats":{"Line":0}},{"line":1397,"address":[],"length":0,"stats":{"Line":0}},{"line":1398,"address":[],"length":0,"stats":{"Line":0}},{"line":1399,"address":[],"length":0,"stats":{"Line":0}},{"line":1400,"address":[],"length":0,"stats":{"Line":0}},{"line":1406,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":0}},{"line":1409,"address":[],"length":0,"stats":{"Line":0}},{"line":1411,"address":[],"length":0,"stats":{"Line":0}},{"line":1413,"address":[],"length":0,"stats":{"Line":0}},{"line":1414,"address":[],"length":0,"stats":{"Line":0}},{"line":1415,"address":[],"length":0,"stats":{"Line":0}},{"line":1416,"address":[],"length":0,"stats":{"Line":0}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1418,"address":[],"length":0,"stats":{"Line":0}},{"line":1423,"address":[],"length":0,"stats":{"Line":0}},{"line":1424,"address":[],"length":0,"stats":{"Line":0}},{"line":1425,"address":[],"length":0,"stats":{"Line":0}},{"line":1427,"address":[],"length":0,"stats":{"Line":0}},{"line":1430,"address":[],"length":0,"stats":{"Line":0}},{"line":1431,"address":[],"length":0,"stats":{"Line":0}},{"line":1433,"address":[],"length":0,"stats":{"Line":0}},{"line":1436,"address":[],"length":0,"stats":{"Line":0}},{"line":1437,"address":[],"length":0,"stats":{"Line":0}},{"line":1438,"address":[],"length":0,"stats":{"Line":0}},{"line":1439,"address":[],"length":0,"stats":{"Line":0}},{"line":1440,"address":[],"length":0,"stats":{"Line":0}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1444,"address":[],"length":0,"stats":{"Line":0}},{"line":1445,"address":[],"length":0,"stats":{"Line":0}},{"line":1446,"address":[],"length":0,"stats":{"Line":0}},{"line":1447,"address":[],"length":0,"stats":{"Line":0}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1451,"address":[],"length":0,"stats":{"Line":0}},{"line":1452,"address":[],"length":0,"stats":{"Line":0}},{"line":1453,"address":[],"length":0,"stats":{"Line":0}},{"line":1454,"address":[],"length":0,"stats":{"Line":0}},{"line":1460,"address":[],"length":0,"stats":{"Line":0}},{"line":1461,"address":[],"length":0,"stats":{"Line":0}},{"line":1462,"address":[],"length":0,"stats":{"Line":0}},{"line":1464,"address":[],"length":0,"stats":{"Line":0}},{"line":1465,"address":[],"length":0,"stats":{"Line":0}},{"line":1466,"address":[],"length":0,"stats":{"Line":0}},{"line":1467,"address":[],"length":0,"stats":{"Line":0}},{"line":1468,"address":[],"length":0,"stats":{"Line":0}},{"line":1469,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":0}},{"line":1475,"address":[],"length":0,"stats":{"Line":0}},{"line":1476,"address":[],"length":0,"stats":{"Line":0}},{"line":1477,"address":[],"length":0,"stats":{"Line":0}},{"line":1479,"address":[],"length":0,"stats":{"Line":0}},{"line":1480,"address":[],"length":0,"stats":{"Line":0}},{"line":1481,"address":[],"length":0,"stats":{"Line":0}},{"line":1482,"address":[],"length":0,"stats":{"Line":0}},{"line":1483,"address":[],"length":0,"stats":{"Line":0}},{"line":1484,"address":[],"length":0,"stats":{"Line":0}},{"line":1485,"address":[],"length":0,"stats":{"Line":0}},{"line":1494,"address":[],"length":0,"stats":{"Line":0}},{"line":1498,"address":[],"length":0,"stats":{"Line":0}},{"line":1500,"address":[],"length":0,"stats":{"Line":0}},{"line":1501,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[],"length":0,"stats":{"Line":0}},{"line":1504,"address":[],"length":0,"stats":{"Line":0}},{"line":1510,"address":[],"length":0,"stats":{"Line":0}},{"line":1515,"address":[],"length":0,"stats":{"Line":0}},{"line":1516,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":0}},{"line":1520,"address":[],"length":0,"stats":{"Line":0}},{"line":1521,"address":[],"length":0,"stats":{"Line":0}},{"line":1524,"address":[],"length":0,"stats":{"Line":0}},{"line":1525,"address":[],"length":0,"stats":{"Line":0}},{"line":1526,"address":[],"length":0,"stats":{"Line":0}},{"line":1527,"address":[],"length":0,"stats":{"Line":0}},{"line":1530,"address":[],"length":0,"stats":{"Line":0}},{"line":1531,"address":[],"length":0,"stats":{"Line":0}},{"line":1532,"address":[],"length":0,"stats":{"Line":0}},{"line":1533,"address":[],"length":0,"stats":{"Line":0}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1537,"address":[],"length":0,"stats":{"Line":0}},{"line":1538,"address":[],"length":0,"stats":{"Line":0}},{"line":1539,"address":[],"length":0,"stats":{"Line":0}},{"line":1540,"address":[],"length":0,"stats":{"Line":0}},{"line":1541,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1548,"address":[],"length":0,"stats":{"Line":0}},{"line":1549,"address":[],"length":0,"stats":{"Line":0}},{"line":1550,"address":[],"length":0,"stats":{"Line":0}},{"line":1552,"address":[],"length":0,"stats":{"Line":0}},{"line":1553,"address":[],"length":0,"stats":{"Line":0}},{"line":1554,"address":[],"length":0,"stats":{"Line":0}},{"line":1555,"address":[],"length":0,"stats":{"Line":0}},{"line":1556,"address":[],"length":0,"stats":{"Line":0}},{"line":1557,"address":[],"length":0,"stats":{"Line":0}},{"line":1558,"address":[],"length":0,"stats":{"Line":0}},{"line":1561,"address":[],"length":0,"stats":{"Line":0}},{"line":1562,"address":[],"length":0,"stats":{"Line":0}},{"line":1563,"address":[],"length":0,"stats":{"Line":0}},{"line":1564,"address":[],"length":0,"stats":{"Line":0}},{"line":1565,"address":[],"length":0,"stats":{"Line":0}},{"line":1566,"address":[],"length":0,"stats":{"Line":0}},{"line":1573,"address":[],"length":0,"stats":{"Line":0}},{"line":1578,"address":[],"length":0,"stats":{"Line":0}},{"line":1579,"address":[],"length":0,"stats":{"Line":0}},{"line":1580,"address":[],"length":0,"stats":{"Line":0}},{"line":1583,"address":[],"length":0,"stats":{"Line":0}},{"line":1584,"address":[],"length":0,"stats":{"Line":0}},{"line":1587,"address":[],"length":0,"stats":{"Line":0}},{"line":1588,"address":[],"length":0,"stats":{"Line":0}},{"line":1589,"address":[],"length":0,"stats":{"Line":0}},{"line":1590,"address":[],"length":0,"stats":{"Line":0}},{"line":1593,"address":[],"length":0,"stats":{"Line":0}},{"line":1594,"address":[],"length":0,"stats":{"Line":0}},{"line":1595,"address":[],"length":0,"stats":{"Line":0}},{"line":1596,"address":[],"length":0,"stats":{"Line":0}},{"line":1599,"address":[],"length":0,"stats":{"Line":0}},{"line":1600,"address":[],"length":0,"stats":{"Line":0}},{"line":1601,"address":[],"length":0,"stats":{"Line":0}},{"line":1602,"address":[],"length":0,"stats":{"Line":0}},{"line":1603,"address":[],"length":0,"stats":{"Line":0}},{"line":1604,"address":[],"length":0,"stats":{"Line":0}},{"line":1607,"address":[],"length":0,"stats":{"Line":0}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1612,"address":[],"length":0,"stats":{"Line":0}},{"line":1613,"address":[],"length":0,"stats":{"Line":0}},{"line":1615,"address":[],"length":0,"stats":{"Line":0}},{"line":1616,"address":[],"length":0,"stats":{"Line":0}},{"line":1617,"address":[],"length":0,"stats":{"Line":0}},{"line":1618,"address":[],"length":0,"stats":{"Line":0}},{"line":1619,"address":[],"length":0,"stats":{"Line":0}},{"line":1620,"address":[],"length":0,"stats":{"Line":0}},{"line":1621,"address":[],"length":0,"stats":{"Line":0}},{"line":1624,"address":[],"length":0,"stats":{"Line":0}},{"line":1625,"address":[],"length":0,"stats":{"Line":0}},{"line":1626,"address":[],"length":0,"stats":{"Line":0}},{"line":1627,"address":[],"length":0,"stats":{"Line":0}},{"line":1628,"address":[],"length":0,"stats":{"Line":0}},{"line":1629,"address":[],"length":0,"stats":{"Line":0}},{"line":1636,"address":[],"length":0,"stats":{"Line":0}},{"line":1637,"address":[],"length":0,"stats":{"Line":0}},{"line":1638,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":0}},{"line":1640,"address":[],"length":0,"stats":{"Line":0}},{"line":1641,"address":[],"length":0,"stats":{"Line":0}},{"line":1642,"address":[],"length":0,"stats":{"Line":0}},{"line":1643,"address":[],"length":0,"stats":{"Line":0}},{"line":1649,"address":[],"length":0,"stats":{"Line":0}},{"line":1650,"address":[],"length":0,"stats":{"Line":0}},{"line":1651,"address":[],"length":0,"stats":{"Line":0}},{"line":1652,"address":[],"length":0,"stats":{"Line":0}},{"line":1653,"address":[],"length":0,"stats":{"Line":0}},{"line":1655,"address":[],"length":0,"stats":{"Line":0}},{"line":1656,"address":[],"length":0,"stats":{"Line":0}},{"line":1657,"address":[],"length":0,"stats":{"Line":0}},{"line":1658,"address":[],"length":0,"stats":{"Line":0}},{"line":1659,"address":[],"length":0,"stats":{"Line":0}},{"line":1660,"address":[],"length":0,"stats":{"Line":0}},{"line":1661,"address":[],"length":0,"stats":{"Line":0}},{"line":1663,"address":[],"length":0,"stats":{"Line":0}},{"line":1664,"address":[],"length":0,"stats":{"Line":0}},{"line":1665,"address":[],"length":0,"stats":{"Line":0}},{"line":1666,"address":[],"length":0,"stats":{"Line":0}},{"line":1667,"address":[],"length":0,"stats":{"Line":0}},{"line":1668,"address":[],"length":0,"stats":{"Line":0}},{"line":1669,"address":[],"length":0,"stats":{"Line":0}},{"line":1670,"address":[],"length":0,"stats":{"Line":0}},{"line":1671,"address":[],"length":0,"stats":{"Line":0}},{"line":1672,"address":[],"length":0,"stats":{"Line":0}},{"line":1673,"address":[],"length":0,"stats":{"Line":0}},{"line":1674,"address":[],"length":0,"stats":{"Line":0}},{"line":1675,"address":[],"length":0,"stats":{"Line":0}},{"line":1676,"address":[],"length":0,"stats":{"Line":0}},{"line":1677,"address":[],"length":0,"stats":{"Line":0}},{"line":1678,"address":[],"length":0,"stats":{"Line":0}},{"line":1679,"address":[],"length":0,"stats":{"Line":0}},{"line":1680,"address":[],"length":0,"stats":{"Line":0}},{"line":1681,"address":[],"length":0,"stats":{"Line":0}},{"line":1682,"address":[],"length":0,"stats":{"Line":0}},{"line":1683,"address":[],"length":0,"stats":{"Line":0}},{"line":1684,"address":[],"length":0,"stats":{"Line":0}},{"line":1686,"address":[],"length":0,"stats":{"Line":0}},{"line":1687,"address":[],"length":0,"stats":{"Line":0}},{"line":1688,"address":[],"length":0,"stats":{"Line":0}},{"line":1689,"address":[],"length":0,"stats":{"Line":0}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1691,"address":[],"length":0,"stats":{"Line":0}},{"line":1692,"address":[],"length":0,"stats":{"Line":0}},{"line":1693,"address":[],"length":0,"stats":{"Line":0}},{"line":1695,"address":[],"length":0,"stats":{"Line":0}},{"line":1696,"address":[],"length":0,"stats":{"Line":0}},{"line":1697,"address":[],"length":0,"stats":{"Line":0}},{"line":1698,"address":[],"length":0,"stats":{"Line":0}},{"line":1699,"address":[],"length":0,"stats":{"Line":0}},{"line":1700,"address":[],"length":0,"stats":{"Line":0}},{"line":1701,"address":[],"length":0,"stats":{"Line":0}},{"line":1702,"address":[],"length":0,"stats":{"Line":0}},{"line":1703,"address":[],"length":0,"stats":{"Line":0}},{"line":1705,"address":[],"length":0,"stats":{"Line":0}},{"line":1706,"address":[],"length":0,"stats":{"Line":0}},{"line":1707,"address":[],"length":0,"stats":{"Line":0}},{"line":1708,"address":[],"length":0,"stats":{"Line":0}},{"line":1709,"address":[],"length":0,"stats":{"Line":0}},{"line":1710,"address":[],"length":0,"stats":{"Line":0}},{"line":1711,"address":[],"length":0,"stats":{"Line":0}},{"line":1713,"address":[],"length":0,"stats":{"Line":0}},{"line":1714,"address":[],"length":0,"stats":{"Line":0}},{"line":1715,"address":[],"length":0,"stats":{"Line":0}},{"line":1717,"address":[],"length":0,"stats":{"Line":0}},{"line":1718,"address":[],"length":0,"stats":{"Line":0}},{"line":1719,"address":[],"length":0,"stats":{"Line":0}},{"line":1721,"address":[],"length":0,"stats":{"Line":0}},{"line":1722,"address":[],"length":0,"stats":{"Line":0}},{"line":1723,"address":[],"length":0,"stats":{"Line":0}},{"line":1724,"address":[],"length":0,"stats":{"Line":0}},{"line":1725,"address":[],"length":0,"stats":{"Line":0}},{"line":1726,"address":[],"length":0,"stats":{"Line":0}},{"line":1728,"address":[],"length":0,"stats":{"Line":0}},{"line":1733,"address":[],"length":0,"stats":{"Line":0}},{"line":1734,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1010},{"path":["C:","\\","Projects","home-registry","src","auth","mod.rs"],"content":"//! Authentication and authorization module\n//!\n//! Provides JWT token handling, password hashing with Argon2, and auth middleware for Actix-Web.\n\nuse actix_web::HttpRequest;\nuse argon2::{\n    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},\n    Argon2,\n};\nuse chrono::Utc;\nuse jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};\nuse std::env;\nuse std::sync::OnceLock;\nuse uuid::Uuid;\n\nuse crate::models::{Claims, User};\n\n// ==================== JWT Secret Management ====================\n\n/// Global JWT secret cache - initialized once at startup\nstatic JWT_SECRET: OnceLock<String> = OnceLock::new();\n\n/// Initialize and get JWT secret\n/// Tries multiple sources in order:\n/// 1. Docker secret file (`/run/secrets/jwt_secret`)\n/// 2. Custom path via `JWT_SECRET_FILE` env var\n/// 3. `JWT_SECRET` environment variable\n/// 4. Auto-generated secret persisted to `/app/data/jwt_secret`\n/// 5. Fallback to auto-generated (not persisted, will change on restart)\npub fn get_or_init_jwt_secret() -> &'static str {\n    JWT_SECRET.get_or_init(|| {\n        // Try to read existing secret from various sources\n        if let Some(secret) = read_jwt_secret() {\n            if secret.len() >= 32 {\n                log::info!(\"Using existing JWT secret\");\n                return secret;\n            }\n            log::warn!(\n                \"JWT_SECRET must be at least 32 characters for cryptographic security. \\\n                 Current length: {}. Generate a secure secret with: openssl rand -base64 32\",\n                secret.len()\n            );\n        }\n\n        // No valid secret found - auto-generate and try to persist\n        log::warn!(\"No JWT_SECRET found. Auto-generating a random secret.\");\n\n        let secret = generate_random_secret(64);\n\n        // Try to persist to /app/data/jwt_secret for container restarts\n        let persist_path = \"/app/data/jwt_secret\";\n        if let Err(e) = std::fs::create_dir_all(\"/app/data\") {\n            log::debug!(\"Could not create /app/data directory: {}\", e);\n        }\n\n        if let Err(e) = std::fs::write(persist_path, &secret) {\n            log::warn!(\n                \"Failed to persist auto-generated JWT secret to {}: {}. \\\n                 Tokens will be invalidated on restart.\",\n                persist_path,\n                e\n            );\n        } else {\n            log::info!(\"Auto-generated JWT secret persisted to {}\", persist_path);\n        }\n\n        secret\n    })\n}\n\n/// Read JWT secret from various sources\nfn read_jwt_secret() -> Option<String> {\n    // 1. Try custom path from JWT_SECRET_FILE env var\n    if let Ok(custom_path) = env::var(\"JWT_SECRET_FILE\") {\n        if let Ok(content) = std::fs::read_to_string(&custom_path) {\n            let secret = content.trim().to_string();\n            if !secret.is_empty() {\n                log::info!(\"Read JWT secret from custom path: {}\", custom_path);\n                return Some(secret);\n            }\n        }\n    }\n\n    // 2. Try Docker secret\n    if let Ok(content) = std::fs::read_to_string(\"/run/secrets/jwt_secret\") {\n        let secret = content.trim().to_string();\n        if !secret.is_empty() {\n            log::info!(\"Read JWT secret from Docker secrets\");\n            return Some(secret);\n        }\n    }\n\n    // 3. Try persisted auto-generated secret\n    if let Ok(content) = std::fs::read_to_string(\"/app/data/jwt_secret\") {\n        let secret = content.trim().to_string();\n        if !secret.is_empty() {\n            log::info!(\"Read JWT secret from persisted file\");\n            return Some(secret);\n        }\n    }\n\n    // 4. Try environment variable\n    if let Ok(secret) = env::var(\"JWT_SECRET\") {\n        if !secret.is_empty() {\n            log::info!(\"Read JWT secret from environment variable\");\n            return Some(secret);\n        }\n    }\n\n    None\n}\n\n/// Generate a cryptographically secure random string\nfn generate_random_secret(length: usize) -> String {\n    use rand::Rng;\n    rand::thread_rng()\n        .sample_iter(&rand::distributions::Alphanumeric)\n        .take(length)\n        .map(char::from)\n        .collect()\n}\n\n// ==================== JWT Token Handling ====================\n\n/// Get JWT secret - wrapper for the cached secret\n#[must_use]\npub fn jwt_secret() -> String {\n    get_or_init_jwt_secret().to_string()\n}\n\n/// Get JWT token lifetime in hours from environment\n#[must_use]\npub fn jwt_token_lifetime_hours() -> i64 {\n    env::var(\"JWT_TOKEN_LIFETIME_HOURS\")\n        .ok()\n        .and_then(|s| s.parse().ok())\n        .unwrap_or(24) // Default to 24 hours\n}\n\n/// Generate a JWT token for a user\npub fn generate_token(user: &User) -> Result<String, jsonwebtoken::errors::Error> {\n    let now = Utc::now();\n    let token_lifetime_hours = jwt_token_lifetime_hours();\n    // Safe cast: Unix timestamps are always positive, max(0) ensures non-negative\n    #[allow(\n        clippy::cast_sign_loss,\n        reason = \"Unix timestamps are always positive; max(0) ensures safety\"\n    )]\n    let expiration = (now + chrono::Duration::hours(token_lifetime_hours))\n        .timestamp()\n        .max(0) as u64;\n\n    let claims = Claims {\n        sub: user.id.to_string(),\n        username: user.username.clone(),\n        is_admin: user.is_admin,\n        exp: expiration,\n        #[allow(\n            clippy::cast_sign_loss,\n            reason = \"Unix timestamps are always positive; max(0) ensures safety\"\n        )]\n        iat: now.timestamp().max(0) as u64,\n    };\n\n    let header = Header::new(Algorithm::HS256);\n    encode(\n        &header,\n        &claims,\n        &EncodingKey::from_secret(jwt_secret().as_bytes()),\n    )\n}\n\n/// Verify and decode a JWT token\npub fn verify_token(token: &str) -> Result<Claims, jsonwebtoken::errors::Error> {\n    let key = DecodingKey::from_secret(jwt_secret().as_bytes());\n    let mut validation = Validation::new(Algorithm::HS256);\n    validation.set_required_spec_claims(&[\"sub\", \"exp\", \"iat\"]);\n\n    decode::<Claims>(token, &key, &validation).map(|data| data.claims)\n}\n\n/// Extract JWT token from Authorization header or `auth_token` cookie\n#[must_use]\npub fn extract_token(req: &HttpRequest) -> Option<String> {\n    // Try Authorization header first (Bearer token)\n    if let Some(auth_header) = req.headers().get(\"Authorization\") {\n        if let Ok(auth_str) = auth_header.to_str() {\n            if let Some(token) = auth_str.strip_prefix(\"Bearer \") {\n                return Some(token.to_string());\n            }\n        }\n    }\n\n    // Fall back to cookie\n    if let Some(cookie) = req.cookie(\"auth_token\") {\n        return Some(cookie.value().to_string());\n    }\n\n    None\n}\n\n// ==================== Password Hashing ====================\n\n/// Hash a password using Argon2id\n/// Uses `spawn_blocking` to avoid blocking the async runtime\npub async fn hash_password(password: String) -> Result<String, argon2::password_hash::Error> {\n    tokio::task::spawn_blocking(move || {\n        let salt = SaltString::generate(&mut OsRng);\n        let argon2 = Argon2::default();\n        let password_hash = argon2.hash_password(password.as_bytes(), &salt)?;\n        Ok(password_hash.to_string())\n    })\n    .await\n    .map_err(|_| argon2::password_hash::Error::Algorithm)?\n}\n\n/// Verify a password against a hash\n/// Uses `spawn_blocking` to avoid blocking the async runtime\npub async fn verify_password(\n    password: String,\n    hash_str: String,\n) -> Result<bool, argon2::password_hash::Error> {\n    tokio::task::spawn_blocking(move || {\n        let parsed_hash = PasswordHash::new(&hash_str)?;\n        Ok(Argon2::default()\n            .verify_password(password.as_bytes(), &parsed_hash)\n            .is_ok())\n    })\n    .await\n    .map_err(|_| argon2::password_hash::Error::Algorithm)?\n}\n\n// ==================== Auth Context ====================\n\n/// Authentication context passed to handlers via request extensions\n#[derive(Debug, Clone)]\npub struct AuthContext {\n    pub user_id: Uuid,\n    pub username: String,\n    pub is_admin: bool,\n}\n\nimpl AuthContext {\n    pub fn from_claims(claims: &Claims) -> Result<Self, uuid::Error> {\n        Ok(Self {\n            user_id: Uuid::parse_str(&claims.sub)?,\n            username: claims.username.clone(),\n            is_admin: claims.is_admin,\n        })\n    }\n}\n\n// ==================== Helper Functions ====================\n\n/// Validate password complexity\npub fn validate_password(password: &str) -> Result<(), &'static str> {\n    if password.len() < 8 {\n        return Err(\"Password must be at least 8 characters long\");\n    }\n    if password.len() > 128 {\n        return Err(\"Password must be at most 128 characters long\");\n    }\n    // Could add more complexity requirements here\n    Ok(())\n}\n\n/// Validate username format\npub fn validate_username(username: &str) -> Result<(), &'static str> {\n    if username.len() < 3 {\n        return Err(\"Username must be at least 3 characters long\");\n    }\n    if username.len() > 50 {\n        return Err(\"Username must be at most 50 characters long\");\n    }\n    if !username\n        .chars()\n        .all(|c| c.is_alphanumeric() || c == '_' || c == '-')\n    {\n        return Err(\"Username can only contain letters, numbers, underscores, and hyphens\");\n    }\n    Ok(())\n}\n\n// ==================== Testing Helpers ====================\n\n/// Synchronous password hashing for tests (do not use in async contexts)\npub fn hash_password_sync(password: &str) -> Result<String, argon2::password_hash::Error> {\n    let salt = SaltString::generate(&mut OsRng);\n    let argon2 = Argon2::default();\n    let password_hash = argon2.hash_password(password.as_bytes(), &salt)?;\n    Ok(password_hash.to_string())\n}\n\n/// Synchronous password verification for tests (do not use in async contexts)\npub fn verify_password_sync(\n    password: &str,\n    hash_str: &str,\n) -> Result<bool, argon2::password_hash::Error> {\n    let parsed_hash = PasswordHash::new(hash_str)?;\n    Ok(Argon2::default()\n        .verify_password(password.as_bytes(), &parsed_hash)\n        .is_ok())\n}\n\n/// Alias for `generate_token` to match common naming convention\npub fn create_token(user_id: &Uuid, username: &str) -> Result<String, jsonwebtoken::errors::Error> {\n    let user = User {\n        id: *user_id,\n        username: username.to_string(),\n        password_hash: String::new(),    // Not used for token generation\n        full_name: username.to_string(), // Use username as full_name for test tokens\n        is_admin: false,\n        is_active: true, // Active by default for new users\n        created_at: Utc::now(),\n        updated_at: Utc::now(),\n        recovery_codes_generated_at: None, // Not generated initially\n        recovery_codes_confirmed: false,   // Not confirmed initially\n    };\n    generate_token(&user)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_password_validation() {\n        assert!(validate_password(\"short\").is_err());\n        assert!(validate_password(\"validpassword123\").is_ok());\n    }\n\n    #[test]\n    fn test_username_validation() {\n        assert!(validate_username(\"ab\").is_err());\n        assert!(validate_username(\"valid_user-123\").is_ok());\n        assert!(validate_username(\"invalid user\").is_err());\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":31,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":33,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":34,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":35,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":36,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":74,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":95,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":96,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":97,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":98,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":128,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":133,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":134,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":136,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":141,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":142,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":143,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":149,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":150,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":151,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":154,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":155,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":156,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":162,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":165,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":167,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":168,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":169,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":174,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":175,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":176,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":177,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":179,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":257,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":258,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":260,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":261,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":264,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":268,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":269,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":270,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":272,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":273,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":275,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":276,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":277,"address":[],"length":0,"stats":{"Line":14555633995661443072}},{"line":279,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":281,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":287,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":288,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":289,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":290,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":291,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":295,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":299,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":300,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":301,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":302,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":306,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":308,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":309,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":310,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":311,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":314,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":315,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":319,"address":[],"length":0,"stats":{"Line":1152921504606846976}}],"covered":72,"coverable":134},{"path":["C:","\\","Projects","home-registry","src","db","mod.rs"],"content":"use crate::models::{\n    AdminUpdateUserRequest,\n    // Backup & Restore models\n    BackupDatabaseContent,\n    CreateInventoryRequest,\n    CreateItemRequest,\n    CreateOrganizerOptionRequest,\n    CreateOrganizerTypeRequest,\n    EffectivePermissions,\n    Inventory,\n    InventoryShare,\n    InventoryShareWithUser,\n    Item,\n    ItemOrganizerValue,\n    ItemOrganizerValueWithDetails,\n    OrganizerOption,\n    OrganizerType,\n    OrganizerTypeWithOptions,\n    PermissionLevel,\n    PermissionSource,\n    SetItemOrganizerValueRequest,\n    UpdateItemRequest,\n    UpdateOrganizerOptionRequest,\n    UpdateOrganizerTypeRequest,\n    UpdateUserSettingsRequest,\n    // User-related models\n    User,\n    // User Access Grant models (All Access tier)\n    UserAccessGrant,\n    UserAccessGrantWithUsers,\n    UserResponse,\n    UserSettings,\n};\nuse chrono::{DateTime, Utc};\nuse deadpool_postgres::{Config, ManagerConfig, Pool, RecyclingMethod};\nuse log::{error, info};\nuse std::env;\nuse tokio_postgres::NoTls;\nuse uuid::Uuid;\n\n/// Escape special characters in SQL LIKE patterns to prevent injection\nfn escape_like_pattern(input: &str) -> String {\n    input\n        .replace('\\\\', \"\\\\\\\\\")\n        .replace('%', \"\\\\%\")\n        .replace('_', \"\\\\_\")\n}\n\npub fn get_pool() -> Result<Pool, Box<dyn std::error::Error + Send + Sync>> {\n    let db_url =\n        env::var(\"DATABASE_URL\").map_err(|_| \"DATABASE_URL environment variable must be set\")?;\n\n    // Parse DATABASE_URL: postgres://user:password@host:port/database\n    let url = db_url\n        .strip_prefix(\"postgres://\")\n        .ok_or(\"Invalid DATABASE_URL format: must start with postgres://\")?;\n\n    let parts: Vec<&str> = url.split('@').collect();\n    if parts.len() != 2 {\n        return Err(\n            \"Invalid DATABASE_URL format: expected postgres://user:password@host/database\".into(),\n        );\n    }\n\n    let auth_parts: Vec<&str> = parts[0].split(':').collect();\n    let host_parts: Vec<&str> = parts[1].split('/').collect();\n    let host_port: Vec<&str> = host_parts[0].split(':').collect();\n\n    let user = (*auth_parts.first().unwrap_or(&\"postgres\")).to_string();\n    let password = (*auth_parts.get(1).unwrap_or(&\"password\")).to_string();\n    let host = (*host_port.first().unwrap_or(&\"localhost\")).to_string();\n    let port = host_port\n        .get(1)\n        .unwrap_or(&\"5432\")\n        .parse::<u16>()\n        .unwrap_or(5432);\n    let dbname = (*host_parts.get(1).unwrap_or(&\"home_inventory\")).to_string();\n\n    let mut cfg = Config::new();\n    cfg.user = Some(user);\n    cfg.password = Some(password);\n    cfg.host = Some(host);\n    cfg.port = Some(port);\n    cfg.dbname = Some(dbname);\n    cfg.manager = Some(ManagerConfig {\n        recycling_method: RecyclingMethod::Fast,\n    });\n\n    cfg.create_pool(None, NoTls)\n        .map_err(|e| format!(\"Failed to create database pool: {e}\").into())\n}\n\npub struct DatabaseService {\n    pool: Pool,\n}\n\nimpl DatabaseService {\n    #[must_use]\n    pub fn new(pool: Pool) -> Self {\n        Self { pool }\n    }\n\n    pub async fn get_all_items(&self) -> Result<Vec<Item>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT id, inventory_id, name, description, category, location, purchase_date::text, purchase_price::float8, warranty_expiry::text, notes, quantity, created_at, updated_at \n             FROM items ORDER BY created_at DESC\",\n                &[],\n            )\n            .await?;\n\n        let mut items = Vec::new();\n        for row in rows {\n            let item = Item {\n                id: Some(row.get(0)),\n                inventory_id: row.get(1),\n                name: row.get(2),\n                description: row.get(3),\n                category: row.get(4),\n                location: row.get(5),\n                purchase_date: row.get::<_, Option<String>>(6),\n                purchase_price: row.get(7),\n                warranty_expiry: row.get::<_, Option<String>>(8),\n                notes: row.get(9),\n                quantity: row.get(10),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(11),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(12),\n            };\n            items.push(item);\n        }\n\n        info!(\"Retrieved {} items from database\", items.len());\n        Ok(items)\n    }\n\n    pub async fn get_item_by_id(\n        &self,\n        id: i32,\n    ) -> Result<Option<Item>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT id, inventory_id, name, description, category, location, purchase_date::text, purchase_price::float8, warranty_expiry::text, notes, quantity, created_at, updated_at \n             FROM items WHERE id = $1\",\n                &[&id],\n            )\n            .await?;\n\n        if let Some(row) = rows.first() {\n            let item = Item {\n                id: Some(row.get(0)),\n                inventory_id: row.get(1),\n                name: row.get(2),\n                description: row.get(3),\n                category: row.get(4),\n                location: row.get(5),\n                purchase_date: row.get::<_, Option<String>>(6),\n                purchase_price: row.get(7),\n                warranty_expiry: row.get::<_, Option<String>>(8),\n                notes: row.get(9),\n                quantity: row.get(10),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(11),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(12),\n            };\n            Ok(Some(item))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn create_item(\n        &self,\n        request: CreateItemRequest,\n    ) -> Result<Item, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        // Convert date strings to proper format or None\n        let purchase_date: Option<chrono::NaiveDate> = request\n            .purchase_date\n            .as_ref()\n            .filter(|s| !s.is_empty())\n            .and_then(|s| chrono::NaiveDate::parse_from_str(s, \"%Y-%m-%d\").ok());\n\n        let warranty_expiry: Option<chrono::NaiveDate> = request\n            .warranty_expiry\n            .as_ref()\n            .filter(|s| !s.is_empty())\n            .and_then(|s| chrono::NaiveDate::parse_from_str(s, \"%Y-%m-%d\").ok());\n\n        // Handle price properly - convert to None if not provided\n        let purchase_price_param: Option<f64> = request.purchase_price;\n\n        let row = client\n            .query_one(\n                \"INSERT INTO items (inventory_id, name, description, category, location, purchase_date, purchase_price, warranty_expiry, notes, quantity) \n             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) \n             RETURNING id, inventory_id, name, description, category, location, purchase_date::text, purchase_price::float8, warranty_expiry::text, notes, quantity, created_at, updated_at\",\n                &[\n                    &request.inventory_id.unwrap_or(1),\n                    &request.name,\n                    &request.description,\n                    &request.category,\n                    &request.location,\n                    &purchase_date,\n                    &purchase_price_param,\n                    &warranty_expiry,\n                    &request.notes,\n                    &request.quantity,\n                ],\n            )\n            .await?;\n\n        let item = Item {\n            id: Some(row.get(0)),\n            inventory_id: row.get(1),\n            name: row.get(2),\n            description: row.get(3),\n            category: row.get(4),\n            location: row.get(5),\n            purchase_date: row.get::<_, Option<String>>(6),\n            purchase_price: row.get(7),\n            warranty_expiry: row.get::<_, Option<String>>(8),\n            notes: row.get(9),\n            quantity: row.get(10),\n            created_at: row.get::<_, Option<DateTime<Utc>>>(11),\n            updated_at: row.get::<_, Option<DateTime<Utc>>>(12),\n        };\n\n        info!(\"Created new item: {} (ID: {:?})\", item.name, item.id);\n        Ok(item)\n    }\n\n    pub async fn update_item(\n        &self,\n        id: i32,\n        request: UpdateItemRequest,\n    ) -> Result<Option<Item>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        // Build dynamic update query\n        let mut fields = Vec::new();\n        let mut values: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> = Vec::new();\n        let mut param_count = 1;\n\n        if let Some(ref name) = request.name {\n            fields.push(format!(\"name = ${param_count}\"));\n            values.push(name);\n            param_count += 1;\n        }\n        if let Some(ref description) = request.description {\n            fields.push(format!(\"description = ${param_count}\"));\n            values.push(description);\n            param_count += 1;\n        }\n        if let Some(ref category) = request.category {\n            fields.push(format!(\"category = ${param_count}\"));\n            values.push(category);\n            param_count += 1;\n        }\n        if let Some(ref location) = request.location {\n            fields.push(format!(\"location = ${param_count}\"));\n            values.push(location);\n            param_count += 1;\n        }\n        if let Some(ref purchase_price) = request.purchase_price {\n            fields.push(format!(\"purchase_price = ${param_count}\"));\n            values.push(purchase_price);\n            param_count += 1;\n        }\n        if let Some(ref quantity) = request.quantity {\n            fields.push(format!(\"quantity = ${param_count}\"));\n            values.push(quantity);\n            param_count += 1;\n        }\n        if let Some(ref notes) = request.notes {\n            fields.push(format!(\"notes = ${param_count}\"));\n            values.push(notes);\n            param_count += 1;\n        }\n        if let Some(ref inventory_id) = request.inventory_id {\n            fields.push(format!(\"inventory_id = ${param_count}\"));\n            values.push(inventory_id);\n            param_count += 1;\n        }\n\n        // Handle date fields\n        let purchase_date_val: Option<chrono::NaiveDate>;\n        if let Some(ref pd) = request.purchase_date {\n            let date_str = pd.trim();\n            purchase_date_val = if date_str.is_empty() {\n                None\n            } else {\n                chrono::NaiveDate::parse_from_str(date_str, \"%Y-%m-%d\").ok()\n            };\n            fields.push(format!(\"purchase_date = ${param_count}\"));\n            values.push(&purchase_date_val);\n            param_count += 1;\n        }\n\n        let warranty_expiry_val: Option<chrono::NaiveDate>;\n        if let Some(ref we) = request.warranty_expiry {\n            let date_str = we.trim();\n            warranty_expiry_val = if date_str.is_empty() {\n                None\n            } else {\n                chrono::NaiveDate::parse_from_str(date_str, \"%Y-%m-%d\").ok()\n            };\n            fields.push(format!(\"warranty_expiry = ${param_count}\"));\n            values.push(&warranty_expiry_val);\n            param_count += 1;\n        }\n\n        if fields.is_empty() {\n            return self.get_item_by_id(id).await;\n        }\n\n        fields.push(\"updated_at = NOW()\".to_string());\n        values.push(&id);\n\n        let query = format!(\n            \"UPDATE items SET {} WHERE id = ${} RETURNING id, inventory_id, name, description, category, location, purchase_date::text, purchase_price::float8, warranty_expiry::text, notes, quantity, created_at, updated_at\",\n            fields.join(\", \"),\n            param_count\n        );\n\n        let rows = client.query(&query, &values).await?;\n\n        if let Some(row) = rows.first() {\n            let item = Item {\n                id: Some(row.get(0)),\n                inventory_id: row.get(1),\n                name: row.get(2),\n                description: row.get(3),\n                category: row.get(4),\n                location: row.get(5),\n                purchase_date: row.get::<_, Option<String>>(6),\n                purchase_price: row.get(7),\n                warranty_expiry: row.get::<_, Option<String>>(8),\n                notes: row.get(9),\n                quantity: row.get(10),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(11),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(12),\n            };\n            info!(\"Updated item ID: {}\", id);\n            Ok(Some(item))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn delete_item(&self, id: i32) -> Result<bool, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows_affected = client\n            .execute(\"DELETE FROM items WHERE id = $1\", &[&id])\n            .await?;\n\n        let deleted = rows_affected > 0;\n        if deleted {\n            info!(\"Deleted item ID: {}\", id);\n        }\n        Ok(deleted)\n    }\n\n    pub async fn search_items(&self, query: &str) -> Result<Vec<Item>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        // Escape SQL LIKE wildcards to prevent pattern injection\n        let escaped_query = escape_like_pattern(&query.to_lowercase());\n        let search_pattern = format!(\"%{escaped_query}%\");\n        let rows = client\n            .query(\n                \"SELECT id, inventory_id, name, description, category, location, purchase_date::text, purchase_price::float8, warranty_expiry::text, notes, quantity, created_at, updated_at \n             FROM items \n             WHERE LOWER(name) LIKE $1 ESCAPE '\\\\' \n                OR LOWER(description) LIKE $1 ESCAPE '\\\\' \n                OR LOWER(category) LIKE $1 ESCAPE '\\\\' \n                OR LOWER(location) LIKE $1 ESCAPE '\\\\'\n             ORDER BY created_at DESC\",\n                &[&search_pattern],\n            )\n            .await?;\n\n        let mut items = Vec::new();\n        for row in rows {\n            let item = Item {\n                id: Some(row.get(0)),\n                inventory_id: row.get(1),\n                name: row.get(2),\n                description: row.get(3),\n                category: row.get(4),\n                location: row.get(5),\n                purchase_date: row.get::<_, Option<String>>(6),\n                purchase_price: row.get(7),\n                warranty_expiry: row.get::<_, Option<String>>(8),\n                notes: row.get(9),\n                quantity: row.get(10),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(11),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(12),\n            };\n            items.push(item);\n        }\n\n        info!(\n            \"Found {} items matching search query: '{}'\",\n            items.len(),\n            query\n        );\n        Ok(items)\n    }\n\n    // Inventory operations\n    pub async fn get_inventory_by_id(\n        &self,\n        id: i32,\n    ) -> Result<Option<Inventory>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT id, name, description, location, image_url, user_id, created_at, updated_at \n                 FROM inventories WHERE id = $1\",\n                &[&id],\n            )\n            .await?;\n\n        if let Some(row) = rows.first() {\n            let inventory = Inventory {\n                id: Some(row.get(0)),\n                name: row.get(1),\n                description: row.get(2),\n                location: row.get(3),\n                image_url: row.get(4),\n                user_id: row.get(5),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(6),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(7),\n            };\n            Ok(Some(inventory))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn create_inventory(\n        &self,\n        request: CreateInventoryRequest,\n        user_id: uuid::Uuid,\n    ) -> Result<Inventory, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let row = client\n            .query_one(\n                \"INSERT INTO inventories (name, description, location, image_url, user_id) \n                 VALUES ($1, $2, $3, $4, $5) \n                 RETURNING id, name, description, location, image_url, user_id, created_at, updated_at\",\n                &[&request.name, &request.description, &request.location, &request.image_url, &user_id],\n            )\n            .await?;\n\n        let inventory = Inventory {\n            id: Some(row.get(0)),\n            name: row.get(1),\n            description: row.get(2),\n            location: row.get(3),\n            image_url: row.get(4),\n            user_id: row.get(5),\n            created_at: row.get::<_, Option<DateTime<Utc>>>(6),\n            updated_at: row.get::<_, Option<DateTime<Utc>>>(7),\n        };\n\n        info!(\n            \"Created new inventory: {} (ID: {:?})\",\n            inventory.name, inventory.id\n        );\n        Ok(inventory)\n    }\n\n    pub async fn update_inventory(\n        &self,\n        id: i32,\n        request: crate::models::UpdateInventoryRequest,\n    ) -> Result<Option<Inventory>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        // Build dynamic update query\n        let mut fields = Vec::new();\n        let mut values: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> = Vec::new();\n        let mut param_count = 1;\n\n        if let Some(ref name) = request.name {\n            fields.push(format!(\"name = ${param_count}\"));\n            values.push(name);\n            param_count += 1;\n        }\n        if let Some(ref description) = request.description {\n            fields.push(format!(\"description = ${param_count}\"));\n            values.push(description);\n            param_count += 1;\n        }\n        if let Some(ref location) = request.location {\n            fields.push(format!(\"location = ${param_count}\"));\n            values.push(location);\n            param_count += 1;\n        }\n        if let Some(ref image_url) = request.image_url {\n            fields.push(format!(\"image_url = ${param_count}\"));\n            values.push(image_url);\n            param_count += 1;\n        }\n\n        if fields.is_empty() {\n            return self.get_inventory_by_id(id).await;\n        }\n\n        fields.push(\"updated_at = NOW()\".to_string());\n        values.push(&id);\n\n        let query = format!(\n            \"UPDATE inventories SET {} WHERE id = ${} RETURNING id, name, description, location, image_url, user_id, created_at, updated_at\",\n            fields.join(\", \"),\n            param_count\n        );\n\n        let rows = client.query(&query, &values).await?;\n\n        if let Some(row) = rows.first() {\n            let inventory = Inventory {\n                id: Some(row.get(0)),\n                name: row.get(1),\n                description: row.get(2),\n                location: row.get(3),\n                image_url: row.get(4),\n                user_id: row.get(5),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(6),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(7),\n            };\n            info!(\"Updated inventory ID: {}\", id);\n            Ok(Some(inventory))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn delete_inventory(&self, id: i32) -> Result<bool, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows_affected = client\n            .execute(\"DELETE FROM inventories WHERE id = $1\", &[&id])\n            .await?;\n\n        let deleted = rows_affected > 0;\n        if deleted {\n            info!(\n                \"Deleted inventory ID: {} (CASCADE: organizers and items)\",\n                id\n            );\n        }\n        Ok(deleted)\n    }\n\n    pub async fn get_items_by_inventory(\n        &self,\n        inventory_id: i32,\n    ) -> Result<Vec<Item>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT id, inventory_id, name, description, category, location, purchase_date::text, purchase_price::float8, warranty_expiry::text, notes, quantity, created_at, updated_at \n                 FROM items WHERE inventory_id = $1 ORDER BY created_at DESC\",\n                &[&inventory_id],\n            )\n            .await?;\n\n        let mut items = Vec::new();\n        for row in rows {\n            let item = Item {\n                id: Some(row.get(0)),\n                inventory_id: row.get(1),\n                name: row.get(2),\n                description: row.get(3),\n                category: row.get(4),\n                location: row.get(5),\n                purchase_date: row.get::<_, Option<String>>(6),\n                purchase_price: row.get(7),\n                warranty_expiry: row.get::<_, Option<String>>(8),\n                notes: row.get(9),\n                quantity: row.get(10),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(11),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(12),\n            };\n            items.push(item);\n        }\n\n        info!(\n            \"Retrieved {} items for inventory {}\",\n            items.len(),\n            inventory_id\n        );\n        Ok(items)\n    }\n\n    // ==================== Organizer Type Operations ====================\n\n    pub async fn get_organizer_types_by_inventory(\n        &self,\n        inventory_id: i32,\n    ) -> Result<Vec<OrganizerType>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT id, inventory_id, name, input_type, is_required, display_order, created_at, updated_at \n                 FROM organizer_types WHERE inventory_id = $1 ORDER BY display_order ASC, name ASC\",\n                &[&inventory_id],\n            )\n            .await?;\n\n        let mut organizers = Vec::new();\n        for row in rows {\n            let organizer = OrganizerType {\n                id: Some(row.get(0)),\n                inventory_id: row.get(1),\n                name: row.get(2),\n                input_type: row.get(3),\n                is_required: row.get(4),\n                display_order: row.get(5),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(6),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(7),\n            };\n            organizers.push(organizer);\n        }\n\n        info!(\n            \"Retrieved {} organizer types for inventory {}\",\n            organizers.len(),\n            inventory_id\n        );\n        Ok(organizers)\n    }\n\n    pub async fn get_organizer_types_with_options_by_inventory(\n        &self,\n        inventory_id: i32,\n    ) -> Result<Vec<OrganizerTypeWithOptions>, Box<dyn std::error::Error>> {\n        let organizer_types = self.get_organizer_types_by_inventory(inventory_id).await?;\n\n        let mut result = Vec::new();\n        for organizer_type in organizer_types {\n            let options = if organizer_type.input_type == \"select\" {\n                if let Some(id) = organizer_type.id {\n                    self.get_organizer_options(id).await?\n                } else {\n                    error!(\"Organizer type missing ID for inventory {}\", inventory_id);\n                    Vec::new()\n                }\n            } else {\n                Vec::new()\n            };\n\n            result.push(OrganizerTypeWithOptions {\n                organizer_type,\n                options,\n            });\n        }\n\n        Ok(result)\n    }\n\n    pub async fn get_organizer_type_by_id(\n        &self,\n        id: i32,\n    ) -> Result<Option<OrganizerType>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT id, inventory_id, name, input_type, is_required, display_order, created_at, updated_at \n                 FROM organizer_types WHERE id = $1\",\n                &[&id],\n            )\n            .await?;\n\n        if let Some(row) = rows.first() {\n            Ok(Some(OrganizerType {\n                id: Some(row.get(0)),\n                inventory_id: row.get(1),\n                name: row.get(2),\n                input_type: row.get(3),\n                is_required: row.get(4),\n                display_order: row.get(5),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(6),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(7),\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn create_organizer_type(\n        &self,\n        inventory_id: i32,\n        request: CreateOrganizerTypeRequest,\n    ) -> Result<OrganizerType, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let input_type = request.input_type.unwrap_or_else(|| \"select\".to_string());\n        let is_required = request.is_required.unwrap_or(false);\n        let display_order = request.display_order.unwrap_or(0);\n\n        let row = client\n            .query_one(\n                \"INSERT INTO organizer_types (inventory_id, name, input_type, is_required, display_order) \n                 VALUES ($1, $2, $3, $4, $5) \n                 RETURNING id, inventory_id, name, input_type, is_required, display_order, created_at, updated_at\",\n                &[&inventory_id, &request.name, &input_type, &is_required, &display_order],\n            )\n            .await?;\n\n        let organizer = OrganizerType {\n            id: Some(row.get(0)),\n            inventory_id: row.get(1),\n            name: row.get(2),\n            input_type: row.get(3),\n            is_required: row.get(4),\n            display_order: row.get(5),\n            created_at: row.get::<_, Option<DateTime<Utc>>>(6),\n            updated_at: row.get::<_, Option<DateTime<Utc>>>(7),\n        };\n\n        info!(\n            \"Created organizer type: {} (ID: {:?})\",\n            organizer.name, organizer.id\n        );\n        Ok(organizer)\n    }\n\n    pub async fn update_organizer_type(\n        &self,\n        id: i32,\n        request: UpdateOrganizerTypeRequest,\n    ) -> Result<Option<OrganizerType>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let mut fields = Vec::new();\n        let mut values: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> = Vec::new();\n        let mut param_count = 1;\n\n        if let Some(ref name) = request.name {\n            fields.push(format!(\"name = ${param_count}\"));\n            values.push(name);\n            param_count += 1;\n        }\n        if let Some(ref input_type) = request.input_type {\n            fields.push(format!(\"input_type = ${param_count}\"));\n            values.push(input_type);\n            param_count += 1;\n        }\n        if let Some(ref is_required) = request.is_required {\n            fields.push(format!(\"is_required = ${param_count}\"));\n            values.push(is_required);\n            param_count += 1;\n        }\n        if let Some(ref display_order) = request.display_order {\n            fields.push(format!(\"display_order = ${param_count}\"));\n            values.push(display_order);\n            param_count += 1;\n        }\n\n        if fields.is_empty() {\n            return self.get_organizer_type_by_id(id).await;\n        }\n\n        fields.push(\"updated_at = NOW()\".to_string());\n        values.push(&id);\n\n        let query = format!(\n            \"UPDATE organizer_types SET {} WHERE id = ${} \n             RETURNING id, inventory_id, name, input_type, is_required, display_order, created_at, updated_at\",\n            fields.join(\", \"),\n            param_count\n        );\n\n        let rows = client.query(&query, &values).await?;\n\n        if let Some(row) = rows.first() {\n            let organizer = OrganizerType {\n                id: Some(row.get(0)),\n                inventory_id: row.get(1),\n                name: row.get(2),\n                input_type: row.get(3),\n                is_required: row.get(4),\n                display_order: row.get(5),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(6),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(7),\n            };\n            info!(\"Updated organizer type ID: {}\", id);\n            Ok(Some(organizer))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn delete_organizer_type(&self, id: i32) -> Result<bool, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows_affected = client\n            .execute(\"DELETE FROM organizer_types WHERE id = $1\", &[&id])\n            .await?;\n\n        let deleted = rows_affected > 0;\n        if deleted {\n            info!(\"Deleted organizer type ID: {}\", id);\n        }\n        Ok(deleted)\n    }\n\n    // ==================== Organizer Option Operations ====================\n\n    pub async fn get_organizer_options(\n        &self,\n        organizer_type_id: i32,\n    ) -> Result<Vec<OrganizerOption>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT id, organizer_type_id, name, display_order, created_at, updated_at \n                 FROM organizer_options WHERE organizer_type_id = $1 ORDER BY display_order ASC, name ASC\",\n                &[&organizer_type_id],\n            )\n            .await?;\n\n        let mut options = Vec::new();\n        for row in rows {\n            let option = OrganizerOption {\n                id: Some(row.get(0)),\n                organizer_type_id: row.get(1),\n                name: row.get(2),\n                display_order: row.get(3),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(4),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(5),\n            };\n            options.push(option);\n        }\n\n        info!(\n            \"Retrieved {} options for organizer type {}\",\n            options.len(),\n            organizer_type_id\n        );\n        Ok(options)\n    }\n\n    pub async fn get_organizer_option_by_id(\n        &self,\n        id: i32,\n    ) -> Result<Option<OrganizerOption>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT id, organizer_type_id, name, display_order, created_at, updated_at \n                 FROM organizer_options WHERE id = $1\",\n                &[&id],\n            )\n            .await?;\n\n        if let Some(row) = rows.first() {\n            Ok(Some(OrganizerOption {\n                id: Some(row.get(0)),\n                organizer_type_id: row.get(1),\n                name: row.get(2),\n                display_order: row.get(3),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(4),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(5),\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn create_organizer_option(\n        &self,\n        organizer_type_id: i32,\n        request: CreateOrganizerOptionRequest,\n    ) -> Result<OrganizerOption, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let display_order = request.display_order.unwrap_or(0);\n\n        let row = client\n            .query_one(\n                \"INSERT INTO organizer_options (organizer_type_id, name, display_order) \n                 VALUES ($1, $2, $3) \n                 RETURNING id, organizer_type_id, name, display_order, created_at, updated_at\",\n                &[&organizer_type_id, &request.name, &display_order],\n            )\n            .await?;\n\n        let option = OrganizerOption {\n            id: Some(row.get(0)),\n            organizer_type_id: row.get(1),\n            name: row.get(2),\n            display_order: row.get(3),\n            created_at: row.get::<_, Option<DateTime<Utc>>>(4),\n            updated_at: row.get::<_, Option<DateTime<Utc>>>(5),\n        };\n\n        info!(\n            \"Created organizer option: {} (ID: {:?})\",\n            option.name, option.id\n        );\n        Ok(option)\n    }\n\n    pub async fn update_organizer_option(\n        &self,\n        id: i32,\n        request: UpdateOrganizerOptionRequest,\n    ) -> Result<Option<OrganizerOption>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let mut fields = Vec::new();\n        let mut values: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> = Vec::new();\n        let mut param_count = 1;\n\n        if let Some(ref name) = request.name {\n            fields.push(format!(\"name = ${param_count}\"));\n            values.push(name);\n            param_count += 1;\n        }\n        if let Some(ref display_order) = request.display_order {\n            fields.push(format!(\"display_order = ${param_count}\"));\n            values.push(display_order);\n            param_count += 1;\n        }\n\n        if fields.is_empty() {\n            return self.get_organizer_option_by_id(id).await;\n        }\n\n        fields.push(\"updated_at = NOW()\".to_string());\n        values.push(&id);\n\n        let query = format!(\n            \"UPDATE organizer_options SET {} WHERE id = ${} \n             RETURNING id, organizer_type_id, name, display_order, created_at, updated_at\",\n            fields.join(\", \"),\n            param_count\n        );\n\n        let rows = client.query(&query, &values).await?;\n\n        if let Some(row) = rows.first() {\n            let option = OrganizerOption {\n                id: Some(row.get(0)),\n                organizer_type_id: row.get(1),\n                name: row.get(2),\n                display_order: row.get(3),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(4),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(5),\n            };\n            info!(\"Updated organizer option ID: {}\", id);\n            Ok(Some(option))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn delete_organizer_option(\n        &self,\n        id: i32,\n    ) -> Result<bool, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows_affected = client\n            .execute(\"DELETE FROM organizer_options WHERE id = $1\", &[&id])\n            .await?;\n\n        let deleted = rows_affected > 0;\n        if deleted {\n            info!(\"Deleted organizer option ID: {}\", id);\n        }\n        Ok(deleted)\n    }\n\n    // ==================== Item Organizer Value Operations ====================\n\n    pub async fn get_item_organizer_values(\n        &self,\n        item_id: i32,\n    ) -> Result<Vec<ItemOrganizerValueWithDetails>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT \n                    iov.organizer_type_id,\n                    ot.name as organizer_type_name,\n                    ot.input_type,\n                    ot.is_required,\n                    COALESCE(oo.name, iov.text_value) as display_value,\n                    iov.organizer_option_id,\n                    iov.text_value\n                 FROM item_organizer_values iov\n                 JOIN organizer_types ot ON iov.organizer_type_id = ot.id\n                 LEFT JOIN organizer_options oo ON iov.organizer_option_id = oo.id\n                 WHERE iov.item_id = $1\n                 ORDER BY ot.display_order ASC, ot.name ASC\",\n                &[&item_id],\n            )\n            .await?;\n\n        let mut values = Vec::new();\n        for row in rows {\n            let value = ItemOrganizerValueWithDetails {\n                organizer_type_id: row.get(0),\n                organizer_type_name: row.get(1),\n                input_type: row.get(2),\n                is_required: row.get(3),\n                value: row.get(4),\n                organizer_option_id: row.get(5),\n                text_value: row.get(6),\n            };\n            values.push(value);\n        }\n\n        info!(\n            \"Retrieved {} organizer values for item {}\",\n            values.len(),\n            item_id\n        );\n        Ok(values)\n    }\n\n    pub async fn set_item_organizer_value(\n        &self,\n        item_id: i32,\n        request: SetItemOrganizerValueRequest,\n    ) -> Result<ItemOrganizerValue, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        // Use UPSERT to insert or update the value\n        let row = client\n            .query_one(\n                \"INSERT INTO item_organizer_values (item_id, organizer_type_id, organizer_option_id, text_value) \n                 VALUES ($1, $2, $3, $4) \n                 ON CONFLICT (item_id, organizer_type_id) \n                 DO UPDATE SET organizer_option_id = $3, text_value = $4, updated_at = NOW()\n                 RETURNING id, item_id, organizer_type_id, organizer_option_id, text_value, created_at, updated_at\",\n                &[&item_id, &request.organizer_type_id, &request.organizer_option_id, &request.text_value],\n            )\n            .await?;\n\n        let value = ItemOrganizerValue {\n            id: Some(row.get(0)),\n            item_id: row.get(1),\n            organizer_type_id: row.get(2),\n            organizer_option_id: row.get(3),\n            text_value: row.get(4),\n            created_at: row.get::<_, Option<DateTime<Utc>>>(5),\n            updated_at: row.get::<_, Option<DateTime<Utc>>>(6),\n        };\n\n        info!(\n            \"Set organizer value for item {} type {}\",\n            item_id, request.organizer_type_id\n        );\n        Ok(value)\n    }\n\n    pub async fn set_item_organizer_values(\n        &self,\n        item_id: i32,\n        values: Vec<SetItemOrganizerValueRequest>,\n    ) -> Result<Vec<ItemOrganizerValue>, Box<dyn std::error::Error>> {\n        let mut results = Vec::new();\n        for request in values {\n            let result = self.set_item_organizer_value(item_id, request).await?;\n            results.push(result);\n        }\n        Ok(results)\n    }\n\n    pub async fn delete_item_organizer_value(\n        &self,\n        item_id: i32,\n        organizer_type_id: i32,\n    ) -> Result<bool, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows_affected = client\n            .execute(\n                \"DELETE FROM item_organizer_values WHERE item_id = $1 AND organizer_type_id = $2\",\n                &[&item_id, &organizer_type_id],\n            )\n            .await?;\n\n        let deleted = rows_affected > 0;\n        if deleted {\n            info!(\n                \"Deleted organizer value for item {} type {}\",\n                item_id, organizer_type_id\n            );\n        }\n        Ok(deleted)\n    }\n\n    #[allow(dead_code)]\n    pub async fn clear_item_organizer_values(\n        &self,\n        item_id: i32,\n    ) -> Result<u64, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows_affected = client\n            .execute(\n                \"DELETE FROM item_organizer_values WHERE item_id = $1\",\n                &[&item_id],\n            )\n            .await?;\n\n        info!(\n            \"Cleared {} organizer values for item {}\",\n            rows_affected, item_id\n        );\n        Ok(rows_affected)\n    }\n\n    // ==================== Item Image Operations ====================\n\n    /// Bulk-fetch item images for an inventory.\n    /// Returns a map of `item_id`  `image_url` for all items that have an image organizer value.\n    /// This avoids N+1 queries when rendering item card thumbnails.\n    pub async fn get_item_image_urls_by_inventory(\n        &self,\n        inventory_id: i32,\n    ) -> Result<std::collections::HashMap<i32, String>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT iov.item_id, iov.text_value\n                 FROM item_organizer_values iov\n                 JOIN organizer_types ot ON iov.organizer_type_id = ot.id\n                 JOIN items i ON iov.item_id = i.id\n                 WHERE ot.inventory_id = $1\n                   AND ot.input_type = 'image'\n                   AND iov.text_value IS NOT NULL\n                   AND iov.text_value != ''\n                 ORDER BY ot.display_order ASC\",\n                &[&inventory_id],\n            )\n            .await?;\n\n        let mut image_map = std::collections::HashMap::new();\n        for row in rows {\n            let item_id: i32 = row.get(0);\n            let image_url: String = row.get(1);\n            // First image organizer wins (by display_order)\n            image_map.entry(item_id).or_insert(image_url);\n        }\n\n        info!(\n            \"Retrieved {} item image URLs for inventory {}\",\n            image_map.len(),\n            inventory_id\n        );\n        Ok(image_map)\n    }\n\n    // ==================== User Operations ====================\n\n    /// Get user count for setup status check\n    pub async fn get_user_count(&self) -> Result<i64, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n        let row = client.query_one(\"SELECT COUNT(*) FROM users\", &[]).await?;\n        Ok(row.get(0))\n    }\n\n    /// Get a user by ID\n    pub async fn get_user_by_id(\n        &self,\n        id: Uuid,\n    ) -> Result<Option<User>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n        let rows = client\n            .query(\n                \"SELECT id, username, full_name, password_hash, is_admin, is_active, created_at, updated_at,\n                        recovery_codes_generated_at, COALESCE(recovery_codes_confirmed, false)\n                 FROM users WHERE id = $1\",\n                &[&id],\n            )\n            .await?;\n\n        if let Some(row) = rows.first() {\n            Ok(Some(User {\n                id: row.get(0),\n                username: row.get(1),\n                full_name: row.get(2),\n                password_hash: row.get(3),\n                is_admin: row.get(4),\n                is_active: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n                recovery_codes_generated_at: row.get(8),\n                recovery_codes_confirmed: row.get(9),\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Get a user by username\n    pub async fn get_user_by_username(\n        &self,\n        username: &str,\n    ) -> Result<Option<User>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n        let rows = client\n            .query(\n                \"SELECT id, username, full_name, password_hash, is_admin, is_active, created_at, updated_at,\n                        recovery_codes_generated_at, COALESCE(recovery_codes_confirmed, false)\n                 FROM users WHERE LOWER(username) = LOWER($1)\",\n                &[&username],\n            )\n            .await?;\n\n        if let Some(row) = rows.first() {\n            Ok(Some(User {\n                id: row.get(0),\n                username: row.get(1),\n                full_name: row.get(2),\n                password_hash: row.get(3),\n                is_admin: row.get(4),\n                is_active: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n                recovery_codes_generated_at: row.get(8),\n                recovery_codes_confirmed: row.get(9),\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Get all users (admin only)\n    pub async fn get_all_users(&self) -> Result<Vec<UserResponse>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n        let rows = client\n            .query(\n                \"SELECT id, username, full_name, is_admin, is_active, created_at, updated_at \n                 FROM users ORDER BY created_at DESC\",\n                &[],\n            )\n            .await?;\n\n        let users = rows\n            .iter()\n            .map(|row| UserResponse {\n                id: row.get(0),\n                username: row.get(1),\n                full_name: row.get(2),\n                is_admin: row.get(3),\n                is_active: row.get(4),\n                created_at: row.get(5),\n                updated_at: row.get(6),\n            })\n            .collect();\n\n        Ok(users)\n    }\n\n    /// Create a new user\n    pub async fn create_user(\n        &self,\n        username: &str,\n        full_name: &str,\n        password_hash: &str,\n        is_admin: bool,\n        is_active: bool,\n    ) -> Result<User, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let row = client\n            .query_one(\n                \"INSERT INTO users (username, full_name, password_hash, is_admin, is_active) \n                 VALUES ($1, $2, $3, $4, $5) \n                 RETURNING id, username, full_name, password_hash, is_admin, is_active, created_at, updated_at\",\n                &[&username, &full_name, &password_hash, &is_admin, &is_active],\n            )\n            .await?;\n\n        let user = User {\n            id: row.get(0),\n            username: row.get(1),\n            full_name: row.get(2),\n            password_hash: row.get(3),\n            is_admin: row.get(4),\n            is_active: row.get(5),\n            created_at: row.get(6),\n            updated_at: row.get(7),\n            recovery_codes_generated_at: None,\n            recovery_codes_confirmed: false,\n        };\n\n        info!(\"Created new user: {} (ID: {})\", user.username, user.id);\n        Ok(user)\n    }\n\n    /// Update a user's profile\n    pub async fn update_user_profile(\n        &self,\n        id: Uuid,\n        full_name: Option<&str>,\n    ) -> Result<Option<User>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let mut fields = Vec::new();\n        let mut values: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> = Vec::new();\n        let mut param_count = 1;\n\n        if let Some(ref n) = full_name {\n            fields.push(format!(\"full_name = ${param_count}\"));\n            values.push(n);\n            param_count += 1;\n        }\n\n        if fields.is_empty() {\n            return self.get_user_by_id(id).await;\n        }\n\n        fields.push(\"updated_at = NOW()\".to_string());\n        values.push(&id);\n\n        let query = format!(\n            \"UPDATE users SET {} WHERE id = ${} \n             RETURNING id, username, full_name, password_hash, is_admin, is_active, created_at, updated_at,\n                       recovery_codes_generated_at, COALESCE(recovery_codes_confirmed, false)\",\n            fields.join(\", \"),\n            param_count\n        );\n\n        let rows = client.query(&query, &values).await?;\n\n        if let Some(row) = rows.first() {\n            Ok(Some(User {\n                id: row.get(0),\n                username: row.get(1),\n                full_name: row.get(2),\n                password_hash: row.get(3),\n                is_admin: row.get(4),\n                is_active: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n                recovery_codes_generated_at: row.get(8),\n                recovery_codes_confirmed: row.get(9),\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Admin update user\n    pub async fn admin_update_user(\n        &self,\n        id: Uuid,\n        request: AdminUpdateUserRequest,\n    ) -> Result<Option<User>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let mut fields = Vec::new();\n        let mut values: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> = Vec::new();\n        let mut param_count = 1;\n\n        if let Some(ref username) = request.username {\n            fields.push(format!(\"username = ${param_count}\"));\n            values.push(username);\n            param_count += 1;\n        }\n        if let Some(ref full_name) = request.full_name {\n            fields.push(format!(\"full_name = ${param_count}\"));\n            values.push(full_name);\n            param_count += 1;\n        }\n        if let Some(ref is_admin) = request.is_admin {\n            fields.push(format!(\"is_admin = ${param_count}\"));\n            values.push(is_admin);\n            param_count += 1;\n        }\n        if let Some(ref is_active) = request.is_active {\n            fields.push(format!(\"is_active = ${param_count}\"));\n            values.push(is_active);\n            param_count += 1;\n        }\n\n        if fields.is_empty() {\n            return self.get_user_by_id(id).await;\n        }\n\n        fields.push(\"updated_at = NOW()\".to_string());\n        values.push(&id);\n\n        let query = format!(\n            \"UPDATE users SET {} WHERE id = ${} \n             RETURNING id, username, full_name, password_hash, is_admin, is_active, created_at, updated_at,\n                       recovery_codes_generated_at, COALESCE(recovery_codes_confirmed, false)\",\n            fields.join(\", \"),\n            param_count\n        );\n\n        let rows = client.query(&query, &values).await?;\n\n        if let Some(row) = rows.first() {\n            Ok(Some(User {\n                id: row.get(0),\n                username: row.get(1),\n                full_name: row.get(2),\n                password_hash: row.get(3),\n                is_admin: row.get(4),\n                is_active: row.get(5),\n                created_at: row.get(6),\n                updated_at: row.get(7),\n                recovery_codes_generated_at: row.get(8),\n                recovery_codes_confirmed: row.get(9),\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Update user password\n    pub async fn update_user_password(\n        &self,\n        id: Uuid,\n        password_hash: &str,\n    ) -> Result<bool, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows_affected = client\n            .execute(\n                \"UPDATE users SET password_hash = $1, updated_at = NOW() WHERE id = $2\",\n                &[&password_hash, &id],\n            )\n            .await?;\n\n        Ok(rows_affected > 0)\n    }\n\n    /// Delete a user\n    pub async fn delete_user(&self, id: Uuid) -> Result<bool, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows_affected = client\n            .execute(\"DELETE FROM users WHERE id = $1\", &[&id])\n            .await?;\n\n        let deleted = rows_affected > 0;\n        if deleted {\n            info!(\"Deleted user ID: {}\", id);\n        }\n        Ok(deleted)\n    }\n\n    /// Count admin users\n    pub async fn count_admin_users(&self) -> Result<i64, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n        let row = client\n            .query_one(\"SELECT COUNT(*) FROM users WHERE is_admin = true\", &[])\n            .await?;\n        Ok(row.get(0))\n    }\n\n    // ==================== User Settings Operations ====================\n\n    /// Get user settings\n    pub async fn get_user_settings(\n        &self,\n        user_id: Uuid,\n    ) -> Result<Option<UserSettings>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT id, user_id, theme, default_inventory_id, items_per_page, date_format, \n                        currency, notifications_enabled, settings_json, created_at, updated_at \n                 FROM user_settings WHERE user_id = $1\",\n                &[&user_id],\n            )\n            .await?;\n\n        if let Some(row) = rows.first() {\n            Ok(Some(UserSettings {\n                id: row.get(0),\n                user_id: row.get(1),\n                theme: row.get(2),\n                default_inventory_id: row.get(3),\n                items_per_page: row.get(4),\n                date_format: row.get(5),\n                currency: row.get(6),\n                notifications_enabled: row.get(7),\n                settings_json: row.get(8),\n                created_at: row.get(9),\n                updated_at: row.get(10),\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Create default user settings\n    pub async fn create_user_settings(\n        &self,\n        user_id: Uuid,\n    ) -> Result<UserSettings, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let row = client\n            .query_one(\n                \"INSERT INTO user_settings (user_id) VALUES ($1) \n                 RETURNING id, user_id, theme, default_inventory_id, items_per_page, date_format, \n                           currency, notifications_enabled, settings_json, created_at, updated_at\",\n                &[&user_id],\n            )\n            .await?;\n\n        Ok(UserSettings {\n            id: row.get(0),\n            user_id: row.get(1),\n            theme: row.get(2),\n            default_inventory_id: row.get(3),\n            items_per_page: row.get(4),\n            date_format: row.get(5),\n            currency: row.get(6),\n            notifications_enabled: row.get(7),\n            settings_json: row.get(8),\n            created_at: row.get(9),\n            updated_at: row.get(10),\n        })\n    }\n\n    /// Update user settings\n    pub async fn update_user_settings(\n        &self,\n        user_id: Uuid,\n        request: UpdateUserSettingsRequest,\n    ) -> Result<Option<UserSettings>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let mut fields = Vec::new();\n        let mut values: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> = Vec::new();\n        let mut param_count = 1;\n\n        if let Some(ref theme) = request.theme {\n            fields.push(format!(\"theme = ${param_count}\"));\n            values.push(theme);\n            param_count += 1;\n        }\n        if let Some(ref default_inventory_id) = request.default_inventory_id {\n            fields.push(format!(\"default_inventory_id = ${param_count}\"));\n            values.push(default_inventory_id);\n            param_count += 1;\n        }\n        if let Some(ref items_per_page) = request.items_per_page {\n            fields.push(format!(\"items_per_page = ${param_count}\"));\n            values.push(items_per_page);\n            param_count += 1;\n        }\n        if let Some(ref date_format) = request.date_format {\n            fields.push(format!(\"date_format = ${param_count}\"));\n            values.push(date_format);\n            param_count += 1;\n        }\n        if let Some(ref currency) = request.currency {\n            fields.push(format!(\"currency = ${param_count}\"));\n            values.push(currency);\n            param_count += 1;\n        }\n        if let Some(ref notifications_enabled) = request.notifications_enabled {\n            fields.push(format!(\"notifications_enabled = ${param_count}\"));\n            values.push(notifications_enabled);\n            param_count += 1;\n        }\n        if let Some(ref settings_json) = request.settings_json {\n            fields.push(format!(\"settings_json = ${param_count}\"));\n            values.push(settings_json);\n            param_count += 1;\n        }\n\n        if fields.is_empty() {\n            return self.get_user_settings(user_id).await;\n        }\n\n        fields.push(\"updated_at = NOW()\".to_string());\n        values.push(&user_id);\n\n        let query = format!(\n            \"UPDATE user_settings SET {} WHERE user_id = ${} \n             RETURNING id, user_id, theme, default_inventory_id, items_per_page, date_format, \n                       currency, notifications_enabled, settings_json, created_at, updated_at\",\n            fields.join(\", \"),\n            param_count\n        );\n\n        let rows = client.query(&query, &values).await?;\n\n        if let Some(row) = rows.first() {\n            Ok(Some(UserSettings {\n                id: row.get(0),\n                user_id: row.get(1),\n                theme: row.get(2),\n                default_inventory_id: row.get(3),\n                items_per_page: row.get(4),\n                date_format: row.get(5),\n                currency: row.get(6),\n                notifications_enabled: row.get(7),\n                settings_json: row.get(8),\n                created_at: row.get(9),\n                updated_at: row.get(10),\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Get or create user settings\n    pub async fn get_or_create_user_settings(\n        &self,\n        user_id: Uuid,\n    ) -> Result<UserSettings, Box<dyn std::error::Error>> {\n        if let Some(settings) = self.get_user_settings(user_id).await? {\n            Ok(settings)\n        } else {\n            self.create_user_settings(user_id).await\n        }\n    }\n\n    // ==================== Inventory Sharing Operations ====================\n\n    /// Share an inventory with a user\n    pub async fn create_inventory_share(\n        &self,\n        inventory_id: i32,\n        shared_with_user_id: Uuid,\n        shared_by_user_id: Uuid,\n        permission_level: PermissionLevel,\n    ) -> Result<InventoryShare, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let permission_str = permission_level.to_string();\n        let row = client\n            .query_one(\n                \"INSERT INTO inventory_shares (inventory_id, shared_with_user_id, shared_by_user_id, permission_level) \n                 VALUES ($1, $2, $3, $4) \n                 RETURNING id, inventory_id, shared_with_user_id, shared_by_user_id, permission_level, created_at, updated_at\",\n                &[&inventory_id, &shared_with_user_id, &shared_by_user_id, &permission_str],\n            )\n            .await?;\n\n        let perm_str: String = row.get(4);\n        Ok(InventoryShare {\n            id: row.get(0),\n            inventory_id: row.get(1),\n            shared_with_user_id: row.get(2),\n            shared_by_user_id: row.get(3),\n            permission_level: perm_str.parse().unwrap_or(PermissionLevel::View),\n            created_at: row.get(5),\n            updated_at: row.get(6),\n        })\n    }\n\n    /// Get shares for an inventory\n    pub async fn get_inventory_shares(\n        &self,\n        inventory_id: i32,\n    ) -> Result<Vec<InventoryShareWithUser>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT \n                    s.id, s.inventory_id, s.permission_level, s.created_at, s.updated_at,\n                    sw.id, sw.username, sw.full_name, sw.is_admin, sw.is_active, sw.created_at, sw.updated_at,\n                    sb.id, sb.username, sb.full_name, sb.is_admin, sb.is_active, sb.created_at, sb.updated_at\n                 FROM inventory_shares s\n                 JOIN users sw ON s.shared_with_user_id = sw.id\n                 JOIN users sb ON s.shared_by_user_id = sb.id\n                 WHERE s.inventory_id = $1\n                 ORDER BY s.created_at DESC\",\n                &[&inventory_id],\n            )\n            .await?;\n\n        let shares = rows\n            .iter()\n            .map(|row| {\n                let perm_str: String = row.get(2);\n                InventoryShareWithUser {\n                    id: row.get(0),\n                    inventory_id: row.get(1),\n                    permission_level: perm_str.parse().unwrap_or(PermissionLevel::View),\n                    created_at: row.get(3),\n                    updated_at: row.get(4),\n                    shared_with_user: UserResponse {\n                        id: row.get(5),\n                        username: row.get(6),\n                        full_name: row.get(7),\n                        is_admin: row.get(8),\n                        is_active: row.get(9),\n                        created_at: row.get(10),\n                        updated_at: row.get(11),\n                    },\n                    shared_by_user: UserResponse {\n                        id: row.get(12),\n                        username: row.get(13),\n                        full_name: row.get(14),\n                        is_admin: row.get(15),\n                        is_active: row.get(16),\n                        created_at: row.get(17),\n                        updated_at: row.get(18),\n                    },\n                }\n            })\n            .collect();\n\n        Ok(shares)\n    }\n\n    /// Get comprehensive effective permissions for a user on an inventory\n    pub async fn get_effective_permissions(\n        &self,\n        user_id: Uuid,\n        inventory_id: i32,\n    ) -> Result<EffectivePermissions, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        // Check if user is the owner\n        let owner_rows = client\n            .query(\n                \"SELECT user_id FROM inventories WHERE id = $1\",\n                &[&inventory_id],\n            )\n            .await?;\n\n        if let Some(row) = owner_rows.first() {\n            let owner_id: Option<Uuid> = row.get(0);\n            if owner_id == Some(user_id) {\n                return Ok(EffectivePermissions {\n                    can_view: true,\n                    can_edit_items: true,\n                    can_add_items: true,\n                    can_remove_items: true,\n                    can_edit_inventory: true,\n                    can_delete_inventory: true,\n                    can_manage_sharing: true,\n                    can_manage_organizers: true,\n                    is_owner: true,\n                    has_all_access: false,\n                    permission_source: PermissionSource::Owner,\n                });\n            }\n\n            // Check for All Access grant from the owner\n            if let Some(owner_uuid) = owner_id {\n                let all_access_rows = client\n                    .query(\n                        \"SELECT id FROM user_access_grants \n                         WHERE grantor_user_id = $1 AND grantee_user_id = $2\",\n                        &[&owner_uuid, &user_id],\n                    )\n                    .await?;\n\n                if !all_access_rows.is_empty() {\n                    return Ok(EffectivePermissions {\n                        can_view: true,\n                        can_edit_items: true,\n                        can_add_items: true,\n                        can_remove_items: true,\n                        can_edit_inventory: true,\n                        can_delete_inventory: true,\n                        can_manage_sharing: true,\n                        can_manage_organizers: true,\n                        is_owner: false,\n                        has_all_access: true,\n                        permission_source: PermissionSource::AllAccess,\n                    });\n                }\n            }\n        }\n\n        // Check for per-inventory share\n        let share_rows = client\n            .query(\n                \"SELECT permission_level FROM inventory_shares \n                 WHERE inventory_id = $1 AND shared_with_user_id = $2\",\n                &[&inventory_id, &user_id],\n            )\n            .await?;\n\n        if let Some(row) = share_rows.first() {\n            let perm_str: String = row.get(0);\n            let permission = perm_str.parse().unwrap_or(PermissionLevel::View);\n\n            return Ok(EffectivePermissions {\n                can_view: permission.can_view(),\n                can_edit_items: permission.can_edit_items(),\n                can_add_items: permission.can_add_items(),\n                can_remove_items: permission.can_remove_items(),\n                can_edit_inventory: permission.can_edit_inventory(),\n                can_delete_inventory: false, // Only owner or AllAccess can delete\n                can_manage_sharing: false,   // Only owner or AllAccess can manage sharing\n                can_manage_organizers: permission.can_manage_organizers(),\n                is_owner: false,\n                has_all_access: false,\n                permission_source: PermissionSource::InventoryShare,\n            });\n        }\n\n        // No access\n        Ok(EffectivePermissions {\n            can_view: false,\n            can_edit_items: false,\n            can_add_items: false,\n            can_remove_items: false,\n            can_edit_inventory: false,\n            can_delete_inventory: false,\n            can_manage_sharing: false,\n            can_manage_organizers: false,\n            is_owner: false,\n            has_all_access: false,\n            permission_source: PermissionSource::None,\n        })\n    }\n\n    /// Update inventory share permission\n    pub async fn update_inventory_share(\n        &self,\n        share_id: Uuid,\n        permission_level: PermissionLevel,\n    ) -> Result<Option<InventoryShare>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let permission_str = permission_level.to_string();\n        let rows = client\n            .query(\n                \"UPDATE inventory_shares SET permission_level = $1, updated_at = NOW() \n                 WHERE id = $2 \n                 RETURNING id, inventory_id, shared_with_user_id, shared_by_user_id, permission_level, created_at, updated_at\",\n                &[&permission_str, &share_id],\n            )\n            .await?;\n\n        if let Some(row) = rows.first() {\n            let perm_str: String = row.get(4);\n            Ok(Some(InventoryShare {\n                id: row.get(0),\n                inventory_id: row.get(1),\n                shared_with_user_id: row.get(2),\n                shared_by_user_id: row.get(3),\n                permission_level: perm_str.parse().unwrap_or(PermissionLevel::View),\n                created_at: row.get(5),\n                updated_at: row.get(6),\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Delete inventory share\n    pub async fn delete_inventory_share(\n        &self,\n        share_id: Uuid,\n    ) -> Result<bool, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows_affected = client\n            .execute(\"DELETE FROM inventory_shares WHERE id = $1\", &[&share_id])\n            .await?;\n\n        Ok(rows_affected > 0)\n    }\n\n    /// Get inventories accessible to a user (owned, shared via `inventory_shares`, or via All Access grants)\n    pub async fn get_accessible_inventories(\n        &self,\n        user_id: Uuid,\n    ) -> Result<Vec<Inventory>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        // Query includes:\n        // 1. Inventories owned by the user (i.user_id = $1)\n        // 2. Inventories shared directly with the user (inventory_shares)\n        // 3. Inventories owned by users who granted All Access to this user (user_access_grants)\n        let rows = client\n            .query(\n                \"SELECT DISTINCT i.id, i.name, i.description, i.location, i.image_url, i.user_id, i.created_at, i.updated_at \n                 FROM inventories i\n                 LEFT JOIN inventory_shares s ON i.id = s.inventory_id AND s.shared_with_user_id = $1\n                 LEFT JOIN user_access_grants g ON i.user_id = g.grantor_user_id AND g.grantee_user_id = $1\n                 WHERE i.user_id = $1 \n                    OR s.shared_with_user_id = $1\n                    OR g.grantee_user_id = $1\n                 ORDER BY i.name ASC\",\n                &[&user_id],\n            )\n            .await?;\n\n        let inventories = rows\n            .iter()\n            .map(|row| Inventory {\n                id: Some(row.get(0)),\n                name: row.get(1),\n                description: row.get(2),\n                location: row.get(3),\n                image_url: row.get(4),\n                user_id: row.get(5),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(6),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(7),\n            })\n            .collect();\n\n        Ok(inventories)\n    }\n\n    // ==================== User Access Grant Operations (All Access Tier) ====================\n\n    /// Create a user access grant (All Access tier)\n    pub async fn create_user_access_grant(\n        &self,\n        grantor_user_id: Uuid,\n        grantee_user_id: Uuid,\n    ) -> Result<UserAccessGrant, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let row = client\n            .query_one(\n                \"INSERT INTO user_access_grants (grantor_user_id, grantee_user_id) \n                 VALUES ($1, $2) \n                 RETURNING id, grantor_user_id, grantee_user_id, created_at, updated_at\",\n                &[&grantor_user_id, &grantee_user_id],\n            )\n            .await?;\n\n        Ok(UserAccessGrant {\n            id: row.get(0),\n            grantor_user_id: row.get(1),\n            grantee_user_id: row.get(2),\n            created_at: row.get(3),\n            updated_at: row.get(4),\n        })\n    }\n\n    /// Get all access grants where the user is the grantor (people who can access my inventories)\n    pub async fn get_user_access_grants_by_grantor(\n        &self,\n        grantor_user_id: Uuid,\n    ) -> Result<Vec<UserAccessGrantWithUsers>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT \n                    g.id, g.created_at, g.updated_at,\n                    gr.id, gr.username, gr.full_name, gr.is_admin, gr.is_active, gr.created_at, gr.updated_at,\n                    ge.id, ge.username, ge.full_name, ge.is_admin, ge.is_active, ge.created_at, ge.updated_at\n                 FROM user_access_grants g\n                 JOIN users gr ON g.grantor_user_id = gr.id\n                 JOIN users ge ON g.grantee_user_id = ge.id\n                 WHERE g.grantor_user_id = $1\n                 ORDER BY g.created_at DESC\",\n                &[&grantor_user_id],\n            )\n            .await?;\n\n        let grants = rows\n            .iter()\n            .map(|row| UserAccessGrantWithUsers {\n                id: row.get(0),\n                created_at: row.get(1),\n                updated_at: row.get(2),\n                grantor: UserResponse {\n                    id: row.get(3),\n                    username: row.get(4),\n                    full_name: row.get(5),\n                    is_admin: row.get(6),\n                    is_active: row.get(7),\n                    created_at: row.get(8),\n                    updated_at: row.get(9),\n                },\n                grantee: UserResponse {\n                    id: row.get(10),\n                    username: row.get(11),\n                    full_name: row.get(12),\n                    is_admin: row.get(13),\n                    is_active: row.get(14),\n                    created_at: row.get(15),\n                    updated_at: row.get(16),\n                },\n            })\n            .collect();\n\n        Ok(grants)\n    }\n\n    /// Get all access grants where the user is the grantee (users who gave me access)\n    pub async fn get_user_access_grants_by_grantee(\n        &self,\n        grantee_user_id: Uuid,\n    ) -> Result<Vec<UserAccessGrantWithUsers>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT \n                    g.id, g.created_at, g.updated_at,\n                    gr.id, gr.username, gr.full_name, gr.is_admin, gr.is_active, gr.created_at, gr.updated_at,\n                    ge.id, ge.username, ge.full_name, ge.is_admin, ge.is_active, ge.created_at, ge.updated_at\n                 FROM user_access_grants g\n                 JOIN users gr ON g.grantor_user_id = gr.id\n                 JOIN users ge ON g.grantee_user_id = ge.id\n                 WHERE g.grantee_user_id = $1\n                 ORDER BY g.created_at DESC\",\n                &[&grantee_user_id],\n            )\n            .await?;\n\n        let grants = rows\n            .iter()\n            .map(|row| UserAccessGrantWithUsers {\n                id: row.get(0),\n                created_at: row.get(1),\n                updated_at: row.get(2),\n                grantor: UserResponse {\n                    id: row.get(3),\n                    username: row.get(4),\n                    full_name: row.get(5),\n                    is_admin: row.get(6),\n                    is_active: row.get(7),\n                    created_at: row.get(8),\n                    updated_at: row.get(9),\n                },\n                grantee: UserResponse {\n                    id: row.get(10),\n                    username: row.get(11),\n                    full_name: row.get(12),\n                    is_admin: row.get(13),\n                    is_active: row.get(14),\n                    created_at: row.get(15),\n                    updated_at: row.get(16),\n                },\n            })\n            .collect();\n\n        Ok(grants)\n    }\n\n    /// Delete a user access grant\n    pub async fn delete_user_access_grant(\n        &self,\n        grant_id: Uuid,\n    ) -> Result<bool, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows_affected = client\n            .execute(\"DELETE FROM user_access_grants WHERE id = $1\", &[&grant_id])\n            .await?;\n\n        Ok(rows_affected > 0)\n    }\n\n    /// Get a user access grant by ID\n    pub async fn get_user_access_grant_by_id(\n        &self,\n        grant_id: Uuid,\n    ) -> Result<Option<UserAccessGrant>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT id, grantor_user_id, grantee_user_id, created_at, updated_at \n                 FROM user_access_grants WHERE id = $1\",\n                &[&grant_id],\n            )\n            .await?;\n\n        if let Some(row) = rows.first() {\n            Ok(Some(UserAccessGrant {\n                id: row.get(0),\n                grantor_user_id: row.get(1),\n                grantee_user_id: row.get(2),\n                created_at: row.get(3),\n                updated_at: row.get(4),\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    // ==================== Ownership Transfer Operations ====================\n\n    /// Transfer ownership of an inventory from one user to another\n    /// This operation:\n    /// 1. Updates the inventory's `user_id` to the new owner\n    /// 2. Removes all existing shares for the inventory (new owner controls sharing)\n    /// 3. The previous owner loses all access\n    pub async fn transfer_inventory_ownership(\n        &self,\n        inventory_id: i32,\n        from_user_id: Uuid,\n        to_user_id: Uuid,\n    ) -> Result<(i64, i64), Box<dyn std::error::Error>> {\n        let mut client = self.pool.get().await?;\n\n        // Start a transaction for atomic operation\n        let transaction = client.transaction().await?;\n\n        // Verify the inventory exists and is owned by from_user_id\n        let verify_result = transaction\n            .query_opt(\n                \"SELECT id FROM inventories WHERE id = $1 AND user_id = $2\",\n                &[&inventory_id, &from_user_id],\n            )\n            .await?;\n\n        if verify_result.is_none() {\n            return Err(\"Inventory not found or you are not the owner\".into());\n        }\n\n        // Verify the target user exists\n        let target_user = transaction\n            .query_opt(\n                \"SELECT id FROM users WHERE id = $1 AND is_active = true\",\n                &[&to_user_id],\n            )\n            .await?;\n\n        if target_user.is_none() {\n            return Err(\"Target user not found or is inactive\".into());\n        }\n\n        // Count items that will be transferred (for reporting)\n        let items_count: i64 = transaction\n            .query_one(\n                \"SELECT COUNT(*) FROM items WHERE inventory_id = $1\",\n                &[&inventory_id],\n            )\n            .await?\n            .get(0);\n\n        // Transfer ownership by updating user_id\n        transaction\n            .execute(\n                \"UPDATE inventories SET user_id = $1, updated_at = NOW() WHERE id = $2\",\n                &[&to_user_id, &inventory_id],\n            )\n            .await?;\n\n        // Remove all existing shares for this inventory (new owner will manage sharing)\n        let shares_removed = transaction\n            .execute(\n                \"DELETE FROM inventory_shares WHERE inventory_id = $1\",\n                &[&inventory_id],\n            )\n            .await?;\n\n        // Commit the transaction\n        transaction.commit().await?;\n\n        info!(\n            \"Transferred ownership of inventory {} from {:?} to {:?}. Items: {}, Shares removed: {}\",\n            inventory_id, from_user_id, to_user_id, items_count, shares_removed\n        );\n\n        // Safe cast: shares_removed is clamped to i64::MAX, preventing wrap\n        #[allow(\n            clippy::cast_possible_wrap,\n            reason = \"Value is clamped to i64::MAX preventing wrap\"\n        )]\n        let shares_removed_i64 = shares_removed.min(i64::MAX as u64) as i64;\n        Ok((items_count, shares_removed_i64))\n    }\n\n    // ==================== Recovery Codes Methods ====================\n\n    /// Store recovery codes for a user (deletes any existing codes first)\n    pub async fn store_recovery_codes(\n        &self,\n        user_id: Uuid,\n        code_hashes: Vec<String>,\n    ) -> Result<(), Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        // Delete any existing recovery codes for this user\n        client\n            .execute(\"DELETE FROM recovery_codes WHERE user_id = $1\", &[&user_id])\n            .await?;\n\n        // Insert new codes\n        for code_hash in code_hashes {\n            client\n                .execute(\n                    \"INSERT INTO recovery_codes (user_id, code_hash) VALUES ($1, $2)\",\n                    &[&user_id, &code_hash],\n                )\n                .await?;\n        }\n\n        // Update user's recovery codes timestamp and reset confirmation\n        client\n            .execute(\n                \"UPDATE users SET recovery_codes_generated_at = NOW(), recovery_codes_confirmed = false WHERE id = $1\",\n                &[&user_id],\n            )\n            .await?;\n\n        info!(\"Stored {} recovery codes for user {}\", 10, user_id);\n        Ok(())\n    }\n\n    /// Confirm that user has saved their recovery codes\n    pub async fn confirm_recovery_codes(\n        &self,\n        user_id: Uuid,\n    ) -> Result<(), Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        client\n            .execute(\n                \"UPDATE users SET recovery_codes_confirmed = true WHERE id = $1\",\n                &[&user_id],\n            )\n            .await?;\n\n        info!(\"User {} confirmed saving recovery codes\", user_id);\n        Ok(())\n    }\n\n    /// Get all unused recovery code hashes for a user (for verification)\n    pub async fn get_unused_recovery_codes(\n        &self,\n        user_id: Uuid,\n    ) -> Result<Vec<(Uuid, String)>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let rows = client\n            .query(\n                \"SELECT id, code_hash FROM recovery_codes WHERE user_id = $1 AND is_used = false\",\n                &[&user_id],\n            )\n            .await?;\n\n        let codes: Vec<(Uuid, String)> = rows.iter().map(|row| (row.get(0), row.get(1))).collect();\n\n        Ok(codes)\n    }\n\n    /// Mark a recovery code as used\n    pub async fn mark_recovery_code_used(\n        &self,\n        code_id: Uuid,\n    ) -> Result<(), Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        client\n            .execute(\n                \"UPDATE recovery_codes SET is_used = true, used_at = NOW() WHERE id = $1\",\n                &[&code_id],\n            )\n            .await?;\n\n        info!(\"Marked recovery code {} as used\", code_id);\n        Ok(())\n    }\n\n    /// Get count of unused recovery codes for a user\n    pub async fn get_unused_recovery_codes_count(\n        &self,\n        user_id: Uuid,\n    ) -> Result<i32, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let row = client\n            .query_one(\n                \"SELECT COUNT(*)::int4 FROM recovery_codes WHERE user_id = $1 AND is_used = false\",\n                &[&user_id],\n            )\n            .await?;\n\n        Ok(row.get(0))\n    }\n\n    /// Get recovery codes status for a user\n    pub async fn get_recovery_codes_status(\n        &self,\n        user_id: Uuid,\n    ) -> Result<(bool, bool, i32, Option<DateTime<Utc>>), Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        // Get user info\n        let user_row = client\n            .query_one(\n                \"SELECT recovery_codes_generated_at, COALESCE(recovery_codes_confirmed, false) FROM users WHERE id = $1\",\n                &[&user_id],\n            )\n            .await?;\n\n        let generated_at: Option<DateTime<Utc>> = user_row.get(0);\n        let confirmed: bool = user_row.get(1);\n\n        // Get unused count\n        let count_row = client\n            .query_one(\n                \"SELECT COUNT(*)::int4 FROM recovery_codes WHERE user_id = $1 AND is_used = false\",\n                &[&user_id],\n            )\n            .await?;\n\n        let unused_count: i32 = count_row.get(0);\n        let has_codes = unused_count > 0;\n\n        Ok((has_codes, confirmed, unused_count, generated_at))\n    }\n\n    // ==================== Inventory Reporting Operations ====================\n\n    /// Check if user has access to a specific inventory\n    pub async fn check_inventory_access(\n        &self,\n        user_id: Uuid,\n        inventory_id: i32,\n    ) -> Result<bool, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let row = client\n            .query_one(\n                \"SELECT COUNT(*)::int8 as count FROM inventories \n                 WHERE id = $1 AND (\n                     user_id = $2\n                     OR id IN (SELECT inventory_id FROM inventory_shares WHERE shared_with_user_id = $2)\n                     OR user_id IN (SELECT grantor_user_id FROM user_access_grants WHERE grantee_user_id = $2)\n                 )\",\n                &[&inventory_id, &user_id],\n            )\n            .await?;\n\n        let count: i64 = row.get(0);\n        Ok(count > 0)\n    }\n\n    /// Retrieves filtered inventory items for report generation.\n    ///\n    /// This method enforces row-level security by only returning items from inventories\n    /// that the user owns or has been granted access to via shares or access grants.\n    ///\n    /// # Arguments\n    /// * `request` - Filter parameters (`inventory_id`, `category`, dates, prices, etc.)\n    /// * `user_id` - UUID of the authenticated user making the request\n    ///\n    /// # Returns\n    /// * `Ok(Vec<Item>)` - Filtered and sorted items accessible to the user\n    /// * `Err(Box<dyn Error>)` - Database connection or query execution errors\n    pub async fn get_inventory_report_data(\n        &self,\n        request: crate::models::InventoryReportRequest,\n        user_id: Uuid,\n    ) -> Result<Vec<crate::models::Item>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        // Build dynamic WHERE clause based on filters\n        let mut conditions = vec![\n            \"i.inventory_id IN (\n                SELECT id FROM inventories \n                WHERE user_id = $1\n                   OR id IN (SELECT inventory_id FROM inventory_shares WHERE shared_with_user_id = $1)\n                   OR user_id IN (SELECT grantor_user_id FROM user_access_grants WHERE grantee_user_id = $1)\n            )\".to_string()\n        ];\n        let mut param_index = 2;\n\n        // Build parameters vector\n        let mut params: Vec<Box<dyn tokio_postgres::types::ToSql + Sync>> = vec![Box::new(user_id)];\n\n        // Add optional filters\n        if let Some(inv_id) = request.inventory_id {\n            conditions.push(format!(\"i.inventory_id = ${param_index}\"));\n            params.push(Box::new(inv_id));\n            param_index += 1;\n        }\n\n        if let Some(ref category) = request.category {\n            conditions.push(format!(\"i.category = ${param_index}\"));\n            params.push(Box::new(category.clone()));\n            param_index += 1;\n        }\n\n        if let Some(ref location) = request.location {\n            let pattern = format!(\"%{}%\", escape_like_pattern(location));\n            conditions.push(format!(\"i.location ILIKE ${param_index}\"));\n            params.push(Box::new(pattern));\n            param_index += 1;\n        }\n\n        if let Some(ref from_date) = request.from_date {\n            conditions.push(format!(\"i.purchase_date >= ${param_index}::date\"));\n            params.push(Box::new(from_date.clone()));\n            param_index += 1;\n        }\n\n        if let Some(ref to_date) = request.to_date {\n            conditions.push(format!(\"i.purchase_date <= ${param_index}::date\"));\n            params.push(Box::new(to_date.clone()));\n            param_index += 1;\n        }\n\n        if let Some(min_price) = request.min_price {\n            conditions.push(format!(\"i.purchase_price >= ${param_index}::float8\"));\n            params.push(Box::new(min_price));\n            param_index += 1;\n        }\n\n        if let Some(max_price) = request.max_price {\n            conditions.push(format!(\"i.purchase_price <= ${param_index}::float8\"));\n            params.push(Box::new(max_price));\n            #[allow(unused_assignments)]\n            {\n                param_index += 1;\n            }\n        }\n\n        // Build ORDER BY clause\n        let order_by = build_order_by(&request);\n\n        let query = format!(\n            \"SELECT i.id, i.inventory_id, i.name, i.description, i.category, i.location,\n                    i.purchase_date::text, i.purchase_price::float8, i.warranty_expiry::text,\n                    i.notes, i.quantity, i.created_at, i.updated_at\n             FROM items i\n             WHERE {}\n             ORDER BY {}\",\n            conditions.join(\" AND \"),\n            order_by\n        );\n\n        // Convert params to references for query\n        let params_refs: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> =\n            params.iter().map(std::convert::AsRef::as_ref).collect();\n\n        let rows = client.query(&query, &params_refs).await?;\n\n        let items: Vec<crate::models::Item> = rows\n            .iter()\n            .map(|row| crate::models::Item {\n                id: Some(row.get(0)),\n                inventory_id: row.get(1),\n                name: row.get(2),\n                description: row.get(3),\n                category: row.get(4),\n                location: row.get(5),\n                purchase_date: row.get::<_, Option<String>>(6),\n                purchase_price: row.get(7),\n                warranty_expiry: row.get::<_, Option<String>>(8),\n                notes: row.get(9),\n                quantity: row.get(10),\n                created_at: row.get::<_, Option<DateTime<Utc>>>(11),\n                updated_at: row.get::<_, Option<DateTime<Utc>>>(12),\n            })\n            .collect();\n\n        info!(\n            \"Generated report with {} items for user {}\",\n            items.len(),\n            user_id\n        );\n        Ok(items)\n    }\n\n    /// Calculates aggregated statistics across inventory items.\n    ///\n    /// Computes total item count, total value (price  quantity), average values,\n    /// and date ranges for items. When `inventory_id` is None, aggregates across\n    /// all inventories the user has access to.\n    ///\n    /// # Arguments\n    /// * `inventory_id` - Optional inventory ID to limit statistics to one inventory\n    /// * `user_id` - UUID of the authenticated user making the request\n    ///\n    /// # Returns\n    /// * `Ok(InventoryStatistics)` - Aggregated statistics\n    /// * `Err(Box<dyn Error>)` - Database connection or query execution errors\n    pub async fn get_inventory_statistics(\n        &self,\n        inventory_id: Option<i32>,\n        user_id: Uuid,\n    ) -> Result<crate::models::InventoryStatistics, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let (query, params): (&str, Vec<Box<dyn tokio_postgres::types::ToSql + Sync>>) =\n            if let Some(inv_id) = inventory_id {\n                (\n                    \"SELECT \n                    COUNT(*)::int8 as total_items,\n                    COALESCE(SUM(purchase_price::float8 * quantity), 0.0)::float8 as total_value,\n                    COALESCE(SUM(quantity), 0)::int8 as total_quantity,\n                    COUNT(DISTINCT category)::int8 as category_count,\n                    1::int8 as inventories_count,\n                    MIN(purchase_date)::text as oldest_item_date,\n                    MAX(purchase_date)::text as newest_item_date,\n                    COALESCE(AVG(purchase_price::float8), 0.0)::float8 as average_item_value\n                 FROM items\n                 WHERE inventory_id = $1\",\n                    vec![Box::new(inv_id)],\n                )\n            } else {\n                (\n                \"SELECT \n                    COUNT(*)::int8 as total_items,\n                    COALESCE(SUM(purchase_price::float8 * quantity), 0.0)::float8 as total_value,\n                    COALESCE(SUM(quantity), 0)::int8 as total_quantity,\n                    COUNT(DISTINCT category)::int8 as category_count,\n                    COUNT(DISTINCT inventory_id)::int8 as inventories_count,\n                    MIN(purchase_date)::text as oldest_item_date,\n                    MAX(purchase_date)::text as newest_item_date,\n                    COALESCE(AVG(purchase_price::float8), 0.0)::float8 as average_item_value\n                 FROM items\n                 WHERE inventory_id IN (\n                     SELECT id FROM inventories \n                     WHERE user_id = $1\n                        OR id IN (SELECT inventory_id FROM inventory_shares WHERE shared_with_user_id = $1)\n                        OR user_id IN (SELECT grantor_user_id FROM user_access_grants WHERE grantee_user_id = $1)\n                 )\",\n                vec![Box::new(user_id)],\n            )\n            };\n\n        let params_refs: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> =\n            params.iter().map(std::convert::AsRef::as_ref).collect();\n\n        let row = client.query_one(query, &params_refs).await?;\n\n        let statistics = crate::models::InventoryStatistics {\n            total_items: row.get(0),\n            total_value: row.get(1),\n            total_quantity: row.get(2),\n            category_count: row.get(3),\n            inventories_count: row.get(4),\n            oldest_item_date: row.get(5),\n            newest_item_date: row.get(6),\n            average_item_value: row.get(7),\n        };\n\n        info!(\"Generated statistics for user {}\", user_id);\n        Ok(statistics)\n    }\n\n    /// Generates category breakdown with item counts and value percentages.\n    ///\n    /// Groups items by category and calculates total values, quantities, and\n    /// percentage of total inventory value for each category. Uncategorized\n    /// items are grouped under \"Uncategorized\".\n    ///\n    /// # Arguments\n    /// * `inventory_id` - Optional inventory ID to limit breakdown to one inventory\n    /// * `user_id` - UUID of the authenticated user making the request\n    ///\n    /// # Returns\n    /// * `Ok(Vec<CategoryBreakdown>)` - Breakdown sorted by total value descending\n    /// * `Err(Box<dyn Error>)` - Database connection or query execution errors\n    pub async fn get_category_breakdown(\n        &self,\n        inventory_id: Option<i32>,\n        user_id: Uuid,\n    ) -> Result<Vec<crate::models::CategoryBreakdown>, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        let (query, params): (&str, Vec<Box<dyn tokio_postgres::types::ToSql + Sync>>) =\n            if let Some(inv_id) = inventory_id {\n                (\n                \"WITH totals AS (\n                     SELECT COALESCE(SUM(purchase_price::float8 * quantity), 0.0)::float8 as grand_total\n                     FROM items\n                     WHERE inventory_id = $1\n                 )\n                 SELECT \n                     COALESCE(i.category, 'Uncategorized') as category,\n                     COUNT(*)::int8 as item_count,\n                     COALESCE(SUM(i.quantity), 0)::int8 as total_quantity,\n                     COALESCE(SUM(i.purchase_price::float8 * i.quantity), 0.0)::float8 as total_value,\n                     CASE \n                         WHEN t.grand_total > 0 THEN \n                             (COALESCE(SUM(i.purchase_price::float8 * i.quantity), 0.0) / t.grand_total * 100.0)::float8\n                         ELSE 0.0::float8\n                     END as percentage\n                 FROM items i\n                 CROSS JOIN totals t\n                 WHERE i.inventory_id = $1\n                 GROUP BY i.category, t.grand_total\n                 ORDER BY total_value DESC\",\n                vec![Box::new(inv_id)],\n            )\n            } else {\n                (\n                \"WITH totals AS (\n                     SELECT COALESCE(SUM(purchase_price::float8 * quantity), 0.0)::float8 as grand_total\n                     FROM items\n                     WHERE inventory_id IN (\n                         SELECT id FROM inventories \n                         WHERE user_id = $1\n                            OR id IN (SELECT inventory_id FROM inventory_shares WHERE shared_with_user_id = $1)\n                            OR user_id IN (SELECT grantor_user_id FROM user_access_grants WHERE grantee_user_id = $1)\n                     )\n                 )\n                 SELECT \n                     COALESCE(i.category, 'Uncategorized') as category,\n                     COUNT(*)::int8 as item_count,\n                     COALESCE(SUM(i.quantity), 0)::int8 as total_quantity,\n                     COALESCE(SUM(i.purchase_price::float8 * i.quantity), 0.0)::float8 as total_value,\n                     CASE \n                         WHEN t.grand_total > 0 THEN \n                             (COALESCE(SUM(i.purchase_price::float8 * i.quantity), 0.0) / t.grand_total * 100.0)::float8\n                         ELSE 0.0::float8\n                     END as percentage\n                 FROM items i\n                 CROSS JOIN totals t\n                 WHERE i.inventory_id IN (\n                     SELECT id FROM inventories \n                     WHERE user_id = $1\n                        OR id IN (SELECT inventory_id FROM inventory_shares WHERE shared_with_user_id = $1)\n                        OR user_id IN (SELECT grantor_user_id FROM user_access_grants WHERE grantee_user_id = $1)\n                 )\n                 GROUP BY i.category, t.grand_total\n                 ORDER BY total_value DESC\",\n                vec![Box::new(user_id)],\n            )\n            };\n\n        let params_refs: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> =\n            params.iter().map(std::convert::AsRef::as_ref).collect();\n\n        let rows = client.query(query, &params_refs).await?;\n\n        let breakdown = rows\n            .iter()\n            .map(|row| crate::models::CategoryBreakdown {\n                category: row.get(0),\n                item_count: row.get(1),\n                total_quantity: row.get(2),\n                total_value: row.get(3),\n                percentage_of_total: row.get(4),\n            })\n            .collect();\n\n        info!(\"Generated category breakdown for user {}\", user_id);\n        Ok(breakdown)\n    }\n\n    // ==================== Backup & Restore Methods ====================\n\n    /// Export all database tables as JSON values for backup\n    pub async fn export_all_data(\n        &self,\n    ) -> Result<BackupDatabaseContent, Box<dyn std::error::Error>> {\n        let client = self.pool.get().await?;\n\n        // Helper closure to build the JSON export query for a table\n        let build_export_query = |table: &str| {\n            format!(\"SELECT COALESCE(jsonb_agg(to_jsonb(t)), '[]'::jsonb) FROM {table} t\")\n        };\n\n        let users: serde_json::Value = client\n            .query_one(&build_export_query(\"users\"), &[])\n            .await?\n            .get(0);\n        let inventories: serde_json::Value = client\n            .query_one(&build_export_query(\"inventories\"), &[])\n            .await?\n            .get(0);\n        let items: serde_json::Value = client\n            .query_one(&build_export_query(\"items\"), &[])\n            .await?\n            .get(0);\n        let categories: serde_json::Value = client\n            .query_one(&build_export_query(\"categories\"), &[])\n            .await?\n            .get(0);\n        let tags: serde_json::Value = client\n            .query_one(&build_export_query(\"tags\"), &[])\n            .await?\n            .get(0);\n        let item_tags: serde_json::Value = client\n            .query_one(&build_export_query(\"item_tags\"), &[])\n            .await?\n            .get(0);\n        let custom_fields: serde_json::Value = client\n            .query_one(&build_export_query(\"custom_fields\"), &[])\n            .await?\n            .get(0);\n        let item_custom_values: serde_json::Value = client\n            .query_one(&build_export_query(\"item_custom_values\"), &[])\n            .await?\n            .get(0);\n        let organizer_types: serde_json::Value = client\n            .query_one(&build_export_query(\"organizer_types\"), &[])\n            .await?\n            .get(0);\n        let organizer_options: serde_json::Value = client\n            .query_one(&build_export_query(\"organizer_options\"), &[])\n            .await?\n            .get(0);\n        let item_organizer_values: serde_json::Value = client\n            .query_one(&build_export_query(\"item_organizer_values\"), &[])\n            .await?\n            .get(0);\n        let user_settings: serde_json::Value = client\n            .query_one(&build_export_query(\"user_settings\"), &[])\n            .await?\n            .get(0);\n        let inventory_shares: serde_json::Value = client\n            .query_one(&build_export_query(\"inventory_shares\"), &[])\n            .await?\n            .get(0);\n        let user_access_grants: serde_json::Value = client\n            .query_one(&build_export_query(\"user_access_grants\"), &[])\n            .await?\n            .get(0);\n        let recovery_codes: serde_json::Value = client\n            .query_one(&build_export_query(\"recovery_codes\"), &[])\n            .await?\n            .get(0);\n        let password_reset_tokens: serde_json::Value = client\n            .query_one(&build_export_query(\"password_reset_tokens\"), &[])\n            .await?\n            .get(0);\n\n        info!(\"Successfully exported all database tables for backup\");\n\n        Ok(BackupDatabaseContent {\n            users,\n            inventories,\n            items,\n            categories,\n            tags,\n            item_tags,\n            custom_fields,\n            item_custom_values,\n            organizer_types,\n            organizer_options,\n            item_organizer_values,\n            user_settings,\n            inventory_shares,\n            user_access_grants,\n            recovery_codes,\n            password_reset_tokens,\n        })\n    }\n\n    /// Import all database tables from backup data (within a transaction)\n    pub async fn import_all_data(\n        &self,\n        data: &BackupDatabaseContent,\n    ) -> Result<(), Box<dyn std::error::Error>> {\n        let mut client = self.pool.get().await?;\n        let transaction = client.transaction().await?;\n\n        // Defer foreign key constraint checks until commit\n        transaction\n            .execute(\"SET CONSTRAINTS ALL DEFERRED\", &[])\n            .await?;\n\n        // Truncate all tables in reverse dependency order\n        let truncate_order = [\n            \"password_reset_tokens\",\n            \"recovery_codes\",\n            \"user_access_grants\",\n            \"inventory_shares\",\n            \"user_settings\",\n            \"item_organizer_values\",\n            \"organizer_options\",\n            \"organizer_types\",\n            \"item_custom_values\",\n            \"custom_fields\",\n            \"item_tags\",\n            \"tags\",\n            \"categories\",\n            \"items\",\n            \"inventories\",\n            \"users\",\n        ];\n\n        for table in &truncate_order {\n            let query = format!(\"TRUNCATE TABLE {table} RESTART IDENTITY CASCADE\");\n            transaction.execute(query.as_str(), &[]).await?;\n        }\n\n        // Import tables in dependency order\n        let import_order: Vec<(&str, &serde_json::Value)> = vec![\n            (\"users\", &data.users),\n            (\"inventories\", &data.inventories),\n            (\"items\", &data.items),\n            (\"categories\", &data.categories),\n            (\"tags\", &data.tags),\n            (\"item_tags\", &data.item_tags),\n            (\"custom_fields\", &data.custom_fields),\n            (\"item_custom_values\", &data.item_custom_values),\n            (\"organizer_types\", &data.organizer_types),\n            (\"organizer_options\", &data.organizer_options),\n            (\"item_organizer_values\", &data.item_organizer_values),\n            (\"user_settings\", &data.user_settings),\n            (\"inventory_shares\", &data.inventory_shares),\n            (\"user_access_grants\", &data.user_access_grants),\n            (\"recovery_codes\", &data.recovery_codes),\n            (\"password_reset_tokens\", &data.password_reset_tokens),\n        ];\n\n        for (table, rows_json) in &import_order {\n            if let Some(rows) = rows_json.as_array() {\n                for row in rows {\n                    let query = format!(\n                        \"INSERT INTO {table} SELECT * FROM jsonb_populate_record(NULL::{table}, $1)\"\n                    );\n                    transaction.execute(query.as_str(), &[row]).await?;\n                }\n            }\n        }\n\n        // Reset sequences for tables with serial/identity columns\n        let sequence_tables = [\n            \"items\",\n            \"inventories\",\n            \"categories\",\n            \"tags\",\n            \"custom_fields\",\n            \"item_custom_values\",\n            \"item_tags\",\n            \"organizer_types\",\n            \"organizer_options\",\n            \"item_organizer_values\",\n        ];\n\n        for table in &sequence_tables {\n            let query = format!(\n                \"SELECT setval(pg_get_serial_sequence('{table}', 'id'), \\\n                 COALESCE(MAX(id), 0) + 1, false) FROM {table}\"\n            );\n            // Ignore errors for tables that may not have sequences\n            if let Err(e) = transaction.execute(query.as_str(), &[]).await {\n                info!(\n                    \"Note: Could not reset sequence for table {}: {} (this may be expected)\",\n                    table, e\n                );\n            }\n        }\n\n        transaction.commit().await?;\n        info!(\"Successfully imported all database tables from backup\");\n        Ok(())\n    }\n}\n\n/// Helper function to build ORDER BY clause\nfn build_order_by(request: &crate::models::InventoryReportRequest) -> String {\n    let sort_by = request.sort_by.as_deref().unwrap_or(\"created_at\");\n    let sort_order = request.sort_order.as_deref().unwrap_or(\"desc\");\n\n    let column = match sort_by {\n        \"name\" => \"i.name\",\n        \"price\" => \"i.purchase_price\",\n        \"date\" => \"i.purchase_date\",\n        \"category\" => \"i.category\",\n        _ => \"i.created_at\",\n    };\n\n    let order = if sort_order.eq_ignore_ascii_case(\"asc\") {\n        \"ASC\"\n    } else {\n        \"DESC\"\n    };\n\n    format!(\"{column} {order}\")\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1029,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1048,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1060,"address":[],"length":0,"stats":{"Line":0}},{"line":1061,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1065,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1081,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1086,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1094,"address":[],"length":0,"stats":{"Line":0}},{"line":1096,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":0}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1104,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1106,"address":[],"length":0,"stats":{"Line":0}},{"line":1110,"address":[],"length":0,"stats":{"Line":0}},{"line":1114,"address":[],"length":0,"stats":{"Line":0}},{"line":1118,"address":[],"length":0,"stats":{"Line":0}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1123,"address":[],"length":0,"stats":{"Line":0}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":0}},{"line":1128,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":0}},{"line":1139,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":0}},{"line":1145,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":0}},{"line":1158,"address":[],"length":0,"stats":{"Line":0}},{"line":1160,"address":[],"length":0,"stats":{"Line":0}},{"line":1161,"address":[],"length":0,"stats":{"Line":0}},{"line":1162,"address":[],"length":0,"stats":{"Line":0}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1173,"address":[],"length":0,"stats":{"Line":0}},{"line":1179,"address":[],"length":0,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":0}},{"line":1181,"address":[],"length":0,"stats":{"Line":0}},{"line":1182,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1190,"address":[],"length":0,"stats":{"Line":0}},{"line":1191,"address":[],"length":0,"stats":{"Line":0}},{"line":1196,"address":[],"length":0,"stats":{"Line":0}},{"line":1198,"address":[],"length":0,"stats":{"Line":0}},{"line":1200,"address":[],"length":0,"stats":{"Line":0}},{"line":1201,"address":[],"length":0,"stats":{"Line":0}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1203,"address":[],"length":0,"stats":{"Line":0}},{"line":1204,"address":[],"length":0,"stats":{"Line":0}},{"line":1205,"address":[],"length":0,"stats":{"Line":0}},{"line":1206,"address":[],"length":0,"stats":{"Line":0}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1208,"address":[],"length":0,"stats":{"Line":0}},{"line":1209,"address":[],"length":0,"stats":{"Line":0}},{"line":1210,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1223,"address":[],"length":0,"stats":{"Line":0}},{"line":1224,"address":[],"length":0,"stats":{"Line":0}},{"line":1229,"address":[],"length":0,"stats":{"Line":0}},{"line":1231,"address":[],"length":0,"stats":{"Line":0}},{"line":1233,"address":[],"length":0,"stats":{"Line":0}},{"line":1234,"address":[],"length":0,"stats":{"Line":0}},{"line":1235,"address":[],"length":0,"stats":{"Line":0}},{"line":1236,"address":[],"length":0,"stats":{"Line":0}},{"line":1237,"address":[],"length":0,"stats":{"Line":0}},{"line":1238,"address":[],"length":0,"stats":{"Line":0}},{"line":1239,"address":[],"length":0,"stats":{"Line":0}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[],"length":0,"stats":{"Line":0}},{"line":1242,"address":[],"length":0,"stats":{"Line":0}},{"line":1243,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1247,"address":[],"length":0,"stats":{"Line":0}},{"line":1252,"address":[],"length":0,"stats":{"Line":0}},{"line":1253,"address":[],"length":0,"stats":{"Line":0}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1260,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[],"length":0,"stats":{"Line":0}},{"line":1265,"address":[],"length":0,"stats":{"Line":0}},{"line":1266,"address":[],"length":0,"stats":{"Line":0}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[],"length":0,"stats":{"Line":0}},{"line":1269,"address":[],"length":0,"stats":{"Line":0}},{"line":1270,"address":[],"length":0,"stats":{"Line":0}},{"line":1271,"address":[],"length":0,"stats":{"Line":0}},{"line":1275,"address":[],"length":0,"stats":{"Line":0}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1287,"address":[],"length":0,"stats":{"Line":0}},{"line":1289,"address":[],"length":0,"stats":{"Line":0}},{"line":1294,"address":[],"length":0,"stats":{"Line":0}},{"line":1296,"address":[],"length":0,"stats":{"Line":0}},{"line":1299,"address":[],"length":0,"stats":{"Line":0}},{"line":1300,"address":[],"length":0,"stats":{"Line":0}},{"line":1301,"address":[],"length":0,"stats":{"Line":0}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1303,"address":[],"length":0,"stats":{"Line":0}},{"line":1304,"address":[],"length":0,"stats":{"Line":0}},{"line":1305,"address":[],"length":0,"stats":{"Line":0}},{"line":1306,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1312,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1323,"address":[],"length":0,"stats":{"Line":0}},{"line":1324,"address":[],"length":0,"stats":{"Line":0}},{"line":1325,"address":[],"length":0,"stats":{"Line":0}},{"line":1327,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1329,"address":[],"length":0,"stats":{"Line":0}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1333,"address":[],"length":0,"stats":{"Line":0}},{"line":1334,"address":[],"length":0,"stats":{"Line":0}},{"line":1337,"address":[],"length":0,"stats":{"Line":0}},{"line":1338,"address":[],"length":0,"stats":{"Line":0}},{"line":1340,"address":[],"length":0,"stats":{"Line":0}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1348,"address":[],"length":0,"stats":{"Line":0}},{"line":1350,"address":[],"length":0,"stats":{"Line":0}},{"line":1351,"address":[],"length":0,"stats":{"Line":0}},{"line":1352,"address":[],"length":0,"stats":{"Line":0}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1356,"address":[],"length":0,"stats":{"Line":0}},{"line":1357,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1361,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":0}},{"line":1369,"address":[],"length":0,"stats":{"Line":0}},{"line":1374,"address":[],"length":0,"stats":{"Line":0}},{"line":1376,"address":[],"length":0,"stats":{"Line":0}},{"line":1377,"address":[],"length":0,"stats":{"Line":0}},{"line":1378,"address":[],"length":0,"stats":{"Line":0}},{"line":1380,"address":[],"length":0,"stats":{"Line":0}},{"line":1381,"address":[],"length":0,"stats":{"Line":0}},{"line":1382,"address":[],"length":0,"stats":{"Line":0}},{"line":1383,"address":[],"length":0,"stats":{"Line":0}},{"line":1385,"address":[],"length":0,"stats":{"Line":0}},{"line":1386,"address":[],"length":0,"stats":{"Line":0}},{"line":1387,"address":[],"length":0,"stats":{"Line":0}},{"line":1388,"address":[],"length":0,"stats":{"Line":0}},{"line":1390,"address":[],"length":0,"stats":{"Line":0}},{"line":1391,"address":[],"length":0,"stats":{"Line":0}},{"line":1392,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[],"length":0,"stats":{"Line":0}},{"line":1395,"address":[],"length":0,"stats":{"Line":0}},{"line":1396,"address":[],"length":0,"stats":{"Line":0}},{"line":1397,"address":[],"length":0,"stats":{"Line":0}},{"line":1398,"address":[],"length":0,"stats":{"Line":0}},{"line":1401,"address":[],"length":0,"stats":{"Line":0}},{"line":1402,"address":[],"length":0,"stats":{"Line":0}},{"line":1405,"address":[],"length":0,"stats":{"Line":0}},{"line":1406,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":0}},{"line":1412,"address":[],"length":0,"stats":{"Line":0}},{"line":1416,"address":[],"length":0,"stats":{"Line":0}},{"line":1418,"address":[],"length":0,"stats":{"Line":0}},{"line":1419,"address":[],"length":0,"stats":{"Line":0}},{"line":1420,"address":[],"length":0,"stats":{"Line":0}},{"line":1421,"address":[],"length":0,"stats":{"Line":0}},{"line":1422,"address":[],"length":0,"stats":{"Line":0}},{"line":1423,"address":[],"length":0,"stats":{"Line":0}},{"line":1424,"address":[],"length":0,"stats":{"Line":0}},{"line":1425,"address":[],"length":0,"stats":{"Line":0}},{"line":1426,"address":[],"length":0,"stats":{"Line":0}},{"line":1427,"address":[],"length":0,"stats":{"Line":0}},{"line":1428,"address":[],"length":0,"stats":{"Line":0}},{"line":1429,"address":[],"length":0,"stats":{"Line":0}},{"line":1432,"address":[],"length":0,"stats":{"Line":0}},{"line":1437,"address":[],"length":0,"stats":{"Line":0}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1444,"address":[],"length":0,"stats":{"Line":0}},{"line":1447,"address":[],"length":0,"stats":{"Line":0}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1451,"address":[],"length":0,"stats":{"Line":0}},{"line":1455,"address":[],"length":0,"stats":{"Line":0}},{"line":1456,"address":[],"length":0,"stats":{"Line":0}},{"line":1458,"address":[],"length":0,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1460,"address":[],"length":0,"stats":{"Line":0}},{"line":1462,"address":[],"length":0,"stats":{"Line":0}},{"line":1463,"address":[],"length":0,"stats":{"Line":0}},{"line":1464,"address":[],"length":0,"stats":{"Line":0}},{"line":1466,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":0}},{"line":1471,"address":[],"length":0,"stats":{"Line":0}},{"line":1472,"address":[],"length":0,"stats":{"Line":0}},{"line":1473,"address":[],"length":0,"stats":{"Line":0}},{"line":1474,"address":[],"length":0,"stats":{"Line":0}},{"line":1475,"address":[],"length":0,"stats":{"Line":0}},{"line":1481,"address":[],"length":0,"stats":{"Line":0}},{"line":1485,"address":[],"length":0,"stats":{"Line":0}},{"line":1487,"address":[],"length":0,"stats":{"Line":0}},{"line":1492,"address":[],"length":0,"stats":{"Line":0}},{"line":1494,"address":[],"length":0,"stats":{"Line":0}},{"line":1496,"address":[],"length":0,"stats":{"Line":0}},{"line":1497,"address":[],"length":0,"stats":{"Line":0}},{"line":1498,"address":[],"length":0,"stats":{"Line":0}},{"line":1499,"address":[],"length":0,"stats":{"Line":0}},{"line":1500,"address":[],"length":0,"stats":{"Line":0}},{"line":1501,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[],"length":0,"stats":{"Line":0}},{"line":1504,"address":[],"length":0,"stats":{"Line":0}},{"line":1505,"address":[],"length":0,"stats":{"Line":0}},{"line":1506,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1508,"address":[],"length":0,"stats":{"Line":0}},{"line":1511,"address":[],"length":0,"stats":{"Line":0}},{"line":1516,"address":[],"length":0,"stats":{"Line":0}},{"line":1520,"address":[],"length":0,"stats":{"Line":0}},{"line":1522,"address":[],"length":0,"stats":{"Line":0}},{"line":1527,"address":[],"length":0,"stats":{"Line":0}},{"line":1529,"address":[],"length":0,"stats":{"Line":0}},{"line":1531,"address":[],"length":0,"stats":{"Line":0}},{"line":1532,"address":[],"length":0,"stats":{"Line":0}},{"line":1533,"address":[],"length":0,"stats":{"Line":0}},{"line":1534,"address":[],"length":0,"stats":{"Line":0}},{"line":1535,"address":[],"length":0,"stats":{"Line":0}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1537,"address":[],"length":0,"stats":{"Line":0}},{"line":1538,"address":[],"length":0,"stats":{"Line":0}},{"line":1539,"address":[],"length":0,"stats":{"Line":0}},{"line":1540,"address":[],"length":0,"stats":{"Line":0}},{"line":1541,"address":[],"length":0,"stats":{"Line":0}},{"line":1542,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":0}},{"line":1552,"address":[],"length":0,"stats":{"Line":0}},{"line":1554,"address":[],"length":0,"stats":{"Line":0}},{"line":1555,"address":[],"length":0,"stats":{"Line":0}},{"line":1556,"address":[],"length":0,"stats":{"Line":0}},{"line":1558,"address":[],"length":0,"stats":{"Line":0}},{"line":1559,"address":[],"length":0,"stats":{"Line":0}},{"line":1560,"address":[],"length":0,"stats":{"Line":0}},{"line":1561,"address":[],"length":0,"stats":{"Line":0}},{"line":1563,"address":[],"length":0,"stats":{"Line":0}},{"line":1564,"address":[],"length":0,"stats":{"Line":0}},{"line":1565,"address":[],"length":0,"stats":{"Line":0}},{"line":1566,"address":[],"length":0,"stats":{"Line":0}},{"line":1568,"address":[],"length":0,"stats":{"Line":0}},{"line":1569,"address":[],"length":0,"stats":{"Line":0}},{"line":1570,"address":[],"length":0,"stats":{"Line":0}},{"line":1571,"address":[],"length":0,"stats":{"Line":0}},{"line":1573,"address":[],"length":0,"stats":{"Line":0}},{"line":1574,"address":[],"length":0,"stats":{"Line":0}},{"line":1575,"address":[],"length":0,"stats":{"Line":0}},{"line":1576,"address":[],"length":0,"stats":{"Line":0}},{"line":1578,"address":[],"length":0,"stats":{"Line":0}},{"line":1579,"address":[],"length":0,"stats":{"Line":0}},{"line":1580,"address":[],"length":0,"stats":{"Line":0}},{"line":1581,"address":[],"length":0,"stats":{"Line":0}},{"line":1583,"address":[],"length":0,"stats":{"Line":0}},{"line":1584,"address":[],"length":0,"stats":{"Line":0}},{"line":1585,"address":[],"length":0,"stats":{"Line":0}},{"line":1586,"address":[],"length":0,"stats":{"Line":0}},{"line":1588,"address":[],"length":0,"stats":{"Line":0}},{"line":1589,"address":[],"length":0,"stats":{"Line":0}},{"line":1590,"address":[],"length":0,"stats":{"Line":0}},{"line":1591,"address":[],"length":0,"stats":{"Line":0}},{"line":1594,"address":[],"length":0,"stats":{"Line":0}},{"line":1595,"address":[],"length":0,"stats":{"Line":0}},{"line":1598,"address":[],"length":0,"stats":{"Line":0}},{"line":1599,"address":[],"length":0,"stats":{"Line":0}},{"line":1601,"address":[],"length":0,"stats":{"Line":0}},{"line":1605,"address":[],"length":0,"stats":{"Line":0}},{"line":1609,"address":[],"length":0,"stats":{"Line":0}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1612,"address":[],"length":0,"stats":{"Line":0}},{"line":1613,"address":[],"length":0,"stats":{"Line":0}},{"line":1614,"address":[],"length":0,"stats":{"Line":0}},{"line":1615,"address":[],"length":0,"stats":{"Line":0}},{"line":1616,"address":[],"length":0,"stats":{"Line":0}},{"line":1617,"address":[],"length":0,"stats":{"Line":0}},{"line":1618,"address":[],"length":0,"stats":{"Line":0}},{"line":1619,"address":[],"length":0,"stats":{"Line":0}},{"line":1620,"address":[],"length":0,"stats":{"Line":0}},{"line":1621,"address":[],"length":0,"stats":{"Line":0}},{"line":1622,"address":[],"length":0,"stats":{"Line":0}},{"line":1623,"address":[],"length":0,"stats":{"Line":0}},{"line":1626,"address":[],"length":0,"stats":{"Line":0}},{"line":1631,"address":[],"length":0,"stats":{"Line":0}},{"line":1635,"address":[],"length":0,"stats":{"Line":0}},{"line":1636,"address":[],"length":0,"stats":{"Line":0}},{"line":1638,"address":[],"length":0,"stats":{"Line":0}},{"line":1645,"address":[],"length":0,"stats":{"Line":0}},{"line":1652,"address":[],"length":0,"stats":{"Line":0}},{"line":1654,"address":[],"length":0,"stats":{"Line":0}},{"line":1655,"address":[],"length":0,"stats":{"Line":0}},{"line":1660,"address":[],"length":0,"stats":{"Line":0}},{"line":1662,"address":[],"length":0,"stats":{"Line":0}},{"line":1664,"address":[],"length":0,"stats":{"Line":0}},{"line":1665,"address":[],"length":0,"stats":{"Line":0}},{"line":1666,"address":[],"length":0,"stats":{"Line":0}},{"line":1667,"address":[],"length":0,"stats":{"Line":0}},{"line":1668,"address":[],"length":0,"stats":{"Line":0}},{"line":1669,"address":[],"length":0,"stats":{"Line":0}},{"line":1670,"address":[],"length":0,"stats":{"Line":0}},{"line":1671,"address":[],"length":0,"stats":{"Line":0}},{"line":1672,"address":[],"length":0,"stats":{"Line":0}},{"line":1677,"address":[],"length":0,"stats":{"Line":0}},{"line":1681,"address":[],"length":0,"stats":{"Line":0}},{"line":1683,"address":[],"length":0,"stats":{"Line":0}},{"line":1694,"address":[],"length":0,"stats":{"Line":0}},{"line":1696,"address":[],"length":0,"stats":{"Line":0}},{"line":1698,"address":[],"length":0,"stats":{"Line":0}},{"line":1700,"address":[],"length":0,"stats":{"Line":0}},{"line":1701,"address":[],"length":0,"stats":{"Line":0}},{"line":1702,"address":[],"length":0,"stats":{"Line":0}},{"line":1703,"address":[],"length":0,"stats":{"Line":0}},{"line":1704,"address":[],"length":0,"stats":{"Line":0}},{"line":1705,"address":[],"length":0,"stats":{"Line":0}},{"line":1706,"address":[],"length":0,"stats":{"Line":0}},{"line":1707,"address":[],"length":0,"stats":{"Line":0}},{"line":1708,"address":[],"length":0,"stats":{"Line":0}},{"line":1709,"address":[],"length":0,"stats":{"Line":0}},{"line":1710,"address":[],"length":0,"stats":{"Line":0}},{"line":1711,"address":[],"length":0,"stats":{"Line":0}},{"line":1712,"address":[],"length":0,"stats":{"Line":0}},{"line":1713,"address":[],"length":0,"stats":{"Line":0}},{"line":1714,"address":[],"length":0,"stats":{"Line":0}},{"line":1715,"address":[],"length":0,"stats":{"Line":0}},{"line":1717,"address":[],"length":0,"stats":{"Line":0}},{"line":1718,"address":[],"length":0,"stats":{"Line":0}},{"line":1719,"address":[],"length":0,"stats":{"Line":0}},{"line":1720,"address":[],"length":0,"stats":{"Line":0}},{"line":1721,"address":[],"length":0,"stats":{"Line":0}},{"line":1722,"address":[],"length":0,"stats":{"Line":0}},{"line":1723,"address":[],"length":0,"stats":{"Line":0}},{"line":1724,"address":[],"length":0,"stats":{"Line":0}},{"line":1730,"address":[],"length":0,"stats":{"Line":0}},{"line":1734,"address":[],"length":0,"stats":{"Line":0}},{"line":1739,"address":[],"length":0,"stats":{"Line":0}},{"line":1742,"address":[],"length":0,"stats":{"Line":0}},{"line":1745,"address":[],"length":0,"stats":{"Line":0}},{"line":1747,"address":[],"length":0,"stats":{"Line":0}},{"line":1749,"address":[],"length":0,"stats":{"Line":0}},{"line":1750,"address":[],"length":0,"stats":{"Line":0}},{"line":1751,"address":[],"length":0,"stats":{"Line":0}},{"line":1752,"address":[],"length":0,"stats":{"Line":0}},{"line":1753,"address":[],"length":0,"stats":{"Line":0}},{"line":1754,"address":[],"length":0,"stats":{"Line":0}},{"line":1755,"address":[],"length":0,"stats":{"Line":0}},{"line":1756,"address":[],"length":0,"stats":{"Line":0}},{"line":1757,"address":[],"length":0,"stats":{"Line":0}},{"line":1758,"address":[],"length":0,"stats":{"Line":0}},{"line":1759,"address":[],"length":0,"stats":{"Line":0}},{"line":1760,"address":[],"length":0,"stats":{"Line":0}},{"line":1761,"address":[],"length":0,"stats":{"Line":0}},{"line":1762,"address":[],"length":0,"stats":{"Line":0}},{"line":1763,"address":[],"length":0,"stats":{"Line":0}},{"line":1768,"address":[],"length":0,"stats":{"Line":0}},{"line":1769,"address":[],"length":0,"stats":{"Line":0}},{"line":1773,"address":[],"length":0,"stats":{"Line":0}},{"line":1775,"address":[],"length":0,"stats":{"Line":0}},{"line":1777,"address":[],"length":0,"stats":{"Line":0}},{"line":1778,"address":[],"length":0,"stats":{"Line":0}},{"line":1779,"address":[],"length":0,"stats":{"Line":0}},{"line":1780,"address":[],"length":0,"stats":{"Line":0}},{"line":1781,"address":[],"length":0,"stats":{"Line":0}},{"line":1782,"address":[],"length":0,"stats":{"Line":0}},{"line":1783,"address":[],"length":0,"stats":{"Line":0}},{"line":1784,"address":[],"length":0,"stats":{"Line":0}},{"line":1785,"address":[],"length":0,"stats":{"Line":0}},{"line":1786,"address":[],"length":0,"stats":{"Line":0}},{"line":1787,"address":[],"length":0,"stats":{"Line":0}},{"line":1788,"address":[],"length":0,"stats":{"Line":0}},{"line":1789,"address":[],"length":0,"stats":{"Line":0}},{"line":1796,"address":[],"length":0,"stats":{"Line":0}},{"line":1800,"address":[],"length":0,"stats":{"Line":0}},{"line":1802,"address":[],"length":0,"stats":{"Line":0}},{"line":1804,"address":[],"length":0,"stats":{"Line":0}},{"line":1805,"address":[],"length":0,"stats":{"Line":0}},{"line":1806,"address":[],"length":0,"stats":{"Line":0}},{"line":1808,"address":[],"length":0,"stats":{"Line":0}},{"line":1809,"address":[],"length":0,"stats":{"Line":0}},{"line":1810,"address":[],"length":0,"stats":{"Line":0}},{"line":1811,"address":[],"length":0,"stats":{"Line":0}},{"line":1812,"address":[],"length":0,"stats":{"Line":0}},{"line":1813,"address":[],"length":0,"stats":{"Line":0}},{"line":1814,"address":[],"length":0,"stats":{"Line":0}},{"line":1815,"address":[],"length":0,"stats":{"Line":0}},{"line":1816,"address":[],"length":0,"stats":{"Line":0}},{"line":1817,"address":[],"length":0,"stats":{"Line":0}},{"line":1818,"address":[],"length":0,"stats":{"Line":0}},{"line":1819,"address":[],"length":0,"stats":{"Line":0}},{"line":1824,"address":[],"length":0,"stats":{"Line":0}},{"line":1825,"address":[],"length":0,"stats":{"Line":0}},{"line":1826,"address":[],"length":0,"stats":{"Line":0}},{"line":1827,"address":[],"length":0,"stats":{"Line":0}},{"line":1828,"address":[],"length":0,"stats":{"Line":0}},{"line":1829,"address":[],"length":0,"stats":{"Line":0}},{"line":1830,"address":[],"length":0,"stats":{"Line":0}},{"line":1831,"address":[],"length":0,"stats":{"Line":0}},{"line":1832,"address":[],"length":0,"stats":{"Line":0}},{"line":1833,"address":[],"length":0,"stats":{"Line":0}},{"line":1834,"address":[],"length":0,"stats":{"Line":0}},{"line":1835,"address":[],"length":0,"stats":{"Line":0}},{"line":1840,"address":[],"length":0,"stats":{"Line":0}},{"line":1845,"address":[],"length":0,"stats":{"Line":0}},{"line":1847,"address":[],"length":0,"stats":{"Line":0}},{"line":1848,"address":[],"length":0,"stats":{"Line":0}},{"line":1853,"address":[],"length":0,"stats":{"Line":0}},{"line":1855,"address":[],"length":0,"stats":{"Line":0}},{"line":1857,"address":[],"length":0,"stats":{"Line":0}},{"line":1858,"address":[],"length":0,"stats":{"Line":0}},{"line":1859,"address":[],"length":0,"stats":{"Line":0}},{"line":1860,"address":[],"length":0,"stats":{"Line":0}},{"line":1861,"address":[],"length":0,"stats":{"Line":0}},{"line":1862,"address":[],"length":0,"stats":{"Line":0}},{"line":1863,"address":[],"length":0,"stats":{"Line":0}},{"line":1864,"address":[],"length":0,"stats":{"Line":0}},{"line":1865,"address":[],"length":0,"stats":{"Line":0}},{"line":1866,"address":[],"length":0,"stats":{"Line":0}},{"line":1869,"address":[],"length":0,"stats":{"Line":0}},{"line":1874,"address":[],"length":0,"stats":{"Line":0}},{"line":1878,"address":[],"length":0,"stats":{"Line":0}},{"line":1880,"address":[],"length":0,"stats":{"Line":0}},{"line":1881,"address":[],"length":0,"stats":{"Line":0}},{"line":1882,"address":[],"length":0,"stats":{"Line":0}},{"line":1884,"address":[],"length":0,"stats":{"Line":0}},{"line":1888,"address":[],"length":0,"stats":{"Line":0}},{"line":1892,"address":[],"length":0,"stats":{"Line":0}},{"line":1898,"address":[],"length":0,"stats":{"Line":0}},{"line":1908,"address":[],"length":0,"stats":{"Line":0}},{"line":1910,"address":[],"length":0,"stats":{"Line":0}},{"line":1912,"address":[],"length":0,"stats":{"Line":0}},{"line":1914,"address":[],"length":0,"stats":{"Line":0}},{"line":1915,"address":[],"length":0,"stats":{"Line":0}},{"line":1916,"address":[],"length":0,"stats":{"Line":0}},{"line":1917,"address":[],"length":0,"stats":{"Line":0}},{"line":1918,"address":[],"length":0,"stats":{"Line":0}},{"line":1919,"address":[],"length":0,"stats":{"Line":0}},{"line":1920,"address":[],"length":0,"stats":{"Line":0}},{"line":1921,"address":[],"length":0,"stats":{"Line":0}},{"line":1922,"address":[],"length":0,"stats":{"Line":0}},{"line":1926,"address":[],"length":0,"stats":{"Line":0}},{"line":1932,"address":[],"length":0,"stats":{"Line":0}},{"line":1937,"address":[],"length":0,"stats":{"Line":0}},{"line":1939,"address":[],"length":0,"stats":{"Line":0}},{"line":1944,"address":[],"length":0,"stats":{"Line":0}},{"line":1946,"address":[],"length":0,"stats":{"Line":0}},{"line":1948,"address":[],"length":0,"stats":{"Line":0}},{"line":1949,"address":[],"length":0,"stats":{"Line":0}},{"line":1950,"address":[],"length":0,"stats":{"Line":0}},{"line":1951,"address":[],"length":0,"stats":{"Line":0}},{"line":1952,"address":[],"length":0,"stats":{"Line":0}},{"line":1953,"address":[],"length":0,"stats":{"Line":0}},{"line":1958,"address":[],"length":0,"stats":{"Line":0}},{"line":1962,"address":[],"length":0,"stats":{"Line":0}},{"line":1964,"address":[],"length":0,"stats":{"Line":0}},{"line":1975,"address":[],"length":0,"stats":{"Line":0}},{"line":1977,"address":[],"length":0,"stats":{"Line":0}},{"line":1979,"address":[],"length":0,"stats":{"Line":0}},{"line":1981,"address":[],"length":0,"stats":{"Line":0}},{"line":1982,"address":[],"length":0,"stats":{"Line":0}},{"line":1983,"address":[],"length":0,"stats":{"Line":0}},{"line":1984,"address":[],"length":0,"stats":{"Line":0}},{"line":1985,"address":[],"length":0,"stats":{"Line":0}},{"line":1986,"address":[],"length":0,"stats":{"Line":0}},{"line":1987,"address":[],"length":0,"stats":{"Line":0}},{"line":1988,"address":[],"length":0,"stats":{"Line":0}},{"line":1989,"address":[],"length":0,"stats":{"Line":0}},{"line":1990,"address":[],"length":0,"stats":{"Line":0}},{"line":1991,"address":[],"length":0,"stats":{"Line":0}},{"line":1992,"address":[],"length":0,"stats":{"Line":0}},{"line":1994,"address":[],"length":0,"stats":{"Line":0}},{"line":1995,"address":[],"length":0,"stats":{"Line":0}},{"line":1996,"address":[],"length":0,"stats":{"Line":0}},{"line":1997,"address":[],"length":0,"stats":{"Line":0}},{"line":1998,"address":[],"length":0,"stats":{"Line":0}},{"line":1999,"address":[],"length":0,"stats":{"Line":0}},{"line":2000,"address":[],"length":0,"stats":{"Line":0}},{"line":2001,"address":[],"length":0,"stats":{"Line":0}},{"line":2006,"address":[],"length":0,"stats":{"Line":0}},{"line":2010,"address":[],"length":0,"stats":{"Line":0}},{"line":2014,"address":[],"length":0,"stats":{"Line":0}},{"line":2016,"address":[],"length":0,"stats":{"Line":0}},{"line":2027,"address":[],"length":0,"stats":{"Line":0}},{"line":2029,"address":[],"length":0,"stats":{"Line":0}},{"line":2031,"address":[],"length":0,"stats":{"Line":0}},{"line":2033,"address":[],"length":0,"stats":{"Line":0}},{"line":2034,"address":[],"length":0,"stats":{"Line":0}},{"line":2035,"address":[],"length":0,"stats":{"Line":0}},{"line":2036,"address":[],"length":0,"stats":{"Line":0}},{"line":2037,"address":[],"length":0,"stats":{"Line":0}},{"line":2038,"address":[],"length":0,"stats":{"Line":0}},{"line":2039,"address":[],"length":0,"stats":{"Line":0}},{"line":2040,"address":[],"length":0,"stats":{"Line":0}},{"line":2041,"address":[],"length":0,"stats":{"Line":0}},{"line":2042,"address":[],"length":0,"stats":{"Line":0}},{"line":2043,"address":[],"length":0,"stats":{"Line":0}},{"line":2044,"address":[],"length":0,"stats":{"Line":0}},{"line":2046,"address":[],"length":0,"stats":{"Line":0}},{"line":2047,"address":[],"length":0,"stats":{"Line":0}},{"line":2048,"address":[],"length":0,"stats":{"Line":0}},{"line":2049,"address":[],"length":0,"stats":{"Line":0}},{"line":2050,"address":[],"length":0,"stats":{"Line":0}},{"line":2051,"address":[],"length":0,"stats":{"Line":0}},{"line":2052,"address":[],"length":0,"stats":{"Line":0}},{"line":2053,"address":[],"length":0,"stats":{"Line":0}},{"line":2058,"address":[],"length":0,"stats":{"Line":0}},{"line":2062,"address":[],"length":0,"stats":{"Line":0}},{"line":2066,"address":[],"length":0,"stats":{"Line":0}},{"line":2068,"address":[],"length":0,"stats":{"Line":0}},{"line":2069,"address":[],"length":0,"stats":{"Line":0}},{"line":2070,"address":[],"length":0,"stats":{"Line":0}},{"line":2072,"address":[],"length":0,"stats":{"Line":0}},{"line":2076,"address":[],"length":0,"stats":{"Line":0}},{"line":2080,"address":[],"length":0,"stats":{"Line":0}},{"line":2082,"address":[],"length":0,"stats":{"Line":0}},{"line":2086,"address":[],"length":0,"stats":{"Line":0}},{"line":2088,"address":[],"length":0,"stats":{"Line":0}},{"line":2090,"address":[],"length":0,"stats":{"Line":0}},{"line":2091,"address":[],"length":0,"stats":{"Line":0}},{"line":2092,"address":[],"length":0,"stats":{"Line":0}},{"line":2093,"address":[],"length":0,"stats":{"Line":0}},{"line":2094,"address":[],"length":0,"stats":{"Line":0}},{"line":2095,"address":[],"length":0,"stats":{"Line":0}},{"line":2096,"address":[],"length":0,"stats":{"Line":0}},{"line":2099,"address":[],"length":0,"stats":{"Line":0}},{"line":2110,"address":[],"length":0,"stats":{"Line":0}},{"line":2116,"address":[],"length":0,"stats":{"Line":0}},{"line":2119,"address":[],"length":0,"stats":{"Line":0}},{"line":2122,"address":[],"length":0,"stats":{"Line":0}},{"line":2125,"address":[],"length":0,"stats":{"Line":0}},{"line":2127,"address":[],"length":0,"stats":{"Line":0}},{"line":2129,"address":[],"length":0,"stats":{"Line":0}},{"line":2130,"address":[],"length":0,"stats":{"Line":0}},{"line":2134,"address":[],"length":0,"stats":{"Line":0}},{"line":2137,"address":[],"length":0,"stats":{"Line":0}},{"line":2139,"address":[],"length":0,"stats":{"Line":0}},{"line":2141,"address":[],"length":0,"stats":{"Line":0}},{"line":2142,"address":[],"length":0,"stats":{"Line":0}},{"line":2146,"address":[],"length":0,"stats":{"Line":0}},{"line":2149,"address":[],"length":0,"stats":{"Line":0}},{"line":2151,"address":[],"length":0,"stats":{"Line":0}},{"line":2155,"address":[],"length":0,"stats":{"Line":0}},{"line":2158,"address":[],"length":0,"stats":{"Line":0}},{"line":2160,"address":[],"length":0,"stats":{"Line":0}},{"line":2163,"address":[],"length":0,"stats":{"Line":0}},{"line":2166,"address":[],"length":0,"stats":{"Line":0}},{"line":2168,"address":[],"length":0,"stats":{"Line":0}},{"line":2171,"address":[],"length":0,"stats":{"Line":0}},{"line":2173,"address":[],"length":0,"stats":{"Line":0}},{"line":2174,"address":[],"length":0,"stats":{"Line":0}},{"line":2183,"address":[],"length":0,"stats":{"Line":0}},{"line":2184,"address":[],"length":0,"stats":{"Line":0}},{"line":2190,"address":[],"length":0,"stats":{"Line":0}},{"line":2195,"address":[],"length":0,"stats":{"Line":0}},{"line":2198,"address":[],"length":0,"stats":{"Line":0}},{"line":2199,"address":[],"length":0,"stats":{"Line":0}},{"line":2200,"address":[],"length":0,"stats":{"Line":0}},{"line":2203,"address":[],"length":0,"stats":{"Line":0}},{"line":2204,"address":[],"length":0,"stats":{"Line":0}},{"line":2207,"address":[],"length":0,"stats":{"Line":0}},{"line":2209,"address":[],"length":0,"stats":{"Line":0}},{"line":2213,"address":[],"length":0,"stats":{"Line":0}},{"line":2216,"address":[],"length":0,"stats":{"Line":0}},{"line":2218,"address":[],"length":0,"stats":{"Line":0}},{"line":2220,"address":[],"length":0,"stats":{"Line":0}},{"line":2221,"address":[],"length":0,"stats":{"Line":0}},{"line":2225,"address":[],"length":0,"stats":{"Line":0}},{"line":2229,"address":[],"length":0,"stats":{"Line":0}},{"line":2231,"address":[],"length":0,"stats":{"Line":0}},{"line":2234,"address":[],"length":0,"stats":{"Line":0}},{"line":2236,"address":[],"length":0,"stats":{"Line":0}},{"line":2238,"address":[],"length":0,"stats":{"Line":0}},{"line":2239,"address":[],"length":0,"stats":{"Line":0}},{"line":2243,"address":[],"length":0,"stats":{"Line":0}},{"line":2247,"address":[],"length":0,"stats":{"Line":0}},{"line":2249,"address":[],"length":0,"stats":{"Line":0}},{"line":2252,"address":[],"length":0,"stats":{"Line":0}},{"line":2254,"address":[],"length":0,"stats":{"Line":0}},{"line":2256,"address":[],"length":0,"stats":{"Line":0}},{"line":2258,"address":[],"length":0,"stats":{"Line":0}},{"line":2262,"address":[],"length":0,"stats":{"Line":0}},{"line":2266,"address":[],"length":0,"stats":{"Line":0}},{"line":2268,"address":[],"length":0,"stats":{"Line":0}},{"line":2271,"address":[],"length":0,"stats":{"Line":0}},{"line":2273,"address":[],"length":0,"stats":{"Line":0}},{"line":2275,"address":[],"length":0,"stats":{"Line":0}},{"line":2276,"address":[],"length":0,"stats":{"Line":0}},{"line":2280,"address":[],"length":0,"stats":{"Line":0}},{"line":2284,"address":[],"length":0,"stats":{"Line":0}},{"line":2286,"address":[],"length":0,"stats":{"Line":0}},{"line":2289,"address":[],"length":0,"stats":{"Line":0}},{"line":2291,"address":[],"length":0,"stats":{"Line":0}},{"line":2293,"address":[],"length":0,"stats":{"Line":0}},{"line":2297,"address":[],"length":0,"stats":{"Line":0}},{"line":2301,"address":[],"length":0,"stats":{"Line":0}},{"line":2304,"address":[],"length":0,"stats":{"Line":0}},{"line":2307,"address":[],"length":0,"stats":{"Line":0}},{"line":2309,"address":[],"length":0,"stats":{"Line":0}},{"line":2311,"address":[],"length":0,"stats":{"Line":0}},{"line":2312,"address":[],"length":0,"stats":{"Line":0}},{"line":2315,"address":[],"length":0,"stats":{"Line":0}},{"line":2318,"address":[],"length":0,"stats":{"Line":0}},{"line":2320,"address":[],"length":0,"stats":{"Line":0}},{"line":2322,"address":[],"length":0,"stats":{"Line":0}},{"line":2323,"address":[],"length":0,"stats":{"Line":0}},{"line":2325,"address":[],"length":0,"stats":{"Line":0}},{"line":2331,"address":[],"length":0,"stats":{"Line":0}},{"line":2336,"address":[],"length":0,"stats":{"Line":0}},{"line":2338,"address":[],"length":0,"stats":{"Line":0}},{"line":2346,"address":[],"length":0,"stats":{"Line":0}},{"line":2348,"address":[],"length":0,"stats":{"Line":0}},{"line":2350,"address":[],"length":0,"stats":{"Line":0}},{"line":2351,"address":[],"length":0,"stats":{"Line":0}},{"line":2366,"address":[],"length":0,"stats":{"Line":0}},{"line":2371,"address":[],"length":0,"stats":{"Line":0}},{"line":2374,"address":[],"length":0,"stats":{"Line":0}},{"line":2380,"address":[],"length":0,"stats":{"Line":0}},{"line":2382,"address":[],"length":0,"stats":{"Line":0}},{"line":2385,"address":[],"length":0,"stats":{"Line":0}},{"line":2388,"address":[],"length":0,"stats":{"Line":0}},{"line":2389,"address":[],"length":0,"stats":{"Line":0}},{"line":2390,"address":[],"length":0,"stats":{"Line":0}},{"line":2391,"address":[],"length":0,"stats":{"Line":0}},{"line":2394,"address":[],"length":0,"stats":{"Line":0}},{"line":2395,"address":[],"length":0,"stats":{"Line":0}},{"line":2396,"address":[],"length":0,"stats":{"Line":0}},{"line":2397,"address":[],"length":0,"stats":{"Line":0}},{"line":2400,"address":[],"length":0,"stats":{"Line":0}},{"line":2401,"address":[],"length":0,"stats":{"Line":0}},{"line":2402,"address":[],"length":0,"stats":{"Line":0}},{"line":2403,"address":[],"length":0,"stats":{"Line":0}},{"line":2404,"address":[],"length":0,"stats":{"Line":0}},{"line":2407,"address":[],"length":0,"stats":{"Line":0}},{"line":2408,"address":[],"length":0,"stats":{"Line":0}},{"line":2409,"address":[],"length":0,"stats":{"Line":0}},{"line":2410,"address":[],"length":0,"stats":{"Line":0}},{"line":2413,"address":[],"length":0,"stats":{"Line":0}},{"line":2414,"address":[],"length":0,"stats":{"Line":0}},{"line":2415,"address":[],"length":0,"stats":{"Line":0}},{"line":2416,"address":[],"length":0,"stats":{"Line":0}},{"line":2419,"address":[],"length":0,"stats":{"Line":0}},{"line":2420,"address":[],"length":0,"stats":{"Line":0}},{"line":2421,"address":[],"length":0,"stats":{"Line":0}},{"line":2422,"address":[],"length":0,"stats":{"Line":0}},{"line":2425,"address":[],"length":0,"stats":{"Line":0}},{"line":2426,"address":[],"length":0,"stats":{"Line":0}},{"line":2427,"address":[],"length":0,"stats":{"Line":0}},{"line":2430,"address":[],"length":0,"stats":{"Line":0}},{"line":2435,"address":[],"length":0,"stats":{"Line":0}},{"line":2437,"address":[],"length":0,"stats":{"Line":0}},{"line":2444,"address":[],"length":0,"stats":{"Line":0}},{"line":2449,"address":[],"length":0,"stats":{"Line":0}},{"line":2450,"address":[],"length":0,"stats":{"Line":0}},{"line":2452,"address":[],"length":0,"stats":{"Line":0}},{"line":2454,"address":[],"length":0,"stats":{"Line":0}},{"line":2456,"address":[],"length":0,"stats":{"Line":0}},{"line":2457,"address":[],"length":0,"stats":{"Line":0}},{"line":2458,"address":[],"length":0,"stats":{"Line":0}},{"line":2459,"address":[],"length":0,"stats":{"Line":0}},{"line":2460,"address":[],"length":0,"stats":{"Line":0}},{"line":2461,"address":[],"length":0,"stats":{"Line":0}},{"line":2462,"address":[],"length":0,"stats":{"Line":0}},{"line":2463,"address":[],"length":0,"stats":{"Line":0}},{"line":2464,"address":[],"length":0,"stats":{"Line":0}},{"line":2465,"address":[],"length":0,"stats":{"Line":0}},{"line":2466,"address":[],"length":0,"stats":{"Line":0}},{"line":2467,"address":[],"length":0,"stats":{"Line":0}},{"line":2468,"address":[],"length":0,"stats":{"Line":0}},{"line":2469,"address":[],"length":0,"stats":{"Line":0}},{"line":2473,"address":[],"length":0,"stats":{"Line":0}},{"line":2474,"address":[],"length":0,"stats":{"Line":0}},{"line":2475,"address":[],"length":0,"stats":{"Line":0}},{"line":2478,"address":[],"length":0,"stats":{"Line":0}},{"line":2494,"address":[],"length":0,"stats":{"Line":0}},{"line":2499,"address":[],"length":0,"stats":{"Line":0}},{"line":2501,"address":[],"length":0,"stats":{"Line":0}},{"line":2502,"address":[],"length":0,"stats":{"Line":0}},{"line":2504,"address":[],"length":0,"stats":{"Line":0}},{"line":2505,"address":[],"length":0,"stats":{"Line":0}},{"line":2506,"address":[],"length":0,"stats":{"Line":0}},{"line":2507,"address":[],"length":0,"stats":{"Line":0}},{"line":2508,"address":[],"length":0,"stats":{"Line":0}},{"line":2509,"address":[],"length":0,"stats":{"Line":0}},{"line":2510,"address":[],"length":0,"stats":{"Line":0}},{"line":2511,"address":[],"length":0,"stats":{"Line":0}},{"line":2512,"address":[],"length":0,"stats":{"Line":0}},{"line":2513,"address":[],"length":0,"stats":{"Line":0}},{"line":2514,"address":[],"length":0,"stats":{"Line":0}},{"line":2515,"address":[],"length":0,"stats":{"Line":0}},{"line":2519,"address":[],"length":0,"stats":{"Line":0}},{"line":2520,"address":[],"length":0,"stats":{"Line":0}},{"line":2521,"address":[],"length":0,"stats":{"Line":0}},{"line":2522,"address":[],"length":0,"stats":{"Line":0}},{"line":2523,"address":[],"length":0,"stats":{"Line":0}},{"line":2524,"address":[],"length":0,"stats":{"Line":0}},{"line":2525,"address":[],"length":0,"stats":{"Line":0}},{"line":2526,"address":[],"length":0,"stats":{"Line":0}},{"line":2527,"address":[],"length":0,"stats":{"Line":0}},{"line":2528,"address":[],"length":0,"stats":{"Line":0}},{"line":2529,"address":[],"length":0,"stats":{"Line":0}},{"line":2530,"address":[],"length":0,"stats":{"Line":0}},{"line":2531,"address":[],"length":0,"stats":{"Line":0}},{"line":2532,"address":[],"length":0,"stats":{"Line":0}},{"line":2533,"address":[],"length":0,"stats":{"Line":0}},{"line":2534,"address":[],"length":0,"stats":{"Line":0}},{"line":2535,"address":[],"length":0,"stats":{"Line":0}},{"line":2539,"address":[],"length":0,"stats":{"Line":0}},{"line":2540,"address":[],"length":0,"stats":{"Line":0}},{"line":2542,"address":[],"length":0,"stats":{"Line":0}},{"line":2545,"address":[],"length":0,"stats":{"Line":0}},{"line":2546,"address":[],"length":0,"stats":{"Line":0}},{"line":2547,"address":[],"length":0,"stats":{"Line":0}},{"line":2548,"address":[],"length":0,"stats":{"Line":0}},{"line":2549,"address":[],"length":0,"stats":{"Line":0}},{"line":2550,"address":[],"length":0,"stats":{"Line":0}},{"line":2551,"address":[],"length":0,"stats":{"Line":0}},{"line":2552,"address":[],"length":0,"stats":{"Line":0}},{"line":2555,"address":[],"length":0,"stats":{"Line":0}},{"line":2556,"address":[],"length":0,"stats":{"Line":0}},{"line":2572,"address":[],"length":0,"stats":{"Line":0}},{"line":2577,"address":[],"length":0,"stats":{"Line":0}},{"line":2579,"address":[],"length":0,"stats":{"Line":0}},{"line":2580,"address":[],"length":0,"stats":{"Line":0}},{"line":2582,"address":[],"length":0,"stats":{"Line":0}},{"line":2583,"address":[],"length":0,"stats":{"Line":0}},{"line":2584,"address":[],"length":0,"stats":{"Line":0}},{"line":2585,"address":[],"length":0,"stats":{"Line":0}},{"line":2587,"address":[],"length":0,"stats":{"Line":0}},{"line":2588,"address":[],"length":0,"stats":{"Line":0}},{"line":2589,"address":[],"length":0,"stats":{"Line":0}},{"line":2590,"address":[],"length":0,"stats":{"Line":0}},{"line":2591,"address":[],"length":0,"stats":{"Line":0}},{"line":2592,"address":[],"length":0,"stats":{"Line":0}},{"line":2593,"address":[],"length":0,"stats":{"Line":0}},{"line":2594,"address":[],"length":0,"stats":{"Line":0}},{"line":2595,"address":[],"length":0,"stats":{"Line":0}},{"line":2596,"address":[],"length":0,"stats":{"Line":0}},{"line":2597,"address":[],"length":0,"stats":{"Line":0}},{"line":2598,"address":[],"length":0,"stats":{"Line":0}},{"line":2599,"address":[],"length":0,"stats":{"Line":0}},{"line":2600,"address":[],"length":0,"stats":{"Line":0}},{"line":2601,"address":[],"length":0,"stats":{"Line":0}},{"line":2602,"address":[],"length":0,"stats":{"Line":0}},{"line":2606,"address":[],"length":0,"stats":{"Line":0}},{"line":2607,"address":[],"length":0,"stats":{"Line":0}},{"line":2608,"address":[],"length":0,"stats":{"Line":0}},{"line":2609,"address":[],"length":0,"stats":{"Line":0}},{"line":2610,"address":[],"length":0,"stats":{"Line":0}},{"line":2611,"address":[],"length":0,"stats":{"Line":0}},{"line":2612,"address":[],"length":0,"stats":{"Line":0}},{"line":2613,"address":[],"length":0,"stats":{"Line":0}},{"line":2616,"address":[],"length":0,"stats":{"Line":0}},{"line":2617,"address":[],"length":0,"stats":{"Line":0}},{"line":2618,"address":[],"length":0,"stats":{"Line":0}},{"line":2619,"address":[],"length":0,"stats":{"Line":0}},{"line":2620,"address":[],"length":0,"stats":{"Line":0}},{"line":2621,"address":[],"length":0,"stats":{"Line":0}},{"line":2622,"address":[],"length":0,"stats":{"Line":0}},{"line":2623,"address":[],"length":0,"stats":{"Line":0}},{"line":2624,"address":[],"length":0,"stats":{"Line":0}},{"line":2625,"address":[],"length":0,"stats":{"Line":0}},{"line":2626,"address":[],"length":0,"stats":{"Line":0}},{"line":2627,"address":[],"length":0,"stats":{"Line":0}},{"line":2628,"address":[],"length":0,"stats":{"Line":0}},{"line":2629,"address":[],"length":0,"stats":{"Line":0}},{"line":2630,"address":[],"length":0,"stats":{"Line":0}},{"line":2631,"address":[],"length":0,"stats":{"Line":0}},{"line":2632,"address":[],"length":0,"stats":{"Line":0}},{"line":2634,"address":[],"length":0,"stats":{"Line":0}},{"line":2635,"address":[],"length":0,"stats":{"Line":0}},{"line":2636,"address":[],"length":0,"stats":{"Line":0}},{"line":2640,"address":[],"length":0,"stats":{"Line":0}},{"line":2641,"address":[],"length":0,"stats":{"Line":0}},{"line":2643,"address":[],"length":0,"stats":{"Line":0}},{"line":2645,"address":[],"length":0,"stats":{"Line":0}},{"line":2647,"address":[],"length":0,"stats":{"Line":0}},{"line":2648,"address":[],"length":0,"stats":{"Line":0}},{"line":2649,"address":[],"length":0,"stats":{"Line":0}},{"line":2650,"address":[],"length":0,"stats":{"Line":0}},{"line":2651,"address":[],"length":0,"stats":{"Line":0}},{"line":2652,"address":[],"length":0,"stats":{"Line":0}},{"line":2656,"address":[],"length":0,"stats":{"Line":0}},{"line":2657,"address":[],"length":0,"stats":{"Line":0}},{"line":2663,"address":[],"length":0,"stats":{"Line":0}},{"line":2666,"address":[],"length":0,"stats":{"Line":0}},{"line":2669,"address":[],"length":0,"stats":{"Line":0}},{"line":2670,"address":[],"length":0,"stats":{"Line":0}},{"line":2673,"address":[],"length":0,"stats":{"Line":0}},{"line":2674,"address":[],"length":0,"stats":{"Line":0}},{"line":2675,"address":[],"length":0,"stats":{"Line":0}},{"line":2677,"address":[],"length":0,"stats":{"Line":0}},{"line":2678,"address":[],"length":0,"stats":{"Line":0}},{"line":2679,"address":[],"length":0,"stats":{"Line":0}},{"line":2681,"address":[],"length":0,"stats":{"Line":0}},{"line":2682,"address":[],"length":0,"stats":{"Line":0}},{"line":2683,"address":[],"length":0,"stats":{"Line":0}},{"line":2685,"address":[],"length":0,"stats":{"Line":0}},{"line":2686,"address":[],"length":0,"stats":{"Line":0}},{"line":2687,"address":[],"length":0,"stats":{"Line":0}},{"line":2689,"address":[],"length":0,"stats":{"Line":0}},{"line":2690,"address":[],"length":0,"stats":{"Line":0}},{"line":2691,"address":[],"length":0,"stats":{"Line":0}},{"line":2693,"address":[],"length":0,"stats":{"Line":0}},{"line":2694,"address":[],"length":0,"stats":{"Line":0}},{"line":2695,"address":[],"length":0,"stats":{"Line":0}},{"line":2697,"address":[],"length":0,"stats":{"Line":0}},{"line":2698,"address":[],"length":0,"stats":{"Line":0}},{"line":2699,"address":[],"length":0,"stats":{"Line":0}},{"line":2701,"address":[],"length":0,"stats":{"Line":0}},{"line":2702,"address":[],"length":0,"stats":{"Line":0}},{"line":2703,"address":[],"length":0,"stats":{"Line":0}},{"line":2705,"address":[],"length":0,"stats":{"Line":0}},{"line":2706,"address":[],"length":0,"stats":{"Line":0}},{"line":2707,"address":[],"length":0,"stats":{"Line":0}},{"line":2709,"address":[],"length":0,"stats":{"Line":0}},{"line":2710,"address":[],"length":0,"stats":{"Line":0}},{"line":2711,"address":[],"length":0,"stats":{"Line":0}},{"line":2713,"address":[],"length":0,"stats":{"Line":0}},{"line":2714,"address":[],"length":0,"stats":{"Line":0}},{"line":2715,"address":[],"length":0,"stats":{"Line":0}},{"line":2717,"address":[],"length":0,"stats":{"Line":0}},{"line":2718,"address":[],"length":0,"stats":{"Line":0}},{"line":2719,"address":[],"length":0,"stats":{"Line":0}},{"line":2721,"address":[],"length":0,"stats":{"Line":0}},{"line":2722,"address":[],"length":0,"stats":{"Line":0}},{"line":2723,"address":[],"length":0,"stats":{"Line":0}},{"line":2725,"address":[],"length":0,"stats":{"Line":0}},{"line":2726,"address":[],"length":0,"stats":{"Line":0}},{"line":2727,"address":[],"length":0,"stats":{"Line":0}},{"line":2729,"address":[],"length":0,"stats":{"Line":0}},{"line":2730,"address":[],"length":0,"stats":{"Line":0}},{"line":2731,"address":[],"length":0,"stats":{"Line":0}},{"line":2733,"address":[],"length":0,"stats":{"Line":0}},{"line":2734,"address":[],"length":0,"stats":{"Line":0}},{"line":2735,"address":[],"length":0,"stats":{"Line":0}},{"line":2738,"address":[],"length":0,"stats":{"Line":0}},{"line":2740,"address":[],"length":0,"stats":{"Line":0}},{"line":2741,"address":[],"length":0,"stats":{"Line":0}},{"line":2742,"address":[],"length":0,"stats":{"Line":0}},{"line":2743,"address":[],"length":0,"stats":{"Line":0}},{"line":2744,"address":[],"length":0,"stats":{"Line":0}},{"line":2745,"address":[],"length":0,"stats":{"Line":0}},{"line":2746,"address":[],"length":0,"stats":{"Line":0}},{"line":2747,"address":[],"length":0,"stats":{"Line":0}},{"line":2748,"address":[],"length":0,"stats":{"Line":0}},{"line":2749,"address":[],"length":0,"stats":{"Line":0}},{"line":2750,"address":[],"length":0,"stats":{"Line":0}},{"line":2751,"address":[],"length":0,"stats":{"Line":0}},{"line":2752,"address":[],"length":0,"stats":{"Line":0}},{"line":2753,"address":[],"length":0,"stats":{"Line":0}},{"line":2754,"address":[],"length":0,"stats":{"Line":0}},{"line":2755,"address":[],"length":0,"stats":{"Line":0}},{"line":2756,"address":[],"length":0,"stats":{"Line":0}},{"line":2761,"address":[],"length":0,"stats":{"Line":0}},{"line":2765,"address":[],"length":0,"stats":{"Line":0}},{"line":2766,"address":[],"length":0,"stats":{"Line":0}},{"line":2769,"address":[],"length":0,"stats":{"Line":0}},{"line":2770,"address":[],"length":0,"stats":{"Line":0}},{"line":2771,"address":[],"length":0,"stats":{"Line":0}},{"line":2774,"address":[],"length":0,"stats":{"Line":0}},{"line":2775,"address":[],"length":0,"stats":{"Line":0}},{"line":2776,"address":[],"length":0,"stats":{"Line":0}},{"line":2777,"address":[],"length":0,"stats":{"Line":0}},{"line":2778,"address":[],"length":0,"stats":{"Line":0}},{"line":2779,"address":[],"length":0,"stats":{"Line":0}},{"line":2780,"address":[],"length":0,"stats":{"Line":0}},{"line":2781,"address":[],"length":0,"stats":{"Line":0}},{"line":2782,"address":[],"length":0,"stats":{"Line":0}},{"line":2783,"address":[],"length":0,"stats":{"Line":0}},{"line":2784,"address":[],"length":0,"stats":{"Line":0}},{"line":2785,"address":[],"length":0,"stats":{"Line":0}},{"line":2786,"address":[],"length":0,"stats":{"Line":0}},{"line":2787,"address":[],"length":0,"stats":{"Line":0}},{"line":2788,"address":[],"length":0,"stats":{"Line":0}},{"line":2789,"address":[],"length":0,"stats":{"Line":0}},{"line":2790,"address":[],"length":0,"stats":{"Line":0}},{"line":2793,"address":[],"length":0,"stats":{"Line":0}},{"line":2794,"address":[],"length":0,"stats":{"Line":0}},{"line":2795,"address":[],"length":0,"stats":{"Line":0}},{"line":2799,"address":[],"length":0,"stats":{"Line":0}},{"line":2800,"address":[],"length":0,"stats":{"Line":0}},{"line":2801,"address":[],"length":0,"stats":{"Line":0}},{"line":2802,"address":[],"length":0,"stats":{"Line":0}},{"line":2803,"address":[],"length":0,"stats":{"Line":0}},{"line":2804,"address":[],"length":0,"stats":{"Line":0}},{"line":2805,"address":[],"length":0,"stats":{"Line":0}},{"line":2806,"address":[],"length":0,"stats":{"Line":0}},{"line":2807,"address":[],"length":0,"stats":{"Line":0}},{"line":2808,"address":[],"length":0,"stats":{"Line":0}},{"line":2809,"address":[],"length":0,"stats":{"Line":0}},{"line":2810,"address":[],"length":0,"stats":{"Line":0}},{"line":2811,"address":[],"length":0,"stats":{"Line":0}},{"line":2812,"address":[],"length":0,"stats":{"Line":0}},{"line":2813,"address":[],"length":0,"stats":{"Line":0}},{"line":2814,"address":[],"length":0,"stats":{"Line":0}},{"line":2815,"address":[],"length":0,"stats":{"Line":0}},{"line":2818,"address":[],"length":0,"stats":{"Line":0}},{"line":2819,"address":[],"length":0,"stats":{"Line":0}},{"line":2820,"address":[],"length":0,"stats":{"Line":0}},{"line":2821,"address":[],"length":0,"stats":{"Line":0}},{"line":2824,"address":[],"length":0,"stats":{"Line":0}},{"line":2830,"address":[],"length":0,"stats":{"Line":0}},{"line":2831,"address":[],"length":0,"stats":{"Line":0}},{"line":2832,"address":[],"length":0,"stats":{"Line":0}},{"line":2833,"address":[],"length":0,"stats":{"Line":0}},{"line":2834,"address":[],"length":0,"stats":{"Line":0}},{"line":2835,"address":[],"length":0,"stats":{"Line":0}},{"line":2836,"address":[],"length":0,"stats":{"Line":0}},{"line":2837,"address":[],"length":0,"stats":{"Line":0}},{"line":2838,"address":[],"length":0,"stats":{"Line":0}},{"line":2839,"address":[],"length":0,"stats":{"Line":0}},{"line":2840,"address":[],"length":0,"stats":{"Line":0}},{"line":2843,"address":[],"length":0,"stats":{"Line":0}},{"line":2844,"address":[],"length":0,"stats":{"Line":0}},{"line":2849,"address":[],"length":0,"stats":{"Line":0}},{"line":2850,"address":[],"length":0,"stats":{"Line":0}},{"line":2851,"address":[],"length":0,"stats":{"Line":0}},{"line":2857,"address":[],"length":0,"stats":{"Line":0}},{"line":2858,"address":[],"length":0,"stats":{"Line":0}},{"line":2859,"address":[],"length":0,"stats":{"Line":0}},{"line":2864,"address":[],"length":0,"stats":{"Line":0}},{"line":2865,"address":[],"length":0,"stats":{"Line":0}},{"line":2866,"address":[],"length":0,"stats":{"Line":0}},{"line":2868,"address":[],"length":0,"stats":{"Line":0}},{"line":2869,"address":[],"length":0,"stats":{"Line":0}},{"line":2870,"address":[],"length":0,"stats":{"Line":0}},{"line":2871,"address":[],"length":0,"stats":{"Line":0}},{"line":2872,"address":[],"length":0,"stats":{"Line":0}},{"line":2873,"address":[],"length":0,"stats":{"Line":0}},{"line":2876,"address":[],"length":0,"stats":{"Line":0}},{"line":2877,"address":[],"length":0,"stats":{"Line":0}},{"line":2879,"address":[],"length":0,"stats":{"Line":0}},{"line":2882,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1508},{"path":["C:","\\","Projects","home-registry","src","lib.rs"],"content":"//! Home Registry Library\n//!\n//! Core functionality for the Home Registry home inventory management system.\n\n#![deny(unsafe_code)]\n#![warn(clippy::all, clippy::pedantic)]\n#![allow(clippy::module_name_repetitions)]\n#![allow(clippy::missing_panics_doc)]\n#![allow(clippy::missing_errors_doc)]\n#![allow(clippy::too_many_lines)]\n\n// Public modules\npub mod api;\npub mod auth;\npub mod db;\npub mod models;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Projects","home-registry","src","main.rs"],"content":"//! Home Registry - A home inventory management system\n//!\n//! This is the main entry point for the Home Registry server.\n\n#![deny(unsafe_code)]\n#![warn(clippy::all, clippy::pedantic)]\n#![allow(clippy::module_name_repetitions)]\n\nuse actix_cors::Cors;\nuse actix_extensible_rate_limit::{\n    backend::memory::InMemoryBackend, backend::SimpleInput, RateLimiter,\n};\nuse actix_files as fs;\nuse actix_web::{\n    dev::ServiceRequest,\n    middleware::{DefaultHeaders, Logger},\n    web, App, HttpResponse, HttpServer, Responder,\n};\nuse dotenvy::dotenv;\nuse refinery::embed_migrations;\nuse std::{env, time::Duration};\n\n// Use the library crate\nuse home_registry::{api, auth, db};\n\n// Embed migrations from the migrations directory at compile time\n// This allows the application to run migrations programmatically on startup\nembed_migrations!(\"migrations\");\n\nasync fn health() -> impl Responder {\n    HttpResponse::Ok().json(serde_json::json!({\n        \"status\": \"healthy\",\n        \"service\": \"home-registry\",\n        \"version\": env!(\"CARGO_PKG_VERSION\"),\n        \"timestamp\": chrono::Utc::now()\n    }))\n}\n\n// Serve index.html for client-side routing (SPA fallback)\nasync fn spa_fallback() -> actix_web::Result<fs::NamedFile> {\n    Ok(fs::NamedFile::open(\"static/index.html\")?)\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    dotenv().ok();\n    env_logger::init();\n\n    let host = env::var(\"HOST\").unwrap_or_else(|_| \"0.0.0.0\".to_string());\n    let port = env::var(\"PORT\").unwrap_or_else(|_| \"8210\".to_string());\n\n    log::info!(\"Starting Home Inventory server at http://{}:{}\", host, port);\n    log::info!(\n        \"Environment: {}\",\n        env::var(\"RUST_ENV\").unwrap_or_else(|_| \"development\".to_string())\n    );\n\n    // Ensure uploads directory exists for image storage\n    match std::fs::create_dir_all(\"uploads/img\") {\n        Ok(()) => log::info!(\"Uploads directory ready: uploads/img/\"),\n        Err(e) => log::warn!(\n            \"Could not create uploads/img directory: {}. Image uploads will be unavailable.\",\n            e\n        ),\n    }\n\n    // Initialize JWT secret at startup (will auto-generate if not found)\n    let _ = auth::get_or_init_jwt_secret();\n    log::info!(\n        \"JWT token lifetime: {} hours\",\n        auth::jwt_token_lifetime_hours()\n    );\n\n    // Initialize database pool with proper error handling (no panics)\n    let pool = match db::get_pool() {\n        Ok(p) => {\n            log::info!(\"Database pool initialized successfully\");\n            p\n        },\n        Err(e) => {\n            log::error!(\"Failed to initialize database pool: {}\", e);\n            std::process::exit(1);\n        },\n    };\n\n    // Run database migrations automatically at startup\n    // Migrations are embedded in the binary and applied idempotently\n    log::info!(\"Running database migrations...\");\n    let mut client = match pool.get().await {\n        Ok(c) => c,\n        Err(e) => {\n            log::error!(\"Failed to get database connection for migrations: {}\", e);\n            std::process::exit(1);\n        },\n    };\n\n    match migrations::runner().run_async(&mut **client).await {\n        Ok(report) => {\n            let applied_count = report.applied_migrations().len();\n            if applied_count > 0 {\n                log::info!(\n                    \"Database migrations completed successfully. Applied {} new migration(s)\",\n                    applied_count\n                );\n            } else {\n                log::info!(\"Database schema is up to date. No new migrations to apply\");\n            }\n        },\n        Err(e) => {\n            log::error!(\"Database migrations failed: {}\", e);\n            log::error!(\n                \"Cannot start application with outdated database schema. \\\n                 Please check migration files and database connectivity.\"\n            );\n            std::process::exit(1);\n        },\n    }\n\n    // Drop the migration client back to the pool\n    drop(client);\n    log::info!(\"Migration client returned to pool\");\n\n    // Rate limiting configuration from environment variables\n    // Migrated from actix-governor (GPL-3.0) to actix-extensible-rate-limit (MIT/Apache-2.0)\n    // These settings provide sensible defaults for a home inventory app:\n    // - 50 requests per second sustained (configurable via RATE_LIMIT_RPS)\n    // - 100 request burst capacity (configurable via RATE_LIMIT_BURST)\n    // This allows rapid page loads while protecting against accidental DoS\n    // NOTE: actix-extensible-rate-limit adds Retry-After headers to 429 responses\n    let requests_per_second = env::var(\"RATE_LIMIT_RPS\")\n        .unwrap_or_else(|_| \"50\".to_string())\n        .parse::<u64>()\n        .unwrap_or(50);\n\n    let burst_size = env::var(\"RATE_LIMIT_BURST\")\n        .unwrap_or_else(|_| \"100\".to_string())\n        .parse::<u64>()\n        .unwrap_or(100);\n\n    log::info!(\n        \"Rate limiting: {} requests/second, burst size: {}\",\n        requests_per_second,\n        burst_size\n    );\n\n    HttpServer::new(move || {\n        // Create in-memory rate limiter backend\n        // Must be created inside HttpServer closure since it's not Send\n        let backend = InMemoryBackend::builder().build();\n\n        // Configure rate limiter to key by client IP address\n        // SimpleInput includes interval, max_requests, and key for rate limiting\n        let rate_limiter = RateLimiter::builder(backend, move |req: &ServiceRequest| {\n            let rps = requests_per_second;\n            let burst = burst_size;\n            // Extract the key before entering the async block to avoid lifetime issues\n            let key = req\n                .peer_addr()\n                .map_or_else(|| \"unknown\".to_string(), |addr| addr.ip().to_string());\n            async move {\n                Ok(SimpleInput {\n                    interval: Duration::from_millis(1000 / rps),\n                    max_requests: burst,\n                    key,\n                })\n            }\n        })\n        .add_headers()\n        .build();\n        // Configure CORS\n        let cors = Cors::default()\n            .allowed_origin_fn(|origin, _req_head| {\n                // Allow requests with no origin (same-origin requests)\n                // Allow localhost in development\n                let origin_str = origin.to_str().unwrap_or(\"\");\n                origin_str.starts_with(\"http://localhost\")\n                    || origin_str.starts_with(\"https://localhost\")\n                    || origin_str.starts_with(\"http://127.0.0.1\")\n                    || origin_str.starts_with(\"https://127.0.0.1\")\n            })\n            .allowed_methods(vec![\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"])\n            .allowed_headers(vec![\n                actix_web::http::header::AUTHORIZATION,\n                actix_web::http::header::CONTENT_TYPE,\n                actix_web::http::header::ACCEPT,\n            ])\n            .supports_credentials()\n            .max_age(3600);\n\n        App::new()\n            .app_data(web::Data::new(pool.clone()))\n            // Allow up to 15 MiB JSON bodies (default is 32KB, too small for image uploads)\n            .app_data(\n                web::JsonConfig::default()\n                    .limit(15_728_640)\n                    .error_handler(|err, req| {\n                        let detail = format!(\"JSON payload error on {}: {}\", req.path(), err);\n                        log::error!(\"{}\", detail);\n                        let response = HttpResponse::BadRequest().json(serde_json::json!({\n                            \"success\": false,\n                            \"error\": \"Request body error\",\n                            \"message\": detail\n                        }));\n                        actix_web::error::InternalError::from_response(err, response).into()\n                    })\n            )\n            // Set payload limit to 20 MiB (default is 256KB, too small for image uploads)\n            .app_data(web::PayloadConfig::new(20 * 1024 * 1024))\n            // Security headers\n            .wrap(DefaultHeaders::new()\n                .add((\"X-Frame-Options\", \"DENY\"))\n                .add((\"X-Content-Type-Options\", \"nosniff\"))\n                .add((\"X-XSS-Protection\", \"1; mode=block\"))\n                .add((\"Referrer-Policy\", \"strict-origin-when-cross-origin\"))\n                .add((\"Permissions-Policy\", \"geolocation=(), microphone=(), camera=()\"))\n                // CSP: Allow external resources for fonts (Google Fonts, Font Awesome) and blob URLs for image processing\n                // Updated to fix CSP violations for Font Awesome CDN and blob URL image uploads\n                .add((\"Content-Security-Policy\", \n                      \"default-src 'self'; \\\n                       script-src 'self' 'unsafe-inline' 'unsafe-eval' https://use.fontawesome.com https://cdnjs.cloudflare.com; \\\n                       style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://use.fontawesome.com https://cdnjs.cloudflare.com; \\\n                       img-src 'self' data: blob: https:; \\\n                       font-src 'self' https://fonts.gstatic.com https://use.fontawesome.com https://cdnjs.cloudflare.com data:; \\\n                       connect-src 'self' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com; \\\n                       frame-ancestors 'none'\")))\n            .wrap(cors)\n            .wrap(Logger::default())\n            // API routes - apply rate limiting ONLY to API endpoints, not static assets\n            // This prevents rate limiting from affecting frontend assets, logos, health checks, etc.\n            .service(\n                api::init_routes()\n                    .wrap(rate_limiter.clone()) // Rate limit scoped to /api/* routes only\n            )\n            .route(\"/health\", web::get().to(health))\n            // Serve static assets (js, css, images, etc.)\n            // Versioned assets with content hashes can be cached indefinitely\n            .service(\n                fs::Files::new(\"/assets\", \"static/assets\")\n                    .use_last_modified(true)\n                    .use_etag(true)\n            )\n            // Serve uploaded images with caching\n            .service(\n                fs::Files::new(\"/uploads/img\", \"uploads/img\")\n                    .use_last_modified(true)\n                    .use_etag(true)\n            )\n            // Serve PWA icon files from icons directory with caching\n            .service(\n                fs::Files::new(\"/icons\", \"static/icons\")\n                    .use_last_modified(true)\n                    .use_etag(true)\n            )\n            // Root route - serve index.html with no-cache to ensure updates are detected\n            .route(\"/\", web::get().to(|| async {\n                fs::NamedFile::open_async(\"static/index.html\")\n                    .await\n                    .map(|file| {\n                        file.customize()\n                            .insert_header((\"Cache-Control\", \"no-cache, must-revalidate\"))\n                    })\n            }))\n            // Logo files at root level - cache for 24 hours\n            .route(\"/logo_icon.png\", web::get().to(|| async {\n                fs::NamedFile::open_async(\"static/logo_icon.png\")\n                    .await\n                    .map(|file| {\n                        file.customize()\n                            .insert_header((\"Cache-Control\", \"public, max-age=86400\"))\n                    })\n            }))\n            .route(\"/logo_full.png\", web::get().to(|| async {\n                fs::NamedFile::open_async(\"static/logo_full.png\")\n                    .await\n                    .map(|file| {\n                        file.customize()\n                            .insert_header((\"Cache-Control\", \"public, max-age=86400\"))\n                    })\n            }))\n            .route(\"/logo_icon3.png\", web::get().to(|| async {\n                fs::NamedFile::open_async(\"static/logo_icon3.png\")\n                    .await\n                    .map(|file| {\n                        file.customize()\n                            .insert_header((\"Cache-Control\", \"public, max-age=86400\"))\n                    })\n            }))\n            .route(\"/favicon.ico\", web::get().to(|| async {\n                fs::NamedFile::open_async(\"static/icons/icon-32.png\")\n                    .await\n                    .map(|file| {\n                        file.customize()\n                            .insert_header((\"Cache-Control\", \"public, max-age=86400\"))\n                    })\n            }))\n            .route(\"/favicon.png\", web::get().to(|| async {\n                fs::NamedFile::open_async(\"static/icons/icon-32.png\")\n                    .await\n                    .map(|file| {\n                        file.customize()\n                            .insert_header((\"Cache-Control\", \"public, max-age=86400\"))\n                    })\n            }))\n            // PWA Manifest (backwards compatibility route for manifest.json)\n            // Both routes serve the same file with consistent 10-minute cache\n            .route(\"/manifest.json\", web::get().to(|| async {\n                fs::NamedFile::open_async(\"static/manifest.webmanifest\")\n                    .await\n                    .map(|file| {\n                        file.customize()\n                            .insert_header((\"Cache-Control\", \"public, max-age=600, must-revalidate\"))\n                    })\n            }))\n            // Service Worker files for PWA - MUST have no-cache for SW update mechanism\n            .route(\"/sw.js\", web::get().to(|| async {\n                fs::NamedFile::open_async(\"static/sw.js\")\n                    .await\n                    .map(|file| {\n                        file.customize()\n                            .insert_header((\"Cache-Control\", \"no-cache, max-age=0, must-revalidate\"))\n                    })\n            }))\n            // Workbox runtime - hash-based filename, safe to cache forever\n            .route(\"/workbox-{filename:.*}.js\", web::get().to(|path: web::Path<String>| async move {\n                let filename = path.into_inner();\n                fs::NamedFile::open_async(format!(\"static/workbox-{filename}.js\"))\n                    .await\n                    .map(|file| {\n                        file.customize()\n                            .insert_header((\"Cache-Control\", \"public, max-age=31536000, immutable\"))\n                    })\n            }))\n            // PWA Manifest - update every 10 minutes (app name/icons)\n            .route(\"/manifest.webmanifest\", web::get().to(|| async {\n                fs::NamedFile::open_async(\"static/manifest.webmanifest\")\n                    .await\n                    .map(|file| {\n                        file.customize()\n                            .insert_header((\"Cache-Control\", \"public, max-age=600, must-revalidate\"))\n                    })\n            }))\n            // Catch-all for SPA client-side routing - serve index.html for everything else\n            // This comes last so API and static routes are handled first\n            .route(\"/{path:.*}\", web::get().to(spa_fallback))\n    })\n    .bind(format!(\"{host}:{port}\"))?\n    .run()\n    .await\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":150},{"path":["C:","\\","Projects","home-registry","src","models","mod.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse validator::Validate;\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Inventory {\n    pub id: Option<i32>,\n    pub name: String,\n    pub description: Option<String>,\n    pub location: Option<String>,\n    pub image_url: Option<String>,\n    pub user_id: Option<uuid::Uuid>,\n    pub created_at: Option<DateTime<Utc>>,\n    pub updated_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Item {\n    pub id: Option<i32>,\n    pub inventory_id: i32,\n    pub name: String,\n    pub description: Option<String>,\n    pub category: Option<String>,\n    pub location: Option<String>,\n    pub purchase_date: Option<String>,\n    pub purchase_price: Option<f64>,\n    pub warranty_expiry: Option<String>,\n    pub notes: Option<String>,\n    pub quantity: Option<i32>,\n    pub created_at: Option<DateTime<Utc>>,\n    pub updated_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Deserialize, Debug, Validate)]\npub struct CreateInventoryRequest {\n    #[validate(length(min = 1, max = 255, message = \"Name must be 1-255 characters\"))]\n    pub name: String,\n    #[validate(length(max = 5000, message = \"Description must be under 5000 characters\"))]\n    pub description: Option<String>,\n    #[validate(length(max = 500, message = \"Location must be under 500 characters\"))]\n    pub location: Option<String>,\n    #[validate(length(max = 10_485_760, message = \"Image URL/data must be under 10MB\"))]\n    pub image_url: Option<String>,\n}\n\n#[derive(Deserialize, Debug, Validate)]\npub struct UpdateInventoryRequest {\n    #[validate(length(min = 1, max = 255, message = \"Name must be 1-255 characters\"))]\n    pub name: Option<String>,\n    #[validate(length(max = 5000, message = \"Description must be under 5000 characters\"))]\n    pub description: Option<String>,\n    #[validate(length(max = 500, message = \"Location must be under 500 characters\"))]\n    pub location: Option<String>,\n    #[validate(length(max = 10_485_760, message = \"Image URL/data must be under 10MB\"))]\n    pub image_url: Option<String>,\n}\n\n#[derive(Deserialize, Debug, Validate)]\npub struct CreateItemRequest {\n    pub inventory_id: Option<i32>,\n    #[validate(length(min = 1, max = 255, message = \"Name must be 1-255 characters\"))]\n    pub name: String,\n    #[validate(length(max = 5000, message = \"Description must be under 5000 characters\"))]\n    pub description: Option<String>,\n    #[validate(length(max = 255, message = \"Category must be under 255 characters\"))]\n    pub category: Option<String>,\n    #[validate(length(max = 500, message = \"Location must be under 500 characters\"))]\n    pub location: Option<String>,\n    pub purchase_date: Option<String>,\n    #[validate(range(\n        min = 0.0,\n        max = 1_000_000_000.0,\n        message = \"Price must be between 0 and 1 billion\"\n    ))]\n    pub purchase_price: Option<f64>,\n    pub warranty_expiry: Option<String>,\n    #[validate(length(max = 10000, message = \"Notes must be under 10000 characters\"))]\n    pub notes: Option<String>,\n    #[validate(range(\n        min = 0,\n        max = 1_000_000,\n        message = \"Quantity must be between 0 and 1 million\"\n    ))]\n    pub quantity: Option<i32>,\n}\n\n#[derive(Deserialize, Debug, Validate)]\npub struct UpdateItemRequest {\n    #[validate(length(min = 1, max = 255, message = \"Name must be 1-255 characters\"))]\n    pub name: Option<String>,\n    #[validate(length(max = 5000, message = \"Description must be under 5000 characters\"))]\n    pub description: Option<String>,\n    #[validate(length(max = 255, message = \"Category must be under 255 characters\"))]\n    pub category: Option<String>,\n    #[validate(length(max = 500, message = \"Location must be under 500 characters\"))]\n    pub location: Option<String>,\n    pub purchase_date: Option<String>,\n    #[validate(range(\n        min = 0.0,\n        max = 1_000_000_000.0,\n        message = \"Price must be between 0 and 1 billion\"\n    ))]\n    pub purchase_price: Option<f64>,\n    pub warranty_expiry: Option<String>,\n    #[validate(length(max = 10000, message = \"Notes must be under 10000 characters\"))]\n    pub notes: Option<String>,\n    #[validate(range(\n        min = 0,\n        max = 1_000_000,\n        message = \"Quantity must be between 0 and 1 million\"\n    ))]\n    pub quantity: Option<i32>,\n    pub inventory_id: Option<i32>,\n}\n\n#[derive(Serialize)]\npub struct ApiResponse<T> {\n    pub success: bool,\n    pub data: Option<T>,\n    pub message: Option<String>,\n    pub error: Option<String>,\n}\n\n#[derive(Serialize)]\npub struct ErrorResponse {\n    pub success: bool,\n    pub error: String,\n    pub message: Option<String>,\n}\n\n// Inventory Reporting Models\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\npub struct InventoryReportRequest {\n    pub inventory_id: Option<i32>,\n    #[validate(length(max = 255, message = \"Category must be under 255 characters\"))]\n    pub category: Option<String>,\n    #[validate(length(max = 500, message = \"Location must be under 500 characters\"))]\n    pub location: Option<String>,\n    pub from_date: Option<String>, // ISO 8601 format\n    pub to_date: Option<String>,\n    #[validate(range(\n        min = 0.0,\n        max = 1_000_000_000.0,\n        message = \"Price must be between 0 and 1 billion\"\n    ))]\n    pub min_price: Option<f64>,\n    #[validate(range(\n        min = 0.0,\n        max = 1_000_000_000.0,\n        message = \"Price must be between 0 and 1 billion\"\n    ))]\n    pub max_price: Option<f64>,\n    #[validate(length(max = 50, message = \"Sort field must be under 50 characters\"))]\n    pub sort_by: Option<String>, // \"name\", \"price\", \"date\", \"category\"\n    #[validate(length(max = 10, message = \"Sort order must be under 10 characters\"))]\n    pub sort_order: Option<String>, // \"asc\", \"desc\"\n    #[validate(length(max = 10, message = \"Format must be under 10 characters\"))]\n    pub format: Option<String>, // \"json\", \"csv\"\n}\n\n#[derive(Serialize, Debug)]\npub struct InventoryStatistics {\n    pub total_items: i64,\n    pub total_value: f64,\n    pub total_quantity: i64,\n    pub category_count: i64,\n    pub inventories_count: i64,\n    pub oldest_item_date: Option<String>,\n    pub newest_item_date: Option<String>,\n    pub average_item_value: f64,\n}\n\n#[derive(Serialize, Debug)]\npub struct CategoryBreakdown {\n    pub category: String,\n    pub item_count: i64,\n    pub total_quantity: i64,\n    pub total_value: f64,\n    pub percentage_of_total: f64,\n}\n\n#[derive(Serialize, Debug)]\npub struct ItemExportRow {\n    pub id: i32,\n    pub inventory_name: String,\n    pub item_name: String,\n    pub description: String,\n    pub category: String,\n    pub location: String,\n    pub quantity: i32,\n    pub purchase_price: String,\n    pub total_value: String,\n    pub purchase_date: String,\n    pub warranty_expiry: String,\n    pub created_at: String,\n}\n\n#[derive(Serialize, Debug)]\npub struct InventoryReportData {\n    pub statistics: InventoryStatistics,\n    pub category_breakdown: Vec<CategoryBreakdown>,\n    pub items: Vec<Item>,\n    pub generated_at: DateTime<Utc>,\n    pub filters_applied: InventoryReportRequest,\n}\n\n// Image upload response\n#[derive(Serialize, Debug)]\npub struct ImageUploadResponse {\n    pub url: String,\n    pub filename: String,\n}\n\n// Categories\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Category {\n    pub id: Option<i32>,\n    pub name: String,\n    pub description: Option<String>,\n    pub color: Option<String>,\n    pub icon: Option<String>,\n    pub created_at: Option<DateTime<Utc>>,\n    pub updated_at: Option<DateTime<Utc>>,\n}\n\n#[allow(dead_code)]\n#[derive(Deserialize, Debug)]\npub struct CreateCategoryRequest {\n    pub name: String,\n    pub description: Option<String>,\n    pub color: Option<String>,\n    pub icon: Option<String>,\n}\n\n// Tags\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Tag {\n    pub id: Option<i32>,\n    pub name: String,\n    pub color: Option<String>,\n    pub created_at: Option<DateTime<Utc>>,\n    pub updated_at: Option<DateTime<Utc>>,\n}\n\n#[allow(dead_code)]\n#[derive(Deserialize, Debug)]\npub struct CreateTagRequest {\n    pub name: String,\n    pub color: Option<String>,\n}\n\n// Custom Fields\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct CustomField {\n    pub id: Option<i32>,\n    pub category_id: i32,\n    pub name: String,\n    pub field_type: String,\n    pub options: Option<String>, // JSON string\n    pub required: bool,\n    pub created_at: Option<DateTime<Utc>>,\n    pub updated_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[allow(dead_code)]\npub struct CustomFieldValue {\n    pub id: Option<i32>,\n    pub item_id: i32,\n    pub custom_field_id: i32,\n    pub value: Option<String>,\n    pub created_at: Option<DateTime<Utc>>,\n    pub updated_at: Option<DateTime<Utc>>,\n}\n\n// Extended Item structure with relationships\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[allow(dead_code)]\npub struct ItemWithRelations {\n    pub id: Option<i32>,\n    pub inventory_id: i32,\n    pub category_id: Option<i32>,\n    pub name: String,\n    pub description: Option<String>,\n    pub location: Option<String>,\n    pub purchase_date: Option<String>,\n    pub purchase_price: Option<f64>,\n    pub warranty_expiry: Option<String>,\n    pub notes: Option<String>,\n    pub quantity: Option<i32>,\n    pub image_url: Option<String>,\n    pub purchase_link: Option<String>,\n    pub warranty_info: Option<String>,\n    pub condition: Option<String>,\n    pub serial_number: Option<String>,\n    pub manufacturer: Option<String>,\n    pub model: Option<String>,\n    pub created_at: Option<DateTime<Utc>>,\n    pub updated_at: Option<DateTime<Utc>>,\n    // Relations\n    pub category: Option<Category>,\n    pub tags: Vec<Tag>,\n    pub custom_fields: Vec<CustomFieldWithValue>,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[allow(dead_code)]\npub struct CustomFieldWithValue {\n    pub field: CustomField,\n    pub value: Option<String>,\n}\n\n// Organizer Types - flexible categorization per inventory\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct OrganizerType {\n    pub id: Option<i32>,\n    pub inventory_id: i32,\n    pub name: String,\n    pub input_type: String, // \"select\" or \"text\"\n    pub is_required: bool,\n    pub display_order: i32,\n    pub created_at: Option<DateTime<Utc>>,\n    pub updated_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Deserialize, Debug)]\npub struct CreateOrganizerTypeRequest {\n    pub name: String,\n    pub input_type: Option<String>, // defaults to \"select\"\n    pub is_required: Option<bool>,  // defaults to false\n    pub display_order: Option<i32>, // defaults to 0\n}\n\n#[derive(Deserialize, Debug)]\npub struct UpdateOrganizerTypeRequest {\n    pub name: Option<String>,\n    pub input_type: Option<String>,\n    pub is_required: Option<bool>,\n    pub display_order: Option<i32>,\n}\n\n// Organizer Options - predefined values for \"select\" type organizers\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct OrganizerOption {\n    pub id: Option<i32>,\n    pub organizer_type_id: i32,\n    pub name: String,\n    pub display_order: i32,\n    pub created_at: Option<DateTime<Utc>>,\n    pub updated_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Deserialize, Debug)]\npub struct CreateOrganizerOptionRequest {\n    pub name: String,\n    pub display_order: Option<i32>,\n}\n\n#[derive(Deserialize, Debug)]\npub struct UpdateOrganizerOptionRequest {\n    pub name: Option<String>,\n    pub display_order: Option<i32>,\n}\n\n// Item Organizer Values - links items to organizer values\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ItemOrganizerValue {\n    pub id: Option<i32>,\n    pub item_id: i32,\n    pub organizer_type_id: i32,\n    pub organizer_option_id: Option<i32>, // For \"select\" type\n    pub text_value: Option<String>,       // For \"text\" type\n    pub created_at: Option<DateTime<Utc>>,\n    pub updated_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Deserialize, Debug)]\npub struct SetItemOrganizerValueRequest {\n    pub organizer_type_id: i32,\n    pub organizer_option_id: Option<i32>, // For \"select\" type\n    pub text_value: Option<String>,       // For \"text\" type\n}\n\n#[derive(Deserialize, Debug)]\npub struct SetItemOrganizerValuesRequest {\n    pub values: Vec<SetItemOrganizerValueRequest>,\n}\n\n// Extended response with organizer details\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct OrganizerTypeWithOptions {\n    #[serde(flatten)]\n    pub organizer_type: OrganizerType,\n    pub options: Vec<OrganizerOption>,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ItemOrganizerValueWithDetails {\n    pub organizer_type_id: i32,\n    pub organizer_type_name: String,\n    pub input_type: String,\n    pub is_required: bool,\n    pub value: Option<String>, // Display value (option name or text value)\n    pub organizer_option_id: Option<i32>,\n    pub text_value: Option<String>,\n}\n\n// ==================== User & Authentication Models ====================\n\nuse uuid::Uuid;\n\n/// User model - represents a user in the system\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct User {\n    pub id: Uuid,\n    pub username: String,\n    pub full_name: String,\n    #[serde(skip_serializing)] // Never serialize password_hash\n    pub password_hash: String,\n    pub is_admin: bool,\n    pub is_active: bool,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub recovery_codes_generated_at: Option<DateTime<Utc>>,\n    #[serde(default)]\n    pub recovery_codes_confirmed: bool,\n}\n\n/// User response without sensitive data (for API responses)\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct UserResponse {\n    pub id: Uuid,\n    pub username: String,\n    pub full_name: String,\n    pub is_admin: bool,\n    pub is_active: bool,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl From<User> for UserResponse {\n    fn from(user: User) -> Self {\n        UserResponse {\n            id: user.id,\n            username: user.username,\n            full_name: user.full_name,\n            is_admin: user.is_admin,\n            is_active: user.is_active,\n            created_at: user.created_at,\n            updated_at: user.updated_at,\n        }\n    }\n}\n\n/// Request to create a new user (registration)\n#[derive(Deserialize, Debug)]\npub struct CreateUserRequest {\n    pub username: String,\n    pub full_name: String,\n    pub password: String,\n}\n\n/// Request for admin to create a new user with additional options\n#[derive(Deserialize, Debug)]\npub struct AdminCreateUserRequest {\n    pub username: String,\n    pub full_name: String,\n    pub password: String,\n    #[serde(default)]\n    pub is_admin: bool,\n    #[serde(default = \"default_true\")]\n    pub is_active: bool,\n}\n\nfn default_true() -> bool {\n    true\n}\n\n/// Request for admin to update a user\n#[derive(Deserialize, Debug)]\npub struct AdminUpdateUserRequest {\n    pub username: Option<String>,\n    pub full_name: Option<String>,\n    pub is_admin: Option<bool>,\n    pub is_active: Option<bool>,\n}\n\n/// Login request\n#[derive(Deserialize, Debug)]\npub struct LoginRequest {\n    pub username: String,\n    pub password: String,\n}\n\n/// Login response with JWT token\n#[derive(Serialize, Debug)]\npub struct LoginResponse {\n    pub token: String,\n    pub user: UserResponse,\n}\n\n/// Request to update current user's profile\n#[derive(Deserialize, Debug)]\npub struct UpdateProfileRequest {\n    pub full_name: Option<String>,\n}\n\n/// Request to change password\n#[derive(Deserialize, Debug)]\npub struct ChangePasswordRequest {\n    pub current_password: String,\n    pub new_password: String,\n}\n\n/// Request to reset password with token\n/// JWT Claims structure\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Claims {\n    pub sub: String, // User ID\n    pub username: String,\n    pub is_admin: bool,\n    pub exp: u64, // Expiration time (Unix timestamp)\n    pub iat: u64, // Issued at (Unix timestamp)\n}\n\n// ==================== Permission Models ====================\n\n/// Permission levels for shared inventories (per-inventory)\n/// The 4-tier system:\n/// 1. View - View shared inventory and its items\n/// 2. `EditItems` - View + Edit item details only (not add/remove)\n/// 3. `EditInventory` - `EditItems` + Edit inventory details, add/remove items\n/// 4. `AllAccess` - User-to-user grant via `UserAccessGrant` table (full access to ALL grantor's inventories)\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub enum PermissionLevel {\n    View,          // Can only view inventory and items\n    EditItems,     // Can view and edit item details (not add/remove items)\n    EditInventory, // Can view, edit items, add/remove items, edit inventory details\n}\n\nimpl PermissionLevel {\n    /// Can view inventory and items\n    #[must_use = \"permission check result should be used to enforce access control\"]\n    pub fn can_view(&self) -> bool {\n        true // All levels can view\n    }\n\n    /// Can edit existing item details (name, description, etc.)\n    #[must_use = \"permission check result should be used to enforce access control\"]\n    pub fn can_edit_items(&self) -> bool {\n        matches!(\n            self,\n            PermissionLevel::EditItems | PermissionLevel::EditInventory\n        )\n    }\n\n    /// Can add new items to inventory\n    #[must_use = \"permission check result should be used to enforce access control\"]\n    pub fn can_add_items(&self) -> bool {\n        matches!(self, PermissionLevel::EditInventory)\n    }\n\n    /// Can remove items from inventory\n    #[must_use = \"permission check result should be used to enforce access control\"]\n    pub fn can_remove_items(&self) -> bool {\n        matches!(self, PermissionLevel::EditInventory)\n    }\n\n    /// Can edit inventory details (name, description, etc.)\n    #[must_use = \"permission check result should be used to enforce access control\"]\n    pub fn can_edit_inventory(&self) -> bool {\n        matches!(self, PermissionLevel::EditInventory)\n    }\n\n    /// Can manage organizers for inventory\n    #[must_use = \"permission check result should be used to enforce access control\"]\n    pub fn can_manage_organizers(&self) -> bool {\n        matches!(self, PermissionLevel::EditInventory)\n    }\n\n    // Legacy method - maps to can_edit_items for backward compatibility\n    #[deprecated(note = \"Use can_edit_items() instead\")]\n    #[allow(dead_code)]\n    #[must_use = \"permission check result should be used to enforce access control\"]\n    pub fn can_edit(&self) -> bool {\n        self.can_edit_items()\n    }\n\n    // Legacy method - only owner or AllAccess users can delete inventory\n    #[deprecated(note = \"Deletion requires ownership or AllAccess grant\")]\n    #[allow(dead_code)]\n    #[must_use = \"permission check result should be used to enforce access control\"]\n    pub fn can_delete(&self) -> bool {\n        false // Per-inventory shares cannot delete - requires ownership or AllAccess\n    }\n\n    // Legacy method - only owner or AllAccess users can manage sharing\n    #[deprecated(note = \"Sharing management requires ownership or AllAccess grant\")]\n    #[allow(dead_code)]\n    #[must_use = \"permission check result should be used to enforce access control\"]\n    pub fn can_manage_sharing(&self) -> bool {\n        false // Per-inventory shares cannot manage sharing - requires ownership or AllAccess\n    }\n}\n\nimpl std::fmt::Display for PermissionLevel {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            PermissionLevel::View => write!(f, \"view\"),\n            PermissionLevel::EditItems => write!(f, \"edit_items\"),\n            PermissionLevel::EditInventory => write!(f, \"edit_inventory\"),\n        }\n    }\n}\n\nimpl std::str::FromStr for PermissionLevel {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s.to_lowercase().as_str() {\n            \"view\" => Ok(PermissionLevel::View),\n            \"edit_items\" | \"edit\" => Ok(PermissionLevel::EditItems),\n            \"edit_inventory\" | \"full\" => Ok(PermissionLevel::EditInventory),\n            _ => Err(format!(\"Invalid permission level: {s}\")),\n        }\n    }\n}\n\n/// Inventory share record\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct InventoryShare {\n    pub id: Uuid,\n    pub inventory_id: i32,\n    pub shared_with_user_id: Uuid,\n    pub shared_by_user_id: Uuid,\n    pub permission_level: PermissionLevel,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n/// Inventory share with user details for API responses\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct InventoryShareWithUser {\n    pub id: Uuid,\n    pub inventory_id: i32,\n    pub shared_with_user: UserResponse,\n    pub shared_by_user: UserResponse,\n    pub permission_level: PermissionLevel,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n/// Request to share an inventory\n#[derive(Deserialize, Debug)]\npub struct CreateInventoryShareRequest {\n    pub shared_with_username: String, // Username of user to share with\n    pub permission_level: PermissionLevel,\n}\n\n/// Request to update share permissions\n#[derive(Deserialize, Debug)]\npub struct UpdateInventoryShareRequest {\n    pub permission_level: PermissionLevel,\n}\n\n// ==================== User Access Grant Models (All Access Tier) ====================\n\n/// User access grant - grants a user full access to ALL inventories of another user\n/// This is the \"All Access\" tier of the 4-tier permission system\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct UserAccessGrant {\n    pub id: Uuid,\n    pub grantor_user_id: Uuid, // User granting access\n    pub grantee_user_id: Uuid, // User receiving access\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n/// User access grant with user details for API responses\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct UserAccessGrantWithUsers {\n    pub id: Uuid,\n    pub grantor: UserResponse,\n    pub grantee: UserResponse,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n/// Request to create a user access grant (All Access)\n#[derive(Deserialize, Debug)]\npub struct CreateUserAccessGrantRequest {\n    pub grantee_username: String, // Username of user to grant access to\n}\n\n// ==================== Ownership Transfer Models ====================\n\n/// Request to transfer inventory ownership to another user\n#[derive(Deserialize, Debug)]\npub struct TransferOwnershipRequest {\n    pub new_owner_username: String, // Username of user to transfer ownership to\n}\n\n/// Response for ownership transfer operation\n#[derive(Serialize, Debug)]\npub struct TransferOwnershipResponse {\n    pub inventory_id: i32,\n    pub inventory_name: String,\n    pub previous_owner: UserResponse,\n    pub new_owner: UserResponse,\n    pub items_transferred: i64,\n    pub shares_removed: i64,\n}\n\n/// Summary of effective permissions a user has for an inventory.\n/// This is a data transfer object (DTO) for API responses.\n#[allow(\n    clippy::struct_excessive_bools,\n    reason = \"DTO for API responses where explicit booleans improve clarity\"\n)]\n#[derive(Serialize, Debug, Clone)]\npub struct EffectivePermissions {\n    pub can_view: bool,\n    pub can_edit_items: bool,\n    pub can_add_items: bool,\n    pub can_remove_items: bool,\n    pub can_edit_inventory: bool,\n    pub can_delete_inventory: bool,\n    pub can_manage_sharing: bool,\n    pub can_manage_organizers: bool,\n    pub is_owner: bool,\n    pub has_all_access: bool, // Via UserAccessGrant\n    pub permission_source: PermissionSource,\n}\n\n/// Where the user's permissions come from\n#[derive(Serialize, Debug, Clone, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub enum PermissionSource {\n    Owner,          // User owns the inventory\n    AllAccess,      // Via UserAccessGrant from owner\n    InventoryShare, // Via InventoryShare record\n    None,           // No access\n}\n\n// ==================== User Settings Models ====================\n\n/// User settings/preferences\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct UserSettings {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub theme: String,\n    pub default_inventory_id: Option<i32>,\n    pub items_per_page: i32,\n    pub date_format: String,\n    pub currency: String,\n    pub notifications_enabled: bool,\n    pub settings_json: serde_json::Value,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n/// Request to update user settings\n#[derive(Deserialize, Debug)]\npub struct UpdateUserSettingsRequest {\n    pub theme: Option<String>,\n    pub default_inventory_id: Option<i32>,\n    pub items_per_page: Option<i32>,\n    pub date_format: Option<String>,\n    pub currency: Option<String>,\n    pub notifications_enabled: Option<bool>,\n    pub settings_json: Option<serde_json::Value>,\n}\n\n// ==================== First-time Setup Models ====================\n\n/// Request for initial admin setup (first run)\n#[derive(Deserialize, Debug)]\npub struct InitialSetupRequest {\n    pub username: String,\n    pub full_name: String,\n    pub password: String,\n}\n\n/// Response for setup status check\n#[derive(Serialize, Debug)]\npub struct SetupStatusResponse {\n    pub needs_setup: bool,\n    pub user_count: i64,\n}\n\n// ==================== Recovery Codes Models ====================\n\n/// Recovery code stored in database (hashed)\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub struct RecoveryCode {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub code_hash: String,\n    pub is_used: bool,\n    pub used_at: Option<DateTime<Utc>>,\n    pub created_at: DateTime<Utc>,\n}\n\n/// Response when generating recovery codes (contains plaintext codes - only shown once!)\n#[derive(Serialize, Debug)]\npub struct RecoveryCodesResponse {\n    pub codes: Vec<String>,\n    pub generated_at: DateTime<Utc>,\n    pub message: String,\n}\n\n/// Request to confirm recovery codes have been saved\n#[derive(Deserialize, Debug)]\npub struct ConfirmRecoveryCodesRequest {\n    pub confirmed: bool,\n}\n\n/// Request to use a recovery code to reset password\n#[derive(Deserialize, Debug)]\npub struct UseRecoveryCodeRequest {\n    pub username: String,\n    pub recovery_code: String,\n    pub new_password: String,\n}\n\n/// Response after successfully using a recovery code\n#[derive(Serialize, Debug)]\npub struct RecoveryCodeUsedResponse {\n    pub success: bool,\n    pub message: String,\n    pub remaining_codes: i32,\n}\n\n/// Status of user's recovery codes\n#[derive(Serialize, Debug)]\npub struct RecoveryCodesStatus {\n    pub has_codes: bool,\n    pub codes_confirmed: bool,\n    pub unused_count: i32,\n    pub generated_at: Option<DateTime<Utc>>,\n}\n\n// ==================== Backup & Restore Models ====================\n\n/// Metadata about a backup file (for listing/responses)\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct BackupInfo {\n    pub name: String,\n    pub date: String,\n    pub size: String,\n}\n\n/// Metadata embedded in the backup file itself\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct BackupMetadata {\n    pub version: String,\n    pub app_version: String,\n    pub created_at: String,\n    pub database_type: String,\n    pub description: Option<String>,\n}\n\n/// The complete backup data envelope\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct BackupData {\n    pub metadata: BackupMetadata,\n    pub data: BackupDatabaseContent,\n}\n\n/// All database tables exported as JSON arrays\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct BackupDatabaseContent {\n    pub users: serde_json::Value,\n    pub inventories: serde_json::Value,\n    pub items: serde_json::Value,\n    pub categories: serde_json::Value,\n    pub tags: serde_json::Value,\n    pub item_tags: serde_json::Value,\n    pub custom_fields: serde_json::Value,\n    pub item_custom_values: serde_json::Value,\n    pub organizer_types: serde_json::Value,\n    pub organizer_options: serde_json::Value,\n    pub item_organizer_values: serde_json::Value,\n    pub user_settings: serde_json::Value,\n    pub inventory_shares: serde_json::Value,\n    pub user_access_grants: serde_json::Value,\n    pub recovery_codes: serde_json::Value,\n    #[serde(default = \"default_empty_json_array\")]\n    pub password_reset_tokens: serde_json::Value,\n}\n\n/// Default empty JSON array for optional backup fields (backward compatibility)\nfn default_empty_json_array() -> serde_json::Value {\n    serde_json::Value::Array(vec![])\n}\n","traces":[{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":42}],"coverage":1.6445865692096848,"covered":72,"coverable":4378}